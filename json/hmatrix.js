[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hmatrix"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe library can be easily extended with additional foreign functions\n using the tools in this module. Illustrative usage examples can be found\n in the \u003ccode\u003eexamples/devel\u003c/code\u003e folder included in the package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Packed.Development",
          "name": "Development",
          "package": "hmatrix",
          "source": "src/Data-Packed-Development.html",
          "type": "module"
        },
        "index": {
          "description": "The library can be easily extended with additional foreign functions using the tools in this module Illustrative usage examples can be found in the examples devel folder included in the package",
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "Development",
          "package": "hmatrix",
          "partial": "Development",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "MatrixOrder",
          "package": "hmatrix",
          "source": "src/Data-Packed-Internal-Matrix.html#MatrixOrder",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "MatrixOrder",
          "package": "hmatrix",
          "partial": "Matrix Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#t:MatrixOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epostfix function application (\u003ccode\u003eflip ($)\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Data.Packed.Development",
          "name": "(//)",
          "package": "hmatrix",
          "signature": "x -\u003e (x -\u003e y) -\u003e y",
          "source": "src/Data-Packed-Internal-Common.html#%2F%2F",
          "type": "function"
        },
        "index": {
          "description": "postfix function application flip",
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "(//) //",
          "normalized": "a-\u003e(a-\u003eb)-\u003eb",
          "package": "hmatrix",
          "signature": "x-\u003e(x-\u003ey)-\u003ey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:-47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "ColumnMajor",
          "package": "hmatrix",
          "signature": "ColumnMajor",
          "source": "src/Data-Packed-Internal-Matrix.html#MatrixOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "ColumnMajor",
          "package": "hmatrix",
          "partial": "Column Major",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:ColumnMajor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "RowMajor",
          "package": "hmatrix",
          "signature": "RowMajor",
          "source": "src/Data-Packed-Internal-Matrix.html#MatrixOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "RowMajor",
          "package": "hmatrix",
          "partial": "Row Major",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:RowMajor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app1",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt1 f t1",
          "source": "src/Data-Packed-Internal-Common.html#app1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app1",
          "normalized": "a-\u003eAdapt a b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app10",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt10 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7 r7 t8 r8 t9 r9 t10",
          "source": "src/Data-Packed-Internal-Common.html#app10",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app10",
          "normalized": "a-\u003eAdapt a b c b c b c b c b c b c b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t r t r t r t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app10"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app2",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt2 f t1 r1 t2",
          "source": "src/Data-Packed-Internal-Common.html#app2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app2",
          "normalized": "a-\u003eAdapt a b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app3",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt3 f t1 r1 t2 r2 t3",
          "source": "src/Data-Packed-Internal-Common.html#app3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app3",
          "normalized": "a-\u003eAdapt a b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app4",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt4 f t1 r1 t2 r2 t3 r3 t4",
          "source": "src/Data-Packed-Internal-Common.html#app4",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app4",
          "normalized": "a-\u003eAdapt a b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app5",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt5 f t1 r1 t2 r2 t3 r3 t4 r4 t5",
          "source": "src/Data-Packed-Internal-Common.html#app5",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app5",
          "normalized": "a-\u003eAdapt a b c b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app6",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt6 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6",
          "source": "src/Data-Packed-Internal-Common.html#app6",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app6",
          "normalized": "a-\u003eAdapt a b c b c b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app7",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt7 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7",
          "source": "src/Data-Packed-Internal-Common.html#app7",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app7",
          "normalized": "a-\u003eAdapt a b c b c b c b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app8",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt8 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7 r7 t8",
          "source": "src/Data-Packed-Internal-Common.html#app8",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app8",
          "normalized": "a-\u003eAdapt a b c b c b c b c b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t r t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "app9",
          "package": "hmatrix",
          "signature": "f -\u003e Adapt9 f t1 r1 t2 r2 t3 r3 t4 r4 t5 r5 t6 r6 t7 r7 t8 r8 t9",
          "source": "src/Data-Packed-Internal-Common.html#app9",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "app9",
          "normalized": "a-\u003eAdapt a b c b c b c b c b c b c b c b c b",
          "package": "hmatrix",
          "signature": "f-\u003eAdapt f t r t r t r t r t r t r t r t r t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:app9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eaccess to Vector elements without range checking\n\u003c/p\u003e",
          "module": "Data.Packed.Development",
          "name": "at'",
          "package": "hmatrix",
          "signature": "Vector a -\u003e Int -\u003e a",
          "source": "src/Data-Packed-Internal-Vector.html#at%27",
          "type": "function"
        },
        "index": {
          "description": "access to Vector elements without range checking",
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "at'",
          "normalized": "Vector a-\u003eInt-\u003ea",
          "package": "hmatrix",
          "signature": "Vector a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:at-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "atM'",
          "package": "hmatrix",
          "signature": "Matrix a -\u003e Int -\u003e Int -\u003e a",
          "source": "src/Data-Packed-Internal-Matrix.html#atM%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "atM'",
          "normalized": "Matrix a-\u003eInt-\u003eInt-\u003ea",
          "package": "hmatrix",
          "partial": "M'",
          "signature": "Matrix a-\u003eInt-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:atM-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echeck the error code\n\u003c/p\u003e",
          "module": "Data.Packed.Development",
          "name": "check",
          "package": "hmatrix",
          "signature": "String -\u003e IO CInt -\u003e IO ()",
          "source": "src/Data-Packed-Internal-Common.html#check",
          "type": "function"
        },
        "index": {
          "description": "check the error code",
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "check",
          "normalized": "String-\u003eIO CInt-\u003eIO()",
          "package": "hmatrix",
          "signature": "String-\u003eIO CInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:check"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "cmat",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#cmat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "cmat",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:cmat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "createMatrix",
          "package": "hmatrix",
          "signature": "MatrixOrder -\u003e Int -\u003e Int -\u003e IO (Matrix a)",
          "source": "src/Data-Packed-Internal-Matrix.html#createMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "createMatrix",
          "normalized": "MatrixOrder-\u003eInt-\u003eInt-\u003eIO(Matrix a)",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "MatrixOrder-\u003eInt-\u003eInt-\u003eIO(Matrix a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:createMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "createVector",
          "package": "hmatrix",
          "signature": "Int -\u003e IO (Vector a)",
          "source": "src/Data-Packed-Internal-Vector.html#createVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "createVector",
          "normalized": "Int-\u003eIO(Vector a)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Int-\u003eIO(Vector a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:createVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "fmat",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#fmat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "fmat",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:fmat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "mat",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (((CInt -\u003e CInt -\u003e Ptr t -\u003e t1) -\u003e t1) -\u003e IO b) -\u003e IO b",
          "source": "src/Data-Packed-Internal-Matrix.html#mat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "mat",
          "normalized": "Matrix a-\u003e(((CInt-\u003eCInt-\u003ePtr a-\u003ea)-\u003ea)-\u003eIO b)-\u003eIO b",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(((CInt-\u003eCInt-\u003ePtr t-\u003et)-\u003et)-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:mat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "matrixFromVector",
          "package": "hmatrix",
          "signature": "MatrixOrder -\u003e Int -\u003e Vector t -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#matrixFromVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "matrixFromVector",
          "normalized": "MatrixOrder-\u003eInt-\u003eVector a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "From Vector",
          "signature": "MatrixOrder-\u003eInt-\u003eVector t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:matrixFromVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "orderOf",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e MatrixOrder",
          "source": "src/Data-Packed-Internal-Matrix.html#orderOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "orderOf",
          "normalized": "Matrix a-\u003eMatrixOrder",
          "package": "hmatrix",
          "partial": "Of",
          "signature": "Matrix t-\u003eMatrixOrder",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:orderOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Create a vector from a \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e with an offset and a length.\n\u003c/p\u003e\u003cp\u003eThe data may not be modified through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e afterwards.\n\u003c/p\u003e\u003cp\u003eIf your offset is 0 it is more efficient to use \u003ccode\u003e\u003ca\u003eunsafeFromForeignPtr0\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Packed.Development",
          "name": "unsafeFromForeignPtr",
          "package": "hmatrix",
          "signature": "ForeignPtr a-\u003e Int-\u003e Int-\u003e Vector a",
          "type": "function"
        },
        "index": {
          "description": "Create vector from ForeignPtr with an offset and length The data may not be modified through the ForeignPtr afterwards If your offset is it is more efficient to use unsafeFromForeignPtr0",
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "unsafeFromForeignPtr",
          "normalized": "ForeignPtr a-\u003eInt-\u003eInt-\u003eVector a",
          "package": "hmatrix",
          "partial": "From Foreign Ptr",
          "signature": "ForeignPtr a-\u003eInt-\u003eInt-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:unsafeFromForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e Yield the underlying \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e together with the offset to the\n data and its length. The data may not be modified through the \u003ccode\u003e\u003ca\u003eForeignPtr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Packed.Development",
          "name": "unsafeToForeignPtr",
          "package": "hmatrix",
          "signature": "Vector a -\u003e (ForeignPtr a, Int, Int)",
          "type": "function"
        },
        "index": {
          "description": "Yield the underlying ForeignPtr together with the offset to the data and its length The data may not be modified through the ForeignPtr",
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "unsafeToForeignPtr",
          "normalized": "Vector a-\u003e(ForeignPtr a,Int,Int)",
          "package": "hmatrix",
          "partial": "To Foreign Ptr",
          "signature": "Vector a-\u003e(ForeignPtr a,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:unsafeToForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Development",
          "name": "vec",
          "package": "hmatrix",
          "signature": "Vector t -\u003e (((CInt -\u003e Ptr t -\u003e t1) -\u003e t1) -\u003e IO b) -\u003e IO b",
          "source": "src/Data-Packed-Internal-Vector.html#vec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Development",
          "module": "Data.Packed.Development",
          "name": "vec",
          "normalized": "Vector a-\u003e(((CInt-\u003ePtr a-\u003ea)-\u003ea)-\u003eIO b)-\u003eIO b",
          "package": "hmatrix",
          "signature": "Vector t-\u003e(((CInt-\u003ePtr t-\u003et)-\u003et)-\u003eIO b)-\u003eIO b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Development.html#v:vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFFI and hmatrix helpers.\n\u003c/p\u003e\u003cp\u003eSample usage, to upload a perspective matrix to a shader.\n\u003c/p\u003e\u003cpre\u003e glUniformMatrix4fv 0 1 (fromIntegral gl_TRUE) `appMatrix` perspective 0.01 100 (pi/2) (4/3) \n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.Packed.Foreign",
          "name": "Foreign",
          "package": "hmatrix",
          "source": "src/Data-Packed-Foreign.html",
          "type": "module"
        },
        "index": {
          "description": "FFI and hmatrix helpers Sample usage to upload perspective matrix to shader glUniformMatrix4fv fromIntegral gl TRUE appMatrix perspective pi",
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "Foreign",
          "package": "hmatrix",
          "partial": "Foreign",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly useful since it is left associated with a precedence of 1, unlike \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e, which is right associative.\n e.g.\n\u003c/p\u003e\u003cpre\u003e\n someFunction\n     `appMatrixLen` m\n     `appVectorLen` v\n     `app` other\n     `app` arguments\n     `app` go here\n\u003c/pre\u003e\u003cp\u003eOne could also write:\n\u003c/p\u003e\u003cpre\u003e\n (someFunction \n     `appMatrixLen` m\n     `appVectorLen` v) \n     other \n     arguments \n     (go here)\n\u003c/pre\u003e",
          "module": "Data.Packed.Foreign",
          "name": "app",
          "package": "hmatrix",
          "signature": "(a -\u003e b) -\u003e a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#app",
          "type": "function"
        },
        "index": {
          "description": "Only useful since it is left associated with precedence of unlike which is right associative e.g someFunction appMatrixLen appVectorLen app other app arguments app go here One could also write someFunction appMatrixLen appVectorLen other arguments go here",
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "app",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "hmatrix",
          "signature": "(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "appMatrix",
          "package": "hmatrix",
          "signature": "(Ptr a -\u003e b) -\u003e Matrix a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#appMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "appMatrix",
          "normalized": "(Ptr a-\u003eb)-\u003eMatrix a-\u003eb",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "(Ptr a-\u003eb)-\u003eMatrix a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:appMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "appMatrixLen",
          "package": "hmatrix",
          "signature": "(CInt -\u003e CInt -\u003e Ptr a -\u003e b) -\u003e Matrix a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#appMatrixLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "appMatrixLen",
          "normalized": "(CInt-\u003eCInt-\u003ePtr a-\u003eb)-\u003eMatrix a-\u003eb",
          "package": "hmatrix",
          "partial": "Matrix Len",
          "signature": "(CInt-\u003eCInt-\u003ePtr a-\u003eb)-\u003eMatrix a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:appMatrixLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "appMatrixRaw",
          "package": "hmatrix",
          "signature": "(Ptr a -\u003e b) -\u003e Matrix a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#appMatrixRaw",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "appMatrixRaw",
          "normalized": "(Ptr a-\u003eb)-\u003eMatrix a-\u003eb",
          "package": "hmatrix",
          "partial": "Matrix Raw",
          "signature": "(Ptr a-\u003eb)-\u003eMatrix a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:appMatrixRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "appMatrixRawLen",
          "package": "hmatrix",
          "signature": "(CInt -\u003e CInt -\u003e Ptr a -\u003e b) -\u003e Matrix a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#appMatrixRawLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "appMatrixRawLen",
          "normalized": "(CInt-\u003eCInt-\u003ePtr a-\u003eb)-\u003eMatrix a-\u003eb",
          "package": "hmatrix",
          "partial": "Matrix Raw Len",
          "signature": "(CInt-\u003eCInt-\u003ePtr a-\u003eb)-\u003eMatrix a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:appMatrixRawLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "appVector",
          "package": "hmatrix",
          "signature": "(Ptr a -\u003e b) -\u003e Vector a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#appVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "appVector",
          "normalized": "(Ptr a-\u003eb)-\u003eVector a-\u003eb",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "(Ptr a-\u003eb)-\u003eVector a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:appVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "appVectorLen",
          "package": "hmatrix",
          "signature": "(CInt -\u003e Ptr a -\u003e b) -\u003e Vector a -\u003e b",
          "source": "src/Data-Packed-Foreign.html#appVectorLen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "appVectorLen",
          "normalized": "(CInt-\u003ePtr a-\u003eb)-\u003eVector a-\u003eb",
          "package": "hmatrix",
          "partial": "Vector Len",
          "signature": "(CInt-\u003ePtr a-\u003eb)-\u003eVector a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:appVectorLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Foreign",
          "name": "unsafeMatrixToForeignPtr",
          "package": "hmatrix",
          "signature": "Matrix a -\u003e (ForeignPtr a, Int)",
          "source": "src/Data-Packed-Foreign.html#unsafeMatrixToForeignPtr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "unsafeMatrixToForeignPtr",
          "normalized": "Matrix a-\u003e(ForeignPtr a,Int)",
          "package": "hmatrix",
          "partial": "Matrix To Foreign Ptr",
          "signature": "Matrix a-\u003e(ForeignPtr a,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:unsafeMatrixToForeignPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis will disregard the order of the matrix, and simply return it as-is. \n If the order of the matrix is RowMajor, this function is identical to \u003ccode\u003e\u003ca\u003eflatten\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Packed.Foreign",
          "name": "unsafeMatrixToVector",
          "package": "hmatrix",
          "signature": "Matrix a -\u003e Vector a",
          "source": "src/Data-Packed-Foreign.html#unsafeMatrixToVector",
          "type": "function"
        },
        "index": {
          "description": "This will disregard the order of the matrix and simply return it as-is If the order of the matrix is RowMajor this function is identical to flatten",
          "hierarchy": "Data Packed Foreign",
          "module": "Data.Packed.Foreign",
          "name": "unsafeMatrixToVector",
          "normalized": "Matrix a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Matrix To Vector",
          "signature": "Matrix a-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Foreign.html#v:unsafeMatrixToVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Matrix representation suitable for numerical computations using LAPACK and GSL.\n\u003c/p\u003e\u003cp\u003eThis module provides basic functions for manipulation of structure.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Packed.Matrix",
          "name": "Matrix",
          "package": "hmatrix",
          "source": "src/Data-Packed-Matrix.html",
          "type": "module"
        },
        "index": {
          "description": "Matrix representation suitable for numerical computations using LAPACK and GSL This module provides basic functions for manipulation of structure",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "Matrix",
          "package": "hmatrix",
          "partial": "Matrix",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupported matrix elements.\n\u003c/p\u003e\u003cp\u003eThis class provides optimized internal\n    operations for selected element types.\n    It provides unoptimised defaults for any \u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e type,\n    so you can create instances simply as:\n    \u003ccode\u003einstance Element Foo\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "Element",
          "package": "hmatrix",
          "source": "src/Data-Packed-Internal-Matrix.html#Element",
          "type": "class"
        },
        "index": {
          "description": "Supported matrix elements This class provides optimized internal operations for selected element types It provides unoptimised defaults for any Storable type so you can create instances simply as instance Element Foo",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "Element",
          "package": "hmatrix",
          "partial": "Element",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#t:Element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix representation suitable for GSL and LAPACK computations.\n\u003c/p\u003e\u003cp\u003eThe elements are stored in a continuous memory array.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "Matrix",
          "package": "hmatrix",
          "source": "src/Data-Packed-Internal-Matrix.html#Matrix",
          "type": "data"
        },
        "index": {
          "description": "Matrix representation suitable for GSL and LAPACK computations The elements are stored in continuous memory array",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "Matrix",
          "package": "hmatrix",
          "partial": "Matrix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#t:Matrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn easy way to create a matrix:\n\u003c/p\u003e\u003cpre\u003e\u003e (2\u003e\u003c3)[1..6]\n(2\u003e\u003c3)\n [ 1.0, 2.0, 3.0\n , 4.0, 5.0, 6.0 ]\u003c/pre\u003e\u003cp\u003eThis is the format produced by the instances of Show (Matrix a), which\ncan also be used for input.\n\u003c/p\u003e\u003cp\u003eThe input list is explicitly truncated, so that it can\nsafely be used with lists that are too long (like infinite lists).\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e\u003e (2\u003e\u003c3)[1..]\n(2\u003e\u003c3)\n [ 1.0, 2.0, 3.0\n , 4.0, 5.0, 6.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "(\u003e\u003c)",
          "package": "hmatrix",
          "signature": "Int -\u003e Int -\u003e [a] -\u003e Matrix a",
          "source": "src/Data-Packed-Matrix.html#%3E%3C",
          "type": "function"
        },
        "index": {
          "description": "An easy way to create matrix This is the format produced by the instances of Show Matrix which can also be used for input The input list is explicitly truncated so that it can safely be used with lists that are too long like infinite lists Example",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "(\u003e\u003c) \u003e\u003c",
          "normalized": "Int-\u003eInt-\u003e[a]-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Int-\u003eInt-\u003e[a]-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:-62--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads a matrix position.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "(@@\u003e)",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Int, Int) -\u003e t",
          "source": "src/Data-Packed-Internal-Matrix.html#%40%40%3E",
          "type": "function"
        },
        "index": {
          "description": "Reads matrix position",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "(@@\u003e) @@\u003e",
          "normalized": "Matrix a-\u003e(Int,Int)-\u003ea",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Int,Int)-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:-64--64--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a 1-column matrix from a vector\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "asColumn",
          "package": "hmatrix",
          "signature": "Vector a -\u003e Matrix a",
          "source": "src/Data-Packed-Matrix.html#asColumn",
          "type": "function"
        },
        "index": {
          "description": "creates column matrix from vector",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "asColumn",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Column",
          "signature": "Vector a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:asColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a 1-row matrix from a vector\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "asRow",
          "package": "hmatrix",
          "signature": "Vector a -\u003e Matrix a",
          "source": "src/Data-Packed-Matrix.html#asRow",
          "type": "function"
        },
        "index": {
          "description": "creates row matrix from vector",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "asRow",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Row",
          "signature": "Vector a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:asRow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a Matrix of the specified size using the supplied function to\n     to map the row/column position to the value at that row/column position.\n\u003c/p\u003e\u003cpre\u003e\u003e buildMatrix 3 4 (\\(r,c) -\u003e fromIntegral r * fromIntegral c)\n(3\u003e\u003c4)\n [ 0.0, 0.0, 0.0, 0.0, 0.0\n , 0.0, 1.0, 2.0, 3.0, 4.0\n , 0.0, 2.0, 4.0, 6.0, 8.0]\u003c/pre\u003e\u003cp\u003eHilbert matrix of order N:\n\u003c/p\u003e\u003cpre\u003ehilb n = buildMatrix n n (\\(i,j)-\u003e1/(fromIntegral i + fromIntegral j +1))\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "buildMatrix",
          "package": "hmatrix",
          "signature": "Int -\u003e Int -\u003e ((Int, Int) -\u003e a) -\u003e Matrix a",
          "source": "src/Data-Packed-Matrix.html#buildMatrix",
          "type": "function"
        },
        "index": {
          "description": "creates Matrix of the specified size using the supplied function to to map the row column position to the value at that row column position buildMatrix fromIntegral fromIntegral Hilbert matrix of order hilb buildMatrix fromIntegral fromIntegral",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "buildMatrix",
          "normalized": "Int-\u003eInt-\u003e((Int,Int)-\u003ea)-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "Int-\u003eInt-\u003e((Int,Int)-\u003ea)-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:buildMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Matrix",
          "name": "cols",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Int",
          "source": "src/Data-Packed-Internal-Matrix.html#cols",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "cols",
          "normalized": "Matrix a-\u003eInt",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:cols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate a block diagonal matrix\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "diagBlock",
          "package": "hmatrix",
          "signature": "[Matrix t] -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#diagBlock",
          "type": "function"
        },
        "index": {
          "description": "create block diagonal matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "diagBlock",
          "normalized": "[Matrix a]-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Block",
          "signature": "[Matrix t]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:diagBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a rectangular diagonal matrix:\n\u003c/p\u003e\u003cpre\u003e\u003e diagRect 7 (fromList [10,20,30]) 4 5 :: Matrix Double\n(4\u003e\u003c5)\n [ 10.0,  7.0,  7.0, 7.0, 7.0\n ,  7.0, 20.0,  7.0, 7.0, 7.0\n ,  7.0,  7.0, 30.0, 7.0, 7.0\n ,  7.0,  7.0,  7.0, 7.0, 7.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "diagRect",
          "package": "hmatrix",
          "signature": "t -\u003e Vector t -\u003e Int -\u003e Int -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#diagRect",
          "type": "function"
        },
        "index": {
          "description": "creates rectangular diagonal matrix diagRect fromList Matrix Double",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "diagRect",
          "normalized": "a-\u003eVector a-\u003eInt-\u003eInt-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Rect",
          "signature": "t-\u003eVector t-\u003eInt-\u003eInt-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:diagRect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a copy of a matrix without the first n columns\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "dropColumns",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#dropColumns",
          "type": "function"
        },
        "index": {
          "description": "Creates copy of matrix without the first columns",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "dropColumns",
          "normalized": "Int-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Columns",
          "signature": "Int-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:dropColumns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a copy of a matrix without the first n rows\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "dropRows",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#dropRows",
          "type": "function"
        },
        "index": {
          "description": "Creates copy of matrix without the first rows",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "dropRows",
          "normalized": "Int-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Rows",
          "signature": "Int-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:dropRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erearranges the rows of a matrix according to the order given in a list of integers.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "extractRows",
          "package": "hmatrix",
          "signature": "[Int] -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#extractRows",
          "type": "function"
        },
        "index": {
          "description": "rearranges the rows of matrix according to the order given in list of integers",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "extractRows",
          "normalized": "[Int]-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Rows",
          "signature": "[Int]-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:extractRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a vector by concatenation of rows. If the matrix is ColumnMajor, this operation requires a transpose.\n\u003c/p\u003e\u003cpre\u003e\u003e flatten (\u003ccode\u003eident\u003c/code\u003e 3)\n 9 |\u003e [1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "flatten",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector t",
          "source": "src/Data-Packed-Internal-Matrix.html#flatten",
          "type": "function"
        },
        "index": {
          "description": "Creates vector by concatenation of rows If the matrix is ColumnMajor this operation requires transpose flatten ident",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "flatten",
          "normalized": "Matrix a-\u003eVector a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse columns\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "fliprl",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#fliprl",
          "type": "function"
        },
        "index": {
          "description": "Reverse columns",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "fliprl",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:fliprl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverse rows\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "flipud",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#flipud",
          "type": "function"
        },
        "index": {
          "description": "Reverse rows",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "flipud",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:flipud"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Matrix",
          "name": "fromArray2D",
          "package": "hmatrix",
          "signature": "Array (Int, Int) e -\u003e Matrix e",
          "source": "src/Data-Packed-Matrix.html#fromArray2D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "fromArray2D",
          "normalized": "Array(Int,Int)a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Array",
          "signature": "Array(Int,Int)e-\u003eMatrix e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:fromArray2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a matrix from blocks given as a list of lists of matrices.\n\u003c/p\u003e\u003cp\u003eSingle row/column components are automatically expanded to match the\ncorresponding common row and column:\n\u003c/p\u003e\u003cpre\u003e\u003e let disp = putStr . dispf 2\n\u003e let vector xs = fromList xs :: Vector Double\n\u003e let diagl = diag . vector\n\u003e let rowm = asRow . vector\n\n\u003e disp $ fromBlocks [[ident 5, 7, rowm[10,20]], [3, diagl[1,2,3], 0]]\n\n8x10\n1  0  0  0  0  7  7  7  10  20\n0  1  0  0  0  7  7  7  10  20\n0  0  1  0  0  7  7  7  10  20\n0  0  0  1  0  7  7  7  10  20\n0  0  0  0  1  7  7  7  10  20\n3  3  3  3  3  1  0  0   0   0\n3  3  3  3  3  0  2  0   0   0\n3  3  3  3  3  0  0  3   0   0\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "fromBlocks",
          "package": "hmatrix",
          "signature": "[[Matrix t]] -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#fromBlocks",
          "type": "function"
        },
        "index": {
          "description": "Creates matrix from blocks given as list of lists of matrices Single row column components are automatically expanded to match the corresponding common row and column let disp putStr dispf let vector xs fromList xs Vector Double let diagl diag vector let rowm asRow vector disp fromBlocks ident rowm diagl x10",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "fromBlocks",
          "normalized": "[[Matrix a]]-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Blocks",
          "signature": "[[Matrix t]]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:fromBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a matrix from a list of vectors, as columns\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "fromColumns",
          "package": "hmatrix",
          "signature": "[Vector t] -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#fromColumns",
          "type": "function"
        },
        "index": {
          "description": "Creates matrix from list of vectors as columns",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "fromColumns",
          "normalized": "[Vector a]-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Columns",
          "signature": "[Vector t]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:fromColumns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e from a list of lists (considered as rows).\n\u003c/p\u003e\u003cpre\u003e\u003e fromLists [[1,2],[3,4],[5,6]]\n(3\u003e\u003c2)\n [ 1.0, 2.0\n , 3.0, 4.0\n , 5.0, 6.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "fromLists",
          "package": "hmatrix",
          "signature": "[[t]] -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#fromLists",
          "type": "function"
        },
        "index": {
          "description": "Creates Matrix from list of lists considered as rows fromLists",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "fromLists",
          "normalized": "[[a]]-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Lists",
          "signature": "[[t]]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:fromLists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a matrix from a list of vectors.\n All vectors must have the same dimension,\n or dimension 1, which is are automatically expanded.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "fromRows",
          "package": "hmatrix",
          "signature": "[Vector t] -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#fromRows",
          "type": "function"
        },
        "index": {
          "description": "Create matrix from list of vectors All vectors must have the same dimension or dimension which is are automatically expanded",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "fromRows",
          "normalized": "[Vector a]-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Rows",
          "signature": "[Vector t]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:fromRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplication of a vector function on the flattened matrix elements\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "liftMatrix",
          "package": "hmatrix",
          "signature": "(Vector a -\u003e Vector b) -\u003e Matrix a -\u003e Matrix b",
          "source": "src/Data-Packed-Internal-Matrix.html#liftMatrix",
          "type": "function"
        },
        "index": {
          "description": "application of vector function on the flattened matrix elements",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "liftMatrix",
          "normalized": "(Vector a-\u003eVector b)-\u003eMatrix a-\u003eMatrix b",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "(Vector a-\u003eVector b)-\u003eMatrix a-\u003eMatrix b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:liftMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplication of a vector function on the flattened matrices elements\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "liftMatrix2",
          "package": "hmatrix",
          "signature": "(Vector a -\u003e Vector b -\u003e Vector t) -\u003e Matrix a -\u003e Matrix b -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#liftMatrix2",
          "type": "function"
        },
        "index": {
          "description": "application of vector function on the flattened matrices elements",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "liftMatrix2",
          "normalized": "(Vector a-\u003eVector b-\u003eVector c)-\u003eMatrix a-\u003eMatrix b-\u003eMatrix c",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "(Vector a-\u003eVector b-\u003eVector t)-\u003eMatrix a-\u003eMatrix b-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:liftMatrix2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003eliftMatrix2\u003c/a\u003e\u003c/code\u003e which automatically adapt matrices with a single row or column to match the dimensions of the other matrix.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "liftMatrix2Auto",
          "package": "hmatrix",
          "signature": "(Vector a -\u003e Vector b -\u003e Vector t) -\u003e Matrix a -\u003e Matrix b -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#liftMatrix2Auto",
          "type": "function"
        },
        "index": {
          "description": "version of liftMatrix2 which automatically adapt matrices with single row or column to match the dimensions of the other matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "liftMatrix2Auto",
          "normalized": "(Vector a-\u003eVector b-\u003eVector c)-\u003eMatrix a-\u003eMatrix b-\u003eMatrix c",
          "package": "hmatrix",
          "partial": "Matrix Auto",
          "signature": "(Vector a-\u003eVector b-\u003eVector t)-\u003eMatrix a-\u003eMatrix b-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:liftMatrix2Auto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Matrix",
          "name": "mapMatrix",
          "package": "hmatrix",
          "signature": "(a -\u003e b) -\u003e Matrix a -\u003e Matrix b",
          "source": "src/Data-Packed-Matrix.html#mapMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrix",
          "normalized": "(a-\u003eb)-\u003eMatrix a-\u003eMatrix b",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "(a-\u003eb)-\u003eMatrix a-\u003eMatrix b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:mapMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003eghci\u003e mapMatrixWithIndex (\\(i,j) v -\u003e 100*v + 10*i + j) (ident 3:: Matrix Double)\n(3\u003e\u003c3)\n [ 100.0,   1.0,   2.0\n ,  10.0, 111.0,  12.0\n ,  20.0,  21.0, 122.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrixWithIndex",
          "package": "hmatrix",
          "signature": "((Int, Int) -\u003e a -\u003e b) -\u003e Matrix a -\u003e Matrix b",
          "source": "src/Data-Packed-Matrix.html#mapMatrixWithIndex",
          "type": "function"
        },
        "index": {
          "description": "ghci mapMatrixWithIndex ident Matrix Double",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrixWithIndex",
          "normalized": "((Int,Int)-\u003ea-\u003eb)-\u003eMatrix a-\u003eMatrix b",
          "package": "hmatrix",
          "partial": "Matrix With Index",
          "signature": "((Int,Int)-\u003ea-\u003eb)-\u003eMatrix a-\u003eMatrix b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:mapMatrixWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003eghci\u003e mapMatrixWithIndexM (\\(i,j) v -\u003e Just $ 100*v + 10*i + j) (ident 3:: Matrix Double)\nJust (3\u003e\u003c3)\n [ 100.0,   1.0,   2.0\n ,  10.0, 111.0,  12.0\n ,  20.0,  21.0, 122.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrixWithIndexM",
          "package": "hmatrix",
          "signature": "((Int, Int) -\u003e a -\u003e m b) -\u003e Matrix a -\u003e m (Matrix b)",
          "source": "src/Data-Packed-Matrix.html#mapMatrixWithIndexM",
          "type": "function"
        },
        "index": {
          "description": "ghci mapMatrixWithIndexM Just ident Matrix Double Just",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrixWithIndexM",
          "normalized": "((Int,Int)-\u003ea-\u003eb c)-\u003eMatrix a-\u003eb(Matrix c)",
          "package": "hmatrix",
          "partial": "Matrix With Index",
          "signature": "((Int,Int)-\u003ea-\u003em b)-\u003eMatrix a-\u003em(Matrix b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:mapMatrixWithIndexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003eghci\u003e mapMatrixWithIndexM_ (\\(i,j) v -\u003e printf \"m[%.0f,%.0f] = %.f\\n\" i j v :: IO()) ((2\u003e\u003c3)[1 :: Double ..])\nm[0,0] = 1\nm[0,1] = 2\nm[0,2] = 3\nm[1,0] = 4\nm[1,1] = 5\nm[1,2] = 6\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrixWithIndexM_",
          "package": "hmatrix",
          "signature": "((Int, Int) -\u003e a -\u003e m ()) -\u003e Matrix a -\u003e m ()",
          "source": "src/Data-Packed-Matrix.html#mapMatrixWithIndexM_",
          "type": "function"
        },
        "index": {
          "description": "ghci mapMatrixWithIndexM printf IO Double",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "mapMatrixWithIndexM_",
          "normalized": "((Int,Int)-\u003ea-\u003eb())-\u003eMatrix a-\u003eb()",
          "package": "hmatrix",
          "partial": "Matrix With Index",
          "signature": "((Int,Int)-\u003ea-\u003em())-\u003eMatrix a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:mapMatrixWithIndexM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates matrix by repetition of a matrix a given number of rows and columns\n\u003c/p\u003e\u003cpre\u003e\u003e repmat (ident 2) 2 3 :: Matrix Double\n(4\u003e\u003c6)\n [ 1.0, 0.0, 1.0, 0.0, 1.0, 0.0\n , 0.0, 1.0, 0.0, 1.0, 0.0, 1.0\n , 1.0, 0.0, 1.0, 0.0, 1.0, 0.0\n , 0.0, 1.0, 0.0, 1.0, 0.0, 1.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "repmat",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Int -\u003e Int -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#repmat",
          "type": "function"
        },
        "index": {
          "description": "creates matrix by repetition of matrix given number of rows and columns repmat ident Matrix Double",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "repmat",
          "normalized": "Matrix a-\u003eInt-\u003eInt-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eInt-\u003eInt-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:repmat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a matrix from a vector by grouping the elements in rows with the desired number of columns. (GNU-Octave groups by columns. To do it you can define \u003ccode\u003ereshapeF r = trans . reshape r\u003c/code\u003e\nwhere r is the desired number of rows.)\n\u003c/p\u003e\u003cpre\u003e\u003e reshape 4 (\u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e [1..12])\n(3\u003e\u003c4)\n [ 1.0,  2.0,  3.0,  4.0\n , 5.0,  6.0,  7.0,  8.0\n , 9.0, 10.0, 11.0, 12.0 ]\u003c/pre\u003e",
          "module": "Data.Packed.Matrix",
          "name": "reshape",
          "package": "hmatrix",
          "signature": "Int -\u003e Vector t -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#reshape",
          "type": "function"
        },
        "index": {
          "description": "Creates matrix from vector by grouping the elements in rows with the desired number of columns GNU-Octave groups by columns To do it you can define reshapeF trans reshape where is the desired number of rows reshape fromList",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "reshape",
          "normalized": "Int-\u003eVector a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Int-\u003eVector t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:reshape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Matrix",
          "name": "rows",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Int",
          "source": "src/Data-Packed-Internal-Matrix.html#rows",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "rows",
          "normalized": "Matrix a-\u003eInt",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:rows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts a submatrix from a matrix.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "subMatrix",
          "package": "hmatrix",
          "signature": "(Int, Int)-\u003e (Int, Int)-\u003e Matrix a-\u003e Matrix a",
          "type": "function"
        },
        "index": {
          "description": "Extracts submatrix from matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "subMatrix",
          "normalized": "(Int,Int)-\u003e(Int,Int)-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "(Int,Int)-\u003e(Int,Int)-\u003eMatrix a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:subMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a matrix with the first n columns of another matrix\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "takeColumns",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#takeColumns",
          "type": "function"
        },
        "index": {
          "description": "Creates matrix with the first columns of another matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "takeColumns",
          "normalized": "Int-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Columns",
          "signature": "Int-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:takeColumns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextracts the diagonal from a rectangular matrix\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "takeDiag",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector t",
          "source": "src/Data-Packed-Matrix.html#takeDiag",
          "type": "function"
        },
        "index": {
          "description": "extracts the diagonal from rectangular matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "takeDiag",
          "normalized": "Matrix a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Diag",
          "signature": "Matrix t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:takeDiag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a matrix with the first n rows of another matrix\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "takeRows",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Matrix.html#takeRows",
          "type": "function"
        },
        "index": {
          "description": "Creates matrix with the first rows of another matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "takeRows",
          "normalized": "Int-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Rows",
          "signature": "Int-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:takeRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartition a matrix into blocks with the given numbers of rows and columns.\n The remaining rows and columns are discarded.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "toBlocks",
          "package": "hmatrix",
          "signature": "[Int] -\u003e [Int] -\u003e Matrix t -\u003e [[Matrix t]]",
          "source": "src/Data-Packed-Matrix.html#toBlocks",
          "type": "function"
        },
        "index": {
          "description": "Partition matrix into blocks with the given numbers of rows and columns The remaining rows and columns are discarded",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "toBlocks",
          "normalized": "[Int]-\u003e[Int]-\u003eMatrix a-\u003e[[Matrix a]]",
          "package": "hmatrix",
          "partial": "Blocks",
          "signature": "[Int]-\u003e[Int]-\u003eMatrix t-\u003e[[Matrix t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:toBlocks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFully partition a matrix into blocks of the same size. If the dimensions are not\n a multiple of the given size the last blocks will be smaller.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "toBlocksEvery",
          "package": "hmatrix",
          "signature": "Int -\u003e Int -\u003e Matrix t -\u003e [[Matrix t]]",
          "source": "src/Data-Packed-Matrix.html#toBlocksEvery",
          "type": "function"
        },
        "index": {
          "description": "Fully partition matrix into blocks of the same size If the dimensions are not multiple of the given size the last blocks will be smaller",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "toBlocksEvery",
          "normalized": "Int-\u003eInt-\u003eMatrix a-\u003e[[Matrix a]]",
          "package": "hmatrix",
          "partial": "Blocks Every",
          "signature": "Int-\u003eInt-\u003eMatrix t-\u003e[[Matrix t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:toBlocksEvery"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a list of vectors from the columns of a matrix\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "toColumns",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e [Vector t]",
          "source": "src/Data-Packed-Internal-Matrix.html#toColumns",
          "type": "function"
        },
        "index": {
          "description": "Creates list of vectors from the columns of matrix",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "toColumns",
          "normalized": "Matrix a-\u003e[Vector a]",
          "package": "hmatrix",
          "partial": "Columns",
          "signature": "Matrix t-\u003e[Vector t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:toColumns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe inverse of \u003ccode\u003e\u003ca\u003efromLists\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "toLists",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e [[t]]",
          "source": "src/Data-Packed-Internal-Matrix.html#toLists",
          "type": "function"
        },
        "index": {
          "description": "the inverse of fromLists",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "toLists",
          "normalized": "Matrix a-\u003e[[a]]",
          "package": "hmatrix",
          "partial": "Lists",
          "signature": "Matrix t-\u003e[[t]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:toLists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextracts the rows of a matrix as a list of vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "toRows",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e [Vector t]",
          "source": "src/Data-Packed-Internal-Matrix.html#toRows",
          "type": "function"
        },
        "index": {
          "description": "extracts the rows of matrix as list of vectors",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "toRows",
          "normalized": "Matrix a-\u003e[Vector a]",
          "package": "hmatrix",
          "partial": "Rows",
          "signature": "Matrix t-\u003e[Vector t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:toRows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix transpose.\n\u003c/p\u003e",
          "module": "Data.Packed.Matrix",
          "name": "trans",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Data-Packed-Internal-Matrix.html#trans",
          "type": "function"
        },
        "index": {
          "description": "Matrix transpose",
          "hierarchy": "Data Packed Matrix",
          "module": "Data.Packed.Matrix",
          "name": "trans",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Matrix.html#v:trans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eIn-place manipulation inside the ST monad.\n See examples/inplace.hs in the distribution.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Packed.ST",
          "name": "ST",
          "package": "hmatrix",
          "source": "src/Data-Packed-ST.html",
          "type": "module"
        },
        "index": {
          "description": "In-place manipulation inside the ST monad See examples inplace.hs in the distribution",
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "ST",
          "package": "hmatrix",
          "partial": "ST",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "STMatrix",
          "package": "hmatrix",
          "source": "src/Data-Packed-ST.html#STMatrix",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "STMatrix",
          "package": "hmatrix",
          "partial": "STMatrix",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#t:STMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "STVector",
          "package": "hmatrix",
          "source": "src/Data-Packed-ST.html#STVector",
          "type": "data"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "STVector",
          "package": "hmatrix",
          "partial": "STVector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#t:STVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "freezeMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s1 t -\u003e ST s2 (Matrix t)",
          "source": "src/Data-Packed-ST.html#freezeMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "freezeMatrix",
          "normalized": "STMatrix a b-\u003eST a(Matrix b)",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "STMatrix s t-\u003eST s(Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:freezeMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "freezeVector",
          "package": "hmatrix",
          "signature": "STVector s1 t -\u003e ST s2 (Vector t)",
          "source": "src/Data-Packed-ST.html#freezeVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "freezeVector",
          "normalized": "STVector a b-\u003eST a(Vector b)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "STVector s t-\u003eST s(Vector t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:freezeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "liftSTMatrix",
          "package": "hmatrix",
          "signature": "(Matrix t -\u003e a) -\u003e STMatrix s1 t -\u003e ST s2 a",
          "source": "src/Data-Packed-ST.html#liftSTMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "liftSTMatrix",
          "normalized": "(Matrix a-\u003eb)-\u003eSTMatrix c a-\u003eST c b",
          "package": "hmatrix",
          "partial": "STMatrix",
          "signature": "(Matrix t-\u003ea)-\u003eSTMatrix s t-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:liftSTMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "liftSTVector",
          "package": "hmatrix",
          "signature": "(Vector t -\u003e a) -\u003e STVector s1 t -\u003e ST s2 a",
          "source": "src/Data-Packed-ST.html#liftSTVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "liftSTVector",
          "normalized": "(Vector a-\u003eb)-\u003eSTVector c a-\u003eST c b",
          "package": "hmatrix",
          "partial": "STVector",
          "signature": "(Vector t-\u003ea)-\u003eSTVector s t-\u003eST s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:liftSTVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "modifyMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s t -\u003e Int -\u003e Int -\u003e (t -\u003e t) -\u003e ST s ()",
          "source": "src/Data-Packed-ST.html#modifyMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "modifyMatrix",
          "normalized": "STMatrix a b-\u003eInt-\u003eInt-\u003e(b-\u003eb)-\u003eST a()",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "STMatrix s t-\u003eInt-\u003eInt-\u003e(t-\u003et)-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:modifyMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "modifyVector",
          "package": "hmatrix",
          "signature": "STVector s t -\u003e Int -\u003e (t -\u003e t) -\u003e ST s ()",
          "source": "src/Data-Packed-ST.html#modifyVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "modifyVector",
          "normalized": "STVector a b-\u003eInt-\u003e(b-\u003eb)-\u003eST a()",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "STVector s t-\u003eInt-\u003e(t-\u003et)-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:modifyVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "newMatrix",
          "package": "hmatrix",
          "signature": "t -\u003e Int -\u003e Int -\u003e ST s (STMatrix s t)",
          "source": "src/Data-Packed-ST.html#newMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "newMatrix",
          "normalized": "a-\u003eInt-\u003eInt-\u003eST b(STMatrix b a)",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "t-\u003eInt-\u003eInt-\u003eST s(STMatrix s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:newMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "newUndefinedMatrix",
          "package": "hmatrix",
          "signature": "MatrixOrder -\u003e Int -\u003e Int -\u003e ST s (STMatrix s t)",
          "source": "src/Data-Packed-ST.html#newUndefinedMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "newUndefinedMatrix",
          "normalized": "MatrixOrder-\u003eInt-\u003eInt-\u003eST a(STMatrix a b)",
          "package": "hmatrix",
          "partial": "Undefined Matrix",
          "signature": "MatrixOrder-\u003eInt-\u003eInt-\u003eST s(STMatrix s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:newUndefinedMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "newUndefinedVector",
          "package": "hmatrix",
          "signature": "Int -\u003e ST s (STVector s t)",
          "source": "src/Data-Packed-ST.html#newUndefinedVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "newUndefinedVector",
          "normalized": "Int-\u003eST a(STVector a b)",
          "package": "hmatrix",
          "partial": "Undefined Vector",
          "signature": "Int-\u003eST s(STVector s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:newUndefinedVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "newVector",
          "package": "hmatrix",
          "signature": "t -\u003e Int -\u003e ST s (STVector s t)",
          "source": "src/Data-Packed-ST.html#newVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "newVector",
          "normalized": "a-\u003eInt-\u003eST b(STVector b a)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "t-\u003eInt-\u003eST s(STVector s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:newVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "readMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s t -\u003e Int -\u003e Int -\u003e ST s t",
          "source": "src/Data-Packed-ST.html#readMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "readMatrix",
          "normalized": "STMatrix a b-\u003eInt-\u003eInt-\u003eST a b",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "STMatrix s t-\u003eInt-\u003eInt-\u003eST s t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:readMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "readVector",
          "package": "hmatrix",
          "signature": "STVector s t -\u003e Int -\u003e ST s t",
          "source": "src/Data-Packed-ST.html#readVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "readVector",
          "normalized": "STVector a b-\u003eInt-\u003eST a b",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "STVector s t-\u003eInt-\u003eST s t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:readVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "runSTMatrix",
          "package": "hmatrix",
          "signature": "(forall s.  ST s (STMatrix s t)) -\u003e Matrix t",
          "source": "src/Data-Packed-ST.html#runSTMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "runSTMatrix",
          "normalized": "(a b ST c(STMatrix c d))-\u003eMatrix d",
          "package": "hmatrix",
          "partial": "STMatrix",
          "signature": "(forall s. ST s(STMatrix s t))-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:runSTMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "runSTVector",
          "package": "hmatrix",
          "signature": "(forall s.  ST s (STVector s t)) -\u003e Vector t",
          "source": "src/Data-Packed-ST.html#runSTVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "runSTVector",
          "normalized": "(a b ST c(STVector c d))-\u003eVector d",
          "package": "hmatrix",
          "partial": "STVector",
          "signature": "(forall s. ST s(STVector s t))-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:runSTVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "thawMatrix",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e ST s (STMatrix s t)",
          "source": "src/Data-Packed-ST.html#thawMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "thawMatrix",
          "normalized": "Matrix a-\u003eST b(STMatrix b a)",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "Matrix t-\u003eST s(STMatrix s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:thawMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "thawVector",
          "package": "hmatrix",
          "signature": "Vector t -\u003e ST s (STVector s t)",
          "source": "src/Data-Packed-ST.html#thawVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "thawVector",
          "normalized": "Vector a-\u003eST b(STVector b a)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Vector t-\u003eST s(STVector s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:thawVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeFreezeMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s1 t -\u003e ST s2 (Matrix t)",
          "source": "src/Data-Packed-ST.html#unsafeFreezeMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeFreezeMatrix",
          "normalized": "STMatrix a b-\u003eST a(Matrix b)",
          "package": "hmatrix",
          "partial": "Freeze Matrix",
          "signature": "STMatrix s t-\u003eST s(Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeFreezeMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeFreezeVector",
          "package": "hmatrix",
          "signature": "STVector s1 t -\u003e ST s2 (Vector t)",
          "source": "src/Data-Packed-ST.html#unsafeFreezeVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeFreezeVector",
          "normalized": "STVector a b-\u003eST a(Vector b)",
          "package": "hmatrix",
          "partial": "Freeze Vector",
          "signature": "STVector s t-\u003eST s(Vector t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeFreezeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeReadMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s t -\u003e Int -\u003e Int -\u003e ST s t",
          "source": "src/Data-Packed-ST.html#unsafeReadMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeReadMatrix",
          "normalized": "STMatrix a b-\u003eInt-\u003eInt-\u003eST a b",
          "package": "hmatrix",
          "partial": "Read Matrix",
          "signature": "STMatrix s t-\u003eInt-\u003eInt-\u003eST s t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeReadMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeReadVector",
          "package": "hmatrix",
          "signature": "STVector s t -\u003e Int -\u003e ST s t",
          "source": "src/Data-Packed-ST.html#unsafeReadVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeReadVector",
          "normalized": "STVector a b-\u003eInt-\u003eST a b",
          "package": "hmatrix",
          "partial": "Read Vector",
          "signature": "STVector s t-\u003eInt-\u003eST s t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeReadVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeThawMatrix",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e ST s (STMatrix s t)",
          "source": "src/Data-Packed-ST.html#unsafeThawMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeThawMatrix",
          "normalized": "Matrix a-\u003eST b(STMatrix b a)",
          "package": "hmatrix",
          "partial": "Thaw Matrix",
          "signature": "Matrix t-\u003eST s(STMatrix s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeThawMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeThawVector",
          "package": "hmatrix",
          "signature": "Vector t -\u003e ST s (STVector s t)",
          "source": "src/Data-Packed-ST.html#unsafeThawVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeThawVector",
          "normalized": "Vector a-\u003eST b(STVector b a)",
          "package": "hmatrix",
          "partial": "Thaw Vector",
          "signature": "Vector t-\u003eST s(STVector s t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeThawVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeWriteMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s t -\u003e Int -\u003e Int -\u003e t -\u003e ST s ()",
          "source": "src/Data-Packed-ST.html#unsafeWriteMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeWriteMatrix",
          "normalized": "STMatrix a b-\u003eInt-\u003eInt-\u003eb-\u003eST a()",
          "package": "hmatrix",
          "partial": "Write Matrix",
          "signature": "STMatrix s t-\u003eInt-\u003eInt-\u003et-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeWriteMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "unsafeWriteVector",
          "package": "hmatrix",
          "signature": "STVector s t -\u003e Int -\u003e t -\u003e ST s ()",
          "source": "src/Data-Packed-ST.html#unsafeWriteVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "unsafeWriteVector",
          "normalized": "STVector a b-\u003eInt-\u003eb-\u003eST a()",
          "package": "hmatrix",
          "partial": "Write Vector",
          "signature": "STVector s t-\u003eInt-\u003et-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:unsafeWriteVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "writeMatrix",
          "package": "hmatrix",
          "signature": "STMatrix s t -\u003e Int -\u003e Int -\u003e t -\u003e ST s ()",
          "source": "src/Data-Packed-ST.html#writeMatrix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "writeMatrix",
          "normalized": "STMatrix a b-\u003eInt-\u003eInt-\u003eb-\u003eST a()",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "STMatrix s t-\u003eInt-\u003eInt-\u003et-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:writeMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.ST",
          "name": "writeVector",
          "package": "hmatrix",
          "signature": "STVector s t -\u003e Int -\u003e t -\u003e ST s ()",
          "source": "src/Data-Packed-ST.html#writeVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed ST",
          "module": "Data.Packed.ST",
          "name": "writeVector",
          "normalized": "STVector a b-\u003eInt-\u003eb-\u003eST a()",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "STVector s t-\u003eInt-\u003et-\u003eST s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-ST.html#v:writeVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e1D arrays suitable for numeric computations using external libraries.\n\u003c/p\u003e\u003cp\u003eThis module provides basic functions for manipulation of structure.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Packed.Vector",
          "name": "Vector",
          "package": "hmatrix",
          "source": "src/Data-Packed-Vector.html",
          "type": "module"
        },
        "index": {
          "description": "arrays suitable for numeric computations using external libraries This module provides basic functions for manipulation of structure",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "Vector",
          "package": "hmatrix",
          "partial": "Vector",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eStorable\u003c/a\u003e\u003c/code\u003e-based vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "Vector",
          "package": "hmatrix",
          "type": "data"
        },
        "index": {
          "description": "Storable based vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "Vector",
          "package": "hmatrix",
          "partial": "Vector",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#t:Vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative to \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e with explicit dimension. The input\n     list is explicitly truncated if it is too long, so it may safely\n     be used, for instance, with infinite lists.\n\u003c/p\u003e\u003cp\u003eThis is the format used in the instances for Show (Vector a).\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "(|\u003e)",
          "package": "hmatrix",
          "signature": "Int -\u003e [a] -\u003e Vector a",
          "source": "src/Data-Packed-Internal-Vector.html#%7C%3E",
          "type": "function"
        },
        "index": {
          "description": "An alternative to fromList with explicit dimension The input list is explicitly truncated if it is too long so it may safely be used for instance with infinite lists This is the format used in the instances for Show Vector",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "(|\u003e) |\u003e",
          "normalized": "Int-\u003e[a]-\u003eVector a",
          "package": "hmatrix",
          "signature": "Int-\u003e[a]-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:-124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReads a vector position:\n\u003c/p\u003e\u003cpre\u003e\u003e fromList [0..9] @\u003e 7\n7.0\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "(@\u003e)",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Int -\u003e t",
          "source": "src/Data-Packed-Internal-Vector.html#%40%3E",
          "type": "function"
        },
        "index": {
          "description": "Reads vector position fromList",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "(@\u003e) @\u003e",
          "normalized": "Vector a-\u003eInt-\u003ea",
          "package": "hmatrix",
          "signature": "Vector t-\u003eInt-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:-64--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a Vector of the specified length using the supplied function to\n     to map the index to the value at that index.\n\u003c/p\u003e\u003cpre\u003e\u003e buildVector 4 fromIntegral\n4 |\u003e [0.0,1.0,2.0,3.0]\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "buildVector",
          "package": "hmatrix",
          "signature": "Int -\u003e (Int -\u003e a) -\u003e Vector a",
          "source": "src/Data-Packed-Vector.html#buildVector",
          "type": "function"
        },
        "index": {
          "description": "creates Vector of the specified length using the supplied function to to map the index to the value at that index buildVector fromIntegral",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "buildVector",
          "normalized": "Int-\u003e(Int-\u003ea)-\u003eVector a",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Int-\u003e(Int-\u003ea)-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:buildVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of elements\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "dim",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Int",
          "source": "src/Data-Packed-Internal-Vector.html#dim",
          "type": "function"
        },
        "index": {
          "description": "Number of elements",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "dim",
          "normalized": "Vector a-\u003eInt",
          "package": "hmatrix",
          "signature": "Vector t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:dim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Vector",
          "name": "foldLoop",
          "package": "hmatrix",
          "signature": "(Int -\u003e t -\u003e t) -\u003e t -\u003e Int -\u003e t",
          "source": "src/Data-Packed-Internal-Vector.html#foldLoop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "foldLoop",
          "normalized": "(Int-\u003ea-\u003ea)-\u003ea-\u003eInt-\u003ea",
          "package": "hmatrix",
          "partial": "Loop",
          "signature": "(Int-\u003et-\u003et)-\u003et-\u003eInt-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:foldLoop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Vector",
          "name": "foldVector",
          "package": "hmatrix",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
          "source": "src/Data-Packed-Internal-Vector.html#foldVector",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "foldVector",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:foldVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Vector",
          "name": "foldVectorG",
          "package": "hmatrix",
          "signature": "(Int -\u003e (Int -\u003e t1) -\u003e t -\u003e t) -\u003e t -\u003e Vector t1 -\u003e t",
          "source": "src/Data-Packed-Internal-Vector.html#foldVectorG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "foldVectorG",
          "normalized": "(Int-\u003e(Int-\u003ea)-\u003ea-\u003ea)-\u003ea-\u003eVector a-\u003ea",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "(Int-\u003e(Int-\u003et)-\u003et-\u003et)-\u003et-\u003eVector t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:foldVectorG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Vector",
          "name": "foldVectorWithIndex",
          "package": "hmatrix",
          "signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Vector a -\u003e b",
          "source": "src/Data-Packed-Internal-Vector.html#foldVectorWithIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "foldVectorWithIndex",
          "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
          "package": "hmatrix",
          "partial": "Vector With Index",
          "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eVector a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:foldVectorWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a Vector from a list:\n\u003c/p\u003e\u003cpre\u003e\u003e fromList [2,3,5,7]\n4 |\u003e [2.0,3.0,5.0,7.0]\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "fromList",
          "package": "hmatrix",
          "signature": "[a] -\u003e Vector a",
          "source": "src/Data-Packed-Internal-Vector.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "creates Vector from list fromList",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "fromList",
          "normalized": "[a]-\u003eVector a",
          "package": "hmatrix",
          "partial": "List",
          "signature": "[a]-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a new Vector by joining a list of Vectors\n\u003c/p\u003e\u003cpre\u003e\u003e join [fromList [1..5], constant 1 3]\n8 |\u003e [1.0,2.0,3.0,4.0,5.0,1.0,1.0,1.0]\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "join",
          "package": "hmatrix",
          "signature": "[Vector t] -\u003e Vector t",
          "source": "src/Data-Packed-Internal-Vector.html#join",
          "type": "function"
        },
        "index": {
          "description": "creates new Vector by joining list of Vectors join fromList constant",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "join",
          "normalized": "[Vector a]-\u003eVector a",
          "package": "hmatrix",
          "signature": "[Vector t]-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:join"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap on Vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "mapVector",
          "package": "hmatrix",
          "signature": "(a -\u003e b) -\u003e Vector a -\u003e Vector b",
          "source": "src/Data-Packed-Internal-Vector.html#mapVector",
          "type": "function"
        },
        "index": {
          "description": "map on Vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "mapVector",
          "normalized": "(a-\u003eb)-\u003eVector a-\u003eVector b",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "(a-\u003eb)-\u003eVector a-\u003eVector b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:mapVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emonadic map over Vectors\n    the monad \u003ccode\u003em\u003c/code\u003e must be strict\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "mapVectorM",
          "package": "hmatrix",
          "signature": "(a -\u003e m b) -\u003e Vector a -\u003e m (Vector b)",
          "source": "src/Data-Packed-Internal-Vector.html#mapVectorM",
          "type": "function"
        },
        "index": {
          "description": "monadic map over Vectors the monad must be strict",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "mapVectorM",
          "normalized": "(a-\u003eb c)-\u003eVector a-\u003eb(Vector c)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "(a-\u003em b)-\u003eVector a-\u003em(Vector b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:mapVectorM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emonadic map over Vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "mapVectorM_",
          "package": "hmatrix",
          "signature": "(a -\u003e m ()) -\u003e Vector a -\u003e m ()",
          "source": "src/Data-Packed-Internal-Vector.html#mapVectorM_",
          "type": "function"
        },
        "index": {
          "description": "monadic map over Vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "mapVectorM_",
          "normalized": "(a-\u003eb())-\u003eVector a-\u003eb()",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "(a-\u003em())-\u003eVector a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:mapVectorM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Packed.Vector",
          "name": "mapVectorWithIndex",
          "package": "hmatrix",
          "signature": "(Int -\u003e a -\u003e b) -\u003e Vector a -\u003e Vector b",
          "source": "src/Data-Packed-Internal-Vector.html#mapVectorWithIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "mapVectorWithIndex",
          "normalized": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b",
          "package": "hmatrix",
          "partial": "Vector With Index",
          "signature": "(Int-\u003ea-\u003eb)-\u003eVector a-\u003eVector b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:mapVectorWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emonadic map over Vectors with the zero-indexed index passed to the mapping function\n    the monad \u003ccode\u003em\u003c/code\u003e must be strict\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "mapVectorWithIndexM",
          "package": "hmatrix",
          "signature": "(Int -\u003e a -\u003e m b) -\u003e Vector a -\u003e m (Vector b)",
          "source": "src/Data-Packed-Internal-Vector.html#mapVectorWithIndexM",
          "type": "function"
        },
        "index": {
          "description": "monadic map over Vectors with the zero-indexed index passed to the mapping function the monad must be strict",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "mapVectorWithIndexM",
          "normalized": "(Int-\u003ea-\u003eb c)-\u003eVector a-\u003eb(Vector c)",
          "package": "hmatrix",
          "partial": "Vector With Index",
          "signature": "(Int-\u003ea-\u003em b)-\u003eVector a-\u003em(Vector b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:mapVectorWithIndexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emonadic map over Vectors with the zero-indexed index passed to the mapping function\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "mapVectorWithIndexM_",
          "package": "hmatrix",
          "signature": "(Int -\u003e a -\u003e m ()) -\u003e Vector a -\u003e m ()",
          "source": "src/Data-Packed-Internal-Vector.html#mapVectorWithIndexM_",
          "type": "function"
        },
        "index": {
          "description": "monadic map over Vectors with the zero-indexed index passed to the mapping function",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "mapVectorWithIndexM_",
          "normalized": "(Int-\u003ea-\u003eb())-\u003eVector a-\u003eb()",
          "package": "hmatrix",
          "partial": "Vector With Index",
          "signature": "(Int-\u003ea-\u003em())-\u003eVector a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:mapVectorWithIndexM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etakes a number of consecutive elements from a Vector\n\u003c/p\u003e\u003cpre\u003e\u003e subVector 2 3 (fromList [1..10])\n3 |\u003e [3.0,4.0,5.0]\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "subVector",
          "package": "hmatrix",
          "signature": "Int-\u003e Int-\u003e Vector t-\u003e Vector t",
          "type": "function"
        },
        "index": {
          "description": "takes number of consecutive elements from Vector subVector fromList",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "subVector",
          "normalized": "Int-\u003eInt-\u003eVector a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Int-\u003eInt-\u003eVector t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:subVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract consecutive subvectors of the given sizes.\n\u003c/p\u003e\u003cpre\u003e\u003e takesV [3,4] (linspace 10 (1,10))\n[3 |\u003e [1.0,2.0,3.0],4 |\u003e [4.0,5.0,6.0,7.0]]\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "takesV",
          "package": "hmatrix",
          "signature": "[Int] -\u003e Vector t -\u003e [Vector t]",
          "source": "src/Data-Packed-Internal-Vector.html#takesV",
          "type": "function"
        },
        "index": {
          "description": "Extract consecutive subvectors of the given sizes takesV linspace",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "takesV",
          "normalized": "[Int]-\u003eVector a-\u003e[Vector a]",
          "package": "hmatrix",
          "signature": "[Int]-\u003eVector t-\u003e[Vector t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:takesV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextracts the Vector elements to a list\n\u003c/p\u003e\u003cpre\u003e\u003e toList (linspace 5 (1,10))\n[1.0,3.25,5.5,7.75,10.0]\u003c/pre\u003e",
          "module": "Data.Packed.Vector",
          "name": "toList",
          "package": "hmatrix",
          "signature": "Vector a -\u003e [a]",
          "source": "src/Data-Packed-Internal-Vector.html#toList",
          "type": "function"
        },
        "index": {
          "description": "extracts the Vector elements to list toList linspace",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "toList",
          "normalized": "Vector a-\u003e[a]",
          "package": "hmatrix",
          "partial": "List",
          "signature": "Vector a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunzip for Vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "unzipVector",
          "package": "hmatrix",
          "signature": "Vector (a, b) -\u003e (Vector a, Vector b)",
          "source": "src/Data-Packed-Vector.html#unzipVector",
          "type": "function"
        },
        "index": {
          "description": "unzip for Vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "unzipVector",
          "normalized": "Vector(a,b)-\u003e(Vector a,Vector b)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Vector(a,b)-\u003e(Vector a,Vector b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:unzipVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunzipWith for Vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "unzipVectorWith",
          "package": "hmatrix",
          "signature": "((a, b) -\u003e (c, d)) -\u003e Vector (a, b) -\u003e (Vector c, Vector d)",
          "source": "src/Data-Packed-Internal-Vector.html#unzipVectorWith",
          "type": "function"
        },
        "index": {
          "description": "unzipWith for Vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "unzipVectorWith",
          "normalized": "((a,b)-\u003e(c,d))-\u003eVector(a,b)-\u003e(Vector c,Vector d)",
          "package": "hmatrix",
          "partial": "Vector With",
          "signature": "((a,b)-\u003e(c,d))-\u003eVector(a,b)-\u003e(Vector c,Vector d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:unzipVectorWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezip for Vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "zipVector",
          "package": "hmatrix",
          "signature": "Vector a -\u003e Vector b -\u003e Vector (a, b)",
          "source": "src/Data-Packed-Vector.html#zipVector",
          "type": "function"
        },
        "index": {
          "description": "zip for Vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "zipVector",
          "normalized": "Vector a-\u003eVector b-\u003eVector(a,b)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Vector a-\u003eVector b-\u003eVector(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:zipVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezipWith for Vectors\n\u003c/p\u003e",
          "module": "Data.Packed.Vector",
          "name": "zipVectorWith",
          "package": "hmatrix",
          "signature": "(a -\u003e b -\u003e c) -\u003e Vector a -\u003e Vector b -\u003e Vector c",
          "source": "src/Data-Packed-Internal-Vector.html#zipVectorWith",
          "type": "function"
        },
        "index": {
          "description": "zipWith for Vectors",
          "hierarchy": "Data Packed Vector",
          "module": "Data.Packed.Vector",
          "name": "zipVectorWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
          "package": "hmatrix",
          "partial": "Vector With",
          "signature": "(a-\u003eb-\u003ec)-\u003eVector a-\u003eVector b-\u003eVector c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed-Vector.html#v:zipVectorWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTypes for dense \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003eStorable\u003c/code\u003e elements.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Packed",
          "name": "Packed",
          "package": "hmatrix",
          "source": "src/Data-Packed.html",
          "type": "module"
        },
        "index": {
          "description": "Types for dense Vector and Matrix of Storable elements",
          "hierarchy": "Data Packed",
          "module": "Data.Packed",
          "name": "Packed",
          "package": "hmatrix",
          "partial": "Packed",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Data-Packed.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is deprecated. It can be replaced by improved drawing tools\n available in the plot\\plot-gtk packages by Vivian McPhail or Gnuplot by Henning Thielemann.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Graphics.Plot",
          "name": "Plot",
          "package": "hmatrix",
          "source": "src/Graphics-Plot.html",
          "type": "module"
        },
        "index": {
          "description": "This module is deprecated It can be replaced by improved drawing tools available in the plot plot-gtk packages by Vivian McPhail or Gnuplot by Henning Thielemann",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "Plot",
          "package": "hmatrix",
          "partial": "Plot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.Plot",
          "name": "gnuplotWin",
          "package": "hmatrix",
          "signature": "String -\u003e String -\u003e [([[Double]], String)] -\u003e IO ()",
          "source": "src/Graphics-Plot.html#gnuplotWin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "gnuplotWin",
          "normalized": "String-\u003eString-\u003e[([[Double]],String)]-\u003eIO()",
          "package": "hmatrix",
          "partial": "Win",
          "signature": "String-\u003eString-\u003e[([[Double]],String)]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:gnuplotWin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.Plot",
          "name": "gnuplotX",
          "package": "hmatrix",
          "signature": "String -\u003e IO ()",
          "source": "src/Graphics-Plot.html#gnuplotX",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "gnuplotX",
          "normalized": "String-\u003eIO()",
          "package": "hmatrix",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:gnuplotX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Graphics.Plot",
          "name": "gnuplotpdf",
          "package": "hmatrix",
          "signature": "String -\u003e String -\u003e [([[Double]], String)] -\u003e IO ()",
          "source": "src/Graphics-Plot.html#gnuplotpdf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "gnuplotpdf",
          "normalized": "String-\u003eString-\u003e[([[Double]],String)]-\u003eIO()",
          "package": "hmatrix",
          "signature": "String-\u003eString-\u003e[([[Double]],String)]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:gnuplotpdf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimshow shows a representation of a matrix as a gray level image using ImageMagick's display.\n\u003c/p\u003e",
          "module": "Graphics.Plot",
          "name": "imshow",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e IO ()",
          "source": "src/Graphics-Plot.html#imshow",
          "type": "function"
        },
        "index": {
          "description": "imshow shows representation of matrix as gray level image using ImageMagick display",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "imshow",
          "normalized": "Matrix Double-\u003eIO()",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:imshow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewrites a matrix to pgm image file\n\u003c/p\u003e",
          "module": "Graphics.Plot",
          "name": "matrixToPGM",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e String",
          "source": "src/Graphics-Plot.html#matrixToPGM",
          "type": "function"
        },
        "index": {
          "description": "writes matrix to pgm image file",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "matrixToPGM",
          "normalized": "Matrix Double-\u003eString",
          "package": "hmatrix",
          "partial": "To PGM",
          "signature": "Matrix Double-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:matrixToPGM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraws a 3D surface representation of a real matrix.\n\u003c/p\u003e\u003cpre\u003e \u003e mesh $ build (10,10) (\\\\i j -\u003e i + (j-5)^2)\n\u003c/pre\u003e\u003cp\u003eIn certain versions you can interactively rotate the graphic using the mouse.\n\u003c/p\u003e",
          "module": "Graphics.Plot",
          "name": "mesh",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e IO ()",
          "source": "src/Graphics-Plot.html#mesh",
          "type": "function"
        },
        "index": {
          "description": "Draws surface representation of real matrix mesh build j-5 In certain versions you can interactively rotate the graphic using the mouse",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "mesh",
          "normalized": "Matrix Double-\u003eIO()",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:mesh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFrom vectors x and y, it generates a pair of matrices to be used as x and y arguments for matrix functions.\n\u003c/p\u003e",
          "module": "Graphics.Plot",
          "name": "meshdom",
          "package": "hmatrix",
          "signature": "Vector Double -\u003e Vector Double -\u003e (Matrix Double, Matrix Double)",
          "source": "src/Graphics-Plot.html#meshdom",
          "type": "function"
        },
        "index": {
          "description": "From vectors and it generates pair of matrices to be used as and arguments for matrix functions",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "meshdom",
          "normalized": "Vector Double-\u003eVector Double-\u003e(Matrix Double,Matrix Double)",
          "package": "hmatrix",
          "signature": "Vector Double-\u003eVector Double-\u003e(Matrix Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:meshdom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eplots several vectors against the first one \n\u003c/p\u003e\u003cpre\u003e \u003e let t = linspace 100 (-3,3) in mplot [t, sin t, exp (-t^2)]\n\u003c/pre\u003e",
          "module": "Graphics.Plot",
          "name": "mplot",
          "package": "hmatrix",
          "signature": "[Vector Double] -\u003e IO ()",
          "source": "src/Graphics-Plot.html#mplot",
          "type": "function"
        },
        "index": {
          "description": "plots several vectors against the first one let linspace in mplot sin exp",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "mplot",
          "normalized": "[Vector Double]-\u003eIO()",
          "package": "hmatrix",
          "signature": "[Vector Double]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:mplot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraws a parametric curve. For instance, to draw a spiral we can do something like:\n\u003c/p\u003e\u003cpre\u003e \u003e parametricPlot (\\t-\u003e(t * sin t, t * cos t)) (0,10*pi) 1000\n\u003c/pre\u003e",
          "module": "Graphics.Plot",
          "name": "parametricPlot",
          "package": "hmatrix",
          "signature": "(Vector Double -\u003e (Vector Double, Vector Double)) -\u003e (Double, Double) -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-Plot.html#parametricPlot",
          "type": "function"
        },
        "index": {
          "description": "Draws parametric curve For instance to draw spiral we can do something like parametricPlot sin cos pi",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "parametricPlot",
          "normalized": "(Vector Double-\u003e(Vector Double,Vector Double))-\u003e(Double,Double)-\u003eInt-\u003eIO()",
          "package": "hmatrix",
          "partial": "Plot",
          "signature": "(Vector Double-\u003e(Vector Double,Vector Double))-\u003e(Double,Double)-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:parametricPlot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraws a list of functions over a desired range and with a desired number of points \n\u003c/p\u003e\u003cpre\u003e \u003e plot [sin, cos, sin.(3*)] (0,2*pi) 1000\n\u003c/pre\u003e",
          "module": "Graphics.Plot",
          "name": "plot",
          "package": "hmatrix",
          "signature": "[Vector Double -\u003e Vector Double] -\u003e (Double, Double) -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-Plot.html#plot",
          "type": "function"
        },
        "index": {
          "description": "Draws list of functions over desired range and with desired number of points plot sin cos sin pi",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "plot",
          "normalized": "[Vector Double-\u003eVector Double]-\u003e(Double,Double)-\u003eInt-\u003eIO()",
          "package": "hmatrix",
          "signature": "[Vector Double-\u003eVector Double]-\u003e(Double,Double)-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:plot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDraws the surface represented by the function f in the desired ranges and number of points, internally using \u003ccode\u003e\u003ca\u003emesh\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e \u003e let f x y = cos (x + y) \n \u003e splot f (0,pi) (0,2*pi) 50    \n\u003c/pre\u003e",
          "module": "Graphics.Plot",
          "name": "splot",
          "package": "hmatrix",
          "signature": "(Matrix Double -\u003e Matrix Double -\u003e Matrix Double) -\u003e (Double, Double) -\u003e (Double, Double) -\u003e Int -\u003e IO ()",
          "source": "src/Graphics-Plot.html#splot",
          "type": "function"
        },
        "index": {
          "description": "Draws the surface represented by the function in the desired ranges and number of points internally using mesh let cos splot pi pi",
          "hierarchy": "Graphics Plot",
          "module": "Graphics.Plot",
          "name": "splot",
          "normalized": "(Matrix Double-\u003eMatrix Double-\u003eMatrix Double)-\u003e(Double,Double)-\u003e(Double,Double)-\u003eInt-\u003eIO()",
          "package": "hmatrix",
          "signature": "(Matrix Double-\u003eMatrix Double-\u003eMatrix Double)-\u003e(Double,Double)-\u003e(Double,Double)-\u003eInt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Graphics-Plot.html#v:splot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic numeric operations on \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e, including conversion routines.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eContainer\u003c/a\u003e\u003c/code\u003e class is used to define optimized generic functions which work\n on \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e with real or complex elements.\n\u003c/p\u003e\u003cp\u003eSome of these functions are also available in the instances of the standard\n numeric Haskell classes provided by \u003ca\u003eNumeric.LinearAlgebra\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.Container",
          "name": "Container",
          "package": "hmatrix",
          "source": "src/Numeric-Container.html",
          "type": "module"
        },
        "index": {
          "description": "Basic numeric operations on Vector and Matrix including conversion routines The Container class is used to define optimized generic functions which work on Vector and Matrix with real or complex elements Some of these functions are also available in the instances of the standard numeric Haskell classes provided by Numeric.LinearAlgebra",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Container",
          "package": "hmatrix",
          "partial": "Container",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "ComplexOf",
          "package": "hmatrix",
          "signature": "ComplexOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "ComplexOf",
          "package": "hmatrix",
          "partial": "Complex Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:ComplexOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStructures that may contain complex numbers\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "Complexable",
          "package": "hmatrix",
          "source": "src/Numeric-Conversion.html#Complexable",
          "type": "class"
        },
        "index": {
          "description": "Structures that may contain complex numbers",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Complexable",
          "package": "hmatrix",
          "partial": "Complexable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:Complexable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic element-by-element functions for numeric containers\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "Container",
          "package": "hmatrix",
          "source": "src/Numeric-ContainerBoot.html#Container",
          "type": "class"
        },
        "index": {
          "description": "Basic element-by-element functions for numeric containers",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Container",
          "package": "hmatrix",
          "partial": "Container",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:Container"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "Convert",
          "package": "hmatrix",
          "source": "src/Numeric-ContainerBoot.html#Convert",
          "type": "class"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Convert",
          "package": "hmatrix",
          "partial": "Convert",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:Convert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "DoubleOf",
          "package": "hmatrix",
          "signature": "DoubleOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "DoubleOf",
          "package": "hmatrix",
          "partial": "Double Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:DoubleOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "IndexOf",
          "package": "hmatrix",
          "signature": "IndexOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "IndexOf",
          "package": "hmatrix",
          "partial": "Index Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:IndexOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "LSDiv",
          "package": "hmatrix",
          "source": "src/Numeric-Container.html#LSDiv",
          "type": "class"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "LSDiv",
          "package": "hmatrix",
          "partial": "LSDiv",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:LSDiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "Mul",
          "package": "hmatrix",
          "source": "src/Numeric-Container.html#Mul",
          "type": "class"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Mul",
          "package": "hmatrix",
          "partial": "Mul",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:Mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix product and related functions\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "Product",
          "package": "hmatrix",
          "source": "src/Numeric-ContainerBoot.html#Product",
          "type": "class"
        },
        "index": {
          "description": "Matrix product and related functions",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Product",
          "package": "hmatrix",
          "partial": "Product",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:Product"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "RandDist",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Vector.html#RandDist",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "RandDist",
          "package": "hmatrix",
          "partial": "Rand Dist",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:RandDist"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupported real types\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "RealElement",
          "package": "hmatrix",
          "source": "src/Numeric-Conversion.html#RealElement",
          "type": "class"
        },
        "index": {
          "description": "Supported real types",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "RealElement",
          "package": "hmatrix",
          "partial": "Real Element",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:RealElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "RealOf",
          "package": "hmatrix",
          "signature": "RealOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "RealOf",
          "package": "hmatrix",
          "partial": "Real Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:RealOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "SingleOf",
          "package": "hmatrix",
          "signature": "SingleOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "SingleOf",
          "package": "hmatrix",
          "partial": "Single Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#t:SingleOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix-matrix, matrix-vector, and vector-matrix products.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "(\u003c\u003e)",
          "package": "hmatrix",
          "signature": "a t -\u003e b t -\u003e c t",
          "source": "src/Numeric-Container.html#%3C%3E",
          "type": "method"
        },
        "index": {
          "description": "Matrix-matrix matrix-vector and vector-matrix products",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a b-\u003ec b-\u003ed b",
          "package": "hmatrix",
          "signature": "a t-\u003eb t-\u003ec t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleast squares solution of a linear system, similar to the \\ operator of Matlab/Octave (based on linearSolveSVD)\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "(\u003c\\\u003e)",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e b t -\u003e c t",
          "source": "src/Numeric-Container.html#%3C%5C%3E",
          "type": "method"
        },
        "index": {
          "description": "least squares solution of linear system similar to the operator of Matlab Octave based on linearSolveSVD",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "(\u003c\\\u003e) \u003c\\\u003e",
          "normalized": "Matrix a-\u003eb a-\u003ec a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eb t-\u003ec t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:-60--92--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDot product: \u003ccode\u003eu \u003c.\u003e v = dot u v\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "(\u003c.\u003e)",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Vector t -\u003e t",
          "source": "src/Numeric-Container.html#%3C.%3E",
          "type": "function"
        },
        "index": {
          "description": "Dot product dot",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "(\u003c.\u003e) \u003c.\u003e",
          "normalized": "Vector a-\u003eVector a-\u003ea",
          "package": "hmatrix",
          "signature": "Vector t-\u003eVector t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:-60-.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enormal distribution with mean zero and standard deviation one\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "Gaussian",
          "package": "hmatrix",
          "signature": "Gaussian",
          "source": "src/Numeric-GSL-Vector.html#RandDist",
          "type": "function"
        },
        "index": {
          "description": "normal distribution with mean zero and standard deviation one",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Gaussian",
          "package": "hmatrix",
          "partial": "Gaussian",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:Gaussian"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003euniform distribution in [0,1)\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "Uniform",
          "package": "hmatrix",
          "signature": "Uniform",
          "source": "src/Numeric-GSL-Vector.html#RandDist",
          "type": "function"
        },
        "index": {
          "description": "uniform distribution in",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "Uniform",
          "package": "hmatrix",
          "partial": "Uniform",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:Uniform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esum of absolute value of elements (differs in complex case from \u003ccode\u003enorm1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "absSum",
          "package": "hmatrix",
          "signature": "Vector e -\u003e RealOf e",
          "source": "src/Numeric-ContainerBoot.html#absSum",
          "type": "method"
        },
        "index": {
          "description": "sum of absolute value of elements differs in complex case from norm1",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "absSum",
          "normalized": "Vector a-\u003eRealOf a",
          "package": "hmatrix",
          "partial": "Sum",
          "signature": "Vector e-\u003eRealOf e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:absSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify a structure using an update function\n\u003c/p\u003e\u003cpre\u003e\u003e accum (ident 5) (+) [((1,1),5),((0,3),3)] :: Matrix Double\n (5\u003e\u003c5)\n  [ 1.0, 0.0, 0.0, 3.0, 0.0\n  , 0.0, 6.0, 0.0, 0.0, 0.0\n  , 0.0, 0.0, 1.0, 0.0, 0.0\n  , 0.0, 0.0, 0.0, 1.0, 0.0\n  , 0.0, 0.0, 0.0, 0.0, 1.0 ]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "accum",
          "package": "hmatrix",
          "signature": "accum",
          "source": "src/Numeric-ContainerBoot.html#accum",
          "type": "method"
        },
        "index": {
          "description": "Modify structure using an update function accum ident Matrix Double",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "accum",
          "package": "hmatrix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:accum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "add",
          "package": "hmatrix",
          "signature": "c e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#add",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "add",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "addConstant",
          "package": "hmatrix",
          "signature": "e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#addConstant",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "addConstant",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hmatrix",
          "partial": "Constant",
          "signature": "e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:addConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "arctan2",
          "package": "hmatrix",
          "signature": "c e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#arctan2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "arctan2",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:arctan2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a structure from an association list\n\u003c/p\u003e\u003cpre\u003e\u003e assoc 5 0 [(2,7),(1,3)] :: Vector Double\n 5 |\u003e [0.0,3.0,7.0,0.0,0.0]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "assoc",
          "package": "hmatrix",
          "signature": "assoc",
          "source": "src/Numeric-ContainerBoot.html#assoc",
          "type": "method"
        },
        "index": {
          "description": "Create structure from an association list assoc Vector Double",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "assoc",
          "package": "hmatrix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:assoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindexing function\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "atIndex",
          "package": "hmatrix",
          "signature": "c e -\u003e IndexOf c -\u003e e",
          "source": "src/Numeric-ContainerBoot.html#atIndex",
          "type": "method"
        },
        "index": {
          "description": "indexing function",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "atIndex",
          "normalized": "a b-\u003eIndexOf a-\u003eb",
          "package": "hmatrix",
          "partial": "Index",
          "signature": "c e-\u003eIndexOf c-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:atIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate a structure using a function\n\u003c/p\u003e\u003cp\u003eHilbert matrix of order N:\n\u003c/p\u003e\u003cpre\u003ehilb n = build (n,n) (\\i j -\u003e 1/(i+j+1))\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "build",
          "package": "hmatrix",
          "signature": "IndexOf c -\u003e ArgOf c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#build",
          "type": "method"
        },
        "index": {
          "description": "create structure using function Hilbert matrix of order hilb build",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "build",
          "normalized": "IndexOf a-\u003eArgOf a b-\u003ea b",
          "package": "hmatrix",
          "signature": "IndexOf c-\u003eArgOf c e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:build"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "build'",
          "package": "hmatrix",
          "signature": "BoundsOf f -\u003e f -\u003e ContainerOf f",
          "source": "src/Numeric-ContainerBoot.html#build%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "build'",
          "normalized": "BoundsOf a-\u003ea-\u003eContainerOf a",
          "package": "hmatrix",
          "signature": "BoundsOf f-\u003ef-\u003eContainerOf f",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:build-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecannot implement instance Functor because of Element class constraint\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "cmap",
          "package": "hmatrix",
          "signature": "(e -\u003e b) -\u003e c e -\u003e c b",
          "source": "src/Numeric-ContainerBoot.html#cmap",
          "type": "method"
        },
        "index": {
          "description": "cannot implement instance Functor because of Element class constraint",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "cmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "hmatrix",
          "signature": "(e-\u003eb)-\u003ec e-\u003ec b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:cmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "complex",
          "package": "hmatrix",
          "signature": "c t -\u003e c (ComplexOf t)",
          "source": "src/Numeric-ContainerBoot.html#complex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "complex",
          "normalized": "a b-\u003ea(ComplexOf b)",
          "package": "hmatrix",
          "signature": "c t-\u003ec(ComplexOf t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eElement by element version of \u003ccode\u003ecase compare a b of {LT -\u003e l; EQ -\u003e e; GT -\u003e g}\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eArguments with any dimension = 1 are automatically expanded: \n\u003c/p\u003e\u003cpre\u003e\u003e cond ((1\u003e\u003c4)[1..]) ((3\u003e\u003c1)[1..]) 0 100 ((3\u003e\u003c4)[1..]) :: Matrix Double\n (3\u003e\u003c4)\n [ 100.0,   2.0,   3.0,  4.0\n ,   0.0, 100.0,   7.0,  8.0\n ,   0.0,   0.0, 100.0, 12.0 ]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "cond",
          "package": "hmatrix",
          "signature": "cond",
          "source": "src/Numeric-ContainerBoot.html#cond",
          "type": "method"
        },
        "index": {
          "description": "Element by element version of case compare of LT EQ GT Arguments with any dimension are automatically expanded cond Matrix Double",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "cond",
          "package": "hmatrix",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:cond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecomplex conjugate\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "conj",
          "package": "hmatrix",
          "signature": "c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#conj",
          "type": "method"
        },
        "index": {
          "description": "complex conjugate",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "conj",
          "normalized": "a b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:conj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates a vector with a given number of equal components:\n\u003c/p\u003e\u003cpre\u003e\u003e constant 2 7\n7 |\u003e [2.0,2.0,2.0,2.0,2.0,2.0,2.0]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "constant",
          "package": "hmatrix",
          "signature": "a -\u003e Int -\u003e Vector a",
          "source": "src/Numeric-Container.html#constant",
          "type": "function"
        },
        "index": {
          "description": "creates vector with given number of equal components constant",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "constant",
          "normalized": "a-\u003eInt-\u003eVector a",
          "package": "hmatrix",
          "signature": "a-\u003eInt-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:constant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econjugate transpose\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "ctrans",
          "package": "hmatrix",
          "signature": "Matrix e -\u003e Matrix e",
          "source": "src/Numeric-ContainerBoot.html#ctrans",
          "type": "function"
        },
        "index": {
          "description": "conjugate transpose",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "ctrans",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix e-\u003eMatrix e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:ctrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a square matrix with a given diagonal.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "diag",
          "package": "hmatrix",
          "signature": "Vector a -\u003e Matrix a",
          "source": "src/Numeric-ContainerBoot.html#diag",
          "type": "function"
        },
        "index": {
          "description": "Creates square matrix with given diagonal",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "diag",
          "normalized": "Vector a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Vector a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:diag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print a complex matrix with at most n decimal digits.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "dispcf",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix (Complex Double) -\u003e String",
          "source": "src/Numeric-IO.html#dispcf",
          "type": "function"
        },
        "index": {
          "description": "Pretty print complex matrix with at most decimal digits",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "dispcf",
          "normalized": "Int-\u003eMatrix(Complex Double)-\u003eString",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix(Complex Double)-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:dispcf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a matrix with a given number of decimal places.\n\u003c/p\u003e\u003cpre\u003edisp = putStr . dispf 3\n\n\u003e disp (1/3 + ident 4)\n4x4\n1.333  0.333  0.333  0.333\n0.333  1.333  0.333  0.333\n0.333  0.333  1.333  0.333\n0.333  0.333  0.333  1.333\n\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "dispf",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix Double -\u003e String",
          "source": "src/Numeric-IO.html#dispf",
          "type": "function"
        },
        "index": {
          "description": "Show matrix with given number of decimal places disp putStr dispf disp ident x4",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "dispf",
          "normalized": "Int-\u003eMatrix Double-\u003eString",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix Double-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:dispf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a matrix with \"autoscaling\" and a given number of decimal places.\n\u003c/p\u003e\u003cpre\u003edisp = putStr . disps 2\n\n\u003e disp $ 120 * (3\u003e\u003c4) [1..]\n3x4  E3\n 0.12  0.24  0.36  0.48\n 0.60  0.72  0.84  0.96\n 1.08  1.20  1.32  1.44\n\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "disps",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix Double -\u003e String",
          "source": "src/Numeric-IO.html#disps",
          "type": "function"
        },
        "index": {
          "description": "Show matrix with autoscaling and given number of decimal places disp putStr disps disp x4 E3",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "disps",
          "normalized": "Int-\u003eMatrix Double-\u003eString",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix Double-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:disps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eelement by element division\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "divide",
          "package": "hmatrix",
          "signature": "c e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#divide",
          "type": "method"
        },
        "index": {
          "description": "element by element division",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "divide",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:divide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edot (inner) product\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "dot",
          "package": "hmatrix",
          "signature": "Vector e -\u003e Vector e -\u003e e",
          "source": "src/Numeric-ContainerBoot.html#dot",
          "type": "method"
        },
        "index": {
          "description": "dot inner product",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "dot",
          "normalized": "Vector a-\u003eVector a-\u003ea",
          "package": "hmatrix",
          "signature": "Vector e-\u003eVector e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "double",
          "package": "hmatrix",
          "signature": "c t -\u003e c (DoubleOf t)",
          "source": "src/Numeric-ContainerBoot.html#double",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "double",
          "normalized": "a b-\u003ea(DoubleOf b)",
          "package": "hmatrix",
          "signature": "c t-\u003ec(DoubleOf t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "equal",
          "package": "hmatrix",
          "signature": "c e -\u003e c e -\u003e Bool",
          "source": "src/Numeric-ContainerBoot.html#equal",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "equal",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "hmatrix",
          "signature": "c e-\u003ec e-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eobtains the number of rows and columns in an ASCII data file\n      (provisionally using unix's wc).\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "fileDimensions",
          "package": "hmatrix",
          "signature": "FilePath -\u003e IO (Int, Int)",
          "source": "src/Numeric-IO.html#fileDimensions",
          "type": "function"
        },
        "index": {
          "description": "obtains the number of rows and columns in an ASCII data file provisionally using unix wc",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "fileDimensions",
          "normalized": "FilePath-\u003eIO(Int,Int)",
          "package": "hmatrix",
          "partial": "Dimensions",
          "signature": "FilePath-\u003eIO(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:fileDimensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind index of elements which satisfy a predicate\n\u003c/p\u003e\u003cpre\u003e\u003e find (\u003e0) (ident 3 :: Matrix Double)\n [(0,0),(1,1),(2,2)]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "find",
          "package": "hmatrix",
          "signature": "(e -\u003e Bool) -\u003e c e -\u003e [IndexOf c]",
          "source": "src/Numeric-ContainerBoot.html#find",
          "type": "method"
        },
        "index": {
          "description": "Find index of elements which satisfy predicate find ident Matrix Double",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "find",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003e[IndexOf b]",
          "package": "hmatrix",
          "signature": "(e-\u003eBool)-\u003ec e-\u003e[IndexOf c]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:find"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a string from a matrix given a separator and a function to show each entry. Using\nthis function the user can easily define any desired display function:\n\u003c/p\u003e\u003cpre\u003eimport Text.Printf(printf)\u003c/pre\u003e\u003cpre\u003edisp = putStr . format \"  \" (printf \"%.2f\")\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "format",
          "package": "hmatrix",
          "signature": "String -\u003e (t -\u003e String) -\u003e Matrix t -\u003e String",
          "source": "src/Numeric-IO.html#format",
          "type": "function"
        },
        "index": {
          "description": "Creates string from matrix given separator and function to show each entry Using this function the user can easily define any desired display function import Text.Printf printf disp putStr format printf",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "format",
          "normalized": "String-\u003e(a-\u003eString)-\u003eMatrix a-\u003eString",
          "package": "hmatrix",
          "signature": "String-\u003e(t-\u003eString)-\u003eMatrix t-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSaves the elements of a vector, with a given format (%f, %e, %g), to an ASCII file.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "fprintfVector",
          "package": "hmatrix",
          "signature": "FilePath -\u003e String -\u003e Vector Double -\u003e IO ()",
          "source": "src/Data-Packed-Internal-Vector.html#fprintfVector",
          "type": "function"
        },
        "index": {
          "description": "Saves the elements of vector with given format to an ASCII file",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "fprintfVector",
          "normalized": "FilePath-\u003eString-\u003eVector Double-\u003eIO()",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "FilePath-\u003eString-\u003eVector Double-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:fprintfVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoads a vector from a binary file (the number of elements must be known in advance).\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "freadVector",
          "package": "hmatrix",
          "signature": "FilePath -\u003e Int -\u003e IO (Vector Double)",
          "source": "src/Data-Packed-Internal-Vector.html#freadVector",
          "type": "function"
        },
        "index": {
          "description": "Loads vector from binary file the number of elements must be known in advance",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "freadVector",
          "normalized": "FilePath-\u003eInt-\u003eIO(Vector Double)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "FilePath-\u003eInt-\u003eIO(Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:freadVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "fromComplex",
          "package": "hmatrix",
          "signature": "c (Complex t) -\u003e (c t, c t)",
          "source": "src/Numeric-ContainerBoot.html#fromComplex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "fromComplex",
          "normalized": "a(Complex b)-\u003e(a b,a b)",
          "package": "hmatrix",
          "partial": "Complex",
          "signature": "c(Complex t)-\u003e(c t,c t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:fromComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoads a matrix from an ASCII file (the number of rows and columns must be known in advance).\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "fromFile",
          "package": "hmatrix",
          "signature": "FilePath -\u003e (Int, Int) -\u003e IO (Matrix Double)",
          "source": "src/Numeric-IO.html#fromFile",
          "type": "function"
        },
        "index": {
          "description": "Loads matrix from an ASCII file the number of rows and columns must be known in advance",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "fromFile",
          "normalized": "FilePath-\u003e(Int,Int)-\u003eIO(Matrix Double)",
          "package": "hmatrix",
          "partial": "File",
          "signature": "FilePath-\u003e(Int,Int)-\u003eIO(Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:fromFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoads a vector from an ASCII file (the number of elements must be known in advance).\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "fscanfVector",
          "package": "hmatrix",
          "signature": "FilePath -\u003e Int -\u003e IO (Vector Double)",
          "source": "src/Data-Packed-Internal-Vector.html#fscanfVector",
          "type": "function"
        },
        "index": {
          "description": "Loads vector from an ASCII file the number of elements must be known in advance",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "fscanfVector",
          "normalized": "FilePath-\u003eInt-\u003eIO(Vector Double)",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "FilePath-\u003eInt-\u003eIO(Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:fscanfVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSaves the elements of a vector to a binary file.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "fwriteVector",
          "package": "hmatrix",
          "signature": "FilePath -\u003e Vector Double -\u003e IO ()",
          "source": "src/Data-Packed-Internal-Vector.html#fwriteVector",
          "type": "function"
        },
        "index": {
          "description": "Saves the elements of vector to binary file",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "fwriteVector",
          "normalized": "FilePath-\u003eVector Double-\u003eIO()",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "FilePath-\u003eVector Double-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:fwriteVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtains a matrix whose rows are pseudorandom samples from a multivariate\n Gaussian distribution.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "gaussianSample",
          "package": "hmatrix",
          "signature": "Seed-\u003e Int-\u003e Vector Double-\u003e Matrix Double-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "Obtains matrix whose rows are pseudorandom samples from multivariate Gaussian distribution",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "gaussianSample",
          "normalized": "Seed-\u003eInt-\u003eVector Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Sample",
          "signature": "Seed-\u003eInt-\u003eVector Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:gaussianSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreates the identity matrix of given dimension\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "ident",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix a",
          "source": "src/Numeric-ContainerBoot.html#ident",
          "type": "function"
        },
        "index": {
          "description": "creates the identity matrix of given dimension",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "ident",
          "normalized": "Int-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:ident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant structure of given size\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "konst",
          "package": "hmatrix",
          "signature": "e -\u003e IndexOf c -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#konst",
          "type": "method"
        },
        "index": {
          "description": "constant structure of given size",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "konst",
          "normalized": "a-\u003eIndexOf b-\u003eb a",
          "package": "hmatrix",
          "signature": "e-\u003eIndexOf c-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:konst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "konst'",
          "package": "hmatrix",
          "signature": "e -\u003e s -\u003e ContainerOf' s e",
          "source": "src/Numeric-ContainerBoot.html#konst%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "konst'",
          "normalized": "a-\u003eb-\u003eContainerOf' b a",
          "package": "hmatrix",
          "signature": "e-\u003es-\u003eContainerOf' s e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:konst-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKronecker product of two matrices.\n\u003c/p\u003e\u003cpre\u003em1=(2\u003e\u003c3)\n [ 1.0,  2.0, 0.0\n , 0.0, -1.0, 3.0 ]\nm2=(4\u003e\u003c3)\n [  1.0,  2.0,  3.0\n ,  4.0,  5.0,  6.0\n ,  7.0,  8.0,  9.0\n , 10.0, 11.0, 12.0 ]\u003c/pre\u003e\u003cpre\u003e\u003e kronecker m1 m2\n(8\u003e\u003c9)\n [  1.0,  2.0,  3.0,   2.0,   4.0,   6.0,  0.0,  0.0,  0.0\n ,  4.0,  5.0,  6.0,   8.0,  10.0,  12.0,  0.0,  0.0,  0.0\n ,  7.0,  8.0,  9.0,  14.0,  16.0,  18.0,  0.0,  0.0,  0.0\n , 10.0, 11.0, 12.0,  20.0,  22.0,  24.0,  0.0,  0.0,  0.0\n ,  0.0,  0.0,  0.0,  -1.0,  -2.0,  -3.0,  3.0,  6.0,  9.0\n ,  0.0,  0.0,  0.0,  -4.0,  -5.0,  -6.0, 12.0, 15.0, 18.0\n ,  0.0,  0.0,  0.0,  -7.0,  -8.0,  -9.0, 21.0, 24.0, 27.0\n ,  0.0,  0.0,  0.0, -10.0, -11.0, -12.0, 30.0, 33.0, 36.0 ]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "kronecker",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-ContainerBoot.html#kronecker",
          "type": "function"
        },
        "index": {
          "description": "Kronecker product of two matrices m1 m2 kronecker m1 m2",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "kronecker",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:kronecker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTool to display matrices with latex syntax.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "latexFormat",
          "package": "hmatrix",
          "signature": "String-\u003e String-\u003e String",
          "type": "function"
        },
        "index": {
          "description": "Tool to display matrices with latex syntax",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "latexFormat",
          "normalized": "String-\u003eString-\u003eString",
          "package": "hmatrix",
          "partial": "Format",
          "signature": "String-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:latexFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a real vector containing a range of values:\n\u003c/p\u003e\u003cpre\u003e\u003e linspace 5 (-3,7)\n5 |\u003e [-3.0,-0.5,2.0,4.5,7.0]\u003c/pre\u003e\u003cp\u003eLogarithmic spacing can be defined as follows:\n\u003c/p\u003e\u003cpre\u003elogspace n (a,b) = 10 ** linspace n (a,b)\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "linspace",
          "package": "hmatrix",
          "signature": "Int -\u003e (e, e) -\u003e Vector e",
          "source": "src/Numeric-Container.html#linspace",
          "type": "function"
        },
        "index": {
          "description": "Creates real vector containing range of values linspace Logarithmic spacing can be defined as follows logspace linspace",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "linspace",
          "normalized": "Int-\u003e(a,a)-\u003eVector a",
          "package": "hmatrix",
          "signature": "Int-\u003e(e,e)-\u003eVector e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:linspace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoads a matrix from an ASCII file formatted as a 2D table.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "loadMatrix",
          "package": "hmatrix",
          "signature": "FilePath -\u003e IO (Matrix Double)",
          "source": "src/Numeric-IO.html#loadMatrix",
          "type": "function"
        },
        "index": {
          "description": "Loads matrix from an ASCII file formatted as table",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "loadMatrix",
          "normalized": "FilePath-\u003eIO(Matrix Double)",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "FilePath-\u003eIO(Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:loadMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "mXm",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-ContainerBoot.html#mXm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "mXm",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Xm",
          "signature": "Matrix t-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:mXm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "mXv",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector t -\u003e Vector t",
          "source": "src/Numeric-ContainerBoot.html#mXv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "mXv",
          "normalized": "Matrix a-\u003eVector a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Xv",
          "signature": "Matrix t-\u003eVector t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:mXv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evalue of max element\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "maxElement",
          "package": "hmatrix",
          "signature": "c e -\u003e e",
          "source": "src/Numeric-ContainerBoot.html#maxElement",
          "type": "method"
        },
        "index": {
          "description": "value of max element",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "maxElement",
          "normalized": "a b-\u003eb",
          "package": "hmatrix",
          "partial": "Element",
          "signature": "c e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:maxElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindex of max element\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "maxIndex",
          "package": "hmatrix",
          "signature": "c e -\u003e IndexOf c",
          "source": "src/Numeric-ContainerBoot.html#maxIndex",
          "type": "method"
        },
        "index": {
          "description": "index of max element",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "maxIndex",
          "normalized": "a b-\u003eIndexOf a",
          "package": "hmatrix",
          "partial": "Index",
          "signature": "c e-\u003eIndexOf c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:maxIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute mean vector and covariance matrix of the rows of a matrix.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "meanCov",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Vector Double, Matrix Double)",
          "source": "src/Numeric-Container.html#meanCov",
          "type": "function"
        },
        "index": {
          "description": "Compute mean vector and covariance matrix of the rows of matrix",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "meanCov",
          "normalized": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "Cov",
          "signature": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:meanCov"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evalue of min element\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "minElement",
          "package": "hmatrix",
          "signature": "c e -\u003e e",
          "source": "src/Numeric-ContainerBoot.html#minElement",
          "type": "method"
        },
        "index": {
          "description": "value of min element",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "minElement",
          "normalized": "a b-\u003eb",
          "package": "hmatrix",
          "partial": "Element",
          "signature": "c e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:minElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindex of min element\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "minIndex",
          "package": "hmatrix",
          "signature": "c e -\u003e IndexOf c",
          "source": "src/Numeric-ContainerBoot.html#minIndex",
          "type": "method"
        },
        "index": {
          "description": "index of min element",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "minIndex",
          "normalized": "a b-\u003eIndexOf a",
          "package": "hmatrix",
          "partial": "Index",
          "signature": "c e-\u003eIndexOf c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:minIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eelement by element multiplication\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "mul",
          "package": "hmatrix",
          "signature": "c e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#mul",
          "type": "method"
        },
        "index": {
          "description": "element by element multiplication",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "mul",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:mul"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematrix product\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "multiply",
          "package": "hmatrix",
          "signature": "Matrix e -\u003e Matrix e -\u003e Matrix e",
          "source": "src/Numeric-ContainerBoot.html#multiply",
          "type": "method"
        },
        "index": {
          "description": "matrix product",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "multiply",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix e-\u003eMatrix e-\u003eMatrix e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:multiply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esum of absolute value of elements\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "norm1",
          "package": "hmatrix",
          "signature": "Vector e -\u003e RealOf e",
          "source": "src/Numeric-ContainerBoot.html#norm1",
          "type": "method"
        },
        "index": {
          "description": "sum of absolute value of elements",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "norm1",
          "normalized": "Vector a-\u003eRealOf a",
          "package": "hmatrix",
          "signature": "Vector e-\u003eRealOf e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:norm1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeuclidean norm\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "norm2",
          "package": "hmatrix",
          "signature": "Vector e -\u003e RealOf e",
          "source": "src/Numeric-ContainerBoot.html#norm2",
          "type": "method"
        },
        "index": {
          "description": "euclidean norm",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "norm2",
          "normalized": "Vector a-\u003eRealOf a",
          "package": "hmatrix",
          "signature": "Vector e-\u003eRealOf e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:norm2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eelement of maximum magnitude\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "normInf",
          "package": "hmatrix",
          "signature": "Vector e -\u003e RealOf e",
          "source": "src/Numeric-ContainerBoot.html#normInf",
          "type": "method"
        },
        "index": {
          "description": "element of maximum magnitude",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "normInf",
          "normalized": "Vector a-\u003eRealOf a",
          "package": "hmatrix",
          "partial": "Inf",
          "signature": "Vector e-\u003eRealOf e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:normInf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvide optimal association order for a chain of matrix multiplications \n     and apply the multiplications.\n\u003c/p\u003e\u003cp\u003eThe algorithm is the well-known O(n^3) dynamic programming algorithm\n     that builds a pyramid of optimal associations.\n\u003c/p\u003e\u003cpre\u003e m1, m2, m3, m4 :: Matrix Double\n m1 = (10\u003e\u003c15) [1..]\n m2 = (15\u003e\u003c20) [1..]\n m3 = (20\u003e\u003c5) [1..]\n m4 = (5\u003e\u003c10) [1..]\n\u003c/pre\u003e\u003cpre\u003e \u003e\u003e\u003e optimiseMult [m1,m2,m3,m4]\n\u003c/pre\u003e\u003cp\u003ewill perform \u003ccode\u003e((m1 \u003ccode\u003e\u003ca\u003emultiply\u003c/a\u003e\u003c/code\u003e (m2 \u003ccode\u003e\u003ca\u003emultiply\u003c/a\u003e\u003c/code\u003e m3)) \u003ccode\u003e\u003ca\u003emultiply\u003c/a\u003e\u003c/code\u003e m4)\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe naive left-to-right multiplication would take \u003ccode\u003e4500\u003c/code\u003e scalar multiplications\nwhereas the optimised version performs \u003ccode\u003e2750\u003c/code\u003e scalar multiplications.  The complexity\nin this case is 32 (= 4^3/2) * (2 comparisons, 3 scalar multiplications, 3 scalar additions,\n5 lookups, 2 updates) + a constant (= three table allocations)\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "optimiseMult",
          "package": "hmatrix",
          "signature": "[Matrix t] -\u003e Matrix t",
          "source": "src/Numeric-Chain.html#optimiseMult",
          "type": "function"
        },
        "index": {
          "description": "Provide optimal association order for chain of matrix multiplications and apply the multiplications The algorithm is the well-known dynamic programming algorithm that builds pyramid of optimal associations m1 m2 m3 m4 Matrix Double m1 m2 m3 m4 optimiseMult m1 m2 m3 m4 will perform m1 multiply m2 multiply m3 multiply m4 The naive left-to-right multiplication would take scalar multiplications whereas the optimised version performs scalar multiplications The complexity in this case is comparisons scalar multiplications scalar additions lookups updates constant three table allocations",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "optimiseMult",
          "normalized": "[Matrix a]-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Mult",
          "signature": "[Matrix t]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:optimiseMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOuter product of two vectors.\n\u003c/p\u003e\u003cpre\u003e\u003e \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e [1,2,3] `outer` \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e [5,2,3]\n(3\u003e\u003c3)\n [  5.0, 2.0, 3.0\n , 10.0, 4.0, 6.0\n , 15.0, 6.0, 9.0 ]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "outer",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Vector t -\u003e Matrix t",
          "source": "src/Numeric-ContainerBoot.html#outer",
          "type": "function"
        },
        "index": {
          "description": "Outer product of two vectors fromList outer fromList",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "outer",
          "normalized": "Vector a-\u003eVector a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Vector t-\u003eVector t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:outer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe product of elements (faster than using \u003ccode\u003efold\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "prodElements",
          "package": "hmatrix",
          "signature": "c e -\u003e e",
          "source": "src/Numeric-ContainerBoot.html#prodElements",
          "type": "method"
        },
        "index": {
          "description": "the product of elements faster than using fold",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "prodElements",
          "normalized": "a b-\u003eb",
          "package": "hmatrix",
          "partial": "Elements",
          "signature": "c e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:prodElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtains a vector of pseudorandom elements from the the mt19937 generator in GSL, with a given seed. Use randomIO to get a random seed.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "randomVector",
          "package": "hmatrix",
          "signature": "Int-\u003e RandDist-\u003e Int-\u003e Vector Double",
          "type": "function"
        },
        "index": {
          "description": "Obtains vector of pseudorandom elements from the the mt19937 generator in GSL with given seed Use randomIO to get random seed",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "randomVector",
          "normalized": "Int-\u003eRandDist-\u003eInt-\u003eVector Double",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Int-\u003eRandDist-\u003eInt-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:randomVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereads a matrix from a string containing a table of numbers.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "readMatrix",
          "package": "hmatrix",
          "signature": "String -\u003e Matrix Double",
          "source": "src/Numeric-IO.html#readMatrix",
          "type": "function"
        },
        "index": {
          "description": "reads matrix from string containing table of numbers",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "readMatrix",
          "normalized": "String-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "String-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:readMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "real",
          "package": "hmatrix",
          "signature": "c (RealOf t) -\u003e c t",
          "source": "src/Numeric-ContainerBoot.html#real",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "real",
          "normalized": "a(RealOf b)-\u003ea b",
          "package": "hmatrix",
          "signature": "c(RealOf t)-\u003ec t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:real"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSaves a matrix as 2D ASCII table.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "saveMatrix",
          "package": "hmatrix",
          "signature": "FilePath-\u003e String-\u003e Matrix Double-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Saves matrix as ASCII table",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "saveMatrix",
          "normalized": "FilePath-\u003eString-\u003eMatrix Double-\u003eIO()",
          "package": "hmatrix",
          "partial": "Matrix",
          "signature": "FilePath-\u003eString-\u003eMatrix Double-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:saveMatrix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate a structure with a single element\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "scalar",
          "package": "hmatrix",
          "signature": "e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#scalar",
          "type": "method"
        },
        "index": {
          "description": "create structure with single element",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "scalar",
          "normalized": "a-\u003eb a",
          "package": "hmatrix",
          "signature": "e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:scalar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "scale",
          "package": "hmatrix",
          "signature": "e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#scale",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "scale",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hmatrix",
          "signature": "e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:scale"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003escale the element by element reciprocal of the object:\n\u003c/p\u003e\u003cpre\u003escaleRecip 2 (fromList [5,i]) == 2 |\u003e [0.4 :+ 0.0,0.0 :+ (-2.0)]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "scaleRecip",
          "package": "hmatrix",
          "signature": "e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#scaleRecip",
          "type": "method"
        },
        "index": {
          "description": "scale the element by element reciprocal of the object scaleRecip fromList",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "scaleRecip",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "hmatrix",
          "partial": "Recip",
          "signature": "e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:scaleRecip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "single",
          "package": "hmatrix",
          "signature": "c t -\u003e c (SingleOf t)",
          "source": "src/Numeric-ContainerBoot.html#single",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "single",
          "normalized": "a b-\u003ea(SingleOf b)",
          "package": "hmatrix",
          "signature": "c t-\u003ec(SingleOf t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:single"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA more efficient implementation of \u003ccode\u003ecmap (\\x -\u003e if x\u003e0 then 1 else 0)\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\u003e step $ linspace 5 (-1,1::Double)\n 5 |\u003e [0.0,0.0,0.0,1.0,1.0]\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "step",
          "package": "hmatrix",
          "signature": "c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#step",
          "type": "method"
        },
        "index": {
          "description": "more efficient implementation of cmap if then else step linspace Double",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "step",
          "normalized": "a b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:step"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "sub",
          "package": "hmatrix",
          "signature": "c e -\u003e c e -\u003e c e",
          "source": "src/Numeric-ContainerBoot.html#sub",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "sub",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "hmatrix",
          "signature": "c e-\u003ec e-\u003ec e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:sub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe sum of elements (faster than using \u003ccode\u003efold\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "sumElements",
          "package": "hmatrix",
          "signature": "c e -\u003e e",
          "source": "src/Numeric-ContainerBoot.html#sumElements",
          "type": "method"
        },
        "index": {
          "description": "the sum of elements faster than using fold",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "sumElements",
          "normalized": "a b-\u003eb",
          "package": "hmatrix",
          "partial": "Elements",
          "signature": "c e-\u003ee",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:sumElements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "toComplex",
          "package": "hmatrix",
          "signature": "(c t, c t) -\u003e c (Complex t)",
          "source": "src/Numeric-ContainerBoot.html#toComplex",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "toComplex",
          "normalized": "(a b,a b)-\u003ea(Complex b)",
          "package": "hmatrix",
          "partial": "Complex",
          "signature": "(c t,c t)-\u003ec(Complex t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:toComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtains a matrix whose rows are pseudorandom samples from a multivariate\n uniform distribution.\n\u003c/p\u003e",
          "module": "Numeric.Container",
          "name": "uniformSample",
          "package": "hmatrix",
          "signature": "Seed-\u003e Int-\u003e [(Double, Double)]-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "Obtains matrix whose rows are pseudorandom samples from multivariate uniform distribution",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "uniformSample",
          "normalized": "Seed-\u003eInt-\u003e[(Double,Double)]-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Sample",
          "signature": "Seed-\u003eInt-\u003e[(Double,Double)]-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:uniformSample"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Container",
          "name": "vXm",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Matrix t -\u003e Vector t",
          "source": "src/Numeric-ContainerBoot.html#vXm",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "vXm",
          "normalized": "Vector a-\u003eMatrix a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Xm",
          "signature": "Vector t-\u003eMatrix t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:vXm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a vector using a function for showing matrices.\n\u003c/p\u003e\u003cpre\u003edisp = putStr . vecdisp (\u003ccode\u003e\u003ca\u003edispf\u003c/a\u003e\u003c/code\u003e 2)\n\n\u003e disp (\u003ccode\u003elinspace\u003c/code\u003e 10 (0,1))\n10 |\u003e 0.00  0.11  0.22  0.33  0.44  0.56  0.67  0.78  0.89  1.00\n\u003c/pre\u003e",
          "module": "Numeric.Container",
          "name": "vecdisp",
          "package": "hmatrix",
          "signature": "(Matrix t -\u003e String) -\u003e Vector t -\u003e String",
          "source": "src/Numeric-IO.html#vecdisp",
          "type": "function"
        },
        "index": {
          "description": "Show vector using function for showing matrices disp putStr vecdisp dispf disp linspace",
          "hierarchy": "Numeric Container",
          "module": "Numeric.Container",
          "name": "vecdisp",
          "normalized": "(Matrix a-\u003eString)-\u003eVector a-\u003eString",
          "package": "hmatrix",
          "signature": "(Matrix t-\u003eString)-\u003eVector t-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-Container.html#v:vecdisp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumerical differentiation.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Numerical-Differentiation.html#Numerical-Differentiation\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eFrom the GSL manual: \"The functions described in this chapter compute numerical derivatives by finite differencing. An adaptive algorithm is used to find the best choice of finite difference and to estimate the error in the derivative.\"\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Differentiation",
          "name": "Differentiation",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Differentiation.html",
          "type": "module"
        },
        "index": {
          "description": "Numerical differentiation http www.gnu.org software gsl manual html node Numerical-Differentiation.html Numerical-Differentiation From the GSL manual The functions described in this chapter compute numerical derivatives by finite differencing An adaptive algorithm is used to find the best choice of finite difference and to estimate the error in the derivative",
          "hierarchy": "Numeric GSL Differentiation",
          "module": "Numeric.GSL.Differentiation",
          "name": "Differentiation",
          "package": "hmatrix",
          "partial": "Differentiation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Differentiation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdaptive backward difference algorithm, \u003cem\u003egsl_deriv_backward\u003c/em\u003e. \n\u003c/p\u003e",
          "module": "Numeric.GSL.Differentiation",
          "name": "derivBackward",
          "package": "hmatrix",
          "signature": "Double-\u003e (Double -\u003e Double)-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Adaptive backward difference algorithm gsl deriv backward",
          "hierarchy": "Numeric GSL Differentiation",
          "module": "Numeric.GSL.Differentiation",
          "name": "derivBackward",
          "normalized": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "Backward",
          "signature": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Differentiation.html#v:derivBackward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdaptive central difference algorithm, \u003cem\u003egsl_deriv_central\u003c/em\u003e. For example:\n\u003c/p\u003e\u003cpre\u003e \u003e let deriv = derivCentral 0.01 \n \u003e deriv sin (pi/4)\n(0.7071067812000676,1.0600063101654055e-10)\n \u003e cos (pi/4)\n0.7071067811865476 \n\u003c/pre\u003e",
          "module": "Numeric.GSL.Differentiation",
          "name": "derivCentral",
          "package": "hmatrix",
          "signature": "Double-\u003e (Double -\u003e Double)-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Adaptive central difference algorithm gsl deriv central For example let deriv derivCentral deriv sin pi e-10 cos pi",
          "hierarchy": "Numeric GSL Differentiation",
          "module": "Numeric.GSL.Differentiation",
          "name": "derivCentral",
          "normalized": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "Central",
          "signature": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Differentiation.html#v:derivCentral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdaptive forward difference algorithm, \u003cem\u003egsl_deriv_forward\u003c/em\u003e. The function is evaluated only at points greater than x, and never at x itself. The derivative is returned in result and an estimate of its absolute error is returned in abserr. This function should be used if f(x) has a discontinuity at x, or is undefined for values less than x. A backward derivative can be obtained using a negative step.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Differentiation",
          "name": "derivForward",
          "package": "hmatrix",
          "signature": "Double-\u003e (Double -\u003e Double)-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Adaptive forward difference algorithm gsl deriv forward The function is evaluated only at points greater than and never at itself The derivative is returned in result and an estimate of its absolute error is returned in abserr This function should be used if has discontinuity at or is undefined for values less than backward derivative can be obtained using negative step",
          "hierarchy": "Numeric GSL Differentiation",
          "module": "Numeric.GSL.Differentiation",
          "name": "derivForward",
          "normalized": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "Forward",
          "signature": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Differentiation.html#v:derivForward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNonlinear Least-Squares Fitting\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Nonlinear-Least_002dSquares-Fitting.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe example program in the GSL manual (see examples/fitting.hs):\n\u003c/p\u003e\u003cpre\u003edat = [\n ([0.0],([6.0133918608118675],0.1)),\n ([1.0],([5.5153769909966535],0.1)),\n ([2.0],([5.261094606015287],0.1)),\n ...\n ([39.0],([1.0619821710802808],0.1))]\n\nexpModel [a,lambda,b] [t] = [a * exp (-lambda * t) + b]\n\nexpModelDer [a,lambda,b] [t] = [[exp (-lambda * t), -t * a * exp(-lambda*t) , 1]]\n\n(sol,path) = fitModelScaled 1E-4 1E-4 20 (expModel, expModelDer) dat [1,0,0]\n\n\u003e path\n(6\u003e\u003c5)\n [ 1.0,  76.45780563978782, 1.6465931240727802, 1.8147715267618197e-2, 0.6465931240727797\n , 2.0, 37.683816318260355,  2.858760367632973,  8.092094813253975e-2, 1.4479636296208662\n , 3.0,    9.5807893736187,  4.948995119561291,   0.11942927999921617, 1.0945766509238248\n , 4.0,  5.630494933603935,  5.021755718065913,   0.10287787128056883, 1.0338835440862608\n , 5.0,  5.443976278682909,  5.045204331329302,   0.10405523433131504,  1.019416067207375\n , 6.0, 5.4439736648994685,  5.045357818922331,   0.10404905846029407, 1.0192487112786812 ]\n\u003e sol\n[(5.045357818922331,6.027976702418132e-2),\n(0.10404905846029407,3.157045047172834e-3),\n(1.0192487112786812,3.782067731353722e-2)]\u003c/pre\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Fitting",
          "name": "Fitting",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Fitting.html",
          "type": "module"
        },
        "index": {
          "description": "Nonlinear Least-Squares Fitting http www.gnu.org software gsl manual html node Nonlinear-Least dSquares-Fitting.html The example program in the GSL manual see examples fitting.hs dat expModel lambda exp lambda expModelDer lambda exp lambda exp lambda sol path fitModelScaled E-4 E-4 expModel expModelDer dat path e-2 e-2 sol e-2 e-3 e-2",
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "Fitting",
          "package": "hmatrix",
          "partial": "Fitting",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Fitting",
          "name": "FittingMethod",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Fitting.html#FittingMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "FittingMethod",
          "package": "hmatrix",
          "partial": "Fitting Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#t:FittingMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an unscaled version of the lmder algorithm. The elements of the diagonal scaling matrix D are set to 1. This algorithm may be useful in circumstances where the scaled version of lmder converges too slowly, or the function is already scaled appropriately.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Fitting",
          "name": "LevenbergMarquardt",
          "package": "hmatrix",
          "signature": "LevenbergMarquardt",
          "source": "src/Numeric-GSL-Fitting.html#FittingMethod",
          "type": "function"
        },
        "index": {
          "description": "This is an unscaled version of the lmder algorithm The elements of the diagonal scaling matrix are set to This algorithm may be useful in circumstances where the scaled version of lmder converges too slowly or the function is already scaled appropriately",
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "LevenbergMarquardt",
          "package": "hmatrix",
          "partial": "Levenberg Marquardt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#v:LevenbergMarquardt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInterface to gsl_multifit_fdfsolver_lmsder. This is a robust and efficient version of the Levenberg-Marquardt algorithm as implemented in the scaled lmder routine in minpack. Minpack was written by Jorge J. More, Burton S. Garbow and Kenneth E. Hillstrom.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Fitting",
          "name": "LevenbergMarquardtScaled",
          "package": "hmatrix",
          "signature": "LevenbergMarquardtScaled",
          "source": "src/Numeric-GSL-Fitting.html#FittingMethod",
          "type": "function"
        },
        "index": {
          "description": "Interface to gsl multifit fdfsolver lmsder This is robust and efficient version of the Levenberg-Marquardt algorithm as implemented in the scaled lmder routine in minpack Minpack was written by Jorge More Burton Garbow and Kenneth Hillstrom",
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "LevenbergMarquardtScaled",
          "package": "hmatrix",
          "partial": "Levenberg Marquardt Scaled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#v:LevenbergMarquardtScaled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHigher level interface to \u003ccode\u003e\u003ca\u003enlFitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLevenbergMarquardt\u003c/a\u003e\u003c/code\u003e. The optimization function and\n Jacobian are automatically built from a model f vs x = y and its derivatives, and a list of\n instances (x,y) to be fitted.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Fitting",
          "name": "fitModel",
          "package": "hmatrix",
          "signature": "Double-\u003e Double-\u003e Int-\u003e ([Double] -\u003e x -\u003e [Double], [Double] -\u003e x -\u003e [[Double]])-\u003e [(x, [Double])]-\u003e [Double]-\u003e ([Double], Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Higher level interface to nlFitting LevenbergMarquardt The optimization function and Jacobian are automatically built from model vs and its derivatives and list of instances to be fitted",
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "fitModel",
          "normalized": "Double-\u003eDouble-\u003eInt-\u003e([Double]-\u003ea-\u003e[Double],[Double]-\u003ea-\u003e[[Double]])-\u003e[(a,[Double])]-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "partial": "Model",
          "signature": "Double-\u003eDouble-\u003eInt-\u003e([Double]-\u003ex-\u003e[Double],[Double]-\u003ex-\u003e[[Double]])-\u003e[(x,[Double])]-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#v:fitModel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHigher level interface to \u003ccode\u003e\u003ca\u003enlFitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLevenbergMarquardtScaled\u003c/a\u003e\u003c/code\u003e. The optimization function and\n Jacobian are automatically built from a model f vs x = y and its derivatives, and a list of\n instances (x, (y,sigma)) to be fitted.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Fitting",
          "name": "fitModelScaled",
          "package": "hmatrix",
          "signature": "Double-\u003e Double-\u003e Int-\u003e ([Double] -\u003e x -\u003e [Double], [Double] -\u003e x -\u003e [[Double]])-\u003e [(x, ([Double], Double))]-\u003e [Double]-\u003e ([(Double, Double)], Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Higher level interface to nlFitting LevenbergMarquardtScaled The optimization function and Jacobian are automatically built from model vs and its derivatives and list of instances sigma to be fitted",
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "fitModelScaled",
          "normalized": "Double-\u003eDouble-\u003eInt-\u003e([Double]-\u003ea-\u003e[Double],[Double]-\u003ea-\u003e[[Double]])-\u003e[(a,([Double],Double))]-\u003e[Double]-\u003e([(Double,Double)],Matrix Double)",
          "package": "hmatrix",
          "partial": "Model Scaled",
          "signature": "Double-\u003eDouble-\u003eInt-\u003e([Double]-\u003ex-\u003e[Double],[Double]-\u003ex-\u003e[[Double]])-\u003e[(x,([Double],Double))]-\u003e[Double]-\u003e([(Double,Double)],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#v:fitModelScaled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNonlinear multidimensional least-squares fitting.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Fitting",
          "name": "nlFitting",
          "package": "hmatrix",
          "signature": "FittingMethod-\u003e Double-\u003e Double-\u003e Int-\u003e (Vector Double -\u003e Vector Double)-\u003e (Vector Double -\u003e Matrix Double)-\u003e Vector Double-\u003e (Vector Double, Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Nonlinear multidimensional least-squares fitting",
          "hierarchy": "Numeric GSL Fitting",
          "module": "Numeric.GSL.Fitting",
          "name": "nlFitting",
          "normalized": "FittingMethod-\u003eDouble-\u003eDouble-\u003eInt-\u003e(Vector Double-\u003eVector Double)-\u003e(Vector Double-\u003eMatrix Double)-\u003eVector Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "Fitting",
          "signature": "FittingMethod-\u003eDouble-\u003eDouble-\u003eInt-\u003e(Vector Double-\u003eVector Double)-\u003e(Vector Double-\u003eMatrix Double)-\u003eVector Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fitting.html#v:nlFitting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFourier Transform.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Fast-Fourier-Transforms.html#Fast-Fourier-Transforms\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Fourier",
          "name": "Fourier",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Fourier.html",
          "type": "module"
        },
        "index": {
          "description": "Fourier Transform http www.gnu.org software gsl manual html node Fast-Fourier-Transforms.html Fast-Fourier-Transforms",
          "hierarchy": "Numeric GSL Fourier",
          "module": "Numeric.GSL.Fourier",
          "name": "Fourier",
          "package": "hmatrix",
          "partial": "Fourier",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fourier.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFast 1D Fourier transform of a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(\u003c/code\u003e\u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e\u003ccode\u003e)\u003c/code\u003e using \u003cem\u003egsl_fft_complex_forward\u003c/em\u003e. It uses the same scaling conventions as GNU Octave.\n\u003c/p\u003e\u003cpre\u003e\u003e fft (\u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e [1,2,3,4])\nvector (4) [10.0 :+ 0.0,(-2.0) :+ 2.0,(-2.0) :+ 0.0,(-2.0) :+ (-2.0)]\u003c/pre\u003e",
          "module": "Numeric.GSL.Fourier",
          "name": "fft",
          "package": "hmatrix",
          "signature": "Vector (Complex Double) -\u003e Vector (Complex Double)",
          "source": "src/Numeric-GSL-Fourier.html#fft",
          "type": "function"
        },
        "index": {
          "description": "Fast Fourier transform of Vector Complex Double using gsl fft complex forward It uses the same scaling conventions as GNU Octave fft fromList vector",
          "hierarchy": "Numeric GSL Fourier",
          "module": "Numeric.GSL.Fourier",
          "name": "fft",
          "normalized": "Vector(Complex Double)-\u003eVector(Complex Double)",
          "package": "hmatrix",
          "signature": "Vector(Complex Double)-\u003eVector(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fourier.html#v:fft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe inverse of \u003ccode\u003e\u003ca\u003efft\u003c/a\u003e\u003c/code\u003e, using \u003cem\u003egsl_fft_complex_inverse\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Fourier",
          "name": "ifft",
          "package": "hmatrix",
          "signature": "Vector (Complex Double) -\u003e Vector (Complex Double)",
          "source": "src/Numeric-GSL-Fourier.html#ifft",
          "type": "function"
        },
        "index": {
          "description": "The inverse of fft using gsl fft complex inverse",
          "hierarchy": "Numeric GSL Fourier",
          "module": "Numeric.GSL.Fourier",
          "name": "ifft",
          "normalized": "Vector(Complex Double)-\u003eVector(Complex Double)",
          "package": "hmatrix",
          "signature": "Vector(Complex Double)-\u003eVector(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Fourier.html#v:ifft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNumerical integration routines.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Numerical-Integration.html#Numerical-Integration\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "Integration",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Integration.html",
          "type": "module"
        },
        "index": {
          "description": "Numerical integration routines http www.gnu.org software gsl manual html node Numerical-Integration.html Numerical-Integration",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "Integration",
          "package": "hmatrix",
          "partial": "Integration",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumerical integration using \u003cem\u003egsl_integration_cquad\u003c/em\u003e (quadrature\nfor general integrands).  From the GSL manual:\n\u003c/p\u003e\u003cpre\u003eCQUAD is a new doubly-adaptive general-purpose quadrature routine\nwhich can handle most types of singularities, non-numerical function\nvalues such as Inf or NaN, as well as some divergent integrals. It\ngenerally requires more function evaluations than the integration\nroutines in QUADPACK, yet fails less often for difficult integrands.\u003c/pre\u003e\u003cp\u003eFor example:\n\u003c/p\u003e\u003cpre\u003e\u003e let quad = integrateCQUAD 1E-12 1000 \n\u003e let f a x = exp(-a * x^2)\n\u003e quad (f 0.5) 2 5\n(5.7025405463957006e-2,9.678874441303705e-16,95)\u003c/pre\u003e\u003cp\u003eUnlike other quadrature methods, integrateCQUAD also returns the\nnumber of function evaluations required.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "integrateCQUAD",
          "package": "hmatrix",
          "signature": "Double-\u003e Int-\u003e (Double -\u003e Double)-\u003e Double-\u003e Double-\u003e (Double, Double, Int)",
          "type": "function"
        },
        "index": {
          "description": "Numerical integration using gsl integration cquad quadrature for general integrands From the GSL manual CQUAD is new doubly-adaptive general-purpose quadrature routine which can handle most types of singularities non-numerical function values such as Inf or NaN as well as some divergent integrals It generally requires more function evaluations than the integration routines in QUADPACK yet fails less often for difficult integrands For example let quad integrateCQUAD E-12 let exp quad e-2 e-16 Unlike other quadrature methods integrateCQUAD also returns the number of function evaluations required",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "integrateCQUAD",
          "normalized": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Double,Int)",
          "package": "hmatrix",
          "partial": "CQUAD",
          "signature": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Double,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#v:integrateCQUAD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumerical integration using \u003cem\u003egsl_integration_qagi\u003c/em\u003e (integration over the infinite integral -Inf..Inf using QAGS). \nFor example:\n\u003c/p\u003e\u003cpre\u003e\u003e let quad = integrateQAGI 1E-9 1000 \n\u003e let f a x = exp(-a * x^2)\n\u003e quad (f 0.5) \n(2.5066282746310002,6.229215880648858e-11)\u003c/pre\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGI",
          "package": "hmatrix",
          "signature": "Double-\u003e Int-\u003e (Double -\u003e Double)-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Numerical integration using gsl integration qagi integration over the infinite integral Inf..Inf using QAGS For example let quad integrateQAGI E-9 let exp quad e-11",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGI",
          "normalized": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "QAGI",
          "signature": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#v:integrateQAGI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumerical integration using \u003cem\u003egsl_integration_qagil\u003c/em\u003e (integration over the semi-infinite integral -Inf..b). \nFor example:\n\u003c/p\u003e\u003cpre\u003e\u003e let quad = integrateQAGIL 1E-9 1000 \n\u003e let f a x = exp(-a * x^2)\n\u003e quad (f 0.5) 0 \n(1.2533141373155001,3.114607940324429e-11)\u003c/pre\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGIL",
          "package": "hmatrix",
          "signature": "Double-\u003e Int-\u003e (Double -\u003e Double)-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Numerical integration using gsl integration qagil integration over the semi-infinite integral Inf..b For example let quad integrateQAGIL E-9 let exp quad e-11",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGIL",
          "normalized": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "QAGIL",
          "signature": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#v:integrateQAGIL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumerical integration using \u003cem\u003egsl_integration_qagiu\u003c/em\u003e (integration over the semi-infinite integral a..Inf). \nFor example:\n\u003c/p\u003e\u003cpre\u003e\u003e let quad = integrateQAGIU 1E-9 1000 \n\u003e let f a x = exp(-a * x^2)\n\u003e quad (f 0.5) 0\n(1.2533141373155001,3.114607940324429e-11)\u003c/pre\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGIU",
          "package": "hmatrix",
          "signature": "Double-\u003e Int-\u003e (Double -\u003e Double)-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Numerical integration using gsl integration qagiu integration over the semi-infinite integral a..Inf For example let quad integrateQAGIU E-9 let exp quad e-11",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGIU",
          "normalized": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "QAGIU",
          "signature": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#v:integrateQAGIU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumerical integration using \u003cem\u003egsl_integration_qags\u003c/em\u003e (adaptive integration with singularities). For example:\n\u003c/p\u003e\u003cpre\u003e\u003e let quad = integrateQAGS 1E-9 1000 \n\u003e let f a x = x**(-0.5) * log (a*x)\n\u003e quad (f 1) 0 1\n(-3.999999999999974,4.871658632055187e-13)\u003c/pre\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGS",
          "package": "hmatrix",
          "signature": "Double-\u003e Int-\u003e (Double -\u003e Double)-\u003e Double-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Numerical integration using gsl integration qags adaptive integration with singularities For example let quad integrateQAGS E-9 let log quad e-13",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQAGS",
          "normalized": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "QAGS",
          "signature": "Double-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#v:integrateQAGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumerical integration using \u003cem\u003egsl_integration_qng\u003c/em\u003e (useful for fast integration of smooth functions). For example:\n\u003c/p\u003e\u003cpre\u003e\u003e let quad = integrateQNG 1E-6 \n\u003e quad (\\x -\u003e 4/(1+x*x)) 0 1 \n(3.141592653589793,3.487868498008632e-14)\u003c/pre\u003e",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQNG",
          "package": "hmatrix",
          "signature": "Double-\u003e (Double -\u003e Double)-\u003e Double-\u003e Double-\u003e (Double, Double)",
          "type": "function"
        },
        "index": {
          "description": "Numerical integration using gsl integration qng useful for fast integration of smooth functions For example let quad integrateQNG E-6 quad e-14",
          "hierarchy": "Numeric GSL Integration",
          "module": "Numeric.GSL.Integration",
          "name": "integrateQNG",
          "normalized": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Double)",
          "package": "hmatrix",
          "partial": "QNG",
          "signature": "Double-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Integration.html#v:integrateQNG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMinimization of a multidimensional function using some of the algorithms described in:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Minimization.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe example in the GSL manual:\n\u003c/p\u003e\u003cpre\u003e\n\nf [x,y] = 10*(x-1)^2 + 20*(y-2)^2 + 30\n\nmain = do\n    let (s,p) = minimize NMSimplex2 1E-2 30 [1,1] f [5,7]\n    print s\n    print p\n\n\u003e main\n[0.9920430849306288,1.9969168063253182]\n 0.000  512.500  1.130  6.500  5.000\n 1.000  290.625  1.409  5.250  4.000\n 2.000  290.625  1.409  5.250  4.000\n 3.000  252.500  1.409  5.500  1.000\n ...\n22.000   30.001  0.013  0.992  1.997\n23.000   30.001  0.008  0.992  1.997\n\u003c/pre\u003e\u003cp\u003eThe path to the solution can be graphically shown by means of:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003emplot\u003c/a\u003e\u003c/code\u003e $ drop 3 (\u003ccode\u003e\u003ca\u003etoColumns\u003c/a\u003e\u003c/code\u003e p)\u003c/pre\u003e\u003cp\u003eTaken from the GSL manual:\n\u003c/p\u003e\u003cp\u003eThe vector Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm is a quasi-Newton method which builds up an approximation to the second derivatives of the function f using the difference between successive gradient vectors. By combining the first and second derivatives the algorithm is able to take Newton-type steps towards the function minimum, assuming quadratic behavior in that region.\n\u003c/p\u003e\u003cp\u003eThe bfgs2 version of this minimizer is the most efficient version available, and is a faithful implementation of the line minimization scheme described in Fletcher's Practical Methods of Optimization, Algorithms 2.6.2 and 2.6.4. It supercedes the original bfgs routine and requires substantially fewer function and gradient evaluations. The user-supplied tolerance tol corresponds to the parameter sigma used by Fletcher. A value of 0.1 is recommended for typical use (larger values correspond to less accurate line searches).\n\u003c/p\u003e\u003cp\u003eThe nmsimplex2 version is a new O(N) implementation of the earlier O(N^2) nmsimplex minimiser. It calculates the size of simplex as the rms distance of each vertex from the center rather than the mean distance, which has the advantage of allowing a linear update.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "Minimization",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Minimization.html",
          "type": "module"
        },
        "index": {
          "description": "Minimization of multidimensional function using some of the algorithms described in http www.gnu.org software gsl manual html node Multidimensional-Minimization.html The example in the GSL manual x-1 y-2 main do let minimize NMSimplex2 E-2 print print main The path to the solution can be graphically shown by means of mplot drop toColumns Taken from the GSL manual The vector Broyden-Fletcher-Goldfarb-Shanno BFGS algorithm is quasi-Newton method which builds up an approximation to the second derivatives of the function using the difference between successive gradient vectors By combining the first and second derivatives the algorithm is able to take Newton-type steps towards the function minimum assuming quadratic behavior in that region The bfgs2 version of this minimizer is the most efficient version available and is faithful implementation of the line minimization scheme described in Fletcher Practical Methods of Optimization Algorithms and It supercedes the original bfgs routine and requires substantially fewer function and gradient evaluations The user-supplied tolerance tol corresponds to the parameter sigma used by Fletcher value of is recommended for typical use larger values correspond to less accurate line searches The nmsimplex2 version is new implementation of the earlier nmsimplex minimiser It calculates the size of simplex as the rms distance of each vertex from the center rather than the mean distance which has the advantage of allowing linear update",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "Minimization",
          "package": "hmatrix",
          "partial": "Minimization",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "MinimizeMethod",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "MinimizeMethod",
          "package": "hmatrix",
          "partial": "Minimize Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#t:MinimizeMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "MinimizeMethodD",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethodD",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "MinimizeMethodD",
          "package": "hmatrix",
          "partial": "Minimize Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#t:MinimizeMethodD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "UniMinimizeMethod",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Minimization.html#UniMinimizeMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "UniMinimizeMethod",
          "package": "hmatrix",
          "partial": "Uni Minimize Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#t:UniMinimizeMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "BrentMini",
          "package": "hmatrix",
          "signature": "BrentMini",
          "source": "src/Numeric-GSL-Minimization.html#UniMinimizeMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "BrentMini",
          "package": "hmatrix",
          "partial": "Brent Mini",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:BrentMini"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "ConjugateFR",
          "package": "hmatrix",
          "signature": "ConjugateFR",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethodD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "ConjugateFR",
          "package": "hmatrix",
          "partial": "Conjugate FR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:ConjugateFR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "ConjugatePR",
          "package": "hmatrix",
          "signature": "ConjugatePR",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethodD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "ConjugatePR",
          "package": "hmatrix",
          "partial": "Conjugate PR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:ConjugatePR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "GoldenSection",
          "package": "hmatrix",
          "signature": "GoldenSection",
          "source": "src/Numeric-GSL-Minimization.html#UniMinimizeMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "GoldenSection",
          "package": "hmatrix",
          "partial": "Golden Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:GoldenSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "NMSimplex",
          "package": "hmatrix",
          "signature": "NMSimplex",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "NMSimplex",
          "package": "hmatrix",
          "partial": "NMSimplex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:NMSimplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "NMSimplex2",
          "package": "hmatrix",
          "signature": "NMSimplex2",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "NMSimplex2",
          "package": "hmatrix",
          "partial": "NMSimplex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:NMSimplex2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "QuadGolden",
          "package": "hmatrix",
          "signature": "QuadGolden",
          "source": "src/Numeric-GSL-Minimization.html#UniMinimizeMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "QuadGolden",
          "package": "hmatrix",
          "partial": "Quad Golden",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:QuadGolden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "SteepestDescent",
          "package": "hmatrix",
          "signature": "SteepestDescent",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethodD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "SteepestDescent",
          "package": "hmatrix",
          "partial": "Steepest Descent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:SteepestDescent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "VectorBFGS",
          "package": "hmatrix",
          "signature": "VectorBFGS",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethodD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "VectorBFGS",
          "package": "hmatrix",
          "partial": "Vector BFGS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:VectorBFGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Minimization",
          "name": "VectorBFGS2",
          "package": "hmatrix",
          "signature": "VectorBFGS2",
          "source": "src/Numeric-GSL-Minimization.html#MinimizeMethodD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "VectorBFGS2",
          "package": "hmatrix",
          "partial": "Vector BFGS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:VectorBFGS2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimization without derivatives\n\u003c/p\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimize",
          "package": "hmatrix",
          "signature": "MinimizeMethod-\u003e Double-\u003e Int-\u003e [Double]-\u003e ([Double] -\u003e Double)-\u003e [Double]-\u003e ([Double], Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Minimization without derivatives",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimize",
          "normalized": "MinimizeMethod-\u003eDouble-\u003eInt-\u003e[Double]-\u003e([Double]-\u003eDouble)-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "signature": "MinimizeMethod-\u003eDouble-\u003eInt-\u003e[Double]-\u003e([Double]-\u003eDouble)-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use minimizeD ConjugateFR eps maxit step tol f g xi\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeConjugateGradient",
          "package": "hmatrix",
          "signature": "Double -\u003e Double -\u003e Double -\u003e Int -\u003e ([Double] -\u003e Double) -\u003e ([Double] -\u003e [Double]) -\u003e [Double] -\u003e ([Double], Matrix Double)",
          "source": "src/Numeric-GSL-Minimization.html#minimizeConjugateGradient",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use minimizeD ConjugateFR eps maxit step tol xi",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeConjugateGradient",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eInt-\u003e([Double]-\u003eDouble)-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "partial": "Conjugate Gradient",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eInt-\u003e([Double]-\u003eDouble)-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimizeConjugateGradient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimization with derivatives.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeD",
          "package": "hmatrix",
          "signature": "MinimizeMethodD-\u003e Double-\u003e Int-\u003e Double-\u003e Double-\u003e ([Double] -\u003e Double)-\u003e ([Double] -\u003e [Double])-\u003e [Double]-\u003e ([Double], Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Minimization with derivatives",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeD",
          "normalized": "MinimizeMethodD-\u003eDouble-\u003eInt-\u003eDouble-\u003eDouble-\u003e([Double]-\u003eDouble)-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "signature": "MinimizeMethodD-\u003eDouble-\u003eInt-\u003eDouble-\u003eDouble-\u003e([Double]-\u003eDouble)-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimizeD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use minimize NMSimplex2 eps maxit sizes f xi\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeNMSimplex",
          "package": "hmatrix",
          "signature": "([Double] -\u003e Double) -\u003e [Double] -\u003e [Double] -\u003e Double -\u003e Int -\u003e ([Double], Matrix Double)",
          "source": "src/Numeric-GSL-Minimization.html#minimizeNMSimplex",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use minimize NMSimplex2 eps maxit sizes xi",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeNMSimplex",
          "normalized": "([Double]-\u003eDouble)-\u003e[Double]-\u003e[Double]-\u003eDouble-\u003eInt-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "partial": "NMSimplex",
          "signature": "([Double]-\u003eDouble)-\u003e[Double]-\u003e[Double]-\u003eDouble-\u003eInt-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimizeNMSimplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimization without derivatives (vector version)\n\u003c/p\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeV",
          "package": "hmatrix",
          "signature": "MinimizeMethod-\u003e Double-\u003e Int-\u003e Vector Double-\u003e (Vector Double -\u003e Double)-\u003e Vector Double-\u003e (Vector Double, Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Minimization without derivatives vector version",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeV",
          "normalized": "MinimizeMethod-\u003eDouble-\u003eInt-\u003eVector Double-\u003e(Vector Double-\u003eDouble)-\u003eVector Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "signature": "MinimizeMethod-\u003eDouble-\u003eInt-\u003eVector Double-\u003e(Vector Double-\u003eDouble)-\u003eVector Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimizeV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimization with derivatives (vector version)\n\u003c/p\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeVD",
          "package": "hmatrix",
          "signature": "MinimizeMethodD-\u003e Double-\u003e Int-\u003e Double-\u003e Double-\u003e (Vector Double -\u003e Double)-\u003e (Vector Double -\u003e Vector Double)-\u003e Vector Double-\u003e (Vector Double, Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Minimization with derivatives vector version",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeVD",
          "normalized": "MinimizeMethodD-\u003eDouble-\u003eInt-\u003eDouble-\u003eDouble-\u003e(Vector Double-\u003eDouble)-\u003e(Vector Double-\u003eVector Double)-\u003eVector Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "VD",
          "signature": "MinimizeMethodD-\u003eDouble-\u003eInt-\u003eDouble-\u003eDouble-\u003e(Vector Double-\u003eDouble)-\u003e(Vector Double-\u003eVector Double)-\u003eVector Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimizeVD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use minimizeD VectorBFGS2 eps maxit step tol f g xi\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeVectorBFGS2",
          "package": "hmatrix",
          "signature": "Double -\u003e Double -\u003e Double -\u003e Int -\u003e ([Double] -\u003e Double) -\u003e ([Double] -\u003e [Double]) -\u003e [Double] -\u003e ([Double], Matrix Double)",
          "source": "src/Numeric-GSL-Minimization.html#minimizeVectorBFGS2",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use minimizeD VectorBFGS2 eps maxit step tol xi",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "minimizeVectorBFGS2",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eInt-\u003e([Double]-\u003eDouble)-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "partial": "Vector BFGS",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eInt-\u003e([Double]-\u003eDouble)-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:minimizeVectorBFGS2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnedimensional minimization.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Minimization",
          "name": "uniMinimize",
          "package": "hmatrix",
          "signature": "UniMinimizeMethod-\u003e Double-\u003e Int-\u003e (Double -\u003e Double)-\u003e Double-\u003e Double-\u003e Double-\u003e (Double, Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Onedimensional minimization",
          "hierarchy": "Numeric GSL Minimization",
          "module": "Numeric.GSL.Minimization",
          "name": "uniMinimize",
          "normalized": "UniMinimizeMethod-\u003eDouble-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003eDouble-\u003e(Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "Minimize",
          "signature": "UniMinimizeMethod-\u003eDouble-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003eDouble-\u003e(Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Minimization.html#v:uniMinimize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSolution of ordinary differential equation (ODE) initial value problems.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Ordinary-Differential-Equations.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eA simple example:\n\u003c/p\u003e\u003cpre\u003eimport Numeric.GSL\nimport Numeric.LinearAlgebra\nimport Graphics.Plot\n\nxdot t [x,v] = [v, -0.95*x - 0.1*v]\n\nts = linspace 100 (0,20 :: Double)\n\nsol = odeSolve xdot [10,0] ts\n\nmain = mplot (ts : toColumns sol)\u003c/pre\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "ODE",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-ODE.html",
          "type": "module"
        },
        "index": {
          "description": "Solution of ordinary differential equation ODE initial value problems http www.gnu.org software gsl manual html node Ordinary-Differential-Equations.html simple example import Numeric.GSL import Numeric.LinearAlgebra import Graphics.Plot xdot ts linspace Double sol odeSolve xdot ts main mplot ts toColumns sol",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "ODE",
          "package": "hmatrix",
          "partial": "ODE",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.ODE",
          "name": "Jacobian",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-ODE.html#Jacobian",
          "type": "type"
        },
        "index": {
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "Jacobian",
          "package": "hmatrix",
          "partial": "Jacobian",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#t:Jacobian"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStepping functions\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "ODEMethod",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "data"
        },
        "index": {
          "description": "Stepping functions",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "ODEMethod",
          "package": "hmatrix",
          "partial": "ODEMethod",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#t:ODEMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit Bulirsch-Stoer method of Bader and Deuflhard. The method is generally suitable for stiff problems.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "BSimp",
          "package": "hmatrix",
          "signature": "BSimp Jacobian",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Implicit Bulirsch-Stoer method of Bader and Deuflhard The method is generally suitable for stiff problems",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "BSimp",
          "package": "hmatrix",
          "partial": "BSimp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:BSimp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable-coefficient linear multistep Adams method in Nordsieck form. This stepper uses explicit Adams-Bashforth (predictor) and implicit Adams-Moulton (corrector) methods in P(EC)^m functional iteration mode. Method order varies dynamically between 1 and 12. \n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "MSAdams",
          "package": "hmatrix",
          "signature": "MSAdams",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "variable-coefficient linear multistep Adams method in Nordsieck form This stepper uses explicit Adams-Bashforth predictor and implicit Adams-Moulton corrector methods in EC functional iteration mode Method order varies dynamically between and",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "MSAdams",
          "package": "hmatrix",
          "partial": "MSAdams",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:MSAdams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variable-coefficient linear multistep backward differentiation formula (BDF) method in Nordsieck form. This stepper uses the explicit BDF formula as predictor and implicit BDF formula as corrector. A modified Newton iteration method is used to solve the system of non-linear equations. Method order varies dynamically between 1 and 5. The method is generally suitable for stiff problems.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "MSBDF",
          "package": "hmatrix",
          "signature": "MSBDF Jacobian",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "variable-coefficient linear multistep backward differentiation formula BDF method in Nordsieck form This stepper uses the explicit BDF formula as predictor and implicit BDF formula as corrector modified Newton iteration method is used to solve the system of non-linear equations Method order varies dynamically between and The method is generally suitable for stiff problems",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "MSBDF",
          "package": "hmatrix",
          "partial": "MSBDF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:MSBDF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit Gaussian first order Runge-Kutta. Also known as implicit Euler or backward Euler method. Error estimation is carried out by the step doubling method.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RK1imp",
          "package": "hmatrix",
          "signature": "RK1imp Jacobian",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Implicit Gaussian first order Runge-Kutta Also known as implicit Euler or backward Euler method Error estimation is carried out by the step doubling method",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RK1imp",
          "package": "hmatrix",
          "partial": "RK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RK1imp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbedded Runge-Kutta (2, 3) method.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RK2",
          "package": "hmatrix",
          "signature": "RK2",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Embedded Runge-Kutta method",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RK2",
          "package": "hmatrix",
          "partial": "RK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RK2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit 2nd order Runge-Kutta at Gaussian points.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RK2imp",
          "package": "hmatrix",
          "signature": "RK2imp Jacobian",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Implicit nd order Runge-Kutta at Gaussian points",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RK2imp",
          "package": "hmatrix",
          "partial": "RK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RK2imp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e4th order (classical) Runge-Kutta. The error estimate is obtained by halving the step-size. For more efficient estimate of the error, use the embedded methods.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RK4",
          "package": "hmatrix",
          "signature": "RK4",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "th order classical Runge-Kutta The error estimate is obtained by halving the step-size For more efficient estimate of the error use the embedded methods",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RK4",
          "package": "hmatrix",
          "partial": "RK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RK4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplicit 4th order Runge-Kutta at Gaussian points.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RK4imp",
          "package": "hmatrix",
          "signature": "RK4imp Jacobian",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Implicit th order Runge-Kutta at Gaussian points",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RK4imp",
          "package": "hmatrix",
          "partial": "RK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RK4imp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbedded Runge-Kutta Prince-Dormand (8,9) method.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RK8pd",
          "package": "hmatrix",
          "signature": "RK8pd",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Embedded Runge-Kutta Prince-Dormand method",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RK8pd",
          "package": "hmatrix",
          "partial": "RK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RK8pd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbedded Runge-Kutta Cash-Karp (4, 5) method.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RKck",
          "package": "hmatrix",
          "signature": "RKck",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Embedded Runge-Kutta Cash-Karp method",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RKck",
          "package": "hmatrix",
          "partial": "RKck",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RKck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmbedded Runge-Kutta-Fehlberg (4, 5) method. This method is a good general-purpose integrator.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "RKf45",
          "package": "hmatrix",
          "signature": "RKf45",
          "source": "src/Numeric-GSL-ODE.html#ODEMethod",
          "type": "function"
        },
        "index": {
          "description": "Embedded Runge-Kutta-Fehlberg method This method is good general-purpose integrator",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "RKf45",
          "package": "hmatrix",
          "partial": "RKf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:RKf45"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003eodeSolveV\u003c/a\u003e\u003c/code\u003e with reasonable default parameters and system of equations defined using lists.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "odeSolve",
          "package": "hmatrix",
          "signature": "(Double -\u003e [Double] -\u003e [Double])-\u003e [Double]-\u003e Vector Double-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "version of odeSolveV with reasonable default parameters and system of equations defined using lists",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "odeSolve",
          "normalized": "(Double-\u003e[Double]-\u003e[Double])-\u003e[Double]-\u003eVector Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "(Double-\u003e[Double]-\u003e[Double])-\u003e[Double]-\u003eVector Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:odeSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvolution of the system with adaptive step-size control.\n\u003c/p\u003e",
          "module": "Numeric.GSL.ODE",
          "name": "odeSolveV",
          "package": "hmatrix",
          "signature": "ODEMethod-\u003e Double-\u003e Double-\u003e Double-\u003e (Double -\u003e Vector Double -\u003e Vector Double)-\u003e Vector Double-\u003e Vector Double-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "Evolution of the system with adaptive step-size control",
          "hierarchy": "Numeric GSL ODE",
          "module": "Numeric.GSL.ODE",
          "name": "odeSolveV",
          "normalized": "ODEMethod-\u003eDouble-\u003eDouble-\u003eDouble-\u003e(Double-\u003eVector Double-\u003eVector Double)-\u003eVector Double-\u003eVector Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "ODEMethod-\u003eDouble-\u003eDouble-\u003eDouble-\u003e(Double-\u003eVector Double-\u003eVector Double)-\u003eVector Double-\u003eVector Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-ODE.html#v:odeSolveV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePolynomials.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/General-Polynomial-Equations.html#General-Polynomial-Equations\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Polynomials",
          "name": "Polynomials",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Polynomials.html",
          "type": "module"
        },
        "index": {
          "description": "Polynomials http www.gnu.org software gsl manual html node General-Polynomial-Equations.html General-Polynomial-Equations",
          "hierarchy": "Numeric GSL Polynomials",
          "module": "Numeric.GSL.Polynomials",
          "name": "Polynomials",
          "package": "hmatrix",
          "partial": "Polynomials",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Polynomials.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolution of general polynomial equations, using \u003cem\u003egsl_poly_complex_solve\u003c/em\u003e. For example,\n     the three solutions of x^3 + 8 = 0\n\u003c/p\u003e\u003cpre\u003e\u003e polySolve [8,0,0,1]\n[(-1.9999999999999998) :+ 0.0,\n 1.0 :+ 1.732050807568877,\n 1.0 :+ (-1.732050807568877)]\u003c/pre\u003e\u003cp\u003eThe example in the GSL manual: To find the roots of x^5 -1 = 0:\n\u003c/p\u003e\u003cpre\u003e\u003e polySolve [-1, 0, 0, 0, 0, 1]\n[(-0.8090169943749475) :+ 0.5877852522924731,\n(-0.8090169943749475) :+ (-0.5877852522924731),\n0.30901699437494734 :+ 0.9510565162951536,\n0.30901699437494734 :+ (-0.9510565162951536),\n1.0 :+ 0.0]\u003c/pre\u003e",
          "module": "Numeric.GSL.Polynomials",
          "name": "polySolve",
          "package": "hmatrix",
          "signature": "[Double] -\u003e [Complex Double]",
          "source": "src/Numeric-GSL-Polynomials.html#polySolve",
          "type": "function"
        },
        "index": {
          "description": "Solution of general polynomial equations using gsl poly complex solve For example the three solutions of polySolve The example in the GSL manual To find the roots of polySolve",
          "hierarchy": "Numeric GSL Polynomials",
          "module": "Numeric.GSL.Polynomials",
          "name": "polySolve",
          "normalized": "[Double]-\u003e[Complex Double]",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "[Double]-\u003e[Complex Double]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Polynomials.html#v:polySolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMultidimensional root finding.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.gnu.org/software/gsl/manual/html_node/Multidimensional-Root_002dFinding.html\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe example in the GSL manual:\n\u003c/p\u003e\u003cpre\u003eimport Numeric.GSL\nimport Numeric.LinearAlgebra(format)\nimport Text.Printf(printf)\n\nrosenbrock a b [x,y] = [ a*(1-x), b*(y-x^2) ]\n\ndisp = putStrLn . format \"  \" (printf \"%.3f\")\n\nmain = do\n    let (sol,path) = root Hybrids 1E-7 30 (rosenbrock 1 10) [-10,-5]\n    print sol\n    disp path\n\n\u003e main\n[1.0,1.0]\n 0.000  -10.000  -5.000  11.000  -1050.000\n 1.000   -3.976  24.827   4.976     90.203\n 2.000   -3.976  24.827   4.976     90.203\n 3.000   -3.976  24.827   4.976     90.203\n 4.000   -1.274  -5.680   2.274    -73.018\n 5.000   -1.274  -5.680   2.274    -73.018\n 6.000    0.249   0.298   0.751      2.359\n 7.000    0.249   0.298   0.751      2.359\n 8.000    1.000   0.878  -0.000     -1.218\n 9.000    1.000   0.989  -0.000     -0.108\n10.000    1.000   1.000   0.000      0.000\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Numeric.GSL.Root",
          "name": "Root",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Root.html",
          "type": "module"
        },
        "index": {
          "description": "Multidimensional root finding http www.gnu.org software gsl manual html node Multidimensional-Root dFinding.html The example in the GSL manual import Numeric.GSL import Numeric.LinearAlgebra format import Text.Printf printf rosenbrock y-x disp putStrLn format printf main do let sol path root Hybrids E-7 rosenbrock print sol disp path main",
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Root",
          "package": "hmatrix",
          "partial": "Root",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "RootMethod",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Root.html#RootMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "RootMethod",
          "package": "hmatrix",
          "partial": "Root Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#t:RootMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "RootMethodJ",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Root.html#RootMethodJ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "RootMethodJ",
          "package": "hmatrix",
          "partial": "Root Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#t:RootMethodJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "UniRootMethod",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Root.html#UniRootMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "UniRootMethod",
          "package": "hmatrix",
          "partial": "Uni Root Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#t:UniRootMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "UniRootMethodJ",
          "package": "hmatrix",
          "source": "src/Numeric-GSL-Root.html#UniRootMethodJ",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "UniRootMethodJ",
          "package": "hmatrix",
          "partial": "Uni Root Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#t:UniRootMethodJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Bisection",
          "package": "hmatrix",
          "signature": "Bisection",
          "source": "src/Numeric-GSL-Root.html#UniRootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Bisection",
          "package": "hmatrix",
          "partial": "Bisection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Bisection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Brent",
          "package": "hmatrix",
          "signature": "Brent",
          "source": "src/Numeric-GSL-Root.html#UniRootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Brent",
          "package": "hmatrix",
          "partial": "Brent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Brent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Broyden",
          "package": "hmatrix",
          "signature": "Broyden",
          "source": "src/Numeric-GSL-Root.html#RootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Broyden",
          "package": "hmatrix",
          "partial": "Broyden",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Broyden"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "DNewton",
          "package": "hmatrix",
          "signature": "DNewton",
          "source": "src/Numeric-GSL-Root.html#RootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "DNewton",
          "package": "hmatrix",
          "partial": "DNewton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:DNewton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "FalsePos",
          "package": "hmatrix",
          "signature": "FalsePos",
          "source": "src/Numeric-GSL-Root.html#UniRootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "FalsePos",
          "package": "hmatrix",
          "partial": "False Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:FalsePos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "GNewton",
          "package": "hmatrix",
          "signature": "GNewton",
          "source": "src/Numeric-GSL-Root.html#RootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "GNewton",
          "package": "hmatrix",
          "partial": "GNewton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:GNewton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Hybrid",
          "package": "hmatrix",
          "signature": "Hybrid",
          "source": "src/Numeric-GSL-Root.html#RootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Hybrid",
          "package": "hmatrix",
          "partial": "Hybrid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Hybrid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "HybridJ",
          "package": "hmatrix",
          "signature": "HybridJ",
          "source": "src/Numeric-GSL-Root.html#RootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "HybridJ",
          "package": "hmatrix",
          "partial": "Hybrid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:HybridJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Hybrids",
          "package": "hmatrix",
          "signature": "Hybrids",
          "source": "src/Numeric-GSL-Root.html#RootMethod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Hybrids",
          "package": "hmatrix",
          "partial": "Hybrids",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Hybrids"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "HybridsJ",
          "package": "hmatrix",
          "signature": "HybridsJ",
          "source": "src/Numeric-GSL-Root.html#RootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "HybridsJ",
          "package": "hmatrix",
          "partial": "Hybrids",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:HybridsJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Newton",
          "package": "hmatrix",
          "signature": "Newton",
          "source": "src/Numeric-GSL-Root.html#RootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Newton",
          "package": "hmatrix",
          "partial": "Newton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Newton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Secant",
          "package": "hmatrix",
          "signature": "Secant",
          "source": "src/Numeric-GSL-Root.html#UniRootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Secant",
          "package": "hmatrix",
          "partial": "Secant",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Secant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "Steffenson",
          "package": "hmatrix",
          "signature": "Steffenson",
          "source": "src/Numeric-GSL-Root.html#UniRootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "Steffenson",
          "package": "hmatrix",
          "partial": "Steffenson",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:Steffenson"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "UNewton",
          "package": "hmatrix",
          "signature": "UNewton",
          "source": "src/Numeric-GSL-Root.html#UniRootMethodJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "UNewton",
          "package": "hmatrix",
          "partial": "UNewton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:UNewton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNonlinear multidimensional root finding using algorithms that do not require \n any derivative information to be supplied by the user.\n Any derivatives needed are approximated by finite differences.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Root",
          "name": "root",
          "package": "hmatrix",
          "signature": "RootMethod-\u003e Double-\u003e Int-\u003e ([Double] -\u003e [Double])-\u003e [Double]-\u003e ([Double], Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Nonlinear multidimensional root finding using algorithms that do not require any derivative information to be supplied by the user Any derivatives needed are approximated by finite differences",
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "root",
          "normalized": "RootMethod-\u003eDouble-\u003eInt-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "signature": "RootMethod-\u003eDouble-\u003eInt-\u003e([Double]-\u003e[Double])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNonlinear multidimensional root finding using both the function and its derivatives.\n\u003c/p\u003e",
          "module": "Numeric.GSL.Root",
          "name": "rootJ",
          "package": "hmatrix",
          "signature": "RootMethodJ-\u003e Double-\u003e Int-\u003e ([Double] -\u003e [Double])-\u003e ([Double] -\u003e [[Double]])-\u003e [Double]-\u003e ([Double], Matrix Double)",
          "type": "function"
        },
        "index": {
          "description": "Nonlinear multidimensional root finding using both the function and its derivatives",
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "rootJ",
          "normalized": "RootMethodJ-\u003eDouble-\u003eInt-\u003e([Double]-\u003e[Double])-\u003e([Double]-\u003e[[Double]])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "package": "hmatrix",
          "signature": "RootMethodJ-\u003eDouble-\u003eInt-\u003e([Double]-\u003e[Double])-\u003e([Double]-\u003e[[Double]])-\u003e[Double]-\u003e([Double],Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:rootJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "uniRoot",
          "package": "hmatrix",
          "signature": "UniRootMethod -\u003e Double -\u003e Int -\u003e (Double -\u003e Double) -\u003e Double -\u003e Double -\u003e (Double, Matrix Double)",
          "source": "src/Numeric-GSL-Root.html#uniRoot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "uniRoot",
          "normalized": "UniRootMethod-\u003eDouble-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "Root",
          "signature": "UniRootMethod-\u003eDouble-\u003eInt-\u003e(Double-\u003eDouble)-\u003eDouble-\u003eDouble-\u003e(Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:uniRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.GSL.Root",
          "name": "uniRootJ",
          "package": "hmatrix",
          "signature": "UniRootMethodJ -\u003e Double -\u003e Int -\u003e (Double -\u003e Double) -\u003e (Double -\u003e Double) -\u003e Double -\u003e (Double, Matrix Double)",
          "source": "src/Numeric-GSL-Root.html#uniRootJ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric GSL Root",
          "module": "Numeric.GSL.Root",
          "name": "uniRootJ",
          "normalized": "UniRootMethodJ-\u003eDouble-\u003eInt-\u003e(Double-\u003eDouble)-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "Root",
          "signature": "UniRootMethodJ-\u003eDouble-\u003eInt-\u003e(Double-\u003eDouble)-\u003e(Double-\u003eDouble)-\u003eDouble-\u003e(Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL-Root.html#v:uniRootJ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module reexports all available GSL functions.\n\u003c/p\u003e\u003cp\u003eThe GSL special functions are in the separate package hmatrix-special.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.GSL",
          "name": "GSL",
          "package": "hmatrix",
          "source": "src/Numeric-GSL.html",
          "type": "module"
        },
        "index": {
          "description": "This module reexports all available GSL functions The GSL special functions are in the separate package hmatrix-special",
          "hierarchy": "Numeric GSL",
          "module": "Numeric.GSL",
          "name": "GSL",
          "package": "hmatrix",
          "partial": "GSL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis action removes the GSL default error handler (which aborts the program), so that\n GSL errors can be handled by Haskell (using Control.Exception) and ghci doesn't abort.\n\u003c/p\u003e",
          "module": "Numeric.GSL",
          "name": "setErrorHandlerOff",
          "package": "hmatrix",
          "signature": "IO ()",
          "source": "src/Numeric-GSL.html#setErrorHandlerOff",
          "type": "function"
        },
        "index": {
          "description": "This action removes the GSL default error handler which aborts the program so that GSL errors can be handled by Haskell using Control.Exception and ghci doesn abort",
          "hierarchy": "Numeric GSL",
          "module": "Numeric.GSL",
          "name": "setErrorHandlerOff",
          "normalized": "IO()",
          "package": "hmatrix",
          "partial": "Error Handler Off",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-GSL.html#v:setErrorHandlerOff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHigh level generic interface to common matrix computations.\n\u003c/p\u003e\u003cp\u003eSpecific functions for particular base types can also be explicitly\nimported from \u003ca\u003eNumeric.LinearAlgebra.LAPACK\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Algorithms",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html",
          "type": "module"
        },
        "index": {
          "description": "High level generic interface to common matrix computations Specific functions for particular base types can also be explicitly imported from Numeric.LinearAlgebra.LAPACK",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Algorithms",
          "package": "hmatrix",
          "partial": "Algorithms",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass used to define generic linear algebra computations for both real and complex matrices. Only double precision is supported in this version (we can\ntransform single precision objects using \u003ccode\u003e\u003ca\u003esingle\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edouble\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Field",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#Field",
          "type": "class"
        },
        "index": {
          "description": "Class used to define generic linear algebra computations for both real and complex matrices Only double precision is supported in this version we can transform single precision objects using single and double",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Field",
          "package": "hmatrix",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "NormType",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#NormType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "NormType",
          "package": "hmatrix",
          "partial": "Norm Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#t:NormType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Normed",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#Normed",
          "type": "class"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Normed",
          "package": "hmatrix",
          "partial": "Normed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#t:Normed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Frobenius",
          "package": "hmatrix",
          "signature": "Frobenius",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#NormType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Frobenius",
          "package": "hmatrix",
          "partial": "Frobenius",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:Frobenius"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Infinity",
          "package": "hmatrix",
          "signature": "Infinity",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#NormType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "Infinity",
          "package": "hmatrix",
          "partial": "Infinity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:Infinity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "PNorm1",
          "package": "hmatrix",
          "signature": "PNorm1",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#NormType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "PNorm1",
          "package": "hmatrix",
          "partial": "PNorm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:PNorm1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "PNorm2",
          "package": "hmatrix",
          "signature": "PNorm2",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#NormType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "PNorm2",
          "package": "hmatrix",
          "partial": "PNorm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:PNorm2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCholesky factorization of a positive definite hermitian or symmetric matrix.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003ec = chol m\u003c/code\u003e then \u003ccode\u003ec\u003c/code\u003e is upper triangular and \u003ccode\u003em == ctrans c \u003c\u003e c\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "chol",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#chol",
          "type": "function"
        },
        "index": {
          "description": "Cholesky factorization of positive definite hermitian or symmetric matrix If chol then is upper triangular and ctrans",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "chol",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:chol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003echol\u003c/a\u003e\u003c/code\u003e, without checking that the input matrix is hermitian or symmetric. It works with the upper triangular part.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "cholSH",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#cholSH",
          "type": "function"
        },
        "index": {
          "description": "Similar to chol without checking that the input matrix is hermitian or symmetric It works with the upper triangular part",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "cholSH",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "SH",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:cholSH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve a symmetric or Hermitian positive definite linear system using a precomputed Cholesky decomposition obtained by \u003ccode\u003e\u003ca\u003echol\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "cholSolve",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#cholSolve",
          "type": "function"
        },
        "index": {
          "description": "Solve symmetric or Hermitian positive definite linear system using precomputed Cholesky decomposition obtained by chol",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "cholSolve",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "Matrix t-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:cholSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003ethinSVD\u003c/a\u003e\u003c/code\u003e, returning only the nonzero singular values and the corresponding singular vectors.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "compactSVD",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Vector Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#compactSVD",
          "type": "function"
        },
        "index": {
          "description": "Similar to thinSVD returning only the nonzero singular values and the corresponding singular vectors",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "compactSVD",
          "normalized": "Matrix a-\u003e(Matrix a,Vector Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SVD",
          "signature": "Matrix t-\u003e(Matrix t,Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:compactSVD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeterminant of a square matrix. To avoid possible overflow or underflow use \u003ccode\u003e\u003ca\u003einvlndet\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "det",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#det",
          "type": "function"
        },
        "index": {
          "description": "Determinant of square matrix To avoid possible overflow or underflow use invlndet",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "det",
          "normalized": "Matrix a-\u003ea",
          "package": "hmatrix",
          "signature": "Matrix t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:det"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues and eigenvectors of a general square matrix.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(s,v) = eig m\u003c/code\u003e then \u003ccode\u003em \u003c\u003e v == v \u003c\u003e diag s\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eig",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Vector (Complex Double), Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eig",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues and eigenvectors of general square matrix If eig then diag",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eig",
          "normalized": "Matrix a-\u003e(Vector(Complex Double),Matrix(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Vector(Complex Double),Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues and Eigenvectors of a complex hermitian or real symmetric matrix.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(s,v) = eigSH m\u003c/code\u003e then \u003ccode\u003em == v \u003c\u003e diag s \u003c\u003e ctrans v\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigSH",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Vector Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eigSH",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues and Eigenvectors of complex hermitian or real symmetric matrix If eigSH then diag ctrans",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigSH",
          "normalized": "Matrix a-\u003e(Vector Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SH",
          "signature": "Matrix t-\u003e(Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eigSH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eeigSH\u003c/a\u003e\u003c/code\u003e without checking that the input matrix is hermitian or symmetric. It works with the upper triangular part.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigSH'",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Vector Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eigSH%27",
          "type": "function"
        },
        "index": {
          "description": "Similar to eigSH without checking that the input matrix is hermitian or symmetric It works with the upper triangular part",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigSH'",
          "normalized": "Matrix a-\u003e(Vector Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SH'",
          "signature": "Matrix t-\u003e(Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eigSH-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues of a general square matrix.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigenvalues",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eigenvalues",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues of general square matrix",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigenvalues",
          "normalized": "Matrix a-\u003eVector(Complex Double)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eVector(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eigenvalues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues of a complex hermitian or real symmetric matrix.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigenvaluesSH",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eigenvaluesSH",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues of complex hermitian or real symmetric matrix",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigenvaluesSH",
          "normalized": "Matrix a-\u003eVector Double",
          "package": "hmatrix",
          "partial": "SH",
          "signature": "Matrix t-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eigenvaluesSH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003eeigenvaluesSH\u003c/a\u003e\u003c/code\u003e without checking that the input matrix is hermitian or symmetric. It works with the upper triangular part.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigenvaluesSH'",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eigenvaluesSH%27",
          "type": "function"
        },
        "index": {
          "description": "Similar to eigenvaluesSH without checking that the input matrix is hermitian or symmetric It works with the upper triangular part",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eigenvaluesSH'",
          "normalized": "Matrix a-\u003eVector Double",
          "package": "hmatrix",
          "partial": "SH'",
          "signature": "Matrix t-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eigenvaluesSH-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe machine precision of a Double: \u003ccode\u003eeps = 2.22044604925031e-16\u003c/code\u003e (the value used by GNU-Octave).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eps",
          "package": "hmatrix",
          "signature": "Double",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#eps",
          "type": "function"
        },
        "index": {
          "description": "The machine precision of Double eps e-16 the value used by GNU-Octave",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "eps",
          "package": "hmatrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:eps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix exponential. It uses a direct translation of Algorithm 11.3.1 in Golub & Van Loan,\n     based on a scaled Pade approximation.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "expm",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#expm",
          "type": "function"
        },
        "index": {
          "description": "Matrix exponential It uses direct translation of Algorithm in Golub Van Loan based on scaled Pade approximation",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "expm",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:expm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003esvd\u003c/a\u003e\u003c/code\u003e which returns an appropriate diagonal matrix with the singular values.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(u,d,v) = fullSVD m\u003c/code\u003e then \u003ccode\u003em == u \u003c\u003e d \u003c\u003e trans v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "fullSVD",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Matrix Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#fullSVD",
          "type": "function"
        },
        "index": {
          "description": "version of svd which returns an appropriate diagonal matrix with the singular values If fullSVD then trans",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "fullSVD",
          "normalized": "Matrix a-\u003e(Matrix a,Matrix Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SVD",
          "signature": "Matrix t-\u003e(Matrix t,Matrix Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:fullSVD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralized symmetric positive definite eigensystem Av = lBv,\n for A and B symmetric, B positive definite (conditions not checked).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "geigSH'",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e Matrix t-\u003e (Vector Double, Matrix t)",
          "type": "function"
        },
        "index": {
          "description": "Generalized symmetric positive definite eigensystem Av lBv for and symmetric positive definite conditions not checked",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "geigSH'",
          "normalized": "Matrix a-\u003eMatrix a-\u003e(Vector Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SH'",
          "signature": "Matrix t-\u003eMatrix t-\u003e(Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:geigSH-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "haussholder",
          "package": "hmatrix",
          "signature": "a -\u003e Vector a -\u003e Matrix a",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#haussholder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "haussholder",
          "normalized": "a-\u003eVector a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "a-\u003eVector a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:haussholder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHessenberg factorization.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(p,h) = hess m\u003c/code\u003e then \u003ccode\u003em == p \u003c\u003e h \u003c\u003e ctrans p\u003c/code\u003e, where p is unitary\n and h is in upper Hessenberg form (it has zero entries below the first subdiagonal).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "hess",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#hess",
          "type": "function"
        },
        "index": {
          "description": "Hessenberg factorization If hess then ctrans where is unitary and is in upper Hessenberg form it has zero entries below the first subdiagonal",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "hess",
          "normalized": "Matrix a-\u003e(Matrix a,Matrix a)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:hess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe imaginary unit: \u003ccode\u003ei = 0.0 :+ 1.0\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "i",
          "package": "hmatrix",
          "signature": "Complex Double",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#i",
          "type": "function"
        },
        "index": {
          "description": "The imaginary unit",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "i",
          "package": "hmatrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:i"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of a square matrix. See also \u003ccode\u003e\u003ca\u003einvlndet\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "inv",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#inv",
          "type": "function"
        },
        "index": {
          "description": "Inverse of square matrix See also invlndet",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "inv",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:inv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoint computation of inverse and logarithm of determinant of a square matrix.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "invlndet",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e (Matrix t, (t, t))",
          "type": "function"
        },
        "index": {
          "description": "Joint computation of inverse and logarithm of determinant of square matrix",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "invlndet",
          "normalized": "Matrix a-\u003e(Matrix a,(a,a))",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,(t,t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:invlndet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values and all left singular vectors.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "leftSV",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Vector Double)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#leftSV",
          "type": "function"
        },
        "index": {
          "description": "Singular values and all left singular vectors",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "leftSV",
          "normalized": "Matrix a-\u003e(Matrix a,Vector Double)",
          "package": "hmatrix",
          "partial": "SV",
          "signature": "Matrix t-\u003e(Matrix t,Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:leftSV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve a linear system (for square coefficient matrix and several right-hand sides) using the LU decomposition. For underconstrained or overconstrained systems use \u003ccode\u003e\u003ca\u003elinearSolveLS\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003elinearSolveSVD\u003c/a\u003e\u003c/code\u003e.\n It is similar to \u003ccode\u003e\u003ca\u003eluSolve\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eluPacked\u003c/a\u003e\u003c/code\u003e, but \u003ccode\u003elinearSolve\u003c/code\u003e raises an error if called on a singular system.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "linearSolve",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#linearSolve",
          "type": "function"
        },
        "index": {
          "description": "Solve linear system for square coefficient matrix and several right-hand sides using the LU decomposition For underconstrained or overconstrained systems use linearSolveLS or linearSolveSVD It is similar to luSolve luPacked but linearSolve raises an error if called on singular system",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "linearSolve",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "Matrix t-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:linearSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast squared error solution of an overconstrained linear system, or the minimum norm solution of an underconstrained system. For rank-deficient systems use \u003ccode\u003e\u003ca\u003elinearSolveSVD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "linearSolveLS",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#linearSolveLS",
          "type": "function"
        },
        "index": {
          "description": "Least squared error solution of an overconstrained linear system or the minimum norm solution of an underconstrained system For rank-deficient systems use linearSolveSVD",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "linearSolveLS",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Solve LS",
          "signature": "Matrix t-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:linearSolveLS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimum norm solution of a general linear least squares problem Ax=B using the SVD. Admits rank-deficient systems but it is slower than \u003ccode\u003e\u003ca\u003elinearSolveLS\u003c/a\u003e\u003c/code\u003e. The effective rank of A is determined by treating as zero those singular valures which are less than \u003ccode\u003e\u003ca\u003eeps\u003c/a\u003e\u003c/code\u003e times the largest singular value.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "linearSolveSVD",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#linearSolveSVD",
          "type": "function"
        },
        "index": {
          "description": "Minimum norm solution of general linear least squares problem Ax using the SVD Admits rank-deficient systems but it is slower than linearSolveLS The effective rank of is determined by treating as zero those singular valures which are less than eps times the largest singular value",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "linearSolveSVD",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Solve SVD",
          "signature": "Matrix t-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:linearSolveSVD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExplicit LU factorization of a general matrix.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(l,u,p,s) = lu m\u003c/code\u003e then \u003ccode\u003em == p \u003c\u003e l \u003c\u003e u\u003c/code\u003e, where l is lower triangular,\n u is upper triangular, p is a permutation matrix and s is the signature of the permutation.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "lu",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Matrix t, Matrix t, t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#lu",
          "type": "function"
        },
        "index": {
          "description": "Explicit LU factorization of general matrix If lu then where is lower triangular is upper triangular is permutation matrix and is the signature of the permutation",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "lu",
          "normalized": "Matrix a-\u003e(Matrix a,Matrix a,Matrix a,a)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,Matrix t,Matrix t,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:lu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtains the LU decomposition of a matrix in a compact data structure suitable for \u003ccode\u003e\u003ca\u003eluSolve\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "luPacked",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, [Int])",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#luPacked",
          "type": "function"
        },
        "index": {
          "description": "Obtains the LU decomposition of matrix in compact data structure suitable for luSolve",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "luPacked",
          "normalized": "Matrix a-\u003e(Matrix a,[Int])",
          "package": "hmatrix",
          "partial": "Packed",
          "signature": "Matrix t-\u003e(Matrix t,[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:luPacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolution of a linear system (for several right hand sides) from the precomputed LU factorization obtained by \u003ccode\u003e\u003ca\u003eluPacked\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "luSolve",
          "package": "hmatrix",
          "signature": "(Matrix t, [Int]) -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#luSolve",
          "type": "function"
        },
        "index": {
          "description": "Solution of linear system for several right hand sides from the precomputed LU factorization obtained by luPacked",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "luSolve",
          "normalized": "(Matrix a,[Int])-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "(Matrix t,[Int])-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:luSolve"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric matrix functions for diagonalizable matrices. For instance:\n\u003c/p\u003e\u003cpre\u003elogm = matFunc log\u003c/pre\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "matFunc",
          "package": "hmatrix",
          "signature": "(Complex Double -\u003e Complex Double) -\u003e Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#matFunc",
          "type": "function"
        },
        "index": {
          "description": "Generic matrix functions for diagonalizable matrices For instance logm matFunc log",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "matFunc",
          "normalized": "(Complex Double-\u003eComplex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "partial": "Func",
          "signature": "(Complex Double-\u003eComplex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:matFunc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003echolSH\u003c/a\u003e\u003c/code\u003e, but instead of an error (e.g., caused by a matrix not positive definite) it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "mbCholSH",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Maybe (Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#mbCholSH",
          "type": "function"
        },
        "index": {
          "description": "Similar to cholSH but instead of an error e.g caused by matrix not positive definite it returns Nothing",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "mbCholSH",
          "normalized": "Matrix a-\u003eMaybe(Matrix a)",
          "package": "hmatrix",
          "partial": "Chol SH",
          "signature": "Matrix t-\u003eMaybe(Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:mbCholSH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe nullspace of a matrix, assumed to be one-dimensional, with machine precision.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "nullVector",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#nullVector",
          "type": "function"
        },
        "index": {
          "description": "The nullspace of matrix assumed to be one-dimensional with machine precision",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "nullVector",
          "normalized": "Matrix a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Vector",
          "signature": "Matrix t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:nullVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe nullspace of a matrix. See also \u003ccode\u003e\u003ca\u003enullspaceSVD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "nullspacePrec",
          "package": "hmatrix",
          "signature": "Double-\u003e Matrix t-\u003e [Vector t]",
          "type": "function"
        },
        "index": {
          "description": "The nullspace of matrix See also nullspaceSVD",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "nullspacePrec",
          "normalized": "Double-\u003eMatrix a-\u003e[Vector a]",
          "package": "hmatrix",
          "partial": "Prec",
          "signature": "Double-\u003eMatrix t-\u003e[Vector t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:nullspacePrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe nullspace of a matrix from its SVD decomposition.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "nullspaceSVD",
          "package": "hmatrix",
          "signature": "Either Double Int-\u003e Matrix t-\u003e (Vector Double, Matrix t)-\u003e [Vector t]",
          "type": "function"
        },
        "index": {
          "description": "The nullspace of matrix from its SVD decomposition",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "nullspaceSVD",
          "normalized": "Either Double Int-\u003eMatrix a-\u003e(Vector Double,Matrix a)-\u003e[Vector a]",
          "package": "hmatrix",
          "partial": "SVD",
          "signature": "Either Double Int-\u003eMatrix t-\u003e(Vector Double,Matrix t)-\u003e[Vector t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:nullspaceSVD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an orthonormal basis of the range space of a matrix\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "orth",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e [Vector t]",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#orth",
          "type": "function"
        },
        "index": {
          "description": "Return an orthonormal basis of the range space of matrix",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "orth",
          "normalized": "Matrix a-\u003e[Vector a]",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e[Vector t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:orth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e1 + 0.5*peps == 1,  1 + 0.6*peps /= 1\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "peps",
          "package": "hmatrix",
          "signature": "x",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#peps",
          "type": "function"
        },
        "index": {
          "description": "peps peps",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "peps",
          "package": "hmatrix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:peps"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePseudoinverse of a general matrix with default tolerance (\u003ccode\u003e\u003ca\u003epinvTol\u003c/a\u003e\u003c/code\u003e 1, similar to GNU-Octave).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "pinv",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#pinv",
          "type": "function"
        },
        "index": {
          "description": "Pseudoinverse of general matrix with default tolerance pinvTol similar to GNU-Octave",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "pinv",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:pinv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003epinvTol r\u003c/code\u003e computes the pseudoinverse of a matrix with tolerance \u003ccode\u003etol=r*g*eps*(max rows cols)\u003c/code\u003e, where g is the greatest singular value.\n\u003c/p\u003e\u003cpre\u003e\u003e let m = \u003ccode\u003e\u003ca\u003efromLists\u003c/a\u003e\u003c/code\u003e [[1,0,    0]\n                    ,[0,1,    0]\n                    ,[0,0,1e-10]]\n  --\n\u003e \u003ccode\u003e\u003ca\u003epinv\u003c/a\u003e\u003c/code\u003e m\n1. 0.           0.\n0. 1.           0.\n0. 0. 10000000000.\n  --\n\u003e pinvTol 1E8 m\n1. 0. 0.\n0. 1. 0.\n0. 0. 1.\u003c/pre\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "pinvTol",
          "package": "hmatrix",
          "signature": "Double -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#pinvTol",
          "type": "function"
        },
        "index": {
          "description": "pinvTol computes the pseudoinverse of matrix with tolerance tol eps max rows cols where is the greatest singular value let fromLists e-10 pinv pinvTol E8",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "pinvTol",
          "normalized": "Double-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "partial": "Tol",
          "signature": "Double-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:pinvTol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "pnorm",
          "package": "hmatrix",
          "signature": "NormType -\u003e c t -\u003e RealOf t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#pnorm",
          "type": "method"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "pnorm",
          "normalized": "NormType-\u003ea b-\u003eRealOf b",
          "package": "hmatrix",
          "signature": "NormType-\u003ec t-\u003eRealOf t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:pnorm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQR factorization.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(q,r) = qr m\u003c/code\u003e then \u003ccode\u003em == q \u003c\u003e r\u003c/code\u003e, where q is unitary and r is upper triangular.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "qr",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#qr",
          "type": "function"
        },
        "index": {
          "description": "QR factorization If qr then where is unitary and is upper triangular",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "qr",
          "normalized": "Matrix a-\u003e(Matrix a,Matrix a)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:qr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumber of linearly independent rows or columns.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rank",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Int",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#rank",
          "type": "function"
        },
        "index": {
          "description": "Number of linearly independent rows or columns",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rank",
          "normalized": "Matrix a-\u003eInt",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:rank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNumeric rank of a matrix from its singular values.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "ranksv",
          "package": "hmatrix",
          "signature": "Double-\u003e Int-\u003e [Double]-\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "Numeric rank of matrix from its singular values",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "ranksv",
          "normalized": "Double-\u003eInt-\u003e[Double]-\u003eInt",
          "package": "hmatrix",
          "signature": "Double-\u003eInt-\u003e[Double]-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:ranksv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReciprocal of the 2-norm condition number of a matrix, computed from the singular values.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rcond",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Double",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#rcond",
          "type": "function"
        },
        "index": {
          "description": "Reciprocal of the norm condition number of matrix computed from the singular values",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rcond",
          "normalized": "Matrix a-\u003eDouble",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:rcond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApproximate number of common digits in the maximum element.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "relativeError",
          "package": "hmatrix",
          "signature": "c t -\u003e c t -\u003e Int",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#relativeError",
          "type": "function"
        },
        "index": {
          "description": "Approximate number of common digits in the maximum element",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "relativeError",
          "normalized": "a b-\u003ea b-\u003eInt",
          "package": "hmatrix",
          "partial": "Error",
          "signature": "c t-\u003ec t-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:relativeError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values and all right singular vectors.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rightSV",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Vector Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#rightSV",
          "type": "function"
        },
        "index": {
          "description": "Singular values and all right singular vectors",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rightSV",
          "normalized": "Matrix a-\u003e(Vector Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SV",
          "signature": "Matrix t-\u003e(Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:rightSV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRQ factorization.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(r,q) = rq m\u003c/code\u003e then \u003ccode\u003em == r \u003c\u003e q\u003c/code\u003e, where q is unitary and r is upper triangular.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rq",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#rq",
          "type": "function"
        },
        "index": {
          "description": "RQ factorization If rq then where is unitary and is upper triangular",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "rq",
          "normalized": "Matrix a-\u003e(Matrix a,Matrix a)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:rq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSchur factorization.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(u,s) = schur m\u003c/code\u003e then \u003ccode\u003em == u \u003c\u003e s \u003c\u003e ctrans u\u003c/code\u003e, where u is unitary\n and s is a Shur matrix. A complex Schur matrix is upper triangular. A real Schur matrix is\n upper triangular in 2x2 blocks.\n\u003c/p\u003e\u003cp\u003e\"Anything that the Jordan decomposition can do, the Schur decomposition\n can do better!\" (Van Loan)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "schur",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#schur",
          "type": "function"
        },
        "index": {
          "description": "Schur factorization If schur then ctrans where is unitary and is Shur matrix complex Schur matrix is upper triangular real Schur matrix is upper triangular in x2 blocks Anything that the Jordan decomposition can do the Schur decomposition can do better Van Loan",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "schur",
          "normalized": "Matrix a-\u003e(Matrix a,Matrix a)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:schur"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values only.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "singularValues",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#singularValues",
          "type": "function"
        },
        "index": {
          "description": "Singular values only",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "singularValues",
          "normalized": "Matrix a-\u003eVector Double",
          "package": "hmatrix",
          "partial": "Values",
          "signature": "Matrix t-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:singularValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix square root. Currently it uses a simple iterative algorithm described in Wikipedia.\nIt only works with invertible matrices that have a real solution. For diagonalizable matrices you can try \u003ccode\u003ematFunc sqrt\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003em = (2\u003e\u003c2) [4,9\n           ,0,4] :: Matrix Double\u003c/pre\u003e\u003cpre\u003e\u003esqrtm m\n(2\u003e\u003c2)\n [ 2.0, 2.25\n , 0.0,  2.0 ]\u003c/pre\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "sqrtm",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#sqrtm",
          "type": "function"
        },
        "index": {
          "description": "Matrix square root Currently it uses simple iterative algorithm described in Wikipedia It only works with invertible matrices that have real solution For diagonalizable matrices you can try matFunc sqrt Matrix Double sqrtm",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "sqrtm",
          "normalized": "Matrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:sqrtm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFull singular value decomposition.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "svd",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Vector Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#svd",
          "type": "function"
        },
        "index": {
          "description": "Full singular value decomposition",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "svd",
          "normalized": "Matrix a-\u003e(Matrix a,Vector Double,Matrix a)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Matrix t,Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:svd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003esvd\u003c/a\u003e\u003c/code\u003e which returns only the \u003ccode\u003emin (rows m) (cols m)\u003c/code\u003e singular vectors of \u003ccode\u003em\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e(u,s,v) = thinSVD m\u003c/code\u003e then \u003ccode\u003em == u \u003c\u003e diag s \u003c\u003e trans v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "thinSVD",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Matrix t, Vector Double, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#thinSVD",
          "type": "function"
        },
        "index": {
          "description": "version of svd which returns only the min rows cols singular vectors of If thinSVD then diag trans",
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "thinSVD",
          "normalized": "Matrix a-\u003e(Matrix a,Vector Double,Matrix a)",
          "package": "hmatrix",
          "partial": "SVD",
          "signature": "Matrix t-\u003e(Matrix t,Vector Double,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:thinSVD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "unpackHess",
          "package": "hmatrix",
          "signature": "(Matrix t -\u003e (Matrix t, Vector t)) -\u003e Matrix t -\u003e (Matrix t, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#unpackHess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "unpackHess",
          "normalized": "(Matrix a-\u003e(Matrix a,Vector a))-\u003eMatrix a-\u003e(Matrix a,Matrix a)",
          "package": "hmatrix",
          "partial": "Hess",
          "signature": "(Matrix t-\u003e(Matrix t,Vector t))-\u003eMatrix t-\u003e(Matrix t,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:unpackHess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "unpackQR",
          "package": "hmatrix",
          "signature": "(Matrix t, Vector t) -\u003e (Matrix t, Matrix t)",
          "source": "src/Numeric-LinearAlgebra-Algorithms.html#unpackQR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Algorithms",
          "module": "Numeric.LinearAlgebra.Algorithms",
          "name": "unpackQR",
          "normalized": "(Matrix a,Vector a)-\u003e(Matrix a,Matrix a)",
          "package": "hmatrix",
          "partial": "QR",
          "signature": "(Matrix t,Vector t)-\u003e(Matrix t,Matrix t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Algorithms.html#v:unpackQR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctional interface to selected LAPACK functions (\u003ca\u003ehttp://www.netlib.org/lapack\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "LAPACK",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html",
          "type": "module"
        },
        "index": {
          "description": "Functional interface to selected LAPACK functions http www.netlib.org lapack",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "LAPACK",
          "package": "hmatrix",
          "partial": "LAPACK",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCholesky factorization of a complex Hermitian positive definite matrix, using LAPACK's \u003cem\u003ezpotrf\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholH",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#cholH",
          "type": "function"
        },
        "index": {
          "description": "Cholesky factorization of complex Hermitian positive definite matrix using LAPACK zpotrf",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholH",
          "normalized": "Matrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:cholH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCholesky factorization of a real symmetric positive definite matrix, using LAPACK's \u003cem\u003edpotrf\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholS",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#cholS",
          "type": "function"
        },
        "index": {
          "description": "Cholesky factorization of real symmetric positive definite matrix using LAPACK dpotrf",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholS",
          "normalized": "Matrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:cholS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves a Hermitian positive definite system of linear equations using a precomputed Cholesky factorization obtained by \u003ccode\u003e\u003ca\u003echolH\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholSolveC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#cholSolveC",
          "type": "function"
        },
        "index": {
          "description": "Solves Hermitian positive definite system of linear equations using precomputed Cholesky factorization obtained by cholH",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholSolveC",
          "normalized": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:cholSolveC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolves a symmetric positive definite system of linear equations using a precomputed Cholesky factorization obtained by \u003ccode\u003e\u003ca\u003echolS\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholSolveR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#cholSolveR",
          "type": "function"
        },
        "index": {
          "description": "Solves symmetric positive definite system of linear equations using precomputed Cholesky factorization obtained by cholS",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "cholSolveR",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:cholSolveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues and right eigenvectors of a general complex matrix, using LAPACK's \u003cem\u003ezgeev\u003c/em\u003e.\n The eigenvectors are the columns of v. The eigenvalues are not sorted.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Vector (Complex Double), Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigC",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues and right eigenvectors of general complex matrix using LAPACK zgeev The eigenvectors are the columns of The eigenvalues are not sorted",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigC",
          "normalized": "Matrix(Complex Double)-\u003e(Vector(Complex Double),Matrix(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Vector(Complex Double),Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues and right eigenvectors of a hermitian complex matrix, using LAPACK's \u003cem\u003ezheev\u003c/em\u003e.\n The eigenvectors are the columns of v.\n The eigenvalues are sorted in descending order (use \u003ccode\u003e\u003ca\u003eeigH'\u003c/a\u003e\u003c/code\u003e for ascending order).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigH",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigH",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues and right eigenvectors of hermitian complex matrix using LAPACK zheev The eigenvectors are the columns of The eigenvalues are sorted in descending order use eigH for ascending order",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigH",
          "normalized": "Matrix(Complex Double)-\u003e(Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eeigH\u003c/a\u003e\u003c/code\u003e in ascending order\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigH'",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigH%27",
          "type": "function"
        },
        "index": {
          "description": "eigH in ascending order",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigH'",
          "normalized": "Matrix(Complex Double)-\u003e(Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "partial": "H'",
          "signature": "Matrix(Complex Double)-\u003e(Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigH-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues of a general complex matrix, using LAPACK's \u003cem\u003ezgeev\u003c/em\u003e with jobz == 'N'.\n The eigenvalues are not sorted.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Vector (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigOnlyC",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues of general complex matrix using LAPACK zgeev with jobz The eigenvalues are not sorted",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyC",
          "normalized": "Matrix(Complex Double)-\u003eVector(Complex Double)",
          "package": "hmatrix",
          "partial": "Only",
          "signature": "Matrix(Complex Double)-\u003eVector(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigOnlyC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues of a hermitian complex matrix, using LAPACK's \u003cem\u003ezheev\u003c/em\u003e with jobz == 'N'.\n The eigenvalues are sorted in descending order.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyH",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigOnlyH",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues of hermitian complex matrix using LAPACK zheev with jobz The eigenvalues are sorted in descending order",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyH",
          "normalized": "Matrix(Complex Double)-\u003eVector Double",
          "package": "hmatrix",
          "partial": "Only",
          "signature": "Matrix(Complex Double)-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigOnlyH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues of a general real matrix, using LAPACK's \u003cem\u003edgeev\u003c/em\u003e with jobz == 'N'.\n The eigenvalues are not sorted.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Vector (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigOnlyR",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues of general real matrix using LAPACK dgeev with jobz The eigenvalues are not sorted",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyR",
          "normalized": "Matrix Double-\u003eVector(Complex Double)",
          "package": "hmatrix",
          "partial": "Only",
          "signature": "Matrix Double-\u003eVector(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigOnlyR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues of a symmetric real matrix, using LAPACK's \u003cem\u003edsyev\u003c/em\u003e with jobz == 'N'.\n The eigenvalues are sorted in descending order.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyS",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigOnlyS",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues of symmetric real matrix using LAPACK dsyev with jobz The eigenvalues are sorted in descending order",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigOnlyS",
          "normalized": "Matrix Double-\u003eVector Double",
          "package": "hmatrix",
          "partial": "Only",
          "signature": "Matrix Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigOnlyS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues and right eigenvectors of a general real matrix, using LAPACK's \u003cem\u003edgeev\u003c/em\u003e.\n The eigenvectors are the columns of v. The eigenvalues are not sorted.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Vector (Complex Double), Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigR",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues and right eigenvectors of general real matrix using LAPACK dgeev The eigenvectors are the columns of The eigenvalues are not sorted",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigR",
          "normalized": "Matrix Double-\u003e(Vector(Complex Double),Matrix(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Vector(Complex Double),Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEigenvalues and right eigenvectors of a symmetric real matrix, using LAPACK's \u003cem\u003edsyev\u003c/em\u003e.\n The eigenvectors are the columns of v.\n The eigenvalues are sorted in descending order (use \u003ccode\u003e\u003ca\u003eeigS'\u003c/a\u003e\u003c/code\u003e for ascending order).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigS",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigS",
          "type": "function"
        },
        "index": {
          "description": "Eigenvalues and right eigenvectors of symmetric real matrix using LAPACK dsyev The eigenvectors are the columns of The eigenvalues are sorted in descending order use eigS for ascending order",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigS",
          "normalized": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eeigS\u003c/a\u003e\u003c/code\u003e in ascending order\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigS'",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#eigS%27",
          "type": "function"
        },
        "index": {
          "description": "eigS in ascending order",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "eigS'",
          "normalized": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "S'",
          "signature": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:eigS-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHessenberg factorization of a square complex matrix, using LAPACK's \u003cem\u003ezgehrd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "hessC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#hessC",
          "type": "function"
        },
        "index": {
          "description": "Hessenberg factorization of square complex matrix using LAPACK zgehrd",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "hessC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:hessC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHessenberg factorization of a square real matrix, using LAPACK's \u003cem\u003edgehrd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "hessR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#hessR",
          "type": "function"
        },
        "index": {
          "description": "Hessenberg factorization of square real matrix using LAPACK dgehrd",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "hessR",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double)",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:hessR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values and all left singular vectors of a complex matrix, using LAPACK's \u003cem\u003ezgesvd\u003c/em\u003e with jobu == 'A' and jobvt == 'N'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "leftSVC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#leftSVC",
          "type": "function"
        },
        "index": {
          "description": "Singular values and all left singular vectors of complex matrix using LAPACK zgesvd with jobu and jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "leftSVC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double)",
          "package": "hmatrix",
          "partial": "SVC",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:leftSVC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values and all left singular vectors of a real matrix, using LAPACK's \u003cem\u003edgesvd\u003c/em\u003e  with jobu == 'A' and jobvt == 'N'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "leftSVR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#leftSVR",
          "type": "function"
        },
        "index": {
          "description": "Singular values and all left singular vectors of real matrix using LAPACK dgesvd with jobu and jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "leftSVR",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double)",
          "package": "hmatrix",
          "partial": "SVR",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:leftSVR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve a complex linear system (for square coefficient matrix and several right-hand sides) using the LU decomposition, based on LAPACK's \u003cem\u003ezgesv\u003c/em\u003e. For underconstrained or overconstrained systems use \u003ccode\u003e\u003ca\u003elinearSolveLSC\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003elinearSolveSVDC\u003c/a\u003e\u003c/code\u003e. See also \u003ccode\u003e\u003ca\u003elusC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#linearSolveC",
          "type": "function"
        },
        "index": {
          "description": "Solve complex linear system for square coefficient matrix and several right-hand sides using the LU decomposition based on LAPACK zgesv For underconstrained or overconstrained systems use linearSolveLSC or linearSolveSVDC See also lusC",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveC",
          "normalized": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:linearSolveC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast squared error solution of an overconstrained complex linear system, or the minimum norm solution of an underconstrained system, using LAPACK's \u003cem\u003ezgels\u003c/em\u003e. For rank-deficient systems use \u003ccode\u003e\u003ca\u003elinearSolveSVDC\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveLSC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#linearSolveLSC",
          "type": "function"
        },
        "index": {
          "description": "Least squared error solution of an overconstrained complex linear system or the minimum norm solution of an underconstrained system using LAPACK zgels For rank-deficient systems use linearSolveSVDC",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveLSC",
          "normalized": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "partial": "Solve LSC",
          "signature": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:linearSolveLSC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast squared error solution of an overconstrained real linear system, or the minimum norm solution of an underconstrained system, using LAPACK's \u003cem\u003edgels\u003c/em\u003e. For rank-deficient systems use \u003ccode\u003e\u003ca\u003elinearSolveSVDR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveLSR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#linearSolveLSR",
          "type": "function"
        },
        "index": {
          "description": "Least squared error solution of an overconstrained real linear system or the minimum norm solution of an underconstrained system using LAPACK dgels For rank-deficient systems use linearSolveSVDR",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveLSR",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Solve LSR",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:linearSolveLSR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve a real linear system (for square coefficient matrix and several right-hand sides) using the LU decomposition, based on LAPACK's \u003cem\u003edgesv\u003c/em\u003e. For underconstrained or overconstrained systems use \u003ccode\u003e\u003ca\u003elinearSolveLSR\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003elinearSolveSVDR\u003c/a\u003e\u003c/code\u003e. See also \u003ccode\u003e\u003ca\u003elusR\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#linearSolveR",
          "type": "function"
        },
        "index": {
          "description": "Solve real linear system for square coefficient matrix and several right-hand sides using the LU decomposition based on LAPACK dgesv For underconstrained or overconstrained systems use linearSolveLSR or linearSolveSVDR See also lusR",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveR",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Solve",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:linearSolveR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimum norm solution of a general complex linear least squares problem Ax=B using the SVD, based on LAPACK's \u003cem\u003ezgelss\u003c/em\u003e. Admits rank-deficient systems but it is slower than \u003ccode\u003e\u003ca\u003elinearSolveLSC\u003c/a\u003e\u003c/code\u003e. The effective rank of A is determined by treating as zero those singular valures which are less than rcond times the largest singular value. If rcond == Nothing machine precision is used.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveSVDC",
          "package": "hmatrix",
          "signature": "Maybe Double-\u003e Matrix (Complex Double)-\u003e Matrix (Complex Double)-\u003e Matrix (Complex Double)",
          "type": "function"
        },
        "index": {
          "description": "Minimum norm solution of general complex linear least squares problem Ax using the SVD based on LAPACK zgelss Admits rank-deficient systems but it is slower than linearSolveLSC The effective rank of is determined by treating as zero those singular valures which are less than rcond times the largest singular value If rcond Nothing machine precision is used",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveSVDC",
          "normalized": "Maybe Double-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "partial": "Solve SVDC",
          "signature": "Maybe Double-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:linearSolveSVDC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimum norm solution of a general real linear least squares problem Ax=B using the SVD, based on LAPACK's \u003cem\u003edgelss\u003c/em\u003e. Admits rank-deficient systems but it is slower than \u003ccode\u003e\u003ca\u003elinearSolveLSR\u003c/a\u003e\u003c/code\u003e. The effective rank of A is determined by treating as zero those singular valures which are less than rcond times the largest singular value. If rcond == Nothing machine precision is used.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveSVDR",
          "package": "hmatrix",
          "signature": "Maybe Double-\u003e Matrix Double-\u003e Matrix Double-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "Minimum norm solution of general real linear least squares problem Ax using the SVD based on LAPACK dgelss Admits rank-deficient systems but it is slower than linearSolveLSR The effective rank of is determined by treating as zero those singular valures which are less than rcond times the largest singular value If rcond Nothing machine precision is used",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "linearSolveSVDR",
          "normalized": "Maybe Double-\u003eMatrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Solve SVDR",
          "signature": "Maybe Double-\u003eMatrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:linearSolveSVDR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLU factorization of a general complex matrix, using LAPACK's \u003cem\u003ezgetrf\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "luC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), [Int])",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#luC",
          "type": "function"
        },
        "index": {
          "description": "LU factorization of general complex matrix using LAPACK zgetrf",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "luC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),[Int])",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:luC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLU factorization of a general real matrix, using LAPACK's \u003cem\u003edgetrf\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "luR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, [Int])",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#luR",
          "type": "function"
        },
        "index": {
          "description": "LU factorization of general real matrix using LAPACK dgetrf",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "luR",
          "normalized": "Matrix Double-\u003e(Matrix Double,[Int])",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Matrix Double,[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:luR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve a real linear system from a precomputed LU decomposition (\u003ccode\u003e\u003ca\u003eluC\u003c/a\u003e\u003c/code\u003e), using LAPACK's \u003cem\u003ezgetrs\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "lusC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e [Int] -\u003e Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#lusC",
          "type": "function"
        },
        "index": {
          "description": "Solve real linear system from precomputed LU decomposition luC using LAPACK zgetrs",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "lusC",
          "normalized": "Matrix(Complex Double)-\u003e[Int]-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e[Int]-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:lusC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSolve a real linear system from a precomputed LU decomposition (\u003ccode\u003e\u003ca\u003eluR\u003c/a\u003e\u003c/code\u003e), using LAPACK's \u003cem\u003edgetrs\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "lusR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e [Int] -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#lusR",
          "type": "function"
        },
        "index": {
          "description": "Solve real linear system from precomputed LU decomposition luR using LAPACK dgetrs",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "lusR",
          "normalized": "Matrix Double-\u003e[Int]-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e[Int]-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:lusR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCholesky factorization of a complex Hermitian positive definite matrix, using LAPACK's \u003cem\u003ezpotrf\u003c/em\u003e (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e version).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "mbCholH",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Maybe (Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#mbCholH",
          "type": "function"
        },
        "index": {
          "description": "Cholesky factorization of complex Hermitian positive definite matrix using LAPACK zpotrf Maybe version",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "mbCholH",
          "normalized": "Matrix(Complex Double)-\u003eMaybe(Matrix(Complex Double))",
          "package": "hmatrix",
          "partial": "Chol",
          "signature": "Matrix(Complex Double)-\u003eMaybe(Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:mbCholH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCholesky factorization of a real symmetric positive definite matrix, using LAPACK's \u003cem\u003edpotrf\u003c/em\u003e  (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e version).\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "mbCholS",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Maybe (Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#mbCholS",
          "type": "function"
        },
        "index": {
          "description": "Cholesky factorization of real symmetric positive definite matrix using LAPACK dpotrf Maybe version",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "mbCholS",
          "normalized": "Matrix Double-\u003eMaybe(Matrix Double)",
          "package": "hmatrix",
          "partial": "Chol",
          "signature": "Matrix Double-\u003eMaybe(Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:mbCholS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix product based on BLAS's \u003cem\u003ezgemm\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Matrix (Complex Double) -\u003e Matrix (Complex Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#multiplyC",
          "type": "function"
        },
        "index": {
          "description": "Matrix product based on BLAS zgemm",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyC",
          "normalized": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003eMatrix(Complex Double)-\u003eMatrix(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:multiplyC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix product based on BLAS's \u003cem\u003esgemm\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyF",
          "package": "hmatrix",
          "signature": "Matrix Float -\u003e Matrix Float -\u003e Matrix Float",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#multiplyF",
          "type": "function"
        },
        "index": {
          "description": "Matrix product based on BLAS sgemm",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyF",
          "normalized": "Matrix Float-\u003eMatrix Float-\u003eMatrix Float",
          "package": "hmatrix",
          "signature": "Matrix Float-\u003eMatrix Float-\u003eMatrix Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:multiplyF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix product based on BLAS's \u003cem\u003ecgemm\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyQ",
          "package": "hmatrix",
          "signature": "Matrix (Complex Float) -\u003e Matrix (Complex Float) -\u003e Matrix (Complex Float)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#multiplyQ",
          "type": "function"
        },
        "index": {
          "description": "Matrix product based on BLAS cgemm",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyQ",
          "normalized": "Matrix(Complex Float)-\u003eMatrix(Complex Float)-\u003eMatrix(Complex Float)",
          "package": "hmatrix",
          "signature": "Matrix(Complex Float)-\u003eMatrix(Complex Float)-\u003eMatrix(Complex Float)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:multiplyQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix product based on BLAS's \u003cem\u003edgemm\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#multiplyR",
          "type": "function"
        },
        "index": {
          "description": "Matrix product based on BLAS dgemm",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "multiplyR",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:multiplyR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQR factorization of a complex matrix, using LAPACK's \u003cem\u003ezgeqr2\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "qrC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#qrC",
          "type": "function"
        },
        "index": {
          "description": "QR factorization of complex matrix using LAPACK zgeqr2",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "qrC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:qrC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQR factorization of a real matrix, using LAPACK's \u003cem\u003edgeqr2\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "qrR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#qrR",
          "type": "function"
        },
        "index": {
          "description": "QR factorization of real matrix using LAPACK dgeqr2",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "qrR",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double)",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:qrR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values and all right singular vectors of a complex matrix, using LAPACK's \u003cem\u003ezgesvd\u003c/em\u003e with jobu == 'N' and jobvt == 'A'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "rightSVC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#rightSVC",
          "type": "function"
        },
        "index": {
          "description": "Singular values and all right singular vectors of complex matrix using LAPACK zgesvd with jobu and jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "rightSVC",
          "normalized": "Matrix(Complex Double)-\u003e(Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "partial": "SVC",
          "signature": "Matrix(Complex Double)-\u003e(Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:rightSVC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values and all right singular vectors of a real matrix, using LAPACK's \u003cem\u003edgesvd\u003c/em\u003e with jobu == 'N' and jobvt == 'A'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "rightSVR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#rightSVR",
          "type": "function"
        },
        "index": {
          "description": "Singular values and all right singular vectors of real matrix using LAPACK dgesvd with jobu and jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "rightSVR",
          "normalized": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "SVR",
          "signature": "Matrix Double-\u003e(Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:rightSVR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSchur factorization of a square complex matrix, using LAPACK's \u003cem\u003ezgees\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "schurC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#schurC",
          "type": "function"
        },
        "index": {
          "description": "Schur factorization of square complex matrix using LAPACK zgees",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "schurC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Matrix(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:schurC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSchur factorization of a square real matrix, using LAPACK's \u003cem\u003edgees\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "schurR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#schurR",
          "type": "function"
        },
        "index": {
          "description": "Schur factorization of square real matrix using LAPACK dgees",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "schurR",
          "normalized": "Matrix Double-\u003e(Matrix Double,Matrix Double)",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Matrix Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:schurR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values of a complex matrix, using LAPACK's \u003cem\u003ezgesvd\u003c/em\u003e with jobu == jobvt == 'N'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svC",
          "type": "function"
        },
        "index": {
          "description": "Singular values of complex matrix using LAPACK zgesvd with jobu jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svC",
          "normalized": "Matrix(Complex Double)-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values of a complex matrix, using LAPACK's \u003cem\u003ezgesdd\u003c/em\u003e with jobz == 'N'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svCd",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svCd",
          "type": "function"
        },
        "index": {
          "description": "Singular values of complex matrix using LAPACK zgesdd with jobz",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svCd",
          "normalized": "Matrix(Complex Double)-\u003eVector Double",
          "package": "hmatrix",
          "partial": "Cd",
          "signature": "Matrix(Complex Double)-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svCd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values of a real matrix, using LAPACK's \u003cem\u003edgesvd\u003c/em\u003e with jobu == jobvt == 'N'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svR",
          "type": "function"
        },
        "index": {
          "description": "Singular values of real matrix using LAPACK dgesvd with jobu jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svR",
          "normalized": "Matrix Double-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSingular values of a real matrix, using LAPACK's \u003cem\u003edgesdd\u003c/em\u003e with jobz == 'N'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svRd",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svRd",
          "type": "function"
        },
        "index": {
          "description": "Singular values of real matrix using LAPACK dgesdd with jobz",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svRd",
          "normalized": "Matrix Double-\u003eVector Double",
          "package": "hmatrix",
          "partial": "Rd",
          "signature": "Matrix Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svRd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFull SVD of a complex matrix using LAPACK's \u003cem\u003ezgesvd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svdC",
          "type": "function"
        },
        "index": {
          "description": "Full SVD of complex matrix using LAPACK zgesvd",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svdC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFull SVD of a complex matrix using LAPACK's \u003cem\u003ezgesdd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdCd",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svdCd",
          "type": "function"
        },
        "index": {
          "description": "Full SVD of complex matrix using LAPACK zgesdd",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdCd",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "partial": "Cd",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svdCd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFull SVD of a real matrix using LAPACK's \u003cem\u003edgesvd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svdR",
          "type": "function"
        },
        "index": {
          "description": "Full SVD of real matrix using LAPACK dgesvd",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdR",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svdR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFull SVD of a real matrix using LAPACK's \u003cem\u003edgesdd\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdRd",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#svdRd",
          "type": "function"
        },
        "index": {
          "description": "Full SVD of real matrix using LAPACK dgesdd",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "svdRd",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "Rd",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:svdRd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThin SVD of a complex matrix, using LAPACK's \u003cem\u003ezgesvd\u003c/em\u003e with jobu == jobvt == 'S'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDC",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#thinSVDC",
          "type": "function"
        },
        "index": {
          "description": "Thin SVD of complex matrix using LAPACK zgesvd with jobu jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDC",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "partial": "SVDC",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:thinSVDC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThin SVD of a complex matrix, using LAPACK's \u003cem\u003ezgesdd\u003c/em\u003e with jobz == 'S'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDCd",
          "package": "hmatrix",
          "signature": "Matrix (Complex Double) -\u003e (Matrix (Complex Double), Vector Double, Matrix (Complex Double))",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#thinSVDCd",
          "type": "function"
        },
        "index": {
          "description": "Thin SVD of complex matrix using LAPACK zgesdd with jobz",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDCd",
          "normalized": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "package": "hmatrix",
          "partial": "SVDCd",
          "signature": "Matrix(Complex Double)-\u003e(Matrix(Complex Double),Vector Double,Matrix(Complex Double))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:thinSVDCd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThin SVD of a real matrix, using LAPACK's \u003cem\u003edgesvd\u003c/em\u003e with jobu == jobvt == 'S'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDR",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#thinSVDR",
          "type": "function"
        },
        "index": {
          "description": "Thin SVD of real matrix using LAPACK dgesvd with jobu jobvt",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDR",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "SVDR",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:thinSVDR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThin SVD of a real matrix, using LAPACK's \u003cem\u003edgesdd\u003c/em\u003e with jobz == 'S'.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDRd",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e (Matrix Double, Vector Double, Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-LAPACK.html#thinSVDRd",
          "type": "function"
        },
        "index": {
          "description": "Thin SVD of real matrix using LAPACK dgesdd with jobz",
          "hierarchy": "Numeric LinearAlgebra LAPACK",
          "module": "Numeric.LinearAlgebra.LAPACK",
          "name": "thinSVDRd",
          "normalized": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "package": "hmatrix",
          "partial": "SVDRd",
          "signature": "Matrix Double-\u003e(Matrix Double,Vector Double,Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-LAPACK.html#v:thinSVDRd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.LinearAlgebra.Util",
          "name": "Util",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra-Util.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "Util",
          "package": "hmatrix",
          "partial": "Util",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(00A6) horizontal concatenation of real matrices\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "()",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#%A6",
          "type": "function"
        },
        "index": {
          "description": "A6 horizontal concatenation of real matrices",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "() ",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:-166-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(00BF) extract selected columns\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e [Int] -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Util.html#%BF",
          "type": "function"
        },
        "index": {
          "description": "BF extract selected columns",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "",
          "normalized": "Matrix a-\u003e[Int]-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e[Int]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:-191-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehorizontal concatenation of real matrices\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(!)",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#%21",
          "type": "function"
        },
        "index": {
          "description": "horizontal concatenation of real matrices",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(!) !",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evertical concatenation of real matrices\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(#)",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#%23",
          "type": "function"
        },
        "index": {
          "description": "vertical concatenation of real matrices",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(#) #",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econcatenation of real vectors\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(&)",
          "package": "hmatrix",
          "signature": "Vector Double -\u003e Vector Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#%26",
          "type": "function"
        },
        "index": {
          "description": "concatenation of real vectors",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(&) &",
          "normalized": "Vector Double-\u003eVector Double-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Vector Double-\u003eVector Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextract selected rows\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(?)",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e [Int] -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Util.html#%3F",
          "type": "function"
        },
        "index": {
          "description": "extract selected rows",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "(?) ?",
          "normalized": "Matrix a-\u003e[Int]-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e[Int]-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate a single column real matrix from a list\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "col",
          "package": "hmatrix",
          "signature": "[Double] -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#col",
          "type": "function"
        },
        "index": {
          "description": "create single column real matrix from list",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "col",
          "normalized": "[Double]-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "[Double]-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:col"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econvolution (\u003ccode\u003e\u003ca\u003ecorr\u003c/a\u003e\u003c/code\u003e with reversed kernel and padded input, equivalent to polynomial product)\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econv (fromList[1,1]) (fromList [-1,1])\n\u003c/code\u003e\u003c/strong\u003efromList [-1.0,0.0,1.0]\n\u003c/pre\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "conv",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Vector t -\u003e Vector t",
          "source": "src/Numeric-LinearAlgebra-Util-Convolution.html#conv",
          "type": "function"
        },
        "index": {
          "description": "convolution corr with reversed kernel and padded input equivalent to polynomial product conv fromList fromList fromList",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "conv",
          "normalized": "Vector a-\u003eVector a-\u003eVector a",
          "package": "hmatrix",
          "signature": "Vector t-\u003eVector t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:conv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2D convolution\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "conv2",
          "package": "hmatrix",
          "signature": "Matrix a -\u003e Matrix a -\u003e Matrix a",
          "source": "src/Numeric-LinearAlgebra-Util-Convolution.html#conv2",
          "type": "function"
        },
        "index": {
          "description": "convolution",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "conv2",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:conv2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecorrelation\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecorr (fromList[1,2,3]) (fromList [1..10])\n\u003c/code\u003e\u003c/strong\u003efromList [14.0,20.0,26.0,32.0,38.0,44.0,50.0,56.0]\n\u003c/pre\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "corr",
          "package": "hmatrix",
          "signature": "Vector t-\u003e Vector t-\u003e Vector t",
          "type": "function"
        },
        "index": {
          "description": "correlation corr fromList fromList fromList",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "corr",
          "normalized": "Vector a-\u003eVector a-\u003eVector a",
          "package": "hmatrix",
          "signature": "Vector t-\u003eVector t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:corr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2D correlation\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "corr2",
          "package": "hmatrix",
          "signature": "Matrix a -\u003e Matrix a -\u003e Matrix a",
          "source": "src/Numeric-LinearAlgebra-Util-Convolution.html#corr2",
          "type": "function"
        },
        "index": {
          "description": "correlation",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "corr2",
          "normalized": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Matrix a-\u003eMatrix a-\u003eMatrix a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:corr2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimilar to \u003ccode\u003e\u003ca\u003ecorr\u003c/a\u003e\u003c/code\u003e, using \u003ccode\u003e\u003ca\u003emin\u003c/a\u003e\u003c/code\u003e instead of (*)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "corrMin",
          "package": "hmatrix",
          "signature": "Vector t -\u003e Vector t -\u003e Vector t",
          "source": "src/Numeric-LinearAlgebra-Util-Convolution.html#corrMin",
          "type": "function"
        },
        "index": {
          "description": "similar to corr using min instead of",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "corrMin",
          "normalized": "Vector a-\u003eVector a-\u003eVector a",
          "package": "hmatrix",
          "partial": "Min",
          "signature": "Vector t-\u003eVector t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:corrMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecross product (for three-element real vectors)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "cross",
          "package": "hmatrix",
          "signature": "Vector Double -\u003e Vector Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#cross",
          "type": "function"
        },
        "index": {
          "description": "cross product for three-element real vectors",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "cross",
          "normalized": "Vector Double-\u003eVector Double-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Vector Double-\u003eVector Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:cross"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate a real diagonal matrix from a list\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "diagl",
          "package": "hmatrix",
          "signature": "[Double] -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#diagl",
          "type": "function"
        },
        "index": {
          "description": "create real diagonal matrix from list",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "diagl",
          "normalized": "[Double]-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "[Double]-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:diagl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshow a matrix with given number of digits after the decimal point\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "disp",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix Double -\u003e IO ()",
          "source": "src/Numeric-LinearAlgebra-Util.html#disp",
          "type": "function"
        },
        "index": {
          "description": "show matrix with given number of digits after the decimal point",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "disp",
          "normalized": "Int-\u003eMatrix Double-\u003eIO()",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix Double-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:disp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eduplication matrix (\u003ccode\u003e\u003ccode\u003e\u003ca\u003edup\u003c/a\u003e\u003c/code\u003e k \u003c\u003e \u003ccode\u003e\u003ca\u003evech\u003c/a\u003e\u003c/code\u003e m == \u003ccode\u003e\u003ca\u003evec\u003c/a\u003e\u003c/code\u003e m\u003c/code\u003e, for symmetric m of \u003ccode\u003e\u003ca\u003edim\u003c/a\u003e\u003c/code\u003e k)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "dup",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Util.html#dup",
          "type": "function"
        },
        "index": {
          "description": "duplication matrix dup vech vec for symmetric of dim",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "dup",
          "normalized": "Int-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:dup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrans . inv\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "mt",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#mt",
          "type": "function"
        },
        "index": {
          "description": "trans inv",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "mt",
          "normalized": "Matrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:mt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e2-norm of real vector\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "norm",
          "package": "hmatrix",
          "signature": "Vector Double -\u003e Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#norm",
          "type": "function"
        },
        "index": {
          "description": "norm of real vector",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "norm",
          "normalized": "Vector Double-\u003eDouble",
          "package": "hmatrix",
          "signature": "Vector Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:norm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esolution of overconstrained homogeneous linear system\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "null1",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#null1",
          "type": "function"
        },
        "index": {
          "description": "solution of overconstrained homogeneous linear system",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "null1",
          "normalized": "Matrix Double-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:null1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esolution of overconstrained homogeneous symmetric linear system\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "null1sym",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#null1sym",
          "type": "function"
        },
        "index": {
          "description": "solution of overconstrained homogeneous symmetric linear system",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "null1sym",
          "normalized": "Matrix Double-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:null1sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea real matrix of ones\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "ones",
          "package": "hmatrix",
          "signature": "Int-\u003e Int-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "real matrix of ones",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "ones",
          "normalized": "Int-\u003eInt-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Int-\u003eInt-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:ones"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatrix of pairwise squared distances of row vectors\n (using the matrix product trick in blog.smola.org)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "pairwiseD2",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#pairwiseD2",
          "type": "function"
        },
        "index": {
          "description": "Matrix of pairwise squared distances of row vectors using the matrix product trick in blog.smola.org",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "pairwiseD2",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:pairwiseD2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epseudorandom matrix with uniform elements between 0 and 1\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "rand",
          "package": "hmatrix",
          "signature": "Int -\u003e Int -\u003e IO (Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-Util.html#rand",
          "type": "function"
        },
        "index": {
          "description": "pseudorandom matrix with uniform elements between and",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "rand",
          "normalized": "Int-\u003eInt-\u003eIO(Matrix Double)",
          "package": "hmatrix",
          "signature": "Int-\u003eInt-\u003eIO(Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:rand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epseudorandom matrix with normal elements\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "randn",
          "package": "hmatrix",
          "signature": "Int -\u003e Int -\u003e IO (Matrix Double)",
          "source": "src/Numeric-LinearAlgebra-Util.html#randn",
          "type": "function"
        },
        "index": {
          "description": "pseudorandom matrix with normal elements",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "randn",
          "normalized": "Int-\u003eInt-\u003eIO(Matrix Double)",
          "package": "hmatrix",
          "signature": "Int-\u003eInt-\u003eIO(Matrix Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:randn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecreate a single row real matrix from a list\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "row",
          "package": "hmatrix",
          "signature": "[Double] -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#row",
          "type": "function"
        },
        "index": {
          "description": "create single row real matrix from list",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "row",
          "normalized": "[Double]-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "[Double]-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:row"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eouter products of rows\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "rowOuters",
          "package": "hmatrix",
          "signature": "Matrix Double -\u003e Matrix Double -\u003e Matrix Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#rowOuters",
          "type": "function"
        },
        "index": {
          "description": "outer products of rows",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "rowOuters",
          "normalized": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "package": "hmatrix",
          "partial": "Outers",
          "signature": "Matrix Double-\u003eMatrix Double-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:rowOuters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematrix computation implemented as separated vector operations by rows and columns.\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "separable",
          "package": "hmatrix",
          "signature": "(Vector t -\u003e Vector t) -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Util-Convolution.html#separable",
          "type": "function"
        },
        "index": {
          "description": "matrix computation implemented as separated vector operations by rows and columns",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "separable",
          "normalized": "(Vector a-\u003eVector a)-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "(Vector t-\u003eVector t)-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:separable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(rows &&& cols)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "size",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e (Int, Int)",
          "source": "src/Numeric-LinearAlgebra-Util.html#size",
          "type": "function"
        },
        "index": {
          "description": "rows cols",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "size",
          "normalized": "Matrix a-\u003e(Int,Int)",
          "package": "hmatrix",
          "signature": "Matrix t-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtains a vector in the same direction with 2-norm=1\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "unitary",
          "package": "hmatrix",
          "signature": "Vector Double -\u003e Vector Double",
          "source": "src/Numeric-LinearAlgebra-Util.html#unitary",
          "type": "function"
        },
        "index": {
          "description": "Obtains vector in the same direction with norm",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "unitary",
          "normalized": "Vector Double-\u003eVector Double",
          "package": "hmatrix",
          "signature": "Vector Double-\u003eVector Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:unitary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estacking of columns\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "vec",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector t",
          "source": "src/Numeric-LinearAlgebra-Util.html#vec",
          "type": "function"
        },
        "index": {
          "description": "stacking of columns",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "vec",
          "normalized": "Matrix a-\u003eVector a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:vec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehalf-vectorization (of the lower triangular part)\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "vech",
          "package": "hmatrix",
          "signature": "Matrix t -\u003e Vector t",
          "source": "src/Numeric-LinearAlgebra-Util.html#vech",
          "type": "function"
        },
        "index": {
          "description": "half-vectorization of the lower triangular part",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "vech",
          "normalized": "Matrix a-\u003eVector a",
          "package": "hmatrix",
          "signature": "Matrix t-\u003eVector t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:vech"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneralized \"vector\" transposition: \u003ccode\u003e\u003ccode\u003e\u003ca\u003evtrans\u003c/a\u003e\u003c/code\u003e 1 == \u003ccode\u003e\u003ca\u003etrans\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ccode\u003e\u003ca\u003evtrans\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003erows\u003c/a\u003e\u003c/code\u003e m) m == \u003ccode\u003e\u003ca\u003easColumn\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003evec\u003c/a\u003e\u003c/code\u003e m)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "vtrans",
          "package": "hmatrix",
          "signature": "Int -\u003e Matrix t -\u003e Matrix t",
          "source": "src/Numeric-LinearAlgebra-Util.html#vtrans",
          "type": "function"
        },
        "index": {
          "description": "generalized vector transposition vtrans trans and vtrans rows asColumn vec",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "vtrans",
          "normalized": "Int-\u003eMatrix a-\u003eMatrix a",
          "package": "hmatrix",
          "signature": "Int-\u003eMatrix t-\u003eMatrix t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:vtrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea real matrix of zeros\n\u003c/p\u003e",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "zeros",
          "package": "hmatrix",
          "signature": "Int-\u003e Int-\u003e Matrix Double",
          "type": "function"
        },
        "index": {
          "description": "real matrix of zeros",
          "hierarchy": "Numeric LinearAlgebra Util",
          "module": "Numeric.LinearAlgebra.Util",
          "name": "zeros",
          "normalized": "Int-\u003eInt-\u003eMatrix Double",
          "package": "hmatrix",
          "signature": "Int-\u003eInt-\u003eMatrix Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra-Util.html#v:zeros"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module reexports all normally required functions for Linear Algebra applications.\n\u003c/p\u003e\u003cp\u003eIt also provides instances of standard classes \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eMatrix\u003c/a\u003e\u003c/code\u003e.\nIn arithmetic operations one-component vectors and matrices automatically\nexpand to match the dimensions of the other operand.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.LinearAlgebra",
          "name": "LinearAlgebra",
          "package": "hmatrix",
          "source": "src/Numeric-LinearAlgebra.html",
          "type": "module"
        },
        "index": {
          "description": "This module reexports all normally required functions for Linear Algebra applications It also provides instances of standard classes Show Read Eq Num Fractional and Floating for Vector and Matrix In arithmetic operations one-component vectors and matrices automatically expand to match the dimensions of the other operand",
          "hierarchy": "Numeric LinearAlgebra",
          "module": "Numeric.LinearAlgebra",
          "name": "LinearAlgebra",
          "package": "hmatrix",
          "partial": "Linear Algebra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hmatrix/docs/Numeric-LinearAlgebra.html#"
      }
    }
  ]
]