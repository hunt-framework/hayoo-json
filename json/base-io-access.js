[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "base-io-access"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "Chan",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent-Chan.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "Chan",
          "package": "base-io-access",
          "partial": "Chan",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "ChanAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent-Chan.html#ChanAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "ChanAccess",
          "package": "base-io-access",
          "partial": "Chan Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#t:ChanAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "dupChan'",
          "package": "base-io-access",
          "signature": "Chan a -\u003e io (Chan a)",
          "source": "src/Access-Control-Concurrent-Chan.html#dupChan%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "dupChan'",
          "normalized": "Chan a-\u003eb(Chan a)",
          "package": "base-io-access",
          "partial": "Chan'",
          "signature": "Chan a-\u003eio(Chan a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#v:dupChan-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "getChanContents'",
          "package": "base-io-access",
          "signature": "Chan a -\u003e io [a]",
          "source": "src/Access-Control-Concurrent-Chan.html#getChanContents%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "getChanContents'",
          "normalized": "Chan a-\u003eb[a]",
          "package": "base-io-access",
          "partial": "Chan Contents'",
          "signature": "Chan a-\u003eio[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#v:getChanContents-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "newChan'",
          "package": "base-io-access",
          "signature": "io (Chan a)",
          "source": "src/Access-Control-Concurrent-Chan.html#newChan%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "newChan'",
          "package": "base-io-access",
          "partial": "Chan'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#v:newChan-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "readChan'",
          "package": "base-io-access",
          "signature": "Chan a -\u003e io a",
          "source": "src/Access-Control-Concurrent-Chan.html#readChan%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "readChan'",
          "normalized": "Chan a-\u003eb a",
          "package": "base-io-access",
          "partial": "Chan'",
          "signature": "Chan a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#v:readChan-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "writeChan'",
          "package": "base-io-access",
          "signature": "Chan a -\u003e a -\u003e io ()",
          "source": "src/Access-Control-Concurrent-Chan.html#writeChan%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "writeChan'",
          "normalized": "Chan a-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "Chan'",
          "signature": "Chan a-\u003ea-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#v:writeChan-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.Chan",
          "name": "writeList2Chan'",
          "package": "base-io-access",
          "signature": "Chan a -\u003e [a] -\u003e io ()",
          "source": "src/Access-Control-Concurrent-Chan.html#writeList2Chan%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent Chan",
          "module": "Access.Control.Concurrent.Chan",
          "name": "writeList2Chan'",
          "normalized": "Chan a-\u003e[a]-\u003eb()",
          "package": "base-io-access",
          "partial": "List Chan'",
          "signature": "Chan a-\u003e[a]-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-Chan.html#v:writeList2Chan-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "MVar",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent-MVar.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "MVar",
          "package": "base-io-access",
          "partial": "MVar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "MVarAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent-MVar.html#MVarAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "MVarAccess",
          "package": "base-io-access",
          "partial": "MVar Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#t:MVarAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "WeakMVarAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent-MVar.html#WeakMVarAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "WeakMVarAccess",
          "package": "base-io-access",
          "partial": "Weak MVar Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#t:WeakMVarAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "isEmptyMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e io Bool",
          "source": "src/Access-Control-Concurrent-MVar.html#isEmptyMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "isEmptyMVar'",
          "normalized": "MVar a-\u003eb Bool",
          "package": "base-io-access",
          "partial": "Empty MVar'",
          "signature": "MVar a-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:isEmptyMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "mkWeakMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e IO () -\u003e io (Weak (MVar a))",
          "source": "src/Access-Control-Concurrent-MVar.html#mkWeakMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "mkWeakMVar'",
          "normalized": "MVar a-\u003eIO()-\u003eb(Weak(MVar a))",
          "package": "base-io-access",
          "partial": "Weak MVar'",
          "signature": "MVar a-\u003eIO()-\u003eio(Weak(MVar a))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:mkWeakMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e (a -\u003e IO (a, b)) -\u003e io b",
          "source": "src/Access-Control-Concurrent-MVar.html#modifyMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVar'",
          "normalized": "MVar a-\u003e(a-\u003eIO(a,b))-\u003ec b",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "MVar a-\u003e(a-\u003eIO(a,b))-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:modifyMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVarMasked'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e (a -\u003e IO (a, b)) -\u003e io b",
          "source": "src/Access-Control-Concurrent-MVar.html#modifyMVarMasked%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVarMasked'",
          "normalized": "MVar a-\u003e(a-\u003eIO(a,b))-\u003ec b",
          "package": "base-io-access",
          "partial": "MVar Masked'",
          "signature": "MVar a-\u003e(a-\u003eIO(a,b))-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:modifyMVarMasked-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVarMasked_'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e (a -\u003e IO a) -\u003e io ()",
          "source": "src/Access-Control-Concurrent-MVar.html#modifyMVarMasked_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVarMasked_'",
          "normalized": "MVar a-\u003e(a-\u003eIO a)-\u003eb()",
          "package": "base-io-access",
          "partial": "MVar Masked",
          "signature": "MVar a-\u003e(a-\u003eIO a)-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:modifyMVarMasked_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVar_'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e (a -\u003e IO a) -\u003e io ()",
          "source": "src/Access-Control-Concurrent-MVar.html#modifyMVar_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "modifyMVar_'",
          "normalized": "MVar a-\u003e(a-\u003eIO a)-\u003eb()",
          "package": "base-io-access",
          "partial": "MVar",
          "signature": "MVar a-\u003e(a-\u003eIO a)-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:modifyMVar_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "newEmptyMVar'",
          "package": "base-io-access",
          "signature": "io (MVar a)",
          "source": "src/Access-Control-Concurrent-MVar.html#newEmptyMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "newEmptyMVar'",
          "package": "base-io-access",
          "partial": "Empty MVar'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:newEmptyMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "newMVar'",
          "package": "base-io-access",
          "signature": "a -\u003e io (MVar a)",
          "source": "src/Access-Control-Concurrent-MVar.html#newMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "newMVar'",
          "normalized": "a-\u003eb(MVar a)",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "a-\u003eio(MVar a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:newMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "putMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e a -\u003e io ()",
          "source": "src/Access-Control-Concurrent-MVar.html#putMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "putMVar'",
          "normalized": "MVar a-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "MVar a-\u003ea-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:putMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "readMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e io a",
          "source": "src/Access-Control-Concurrent-MVar.html#readMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "readMVar'",
          "normalized": "MVar a-\u003eb a",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "MVar a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:readMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "swapMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e a -\u003e io a",
          "source": "src/Access-Control-Concurrent-MVar.html#swapMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "swapMVar'",
          "normalized": "MVar a-\u003ea-\u003eb a",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "MVar a-\u003ea-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:swapMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "takeMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e io a",
          "source": "src/Access-Control-Concurrent-MVar.html#takeMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "takeMVar'",
          "normalized": "MVar a-\u003eb a",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "MVar a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:takeMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "tryPutMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e a -\u003e io Bool",
          "source": "src/Access-Control-Concurrent-MVar.html#tryPutMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "tryPutMVar'",
          "normalized": "MVar a-\u003ea-\u003eb Bool",
          "package": "base-io-access",
          "partial": "Put MVar'",
          "signature": "MVar a-\u003ea-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:tryPutMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "tryTakeMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e io (Maybe a)",
          "source": "src/Access-Control-Concurrent-MVar.html#tryTakeMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "tryTakeMVar'",
          "normalized": "MVar a-\u003eb(Maybe a)",
          "package": "base-io-access",
          "partial": "Take MVar'",
          "signature": "MVar a-\u003eio(Maybe a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:tryTakeMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent.MVar",
          "name": "withMVar'",
          "package": "base-io-access",
          "signature": "MVar a -\u003e (a -\u003e IO b) -\u003e io b",
          "source": "src/Access-Control-Concurrent-MVar.html#withMVar%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent MVar",
          "module": "Access.Control.Concurrent.MVar",
          "name": "withMVar'",
          "normalized": "MVar a-\u003e(a-\u003eIO b)-\u003ec b",
          "package": "base-io-access",
          "partial": "MVar'",
          "signature": "MVar a-\u003e(a-\u003eIO b)-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent-MVar.html#v:withMVar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "Concurrent",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "Concurrent",
          "package": "base-io-access",
          "partial": "Concurrent",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "BoundThreadAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent.html#BoundThreadAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "BoundThreadAccess",
          "package": "base-io-access",
          "partial": "Bound Thread Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#t:BoundThreadAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "ThreadAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent.html#ThreadAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "ThreadAccess",
          "package": "base-io-access",
          "partial": "Thread Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#t:ThreadAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "WeakThreadAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Concurrent.html#WeakThreadAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "WeakThreadAccess",
          "package": "base-io-access",
          "partial": "Weak Thread Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#t:WeakThreadAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "forkFinally'",
          "package": "base-io-access",
          "signature": "io a -\u003e (Either SomeException a -\u003e io ()) -\u003e io ThreadId",
          "source": "src/Access-Control-Concurrent.html#forkFinally%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "forkFinally'",
          "normalized": "a b-\u003e(Either SomeException b-\u003ea())-\u003ea ThreadId",
          "package": "base-io-access",
          "partial": "Finally'",
          "signature": "io a-\u003e(Either SomeException a-\u003eio())-\u003eio ThreadId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:forkFinally-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "forkIO'",
          "package": "base-io-access",
          "signature": "io () -\u003e io ThreadId",
          "source": "src/Access-Control-Concurrent.html#forkIO%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "forkIO'",
          "normalized": "a()-\u003ea ThreadId",
          "package": "base-io-access",
          "partial": "IO'",
          "signature": "io()-\u003eio ThreadId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:forkIO-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "forkIOWithUnmask'",
          "package": "base-io-access",
          "signature": "((forall a.  io a -\u003e io a) -\u003e io ()) -\u003e io ThreadId",
          "source": "src/Access-Control-Concurrent.html#forkIOWithUnmask%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "forkIOWithUnmask'",
          "normalized": "((a b c d-\u003ec d)-\u003ec())-\u003ec ThreadId",
          "package": "base-io-access",
          "partial": "IOWith Unmask'",
          "signature": "((forall a. io a-\u003eio a)-\u003eio())-\u003eio ThreadId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:forkIOWithUnmask-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "forkOS'",
          "package": "base-io-access",
          "signature": "io () -\u003e io ThreadId",
          "source": "src/Access-Control-Concurrent.html#forkOS%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "forkOS'",
          "normalized": "a()-\u003ea ThreadId",
          "package": "base-io-access",
          "partial": "OS'",
          "signature": "io()-\u003eio ThreadId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:forkOS-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "forkOn'",
          "package": "base-io-access",
          "signature": "Int -\u003e io () -\u003e io ThreadId",
          "source": "src/Access-Control-Concurrent.html#forkOn%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "forkOn'",
          "normalized": "Int-\u003ea()-\u003ea ThreadId",
          "package": "base-io-access",
          "partial": "On'",
          "signature": "Int-\u003eio()-\u003eio ThreadId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:forkOn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "forkOnWithUnmask'",
          "package": "base-io-access",
          "signature": "Int -\u003e ((forall a.  io a -\u003e io a) -\u003e io ()) -\u003e io ThreadId",
          "source": "src/Access-Control-Concurrent.html#forkOnWithUnmask%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "forkOnWithUnmask'",
          "normalized": "Int-\u003e((a b c d-\u003ec d)-\u003ec())-\u003ec ThreadId",
          "package": "base-io-access",
          "partial": "On With Unmask'",
          "signature": "Int-\u003e((forall a. io a-\u003eio a)-\u003eio())-\u003eio ThreadId",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:forkOnWithUnmask-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "getNumCapabilities'",
          "package": "base-io-access",
          "signature": "io Int",
          "source": "src/Access-Control-Concurrent.html#getNumCapabilities%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "getNumCapabilities'",
          "package": "base-io-access",
          "partial": "Num Capabilities'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:getNumCapabilities-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "isCurrentThreadBound'",
          "package": "base-io-access",
          "signature": "io Bool",
          "source": "src/Access-Control-Concurrent.html#isCurrentThreadBound%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "isCurrentThreadBound'",
          "package": "base-io-access",
          "partial": "Current Thread Bound'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:isCurrentThreadBound-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "killThread'",
          "package": "base-io-access",
          "signature": "ThreadId -\u003e io ()",
          "source": "src/Access-Control-Concurrent.html#killThread%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "killThread'",
          "normalized": "ThreadId-\u003ea()",
          "package": "base-io-access",
          "partial": "Thread'",
          "signature": "ThreadId-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:killThread-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "mkWeakThreadId'",
          "package": "base-io-access",
          "signature": "ThreadId -\u003e io (Weak ThreadId)",
          "source": "src/Access-Control-Concurrent.html#mkWeakThreadId%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "mkWeakThreadId'",
          "normalized": "ThreadId-\u003ea(Weak ThreadId)",
          "package": "base-io-access",
          "partial": "Weak Thread Id'",
          "signature": "ThreadId-\u003eio(Weak ThreadId)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:mkWeakThreadId-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "myThreadId'",
          "package": "base-io-access",
          "signature": "io ThreadId",
          "source": "src/Access-Control-Concurrent.html#myThreadId%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "myThreadId'",
          "package": "base-io-access",
          "partial": "Thread Id'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:myThreadId-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "runInBoundThread'",
          "package": "base-io-access",
          "signature": "io a -\u003e io a",
          "source": "src/Access-Control-Concurrent.html#runInBoundThread%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "runInBoundThread'",
          "normalized": "a b-\u003ea b",
          "package": "base-io-access",
          "partial": "In Bound Thread'",
          "signature": "io a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:runInBoundThread-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "runInUnboundThread'",
          "package": "base-io-access",
          "signature": "io a -\u003e io a",
          "source": "src/Access-Control-Concurrent.html#runInUnboundThread%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "runInUnboundThread'",
          "normalized": "a b-\u003ea b",
          "package": "base-io-access",
          "partial": "In Unbound Thread'",
          "signature": "io a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:runInUnboundThread-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "setNumCapabilities'",
          "package": "base-io-access",
          "signature": "Int -\u003e io ()",
          "source": "src/Access-Control-Concurrent.html#setNumCapabilities%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "setNumCapabilities'",
          "normalized": "Int-\u003ea()",
          "package": "base-io-access",
          "partial": "Num Capabilities'",
          "signature": "Int-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:setNumCapabilities-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "threadCapability'",
          "package": "base-io-access",
          "signature": "ThreadId -\u003e io (Int, Bool)",
          "source": "src/Access-Control-Concurrent.html#threadCapability%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "threadCapability'",
          "normalized": "ThreadId-\u003ea(Int,Bool)",
          "package": "base-io-access",
          "partial": "Capability'",
          "signature": "ThreadId-\u003eio(Int,Bool)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:threadCapability-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "threadDelay'",
          "package": "base-io-access",
          "signature": "Int -\u003e io ()",
          "source": "src/Access-Control-Concurrent.html#threadDelay%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "threadDelay'",
          "normalized": "Int-\u003ea()",
          "package": "base-io-access",
          "partial": "Delay'",
          "signature": "Int-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:threadDelay-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "threadWaitRead'",
          "package": "base-io-access",
          "signature": "Fd -\u003e io ()",
          "source": "src/Access-Control-Concurrent.html#threadWaitRead%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "threadWaitRead'",
          "normalized": "Fd-\u003ea()",
          "package": "base-io-access",
          "partial": "Wait Read'",
          "signature": "Fd-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:threadWaitRead-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "threadWaitWrite'",
          "package": "base-io-access",
          "signature": "Fd -\u003e io ()",
          "source": "src/Access-Control-Concurrent.html#threadWaitWrite%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "threadWaitWrite'",
          "normalized": "Fd-\u003ea()",
          "package": "base-io-access",
          "partial": "Wait Write'",
          "signature": "Fd-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:threadWaitWrite-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "throwTo'",
          "package": "base-io-access",
          "signature": "ThreadId -\u003e e -\u003e io ()",
          "source": "src/Access-Control-Concurrent.html#throwTo%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "throwTo'",
          "normalized": "ThreadId-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "To'",
          "signature": "ThreadId-\u003ee-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:throwTo-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Concurrent",
          "name": "yield'",
          "package": "base-io-access",
          "signature": "io ()",
          "source": "src/Access-Control-Concurrent.html#yield%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Concurrent",
          "module": "Access.Control.Concurrent",
          "name": "yield'",
          "normalized": "a()",
          "package": "base-io-access",
          "signature": "io()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Concurrent.html#v:yield-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "Exception",
          "package": "base-io-access",
          "source": "src/Access-Control-Exception.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "Exception",
          "package": "base-io-access",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "ExceptionAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Exception.html#ExceptionAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "ExceptionAccess",
          "package": "base-io-access",
          "partial": "Exception Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#t:ExceptionAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "MaskingAccess",
          "package": "base-io-access",
          "source": "src/Access-Control-Exception.html#MaskingAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "MaskingAccess",
          "package": "base-io-access",
          "partial": "Masking Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#t:MaskingAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "allowInterrupt'",
          "package": "base-io-access",
          "signature": "io ()",
          "source": "src/Access-Control-Exception.html#allowInterrupt%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "allowInterrupt'",
          "normalized": "a()",
          "package": "base-io-access",
          "partial": "Interrupt'",
          "signature": "io()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:allowInterrupt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "bracket'",
          "package": "base-io-access",
          "signature": "io a -\u003e (a -\u003e io b) -\u003e (a -\u003e io c) -\u003e io c",
          "source": "src/Access-Control-Exception.html#bracket%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "bracket'",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003e(b-\u003ea d)-\u003ea d",
          "package": "base-io-access",
          "signature": "io a-\u003e(a-\u003eio b)-\u003e(a-\u003eio c)-\u003eio c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:bracket-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "bracketOnError'",
          "package": "base-io-access",
          "signature": "io a -\u003e (a -\u003e io b) -\u003e (a -\u003e io c) -\u003e io c",
          "source": "src/Access-Control-Exception.html#bracketOnError%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "bracketOnError'",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003e(b-\u003ea d)-\u003ea d",
          "package": "base-io-access",
          "partial": "On Error'",
          "signature": "io a-\u003e(a-\u003eio b)-\u003e(a-\u003eio c)-\u003eio c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:bracketOnError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "bracket_'",
          "package": "base-io-access",
          "signature": "io a -\u003e io b -\u003e io c -\u003e io c",
          "source": "src/Access-Control-Exception.html#bracket_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "bracket_'",
          "normalized": "a b-\u003ea c-\u003ea d-\u003ea d",
          "package": "base-io-access",
          "signature": "io a-\u003eio b-\u003eio c-\u003eio c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:bracket_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "catch'",
          "package": "base-io-access",
          "signature": "io a -\u003e (e -\u003e io a) -\u003e io a",
          "source": "src/Access-Control-Exception.html#catch%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "catch'",
          "normalized": "a b-\u003e(c-\u003ea b)-\u003ea b",
          "package": "base-io-access",
          "signature": "io a-\u003e(e-\u003eio a)-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:catch-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "catchJust'",
          "package": "base-io-access",
          "signature": "(e -\u003e Maybe b) -\u003e io a -\u003e (b -\u003e io a) -\u003e io a",
          "source": "src/Access-Control-Exception.html#catchJust%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "catchJust'",
          "normalized": "(a-\u003eMaybe b)-\u003ec d-\u003e(b-\u003ec d)-\u003ec d",
          "package": "base-io-access",
          "partial": "Just'",
          "signature": "(e-\u003eMaybe b)-\u003eio a-\u003e(b-\u003eio a)-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:catchJust-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "catches'",
          "package": "base-io-access",
          "signature": "io a -\u003e [Handler a] -\u003e io a",
          "source": "src/Access-Control-Exception.html#catches%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "catches'",
          "normalized": "a b-\u003e[Handler b]-\u003ea b",
          "package": "base-io-access",
          "signature": "io a-\u003e[Handler a]-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:catches-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "evaluate'",
          "package": "base-io-access",
          "signature": "a -\u003e io a",
          "source": "src/Access-Control-Exception.html#evaluate%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "evaluate'",
          "normalized": "a-\u003eb a",
          "package": "base-io-access",
          "signature": "a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:evaluate-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "finally'",
          "package": "base-io-access",
          "signature": "io a -\u003e io b -\u003e io a",
          "source": "src/Access-Control-Exception.html#finally%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "finally'",
          "normalized": "a b-\u003ea c-\u003ea b",
          "package": "base-io-access",
          "signature": "io a-\u003eio b-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:finally-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "getMaskingState'",
          "package": "base-io-access",
          "signature": "io MaskingState",
          "source": "src/Access-Control-Exception.html#getMaskingState%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "getMaskingState'",
          "package": "base-io-access",
          "partial": "Masking State'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:getMaskingState-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "handle'",
          "package": "base-io-access",
          "signature": "(e -\u003e io a) -\u003e io a -\u003e io a",
          "source": "src/Access-Control-Exception.html#handle%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "handle'",
          "normalized": "(a-\u003eb c)-\u003eb c-\u003eb c",
          "package": "base-io-access",
          "signature": "(e-\u003eio a)-\u003eio a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:handle-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "handleJust'",
          "package": "base-io-access",
          "signature": "(e -\u003e Maybe b) -\u003e (b -\u003e io a) -\u003e io a -\u003e io a",
          "source": "src/Access-Control-Exception.html#handleJust%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "handleJust'",
          "normalized": "(a-\u003eMaybe b)-\u003e(b-\u003ec d)-\u003ec d-\u003ec d",
          "package": "base-io-access",
          "partial": "Just'",
          "signature": "(e-\u003eMaybe b)-\u003e(b-\u003eio a)-\u003eio a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:handleJust-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "ioError'",
          "package": "base-io-access",
          "signature": "IOError -\u003e io a",
          "source": "src/Access-Control-Exception.html#ioError%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "ioError'",
          "normalized": "IOError-\u003ea b",
          "package": "base-io-access",
          "partial": "Error'",
          "signature": "IOError-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:ioError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "mask'",
          "package": "base-io-access",
          "signature": "((forall a.  io a -\u003e io a) -\u003e io b) -\u003e io b",
          "source": "src/Access-Control-Exception.html#mask%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "mask'",
          "normalized": "((a b c d-\u003ec d)-\u003ec e)-\u003ec e",
          "package": "base-io-access",
          "signature": "((forall a. io a-\u003eio a)-\u003eio b)-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:mask-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "mask_'",
          "package": "base-io-access",
          "signature": "io a -\u003e io a",
          "source": "src/Access-Control-Exception.html#mask_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "mask_'",
          "normalized": "a b-\u003ea b",
          "package": "base-io-access",
          "signature": "io a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:mask_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "onException'",
          "package": "base-io-access",
          "signature": "io a -\u003e io b -\u003e io a",
          "source": "src/Access-Control-Exception.html#onException%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "onException'",
          "normalized": "a b-\u003ea c-\u003ea b",
          "package": "base-io-access",
          "partial": "Exception'",
          "signature": "io a-\u003eio b-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:onException-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "throwIO'",
          "package": "base-io-access",
          "signature": "e -\u003e io a",
          "source": "src/Access-Control-Exception.html#throwIO%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "throwIO'",
          "normalized": "a-\u003eb c",
          "package": "base-io-access",
          "partial": "IO'",
          "signature": "e-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:throwIO-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "throwTo'",
          "package": "base-io-access",
          "signature": "ThreadId -\u003e e -\u003e io ()",
          "source": "src/Access-Control-Exception.html#throwTo%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "throwTo'",
          "normalized": "ThreadId-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "To'",
          "signature": "ThreadId-\u003ee-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:throwTo-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "try'",
          "package": "base-io-access",
          "signature": "io a -\u003e io (Either e a)",
          "source": "src/Access-Control-Exception.html#try%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "try'",
          "normalized": "a b-\u003ea(Either c b)",
          "package": "base-io-access",
          "signature": "io a-\u003eio(Either e a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:try-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "tryJust'",
          "package": "base-io-access",
          "signature": "(e -\u003e Maybe b) -\u003e io a -\u003e io (Either b a)",
          "source": "src/Access-Control-Exception.html#tryJust%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "tryJust'",
          "normalized": "(a-\u003eMaybe b)-\u003ec d-\u003ec(Either b d)",
          "package": "base-io-access",
          "partial": "Just'",
          "signature": "(e-\u003eMaybe b)-\u003eio a-\u003eio(Either b a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:tryJust-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "uninterruptibleMask'",
          "package": "base-io-access",
          "signature": "((forall a.  io a -\u003e io a) -\u003e io b) -\u003e io b",
          "source": "src/Access-Control-Exception.html#uninterruptibleMask%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "uninterruptibleMask'",
          "normalized": "((a b c d-\u003ec d)-\u003ec e)-\u003ec e",
          "package": "base-io-access",
          "partial": "Mask'",
          "signature": "((forall a. io a-\u003eio a)-\u003eio b)-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:uninterruptibleMask-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Control.Exception",
          "name": "uninterruptibleMask_'",
          "package": "base-io-access",
          "signature": "io a -\u003e io a",
          "source": "src/Access-Control-Exception.html#uninterruptibleMask_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Control Exception",
          "module": "Access.Control.Exception",
          "name": "uninterruptibleMask_'",
          "normalized": "a b-\u003ea b",
          "package": "base-io-access",
          "partial": "Mask",
          "signature": "io a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Control-Exception.html#v:uninterruptibleMask_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Core",
          "name": "Core",
          "package": "base-io-access",
          "source": "src/Access-Core.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Core",
          "module": "Access.Core",
          "name": "Core",
          "package": "base-io-access",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Core",
          "name": "Access",
          "package": "base-io-access",
          "source": "src/Access-Core.html#Access",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Core",
          "module": "Access.Core",
          "name": "Access",
          "package": "base-io-access",
          "partial": "Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Core.html#t:Access"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "IORef",
          "package": "base-io-access",
          "source": "src/Access-Data-IORef.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "IORef",
          "package": "base-io-access",
          "partial": "IORef",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "IORefAccess",
          "package": "base-io-access",
          "source": "src/Access-Data-IORef.html#IORefAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "IORefAccess",
          "package": "base-io-access",
          "partial": "IORef Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#t:IORefAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "WeakIORefAccess",
          "package": "base-io-access",
          "source": "src/Access-Data-IORef.html#WeakIORefAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "WeakIORefAccess",
          "package": "base-io-access",
          "partial": "Weak IORef Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#t:WeakIORefAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "atomicModifyIORef_",
          "package": "base-io-access",
          "signature": "IORef a -\u003e (a -\u003e (a, b)) -\u003e io b",
          "source": "src/Access-Data-IORef.html#atomicModifyIORef_",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "atomicModifyIORef_",
          "normalized": "IORef a-\u003e(a-\u003e(a,b))-\u003ec b",
          "package": "base-io-access",
          "partial": "Modify IORef",
          "signature": "IORef a-\u003e(a-\u003e(a,b))-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:atomicModifyIORef_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "atomicModifyIORef_'",
          "package": "base-io-access",
          "signature": "IORef a -\u003e (a -\u003e (a, b)) -\u003e io b",
          "source": "src/Access-Data-IORef.html#atomicModifyIORef_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "atomicModifyIORef_'",
          "normalized": "IORef a-\u003e(a-\u003e(a,b))-\u003ec b",
          "package": "base-io-access",
          "partial": "Modify IORef",
          "signature": "IORef a-\u003e(a-\u003e(a,b))-\u003eio b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:atomicModifyIORef_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "atomicWriteIORef'",
          "package": "base-io-access",
          "signature": "IORef a -\u003e a -\u003e io ()",
          "source": "src/Access-Data-IORef.html#atomicWriteIORef%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "atomicWriteIORef'",
          "normalized": "IORef a-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "Write IORef'",
          "signature": "IORef a-\u003ea-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:atomicWriteIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "mkWeakIORef'",
          "package": "base-io-access",
          "signature": "IORef a -\u003e IO () -\u003e io (Weak (IORef a))",
          "source": "src/Access-Data-IORef.html#mkWeakIORef%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "mkWeakIORef'",
          "normalized": "IORef a-\u003eIO()-\u003eb(Weak(IORef a))",
          "package": "base-io-access",
          "partial": "Weak IORef'",
          "signature": "IORef a-\u003eIO()-\u003eio(Weak(IORef a))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:mkWeakIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "modifyIORef_",
          "package": "base-io-access",
          "signature": "IORef a -\u003e (a -\u003e a) -\u003e io ()",
          "source": "src/Access-Data-IORef.html#modifyIORef_",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "modifyIORef_",
          "normalized": "IORef a-\u003e(a-\u003ea)-\u003eb()",
          "package": "base-io-access",
          "partial": "IORef",
          "signature": "IORef a-\u003e(a-\u003ea)-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:modifyIORef_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "modifyIORef_'",
          "package": "base-io-access",
          "signature": "IORef a -\u003e (a -\u003e a) -\u003e io ()",
          "source": "src/Access-Data-IORef.html#modifyIORef_%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "modifyIORef_'",
          "normalized": "IORef a-\u003e(a-\u003ea)-\u003eb()",
          "package": "base-io-access",
          "partial": "IORef",
          "signature": "IORef a-\u003e(a-\u003ea)-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:modifyIORef_-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "newIORef'",
          "package": "base-io-access",
          "signature": "a -\u003e io (IORef a)",
          "source": "src/Access-Data-IORef.html#newIORef%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "newIORef'",
          "normalized": "a-\u003eb(IORef a)",
          "package": "base-io-access",
          "partial": "IORef'",
          "signature": "a-\u003eio(IORef a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:newIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "readIORef'",
          "package": "base-io-access",
          "signature": "IORef a -\u003e io a",
          "source": "src/Access-Data-IORef.html#readIORef%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "readIORef'",
          "normalized": "IORef a-\u003eb a",
          "package": "base-io-access",
          "partial": "IORef'",
          "signature": "IORef a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:readIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.IORef",
          "name": "writeIORef'",
          "package": "base-io-access",
          "signature": "IORef a -\u003e a -\u003e io ()",
          "source": "src/Access-Data-IORef.html#writeIORef%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data IORef",
          "module": "Access.Data.IORef",
          "name": "writeIORef'",
          "normalized": "IORef a-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "IORef'",
          "signature": "IORef a-\u003ea-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-IORef.html#v:writeIORef-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.Unique",
          "name": "Unique",
          "package": "base-io-access",
          "source": "src/Access-Data-Unique.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Data Unique",
          "module": "Access.Data.Unique",
          "name": "Unique",
          "package": "base-io-access",
          "partial": "Unique",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-Unique.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.Unique",
          "name": "UniqueAccess",
          "package": "base-io-access",
          "source": "src/Access-Data-Unique.html#UniqueAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Data Unique",
          "module": "Access.Data.Unique",
          "name": "UniqueAccess",
          "package": "base-io-access",
          "partial": "Unique Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-Unique.html#t:UniqueAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Data.Unique",
          "name": "newUnique'",
          "package": "base-io-access",
          "signature": "io Unique",
          "source": "src/Access-Data-Unique.html#newUnique%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Data Unique",
          "module": "Access.Data.Unique",
          "name": "newUnique'",
          "package": "base-io-access",
          "partial": "Unique'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Data-Unique.html#v:newUnique-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Debug.Trace",
          "name": "Trace",
          "package": "base-io-access",
          "source": "src/Access-Debug-Trace.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access Debug Trace",
          "module": "Access.Debug.Trace",
          "name": "Trace",
          "package": "base-io-access",
          "partial": "Trace",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Debug-Trace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Debug.Trace",
          "name": "TraceAccess",
          "package": "base-io-access",
          "source": "src/Access-Debug-Trace.html#TraceAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access Debug Trace",
          "module": "Access.Debug.Trace",
          "name": "TraceAccess",
          "package": "base-io-access",
          "partial": "Trace Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Debug-Trace.html#t:TraceAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Debug.Trace",
          "name": "traceEventIO'",
          "package": "base-io-access",
          "signature": "String -\u003e io ()",
          "source": "src/Access-Debug-Trace.html#traceEventIO%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Debug Trace",
          "module": "Access.Debug.Trace",
          "name": "traceEventIO'",
          "normalized": "String-\u003ea()",
          "package": "base-io-access",
          "partial": "Event IO'",
          "signature": "String-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Debug-Trace.html#v:traceEventIO-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.Debug.Trace",
          "name": "traceIO'",
          "package": "base-io-access",
          "signature": "String -\u003e io ()",
          "source": "src/Access-Debug-Trace.html#traceIO%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access Debug Trace",
          "module": "Access.Debug.Trace",
          "name": "traceIO'",
          "normalized": "String-\u003ea()",
          "package": "base-io-access",
          "partial": "IO'",
          "signature": "String-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-Debug-Trace.html#v:traceIO-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.CPUTime",
          "name": "CPUTime",
          "package": "base-io-access",
          "source": "src/Access-System-CPUTime.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System CPUTime",
          "module": "Access.System.CPUTime",
          "name": "CPUTime",
          "package": "base-io-access",
          "partial": "CPUTime",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-CPUTime.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.CPUTime",
          "name": "CPUTimeAccess",
          "package": "base-io-access",
          "source": "src/Access-System-CPUTime.html#CPUTimeAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System CPUTime",
          "module": "Access.System.CPUTime",
          "name": "CPUTimeAccess",
          "package": "base-io-access",
          "partial": "CPUTime Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-CPUTime.html#t:CPUTimeAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.CPUTime",
          "name": "getCPUTime'",
          "package": "base-io-access",
          "signature": "io Integer",
          "source": "src/Access-System-CPUTime.html#getCPUTime%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System CPUTime",
          "module": "Access.System.CPUTime",
          "name": "getCPUTime'",
          "package": "base-io-access",
          "partial": "CPUTime'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-CPUTime.html#v:getCPUTime-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "Environment",
          "package": "base-io-access",
          "source": "src/Access-System-Environment.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "Environment",
          "package": "base-io-access",
          "partial": "Environment",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "EnvironmentAccess",
          "package": "base-io-access",
          "source": "src/Access-System-Environment.html#EnvironmentAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "EnvironmentAccess",
          "package": "base-io-access",
          "partial": "Environment Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#t:EnvironmentAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "getArgs'",
          "package": "base-io-access",
          "signature": "io [String]",
          "source": "src/Access-System-Environment.html#getArgs%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "getArgs'",
          "normalized": "a[String]",
          "package": "base-io-access",
          "partial": "Args'",
          "signature": "io[String]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:getArgs-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "getEnv'",
          "package": "base-io-access",
          "signature": "String -\u003e io String",
          "source": "src/Access-System-Environment.html#getEnv%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "getEnv'",
          "normalized": "String-\u003ea String",
          "package": "base-io-access",
          "partial": "Env'",
          "signature": "String-\u003eio String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:getEnv-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "getEnvironment'",
          "package": "base-io-access",
          "signature": "io [(String, String)]",
          "source": "src/Access-System-Environment.html#getEnvironment%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "getEnvironment'",
          "normalized": "a[(String,String)]",
          "package": "base-io-access",
          "partial": "Environment'",
          "signature": "io[(String,String)]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:getEnvironment-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "getExecutablePath'",
          "package": "base-io-access",
          "signature": "io FilePath",
          "source": "src/Access-System-Environment.html#getExecutablePath%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "getExecutablePath'",
          "package": "base-io-access",
          "partial": "Executable Path'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:getExecutablePath-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "getProgName'",
          "package": "base-io-access",
          "signature": "io String",
          "source": "src/Access-System-Environment.html#getProgName%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "getProgName'",
          "package": "base-io-access",
          "partial": "Prog Name'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:getProgName-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "lookupEnv'",
          "package": "base-io-access",
          "signature": "String -\u003e io (Maybe String)",
          "source": "src/Access-System-Environment.html#lookupEnv%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "lookupEnv'",
          "normalized": "String-\u003ea(Maybe String)",
          "package": "base-io-access",
          "partial": "Env'",
          "signature": "String-\u003eio(Maybe String)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:lookupEnv-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "withArgs'",
          "package": "base-io-access",
          "signature": "[String] -\u003e IO a -\u003e io a",
          "source": "src/Access-System-Environment.html#withArgs%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "withArgs'",
          "normalized": "[String]-\u003eIO a-\u003eb a",
          "package": "base-io-access",
          "partial": "Args'",
          "signature": "[String]-\u003eIO a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:withArgs-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Environment",
          "name": "withProgName'",
          "package": "base-io-access",
          "signature": "String -\u003e IO a -\u003e io a",
          "source": "src/Access-System-Environment.html#withProgName%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Environment",
          "module": "Access.System.Environment",
          "name": "withProgName'",
          "normalized": "String-\u003eIO a-\u003eb a",
          "package": "base-io-access",
          "partial": "Prog Name'",
          "signature": "String-\u003eIO a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Environment.html#v:withProgName-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Exit",
          "name": "Exit",
          "package": "base-io-access",
          "source": "src/Access-System-Exit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System Exit",
          "module": "Access.System.Exit",
          "name": "Exit",
          "package": "base-io-access",
          "partial": "Exit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Exit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Exit",
          "name": "ExitAccess",
          "package": "base-io-access",
          "source": "src/Access-System-Exit.html#ExitAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System Exit",
          "module": "Access.System.Exit",
          "name": "ExitAccess",
          "package": "base-io-access",
          "partial": "Exit Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Exit.html#t:ExitAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Exit",
          "name": "exitFailure'",
          "package": "base-io-access",
          "signature": "io a",
          "source": "src/Access-System-Exit.html#exitFailure%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Exit",
          "module": "Access.System.Exit",
          "name": "exitFailure'",
          "package": "base-io-access",
          "partial": "Failure'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Exit.html#v:exitFailure-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Exit",
          "name": "exitSuccess'",
          "package": "base-io-access",
          "signature": "io a",
          "source": "src/Access-System-Exit.html#exitSuccess%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Exit",
          "module": "Access.System.Exit",
          "name": "exitSuccess'",
          "package": "base-io-access",
          "partial": "Success'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Exit.html#v:exitSuccess-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Exit",
          "name": "exitWith'",
          "package": "base-io-access",
          "signature": "ExitCode -\u003e io a",
          "source": "src/Access-System-Exit.html#exitWith%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Exit",
          "module": "Access.System.Exit",
          "name": "exitWith'",
          "normalized": "ExitCode-\u003ea b",
          "package": "base-io-access",
          "partial": "With'",
          "signature": "ExitCode-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Exit.html#v:exitWith-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO.Error",
          "name": "Error",
          "package": "base-io-access",
          "source": "src/Access-System-IO-Error.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System IO Error",
          "module": "Access.System.IO.Error",
          "name": "Error",
          "package": "base-io-access",
          "partial": "Error",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO-Error.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO.Error",
          "name": "IOErrorAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO-Error.html#IOErrorAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System IO Error",
          "module": "Access.System.IO.Error",
          "name": "IOErrorAccess",
          "package": "base-io-access",
          "partial": "IOError Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO-Error.html#t:IOErrorAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO.Error",
          "name": "catchIOError'",
          "package": "base-io-access",
          "signature": "io a -\u003e (IOError -\u003e io a) -\u003e io a",
          "source": "src/Access-System-IO-Error.html#catchIOError%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System IO Error",
          "module": "Access.System.IO.Error",
          "name": "catchIOError'",
          "normalized": "a b-\u003e(IOError-\u003ea b)-\u003ea b",
          "package": "base-io-access",
          "partial": "IOError'",
          "signature": "io a-\u003e(IOError-\u003eio a)-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO-Error.html#v:catchIOError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO.Error",
          "name": "ioError'",
          "package": "base-io-access",
          "signature": "IOError -\u003e io a",
          "source": "src/Access-System-IO-Error.html#ioError%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System IO Error",
          "module": "Access.System.IO.Error",
          "name": "ioError'",
          "normalized": "IOError-\u003ea b",
          "package": "base-io-access",
          "partial": "Error'",
          "signature": "IOError-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO-Error.html#v:ioError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO.Error",
          "name": "modifyIOError'",
          "package": "base-io-access",
          "signature": "(IOError -\u003e IOError) -\u003e io a -\u003e io a",
          "source": "src/Access-System-IO-Error.html#modifyIOError%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System IO Error",
          "module": "Access.System.IO.Error",
          "name": "modifyIOError'",
          "normalized": "(IOError-\u003eIOError)-\u003ea b-\u003ea b",
          "package": "base-io-access",
          "partial": "IOError'",
          "signature": "(IOError-\u003eIOError)-\u003eio a-\u003eio a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO-Error.html#v:modifyIOError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO.Error",
          "name": "tryIOError'",
          "package": "base-io-access",
          "signature": "io a -\u003e io (Either IOError a)",
          "source": "src/Access-System-IO-Error.html#tryIOError%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System IO Error",
          "module": "Access.System.IO.Error",
          "name": "tryIOError'",
          "normalized": "a b-\u003ea(Either IOError b)",
          "package": "base-io-access",
          "partial": "IOError'",
          "signature": "io a-\u003eio(Either IOError a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO-Error.html#v:tryIOError-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.IO",
          "name": "IO",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "IO",
          "package": "base-io-access",
          "partial": "IO",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines \u003ccode\u003e\u003ca\u003eHandleAccess\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFileReadAccess\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eFileWriteAccess\u003c/a\u003e\u003c/code\u003e for\n manipulating files (this does allow for general \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e access and should be\n considered unsafe)\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "FileAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#FileAccess",
          "type": "class"
        },
        "index": {
          "description": "Combines HandleAccess FileReadAccess and FileWriteAccess for manipulating files this does allow for general Handle access and should be considered unsafe",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "FileAccess",
          "package": "base-io-access",
          "partial": "File Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:FileAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides the function \u003ccode\u003e\u003ca\u003ereadFile'\u003c/a\u003e\u003c/code\u003e for reading the contents of a file\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "FileReadAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#FileReadAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides the function readFile for reading the contents of file",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "FileReadAccess",
          "package": "base-io-access",
          "partial": "File Read Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:FileReadAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides functions for writing to files\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "FileWriteAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#FileWriteAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides functions for writing to files",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "FileWriteAccess",
          "package": "base-io-access",
          "partial": "File Write Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:FileWriteAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines the \u003ccode\u003e\u003ca\u003eHandleWriteAccess\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eHandleReadAccess\u003c/a\u003e\u003c/code\u003e classes and adds\n additional miscellaneous functions for \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e manipulation\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "HandleAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#HandleAccess",
          "type": "class"
        },
        "index": {
          "description": "Combines the HandleWriteAccess and HandleReadAccess classes and adds additional miscellaneous functions for Handle manipulation",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "HandleAccess",
          "package": "base-io-access",
          "partial": "Handle Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:HandleAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e read functions\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "HandleReadAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#HandleReadAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides access to Handle read functions",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "HandleReadAccess",
          "package": "base-io-access",
          "partial": "Handle Read Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:HandleReadAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e write functions\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "HandleWriteAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#HandleWriteAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides access to Handle write functions",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "HandleWriteAccess",
          "package": "base-io-access",
          "partial": "Handle Write Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:HandleWriteAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines the \u003ccode\u003e\u003ca\u003eStdInAccess\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eStdOutAccess\u003c/a\u003e\u003c/code\u003e into a single class\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "StdIOAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#StdIOAccess",
          "type": "class"
        },
        "index": {
          "description": "Combines the StdInAccess and StdOutAccess into single class",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "StdIOAccess",
          "package": "base-io-access",
          "partial": "Std IOAccess",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:StdIOAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to functions to read from \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "StdInAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#StdInAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides access to functions to read from stdin",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "StdInAccess",
          "package": "base-io-access",
          "partial": "Std In Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:StdInAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to functions to write to \u003ccode\u003e\u003ca\u003estdout\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "StdOutAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#StdOutAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides access to functions to write to stdout",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "StdOutAccess",
          "package": "base-io-access",
          "partial": "Std Out Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:StdOutAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to functions for opening temporary file \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003es\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "TempFileAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#TempFileAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides access to functions for opening temporary file Handle",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "TempFileAccess",
          "package": "base-io-access",
          "partial": "Temp File Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:TempFileAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to \u003ccode\u003e\u003ca\u003emkTextEncoding'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "TextEncodingAccess",
          "package": "base-io-access",
          "source": "src/Access-System-IO.html#TextEncodingAccess",
          "type": "class"
        },
        "index": {
          "description": "Provides access to mkTextEncoding",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "TextEncodingAccess",
          "package": "base-io-access",
          "partial": "Text Encoding Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#t:TextEncodingAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eappendFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003eappendFile'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile str\u003c/code\u003e function appends the string\n \u003ccode\u003estr\u003c/code\u003e, to the file \u003ccode\u003efile\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003ewriteFile'\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eappendFile'\u003c/a\u003e\u003c/code\u003e write a literal string\n to a file.  To write a value of any printable type, as with \u003ccode\u003e\u003ca\u003eprint'\u003c/a\u003e\u003c/code\u003e,\n use the \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e function to convert the value to a string first.\n\u003c/p\u003e\u003cpre\u003e main = appendFile' \"squares\" (show [(x,x*x) | x \u003c- [0,0.1..2]])\n\u003c/pre\u003e",
          "module": "Access.System.IO",
          "name": "appendFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e String -\u003e io ()",
          "source": "src/Access-System-IO.html#appendFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps appendFile The computation appendFile file str function appends the string str to the file file Note that writeFile and appendFile write literal string to file To write value of any printable type as with print use the show function to convert the value to string first main appendFile squares show",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "appendFile'",
          "normalized": "FilePath-\u003eString-\u003ea()",
          "package": "base-io-access",
          "partial": "File'",
          "signature": "FilePath-\u003eString-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:appendFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003egetChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eRead a character from the standard input device\n (same as \u003ccode\u003e\u003ca\u003ehGetChar'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "getChar'",
          "package": "base-io-access",
          "signature": "io Char",
          "source": "src/Access-System-IO.html#getChar%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps getChar Read character from the standard input device same as hGetChar stdin",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "getChar'",
          "package": "base-io-access",
          "partial": "Char'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:getChar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003egetContents\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egetContents\u003c/a\u003e\u003c/code\u003e operation returns all user input as a single string,\n which is read lazily as it is needed (same as \u003ccode\u003e\u003ca\u003ehGetContents'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "getContents'",
          "package": "base-io-access",
          "signature": "io String",
          "source": "src/Access-System-IO.html#getContents%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps getContents The getContents operation returns all user input as single string which is read lazily as it is needed same as hGetContents stdin",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "getContents'",
          "package": "base-io-access",
          "partial": "Contents'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:getContents-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003egetLine\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eRead a line from the standard input device (same as \u003ccode\u003e\u003ca\u003ehGetLine'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdin\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "getLine'",
          "package": "base-io-access",
          "signature": "io String",
          "source": "src/Access-System-IO.html#getLine%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps getLine Read line from the standard input device same as hGetLine stdin",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "getLine'",
          "package": "base-io-access",
          "partial": "Line'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:getLine-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehClose\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehClose'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e makes handle \u003ccode\u003ehdl\u003c/code\u003e closed.  Before the\n computation finishes, if \u003ccode\u003ehdl\u003c/code\u003e is writable its buffer is flushed as\n for \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e.\n Performing \u003ccode\u003e\u003ca\u003ehClose'\u003c/a\u003e\u003c/code\u003e on a handle that has already been closed has no\n effect; doing so is not an error.  All other operations on a closed\n handle will fail.  If \u003ccode\u003e\u003ca\u003ehClose'\u003c/a\u003e\u003c/code\u003e fails for any reason, any further\n operations (apart from \u003ccode\u003e\u003ca\u003ehClose'\u003c/a\u003e\u003c/code\u003e) on the handle will still fail as if\n \u003ccode\u003ehdl\u003c/code\u003e had been successfully closed.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hClose'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io ()",
          "source": "src/Access-System-IO.html#hClose%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hClose Computation hClose hdl makes handle hdl closed Before the computation finishes if hdl is writable its buffer is flushed as for hFlush Performing hClose on handle that has already been closed has no effect doing so is not an error All other operations on closed handle will fail If hClose fails for any reason any further operations apart from hClose on the handle will still fail as if hdl had been successfully closed",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hClose'",
          "normalized": "Handle-\u003ea()",
          "package": "base-io-access",
          "partial": "Close'",
          "signature": "Handle-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hClose-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehFileSize\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eFor a handle \u003ccode\u003ehdl\u003c/code\u003e which attached to a physical file, \u003ccode\u003e\u003ca\u003ehFileSize\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e\n returns the size of that file in 8-bit bytes.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hFileSize'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Integer",
          "source": "src/Access-System-IO.html#hFileSize%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hFileSize For handle hdl which attached to physical file hFileSize hdl returns the size of that file in bit bytes",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hFileSize'",
          "normalized": "Handle-\u003ea Integer",
          "package": "base-io-access",
          "partial": "File Size'",
          "signature": "Handle-\u003eio Integer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hFileSize-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehFlush\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe action \u003ccode\u003e\u003ca\u003ehFlush'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e causes any items buffered for output\n in handle \u003ccode\u003ehdl\u003c/code\u003e to be sent immediately to the operating system.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if a system resource limit would\n    be exceeded.  It is unspecified whether the characters in the buffer\n    are discarded or retained under these circumstances.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hFlush'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io ()",
          "source": "src/Access-System-IO.html#hFlush%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hFlush The action hFlush hdl causes any items buffered for output in handle hdl to be sent immediately to the operating system This operation may fail with isFullError if the device is full isPermissionError if system resource limit would be exceeded It is unspecified whether the characters in the buffer are discarded or retained under these circumstances",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hFlush'",
          "normalized": "Handle-\u003ea()",
          "package": "base-io-access",
          "partial": "Flush'",
          "signature": "Handle-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hFlush-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e into the\n buffer \u003ccode\u003ebuf\u003c/code\u003e until either EOF is reached or \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes have been\n read.  It returns the number of bytes actually read.  This may be zero if\n EOF was reached before any data was read (or if \u003ccode\u003ecount\u003c/code\u003e is zero).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e never raises an EOF exception, instead it returns a value\n smaller than \u003ccode\u003ecount\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e\n on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetBuf'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e io Int",
          "source": "src/Access-System-IO.html#hGetBuf%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetBuf hGetBuf hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count bit bytes have been read It returns the number of bytes actually read This may be zero if EOF was reached before any data was read or if count is zero hGetBuf never raises an EOF exception instead it returns value smaller than count If the handle is pipe or socket and the writing end is closed hGetBuf will behave as if EOF was reached hGetBuf ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetBuf'",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eb Int",
          "package": "base-io-access",
          "partial": "Get Buf'",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eio Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetBuf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e\n into the buffer \u003ccode\u003ebuf\u003c/code\u003e until either EOF is reached, or\n \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes have been read, or there is no more data available\n to read immediately.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e is identical to \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e, except that it will\n never block waiting for data to become available, instead it returns\n only whatever data is available.  To wait for data to arrive before\n calling \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e\u003cp\u003eNOTE: on Windows, this function does not work correctly; it\n behaves identically to \u003ccode\u003e\u003ca\u003ehGetBuf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetBufNonBlocking'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e io Int",
          "source": "src/Access-System-IO.html#hGetBufNonBlocking%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetBufNonBlocking hGetBufNonBlocking hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count bit bytes have been read or there is no more data available to read immediately hGetBufNonBlocking is identical to hGetBuf except that it will never block waiting for data to become available instead it returns only whatever data is available To wait for data to arrive before calling hGetBufNonBlocking use hWaitForInput If the handle is pipe or socket and the writing end is closed hGetBufNonBlocking will behave as if EOF was reached hGetBufNonBlocking ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly NOTE on Windows this function does not work correctly it behaves identically to hGetBuf",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetBufNonBlocking'",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eb Int",
          "package": "base-io-access",
          "partial": "Get Buf Non Blocking'",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eio Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetBufNonBlocking-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e\n into the buffer \u003ccode\u003ebuf\u003c/code\u003e.  If there is any data available to read,\n then \u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e returns it immediately; it only blocks if there\n is no data to be read.\n\u003c/p\u003e\u003cp\u003eIt returns the number of bytes actually read.  This may be zero if\n EOF was reached before any data was read (or if \u003ccode\u003ecount\u003c/code\u003e is zero).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e never raises an EOF exception, instead it returns a value\n smaller than \u003ccode\u003ecount\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufSome\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e\n on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetBufSome'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e io Int",
          "source": "src/Access-System-IO.html#hGetBufSome%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetBufSome hGetBufSome hdl buf count reads data from the handle hdl into the buffer buf If there is any data available to read then hGetBufSome returns it immediately it only blocks if there is no data to be read It returns the number of bytes actually read This may be zero if EOF was reached before any data was read or if count is zero hGetBufSome never raises an EOF exception instead it returns value smaller than count If the handle is pipe or socket and the writing end is closed hGetBufSome will behave as if EOF was reached hGetBufSome ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetBufSome'",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eb Int",
          "package": "base-io-access",
          "partial": "Get Buf Some'",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eio Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetBufSome-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetBuffering\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetBuffering'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the current buffering mode\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetBuffering'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io BufferMode",
          "source": "src/Access-System-IO.html#hGetBuffering%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetBuffering Computation hGetBuffering hdl returns the current buffering mode",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetBuffering'",
          "normalized": "Handle-\u003ea BufferMode",
          "package": "base-io-access",
          "partial": "Get Buffering'",
          "signature": "Handle-\u003eio BufferMode",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetBuffering-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetChar'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e reads a character from the file or\n channel managed by \u003ccode\u003ehdl\u003c/code\u003e, blocking until a character is available.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hGetChar'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Char",
          "source": "src/Access-System-IO.html#hGetChar%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetChar Computation hGetChar hdl reads character from the file or channel managed by hdl blocking until character is available This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetChar'",
          "normalized": "Handle-\u003ea Char",
          "package": "base-io-access",
          "partial": "Get Char'",
          "signature": "Handle-\u003eio Char",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetChar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetContents\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetContents'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the list of characters\n corresponding to the unread portion of the channel or file managed\n by \u003ccode\u003ehdl\u003c/code\u003e, which is put into an intermediate state, \u003cem\u003esemi-closed\u003c/em\u003e.\n In this state, \u003ccode\u003ehdl\u003c/code\u003e is effectively closed,\n but items are read from \u003ccode\u003ehdl\u003c/code\u003e on demand and accumulated in a special\n list returned by \u003ccode\u003e\u003ca\u003ehGetContents'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAny operation that fails because a handle is closed,\n also fails if a handle is semi-closed.  The only exception is \u003ccode\u003e\u003ca\u003ehClose'\u003c/a\u003e\u003c/code\u003e.\n A semi-closed handle becomes closed:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if \u003ccode\u003e\u003ca\u003ehClose'\u003c/a\u003e\u003c/code\u003e is applied to it;\n\u003c/li\u003e\u003cli\u003e if an I/O error occurs when reading an item from the handle;\n\u003c/li\u003e\u003cli\u003e or once the entire contents of the handle has been read.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOnce a semi-closed handle becomes closed, the contents of the\n associated list becomes fixed.  The contents of this final list is\n only partially specified: it will contain at least all the items of\n the stream that were evaluated prior to the handle becoming closed.\n\u003c/p\u003e\u003cp\u003eAny I/O errors encountered while a handle is semi-closed are simply\n discarded.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hGetContents'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io String",
          "source": "src/Access-System-IO.html#hGetContents%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetContents Computation hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl which is put into an intermediate state semi-closed In this state hdl is effectively closed but items are read from hdl on demand and accumulated in special list returned by hGetContents hdl Any operation that fails because handle is closed also fails if handle is semi-closed The only exception is hClose semi-closed handle becomes closed if hClose is applied to it if an error occurs when reading an item from the handle or once the entire contents of the handle has been read Once semi-closed handle becomes closed the contents of the associated list becomes fixed The contents of this final list is only partially specified it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed Any errors encountered while handle is semi-closed are simply discarded This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetContents'",
          "normalized": "Handle-\u003ea String",
          "package": "base-io-access",
          "partial": "Get Contents'",
          "signature": "Handle-\u003eio String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetContents-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetEcho\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eGet the echoing status of a handle connected to a terminal.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetEcho'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hGetEcho%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetEcho Get the echoing status of handle connected to terminal",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetEcho'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Get Echo'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetEcho-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetEncoding\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eReturn the current \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e for the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, or\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e is in binary mode.\n\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e remembers nothing about the state of\n the encoder/decoder in use on this \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.  For example, if the\n encoding in use is UTF-16, then using \u003ccode\u003e\u003ca\u003ehGetEncoding'\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003ehSetEncoding'\u003c/a\u003e\u003c/code\u003e to save and restore the encoding may result in an\n extra byte-order-mark being written to the file.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetEncoding'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io (Maybe TextEncoding)",
          "source": "src/Access-System-IO.html#hGetEncoding%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetEncoding Return the current TextEncoding for the specified Handle or Nothing if the Handle is in binary mode Note that the TextEncoding remembers nothing about the state of the encoder decoder in use on this Handle For example if the encoding in use is UTF-16 then using hGetEncoding and hSetEncoding to save and restore the encoding may result in an extra byte-order-mark being written to the file",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetEncoding'",
          "normalized": "Handle-\u003ea(Maybe TextEncoding)",
          "package": "base-io-access",
          "partial": "Get Encoding'",
          "signature": "Handle-\u003eio(Maybe TextEncoding)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetEncoding-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetLine\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetLine'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e reads a line from the file or\n channel managed by \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file is encountered when reading\n    the \u003cem\u003efirst\u003c/em\u003e character of the line.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIf \u003ccode\u003e\u003ca\u003ehGetLine'\u003c/a\u003e\u003c/code\u003e encounters end-of-file at any other point while reading\n in a line, it is treated as a line terminator and the (partial)\n line is returned.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetLine'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io String",
          "source": "src/Access-System-IO.html#hGetLine%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetLine Computation hGetLine hdl reads line from the file or channel managed by hdl This operation may fail with isEOFError if the end of file is encountered when reading the first character of the line If hGetLine encounters end-of-file at any other point while reading in line it is treated as line terminator and the partial line is returned",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetLine'",
          "normalized": "Handle-\u003ea String",
          "package": "base-io-access",
          "partial": "Get Line'",
          "signature": "Handle-\u003eio String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetLine-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehGetPosn\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehGetPosn'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the current I/O position of\n \u003ccode\u003ehdl\u003c/code\u003e as a value of the abstract type \u003ccode\u003e\u003ca\u003eHandlePosn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hGetPosn'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io HandlePosn",
          "source": "src/Access-System-IO.html#hGetPosn%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hGetPosn Computation hGetPosn hdl returns the current position of hdl as value of the abstract type HandlePosn",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hGetPosn'",
          "normalized": "Handle-\u003ea HandlePosn",
          "package": "base-io-access",
          "partial": "Get Posn'",
          "signature": "Handle-\u003eio HandlePosn",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hGetPosn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsClosed\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsClosed'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsClosed%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsClosed",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsClosed'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is Closed'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsClosed-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsEOF\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eFor a readable handle \u003ccode\u003ehdl\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehIsEOF'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if no further input can be taken from \u003ccode\u003ehdl\u003c/code\u003e or for a\n physical file, if the current I/O position is equal to the length of\n the file.  Otherwise, it returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNOTE: \u003ccode\u003e\u003ca\u003ehIsEOF'\u003c/a\u003e\u003c/code\u003e may block, because it has to attempt to read from\n the stream to determine whether there is any more data to be read.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsEOF'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsEOF%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsEOF For readable handle hdl hIsEOF hdl returns True if no further input can be taken from hdl or for physical file if the current position is equal to the length of the file Otherwise it returns False NOTE hIsEOF may block because it has to attempt to read from the stream to determine whether there is any more data to be read",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsEOF'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is EOF'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsEOF-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsOpen\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsOpen'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsOpen%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsOpen",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsOpen'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is Open'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsOpen-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsReadable\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsReadable'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsReadable%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsReadable",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsReadable'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is Readable'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsReadable-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsSeekable\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsSeekable'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsSeekable%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsSeekable",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsSeekable'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is Seekable'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsSeekable-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsTerminalDevice\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIs the handle connected to a terminal?\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsTerminalDevice'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsTerminalDevice%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsTerminalDevice Is the handle connected to terminal",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsTerminalDevice'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is Terminal Device'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsTerminalDevice-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehIsWritable\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hIsWritable'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hIsWritable%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hIsWritable",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hIsWritable'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Is Writable'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hIsWritable-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehLookAhead\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehLookAhead\u003c/a\u003e\u003c/code\u003e returns the next character from the handle\n without removing it from the input buffer, blocking until a character\n is available.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hLookAhead'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Char",
          "source": "src/Access-System-IO.html#hLookAhead%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hLookAhead Computation hLookAhead returns the next character from the handle without removing it from the input buffer blocking until character is available This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hLookAhead'",
          "normalized": "Handle-\u003ea Char",
          "package": "base-io-access",
          "partial": "Look Ahead'",
          "signature": "Handle-\u003eio Char",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hLookAhead-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehPrint\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehPrint'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl t\u003c/code\u003e writes the string representation of \u003ccode\u003et\u003c/code\u003e\n given by the \u003ccode\u003e\u003ca\u003eshows\u003c/a\u003e\u003c/code\u003e function to the file or channel managed\n by \u003ccode\u003ehdl\u003c/code\u003e and appends a newline.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if another system resource limit would be exceeded\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hPrint'",
          "package": "base-io-access",
          "signature": "Handle -\u003e a -\u003e io ()",
          "source": "src/Access-System-IO.html#hPrint%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hPrint Computation hPrint hdl writes the string representation of given by the shows function to the file or channel managed by hdl and appends newline This operation may fail with isFullError if the device is full or isPermissionError if another system resource limit would be exceeded",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hPrint'",
          "normalized": "Handle-\u003ea-\u003eb()",
          "package": "base-io-access",
          "partial": "Print'",
          "signature": "Handle-\u003ea-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hPrint-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehPutBuf\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehPutBuf'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e writes \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes from the\n buffer \u003ccode\u003ebuf\u003c/code\u003e to the handle \u003ccode\u003ehdl\u003c/code\u003e.  It returns ().\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehPutBuf'\u003c/a\u003e\u003c/code\u003e ignores any text encoding that applies to the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e,\n writing the bytes directly to the underlying file or device.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehPutBuf'\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and writes bytes directly.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eResourceVanished\u003c/code\u003e if the handle is a pipe or socket, and the\n    reading end is closed.  (If this is a POSIX system, and the program\n    has not asked to ignore SIGPIPE, then a SIGPIPE may be delivered\n    instead, whose default action is to terminate the program).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hPutBuf'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e io ()",
          "source": "src/Access-System-IO.html#hPutBuf%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hPutBuf hPutBuf hdl buf count writes count bit bytes from the buffer buf to the handle hdl It returns hPutBuf ignores any text encoding that applies to the Handle writing the bytes directly to the underlying file or device hPutBuf ignores the prevailing TextEncoding and NewlineMode on the Handle and writes bytes directly This operation may fail with ResourceVanished if the handle is pipe or socket and the reading end is closed If this is POSIX system and the program has not asked to ignore SIGPIPE then SIGPIPE may be delivered instead whose default action is to terminate the program",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hPutBuf'",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eb()",
          "package": "base-io-access",
          "partial": "Put Buf'",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hPutBuf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehPutBufNonBlocking\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl buf count\u003c/code\u003e reads data from the handle \u003ccode\u003ehdl\u003c/code\u003e\n into the buffer \u003ccode\u003ebuf\u003c/code\u003e until either EOF is reached, or\n \u003ccode\u003ecount\u003c/code\u003e 8-bit bytes have been read, or there is no more data available\n to read immediately.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking'\u003c/a\u003e\u003c/code\u003e is identical to \u003ccode\u003e\u003ca\u003ehGetBuf'\u003c/a\u003e\u003c/code\u003e, except that it will\n never block waiting for data to become available, instead it returns\n only whatever data is available.  To wait for data to arrive before\n calling \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking'\u003c/a\u003e\u003c/code\u003e, use \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the handle is a pipe or socket, and the writing end\n is closed, \u003ccode\u003e\u003ca\u003ehGetBufNonBlocking'\u003c/a\u003e\u003c/code\u003e will behave as if EOF was reached.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehGetBufNonBlocking'\u003c/a\u003e\u003c/code\u003e ignores the prevailing \u003ccode\u003e\u003ca\u003eTextEncoding\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, and reads bytes directly.\n\u003c/p\u003e\u003cp\u003eNOTE: on Windows, this function does not work correctly; it\n behaves identically to \u003ccode\u003e\u003ca\u003ehGetBuf'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hPutBufNonBlocking'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Ptr a -\u003e Int -\u003e io Int",
          "source": "src/Access-System-IO.html#hPutBufNonBlocking%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hPutBufNonBlocking hGetBufNonBlocking hdl buf count reads data from the handle hdl into the buffer buf until either EOF is reached or count bit bytes have been read or there is no more data available to read immediately hGetBufNonBlocking is identical to hGetBuf except that it will never block waiting for data to become available instead it returns only whatever data is available To wait for data to arrive before calling hGetBufNonBlocking use hWaitForInput If the handle is pipe or socket and the writing end is closed hGetBufNonBlocking will behave as if EOF was reached hGetBufNonBlocking ignores the prevailing TextEncoding and NewlineMode on the Handle and reads bytes directly NOTE on Windows this function does not work correctly it behaves identically to hGetBuf",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hPutBufNonBlocking'",
          "normalized": "Handle-\u003ePtr a-\u003eInt-\u003eb Int",
          "package": "base-io-access",
          "partial": "Put Buf Non Blocking'",
          "signature": "Handle-\u003ePtr a-\u003eInt-\u003eio Int",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hPutBufNonBlocking-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehPutChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehPutChar'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl ch\u003c/code\u003e writes the character \u003ccode\u003ech\u003c/code\u003e to the\n file or channel managed by \u003ccode\u003ehdl\u003c/code\u003e.  Characters may be buffered if\n buffering is enabled for \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if another system resource limit would be exceeded\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hPutChar'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Char -\u003e io ()",
          "source": "src/Access-System-IO.html#hPutChar%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hPutChar Computation hPutChar hdl ch writes the character ch to the file or channel managed by hdl Characters may be buffered if buffering is enabled for hdl This operation may fail with isFullError if the device is full or isPermissionError if another system resource limit would be exceeded",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hPutChar'",
          "normalized": "Handle-\u003eChar-\u003ea()",
          "package": "base-io-access",
          "partial": "Put Char'",
          "signature": "Handle-\u003eChar-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hPutChar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehPutStr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehPutStr'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl s\u003c/code\u003e writes the string \u003ccode\u003es\u003c/code\u003e to the file or\n channel managed by \u003ccode\u003ehdl\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisFullError\u003c/a\u003e\u003c/code\u003e if the device is full; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if another system resource limit would be exceeded\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hPutStr'",
          "package": "base-io-access",
          "signature": "Handle -\u003e String -\u003e io ()",
          "source": "src/Access-System-IO.html#hPutStr%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hPutStr Computation hPutStr hdl writes the string to the file or channel managed by hdl This operation may fail with isFullError if the device is full or isPermissionError if another system resource limit would be exceeded",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hPutStr'",
          "normalized": "Handle-\u003eString-\u003ea()",
          "package": "base-io-access",
          "partial": "Put Str'",
          "signature": "Handle-\u003eString-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hPutStr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehPutStrLn\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003ehPutStr'\u003c/a\u003e\u003c/code\u003e, but adds a newline character\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hPutStrLn'",
          "package": "base-io-access",
          "signature": "Handle -\u003e String -\u003e io ()",
          "source": "src/Access-System-IO.html#hPutStrLn%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hPutStrLn The same as hPutStr but adds newline character",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hPutStrLn'",
          "normalized": "Handle-\u003eString-\u003ea()",
          "package": "base-io-access",
          "partial": "Put Str Ln'",
          "signature": "Handle-\u003eString-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hPutStrLn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehReady\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehReady'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e indicates whether at least one item is\n available for input from handle \u003ccode\u003ehdl\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hReady'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Bool",
          "source": "src/Access-System-IO.html#hReady%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hReady Computation hReady hdl indicates whether at least one item is available for input from handle hdl This operation may fail with isEOFError if the end of file has been reached",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hReady'",
          "normalized": "Handle-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Ready'",
          "signature": "Handle-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hReady-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSeek\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehSeek'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl mode i\u003c/code\u003e sets the position of handle\n \u003ccode\u003ehdl\u003c/code\u003e depending on \u003ccode\u003emode\u003c/code\u003e.\n The offset \u003ccode\u003ei\u003c/code\u003e is given in terms of 8-bit bytes.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003ehdl\u003c/code\u003e is block- or line-buffered, then seeking to a position which is\n not in the current buffer will first cause any items in the output buffer\n to be written to the device, and then cause the input buffer to be\n discarded. Some handles may not be seekable (see \u003ccode\u003e\u003ca\u003ehIsSeekable'\u003c/a\u003e\u003c/code\u003e), or only\n support a subset of the possible positioning operations (for instance, it\n may only be possible to seek to the end of a tape, or to a positive\n offset from the beginning or current position).\n It is not possible to set a negative I/O position, or for\n a physical file, an I/O position beyond the current end-of-file.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisIllegalOperationError\u003c/a\u003e\u003c/code\u003e if the Handle is not\n    seekable, or does not support the requested seek mode.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if a system resource limit would\n    be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hSeek'",
          "package": "base-io-access",
          "signature": "Handle -\u003e SeekMode -\u003e Integer -\u003e io ()",
          "source": "src/Access-System-IO.html#hSeek%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSeek Computation hSeek hdl mode sets the position of handle hdl depending on mode The offset is given in terms of bit bytes If hdl is block or line-buffered then seeking to position which is not in the current buffer will first cause any items in the output buffer to be written to the device and then cause the input buffer to be discarded Some handles may not be seekable see hIsSeekable or only support subset of the possible positioning operations for instance it may only be possible to seek to the end of tape or to positive offset from the beginning or current position It is not possible to set negative position or for physical file an position beyond the current end-of-file This operation may fail with isIllegalOperationError if the Handle is not seekable or does not support the requested seek mode isPermissionError if system resource limit would be exceeded",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSeek'",
          "normalized": "Handle-\u003eSeekMode-\u003eInteger-\u003ea()",
          "package": "base-io-access",
          "partial": "Seek'",
          "signature": "Handle-\u003eSeekMode-\u003eInteger-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSeek-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSetBuffering\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehSetBuffering'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl mode\u003c/code\u003e sets the mode of buffering for\n handle \u003ccode\u003ehdl\u003c/code\u003e on subsequent reads and writes.\n\u003c/p\u003e\u003cp\u003eIf the buffer mode is changed from \u003ccode\u003e\u003ca\u003eBlockBuffering\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eLineBuffering\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eNoBuffering\u003c/a\u003e\u003c/code\u003e, then\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if \u003ccode\u003ehdl\u003c/code\u003e is writable, the buffer is flushed as for \u003ccode\u003e\u003ca\u003ehFlush'\u003c/a\u003e\u003c/code\u003e;\n\u003c/li\u003e\u003cli\u003e if \u003ccode\u003ehdl\u003c/code\u003e is not writable, the contents of the buffer is discarded.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if the handle has already been\n    used for reading or writing and the implementation does not allow the\n    buffering mode to be changed.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hSetBuffering'",
          "package": "base-io-access",
          "signature": "Handle -\u003e BufferMode -\u003e io ()",
          "source": "src/Access-System-IO.html#hSetBuffering%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSetBuffering Computation hSetBuffering hdl mode sets the mode of buffering for handle hdl on subsequent reads and writes If the buffer mode is changed from BlockBuffering or LineBuffering to NoBuffering then if hdl is writable the buffer is flushed as for hFlush if hdl is not writable the contents of the buffer is discarded This operation may fail with isPermissionError if the handle has already been used for reading or writing and the implementation does not allow the buffering mode to be changed",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSetBuffering'",
          "normalized": "Handle-\u003eBufferMode-\u003ea()",
          "package": "base-io-access",
          "partial": "Set Buffering'",
          "signature": "Handle-\u003eBufferMode-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSetBuffering-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSetEcho\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eSet the echoing status of a handle connected to a terminal.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hSetEcho'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Bool -\u003e io ()",
          "source": "src/Access-System-IO.html#hSetEcho%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSetEcho Set the echoing status of handle connected to terminal",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSetEcho'",
          "normalized": "Handle-\u003eBool-\u003ea()",
          "package": "base-io-access",
          "partial": "Set Echo'",
          "signature": "Handle-\u003eBool-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSetEcho-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSetEncoding\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe action \u003ccode\u003e\u003ca\u003ehSetEncoding'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e \u003ccode\u003eencoding\u003c/code\u003e changes the text encoding\n for the handle \u003ccode\u003ehdl\u003c/code\u003e to \u003ccode\u003eencoding\u003c/code\u003e.  The default encoding when a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e\n is created is \u003ccode\u003e\u003ca\u003elocaleEncoding\u003c/a\u003e\u003c/code\u003e, namely the default encoding for the\n current locale.\n\u003c/p\u003e\u003cp\u003eTo create a \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e with no encoding at all, use \u003ccode\u003e\u003ca\u003eopenBinaryFile'\u003c/a\u003e\u003c/code\u003e.  To\n stop further encoding or decoding on an existing \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e, use\n \u003ccode\u003ehSetBinaryMode'\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehSetEncoding'\u003c/a\u003e\u003c/code\u003e may need to flush buffered data in order to change\n the encoding.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hSetEncoding'",
          "package": "base-io-access",
          "signature": "Handle -\u003e TextEncoding -\u003e io ()",
          "source": "src/Access-System-IO.html#hSetEncoding%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSetEncoding The action hSetEncoding hdl encoding changes the text encoding for the handle hdl to encoding The default encoding when Handle is created is localeEncoding namely the default encoding for the current locale To create Handle with no encoding at all use openBinaryFile To stop further encoding or decoding on an existing Handle use hSetBinaryMode hSetEncoding may need to flush buffered data in order to change the encoding",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSetEncoding'",
          "normalized": "Handle-\u003eTextEncoding-\u003ea()",
          "package": "base-io-access",
          "partial": "Set Encoding'",
          "signature": "Handle-\u003eTextEncoding-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSetEncoding-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSetFileSize\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehSetFileSize'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e \u003ccode\u003esize\u003c/code\u003e truncates the physical file with handle\n \u003ccode\u003ehdl\u003c/code\u003e to \u003ccode\u003esize\u003c/code\u003e bytes.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hSetFileSize'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Integer -\u003e io ()",
          "source": "src/Access-System-IO.html#hSetFileSize%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSetFileSize hSetFileSize hdl size truncates the physical file with handle hdl to size bytes",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSetFileSize'",
          "normalized": "Handle-\u003eInteger-\u003ea()",
          "package": "base-io-access",
          "partial": "Set File Size'",
          "signature": "Handle-\u003eInteger-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSetFileSize-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSetNewlineMode\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eSet the \u003ccode\u003e\u003ca\u003eNewlineMode\u003c/a\u003e\u003c/code\u003e on the specified \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.  All buffered data is\n flushed first.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hSetNewlineMode'",
          "package": "base-io-access",
          "signature": "Handle -\u003e NewlineMode -\u003e io ()",
          "source": "src/Access-System-IO.html#hSetNewlineMode%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSetNewlineMode Set the NewlineMode on the specified Handle All buffered data is flushed first",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSetNewlineMode'",
          "normalized": "Handle-\u003eNewlineMode-\u003ea()",
          "package": "base-io-access",
          "partial": "Set Newline Mode'",
          "signature": "Handle-\u003eNewlineMode-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSetNewlineMode-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehSetPosn\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eIf a call to \u003ccode\u003e\u003ca\u003ehGetPosn'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns a position \u003ccode\u003ep\u003c/code\u003e,\n then computation \u003ccode\u003e\u003ca\u003ehSetPosn'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ep\u003c/code\u003e sets the position of \u003ccode\u003ehdl\u003c/code\u003e\n to the position it held at the time of the call to \u003ccode\u003e\u003ca\u003ehGetPosn'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if a system resource limit would\n    be exceeded.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hSetPosn'",
          "package": "base-io-access",
          "signature": "HandlePosn -\u003e io ()",
          "source": "src/Access-System-IO.html#hSetPosn%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hSetPosn If call to hGetPosn hdl returns position then computation hSetPosn sets the position of hdl to the position it held at the time of the call to hGetPosn This operation may fail with isPermissionError if system resource limit would be exceeded",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hSetPosn'",
          "normalized": "HandlePosn-\u003ea()",
          "package": "base-io-access",
          "partial": "Set Posn'",
          "signature": "HandlePosn-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hSetPosn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehShow\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ehShow'\u003c/a\u003e\u003c/code\u003e is in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad, and gives more comprehensive output\n than the (pure) instance of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eHandle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hShow'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io String",
          "source": "src/Access-System-IO.html#hShow%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hShow hShow is in the IO monad and gives more comprehensive output than the pure instance of Show for Handle",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hShow'",
          "normalized": "Handle-\u003ea String",
          "package": "base-io-access",
          "partial": "Show'",
          "signature": "Handle-\u003eio String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hShow-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehTell\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehTell'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns the current position of the\n handle \u003ccode\u003ehdl\u003c/code\u003e, as the number of bytes from the beginning of\n the file.  The value returned may be subsequently passed to\n \u003ccode\u003e\u003ca\u003ehSeek\u003c/a\u003e\u003c/code\u003e to reposition the handle to the current position.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisIllegalOperationError\u003c/a\u003e\u003c/code\u003e if the Handle is not seekable.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Access.System.IO",
          "name": "hTell'",
          "package": "base-io-access",
          "signature": "Handle -\u003e io Integer",
          "source": "src/Access-System-IO.html#hTell%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hTell Computation hTell hdl returns the current position of the handle hdl as the number of bytes from the beginning of the file The value returned may be subsequently passed to hSeek to reposition the handle to the current position This operation may fail with isIllegalOperationError if the Handle is not seekable",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hTell'",
          "normalized": "Handle-\u003ea Integer",
          "package": "base-io-access",
          "partial": "Tell'",
          "signature": "Handle-\u003eio Integer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hTell-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ehWaitForInput\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003ehWaitForInput'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl t\u003c/code\u003e\n waits until input is available on handle \u003ccode\u003ehdl\u003c/code\u003e.\n It returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e as soon as input is available on \u003ccode\u003ehdl\u003c/code\u003e,\n or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if no input is available within \u003ccode\u003et\u003c/code\u003e milliseconds.  Note that\n \u003ccode\u003e\u003ca\u003ehWaitForInput'\u003c/a\u003e\u003c/code\u003e waits until one or more full \u003cem\u003echaracters\u003c/em\u003e are available,\n which means that it needs to do decoding, and hence may fail\n with a decoding error.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003et\u003c/code\u003e is less than zero, then \u003ccode\u003ehWaitForInput\u003c/code\u003e waits indefinitely.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisEOFError\u003c/a\u003e\u003c/code\u003e if the end of file has been reached.\n\u003c/li\u003e\u003cli\u003e a decoding error, if the input begins with an invalid byte sequence\n    in this Handle's encoding.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNOTE for GHC users: unless you use the \u003ccode\u003e-threaded\u003c/code\u003e flag,\n \u003ccode\u003ehWaitForInput t\u003c/code\u003e where \u003ccode\u003et \u003e= 0\u003c/code\u003e will block all other Haskell\n threads for the duration of the call.  It behaves like a\n \u003ccode\u003esafe\u003c/code\u003e foreign call in this respect.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "hWaitForInput'",
          "package": "base-io-access",
          "signature": "Handle -\u003e Int -\u003e io Bool",
          "source": "src/Access-System-IO.html#hWaitForInput%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps hWaitForInput Computation hWaitForInput hdl waits until input is available on handle hdl It returns True as soon as input is available on hdl or False if no input is available within milliseconds Note that hWaitForInput waits until one or more full characters are available which means that it needs to do decoding and hence may fail with decoding error If is less than zero then hWaitForInput waits indefinitely This operation may fail with isEOFError if the end of file has been reached decoding error if the input begins with an invalid byte sequence in this Handle encoding NOTE for GHC users unless you use the threaded flag hWaitForInput where will block all other Haskell threads for the duration of the call It behaves like safe foreign call in this respect",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "hWaitForInput'",
          "normalized": "Handle-\u003eInt-\u003ea Bool",
          "package": "base-io-access",
          "partial": "Wait For Input'",
          "signature": "Handle-\u003eInt-\u003eio Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:hWaitForInput-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003einteract\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003einteract'\u003c/a\u003e\u003c/code\u003e function takes a function of type \u003ccode\u003eString-\u003eString\u003c/code\u003e\n as its argument.  The entire input from the standard input device is\n passed to this function as its argument, and the resulting string is\n output on the standard output device.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "interact'",
          "package": "base-io-access",
          "signature": "(String -\u003e String) -\u003e io ()",
          "source": "src/Access-System-IO.html#interact%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps interact The interact function takes function of type String String as its argument The entire input from the standard input device is passed to this function as its argument and the resulting string is output on the standard output device",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "interact'",
          "normalized": "(String-\u003eString)-\u003ea()",
          "package": "base-io-access",
          "signature": "(String-\u003eString)-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:interact-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eisEOF\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eFor a readable handle \u003ccode\u003ehdl\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehIsEOF'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ehdl\u003c/code\u003e returns\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if no further input can be taken from \u003ccode\u003ehdl\u003c/code\u003e or for a\n physical file, if the current I/O position is equal to the length of\n the file.  Otherwise, it returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNOTE: \u003ccode\u003e\u003ca\u003ehIsEOF'\u003c/a\u003e\u003c/code\u003e may block, because it has to attempt to read from\n the stream to determine whether there is any more data to be read.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "isEOF'",
          "package": "base-io-access",
          "signature": "io Bool",
          "source": "src/Access-System-IO.html#isEOF%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps isEOF For readable handle hdl hIsEOF hdl returns True if no further input can be taken from hdl or for physical file if the current position is equal to the length of the file Otherwise it returns False NOTE hIsEOF may block because it has to attempt to read from the stream to determine whether there is any more data to be read",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "isEOF'",
          "package": "base-io-access",
          "partial": "EOF'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:isEOF-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003emkTextEncoding\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eLook up the named Unicode encoding.  May fail with\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisDoesNotExistError\u003c/a\u003e\u003c/code\u003e if the encoding is unknown\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe set of known encodings is system-dependent, but includes at least:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cpre\u003eUTF-8\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e \u003ccode\u003eUTF-16\u003c/code\u003e, \u003ccode\u003eUTF-16BE\u003c/code\u003e, \u003ccode\u003eUTF-16LE\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eUTF-32\u003c/code\u003e, \u003ccode\u003eUTF-32BE\u003c/code\u003e, \u003ccode\u003eUTF-32LE\u003c/code\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOn systems using GNU iconv (e.g. Linux), there is additional\n notation for specifying how illegal characters are handled:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e a suffix of \u003ccode\u003e//IGNORE\u003c/code\u003e, e.g. \u003ccode\u003eUTF-8//IGNORE\u003c/code\u003e, will cause\n    all illegal sequences on input to be ignored, and on output\n    will drop all code points that have no representation in the\n    target encoding.\n\u003c/li\u003e\u003cli\u003e a suffix of \u003ccode\u003e//TRANSLIT\u003c/code\u003e will choose a replacement character\n    for illegal sequences or code points.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOn Windows, you can access supported code pages with the prefix\n \u003ccode\u003eCP\u003c/code\u003e; for example, \u003ccode\u003e\"CP1250\"\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "mkTextEncoding'",
          "package": "base-io-access",
          "signature": "String -\u003e io TextEncoding",
          "source": "src/Access-System-IO.html#mkTextEncoding%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps mkTextEncoding Look up the named Unicode encoding May fail with isDoesNotExistError if the encoding is unknown The set of known encodings is system-dependent but includes at least UTF-8 UTF-16 UTF-16BE UTF-16LE UTF-32 UTF-32BE UTF-32LE On systems using GNU iconv e.g Linux there is additional notation for specifying how illegal characters are handled suffix of IGNORE e.g UTF-8 IGNORE will cause all illegal sequences on input to be ignored and on output will drop all code points that have no representation in the target encoding suffix of TRANSLIT will choose replacement character for illegal sequences or code points On Windows you can access supported code pages with the prefix CP for example CP1250",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "mkTextEncoding'",
          "normalized": "String-\u003ea TextEncoding",
          "package": "base-io-access",
          "partial": "Text Encoding'",
          "signature": "String-\u003eio TextEncoding",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:mkTextEncoding-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eopenBinaryFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenFile'\u003c/a\u003e\u003c/code\u003e, but open the file in binary mode.\n On Windows, reading a file in text mode (which is the default)\n will translate CRLF to LF, and writing will translate LF to CRLF.\n This is usually what you want with text files.  With binary files\n this is undesirable; also, as usual under Microsoft operating systems,\n text mode treats control-Z as EOF.  Binary mode turns off all special\n treatment of end-of-line and end-of-file characters.\n (See also \u003ccode\u003ehSetBinaryMode'\u003c/code\u003e.)\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "openBinaryFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e IOMode -\u003e io Handle",
          "source": "src/Access-System-IO.html#openBinaryFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps openBinaryFile Like openFile but open the file in binary mode On Windows reading file in text mode which is the default will translate CRLF to LF and writing will translate LF to CRLF This is usually what you want with text files With binary files this is undesirable also as usual under Microsoft operating systems text mode treats control-Z as EOF Binary mode turns off all special treatment of end-of-line and end-of-file characters See also hSetBinaryMode",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "openBinaryFile'",
          "normalized": "FilePath-\u003eIOMode-\u003ea Handle",
          "package": "base-io-access",
          "partial": "Binary File'",
          "signature": "FilePath-\u003eIOMode-\u003eio Handle",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:openBinaryFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eopenBinaryTempFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenTempFile'\u003c/a\u003e\u003c/code\u003e, but opens the file in binary mode.\n See \u003ccode\u003e\u003ca\u003eopenBinaryFile'\u003c/a\u003e\u003c/code\u003e for more comments.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "openBinaryTempFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e String -\u003e io (FilePath, Handle)",
          "source": "src/Access-System-IO.html#openBinaryTempFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps openBinaryTempFile Like openTempFile but opens the file in binary mode See openBinaryFile for more comments",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "openBinaryTempFile'",
          "normalized": "FilePath-\u003eString-\u003ea(FilePath,Handle)",
          "package": "base-io-access",
          "partial": "Binary Temp File'",
          "signature": "FilePath-\u003eString-\u003eio(FilePath,Handle)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:openBinaryTempFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eopenBinaryTempFileWithDefaultPermissions\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenBinaryTempFile'\u003c/a\u003e\u003c/code\u003e, but uses the default file permissions\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "openBinaryTempFileWithDefaultPermissions'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e String -\u003e io (FilePath, Handle)",
          "source": "src/Access-System-IO.html#openBinaryTempFileWithDefaultPermissions%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps openBinaryTempFileWithDefaultPermissions Like openBinaryTempFile but uses the default file permissions",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "openBinaryTempFileWithDefaultPermissions'",
          "normalized": "FilePath-\u003eString-\u003ea(FilePath,Handle)",
          "package": "base-io-access",
          "partial": "Binary Temp File With Default Permissions'",
          "signature": "FilePath-\u003eString-\u003eio(FilePath,Handle)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:openBinaryTempFileWithDefaultPermissions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eopenFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eComputation \u003ccode\u003e\u003ca\u003eopenFile'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile mode\u003c/code\u003e allocates and returns a new, open\n handle to manage the file \u003ccode\u003efile\u003c/code\u003e.  It manages input if \u003ccode\u003emode\u003c/code\u003e\n is \u003ccode\u003e\u003ca\u003eReadMode\u003c/a\u003e\u003c/code\u003e, output if \u003ccode\u003emode\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eWriteMode\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eAppendMode\u003c/a\u003e\u003c/code\u003e,\n and both input and output if mode is \u003ccode\u003e\u003ca\u003eReadWriteMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the file does not exist and it is opened for output, it should be\n created as a new file.  If \u003ccode\u003emode\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eWriteMode\u003c/a\u003e\u003c/code\u003e and the file\n already exists, then it should be truncated to zero length.\n Some operating systems delete empty files, so there is no guarantee\n that the file will exist following an \u003ccode\u003e\u003ca\u003eopenFile'\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003emode\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eWriteMode\u003c/a\u003e\u003c/code\u003e unless it is subsequently written to successfully.\n The handle is positioned at the end of the file if \u003ccode\u003emode\u003c/code\u003e is\n \u003ccode\u003e\u003ca\u003eAppendMode\u003c/a\u003e\u003c/code\u003e, and otherwise at the beginning (in which case its\n internal position is 0).\n The initial buffer mode is implementation-dependent.\n\u003c/p\u003e\u003cp\u003eThis operation may fail with:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisAlreadyInUseError\u003c/a\u003e\u003c/code\u003e if the file is already open and\n    cannot be reopened;\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisDoesNotExistError\u003c/a\u003e\u003c/code\u003e if the file does not exist; or\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eisPermissionError\u003c/a\u003e\u003c/code\u003e if the user does not have\n    permission to open the file.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote: if you will be working with files containing binary data, you'll want to\n be using \u003ccode\u003e\u003ca\u003eopenBinaryFile'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "openFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e IOMode -\u003e io Handle",
          "source": "src/Access-System-IO.html#openFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps openFile Computation openFile file mode allocates and returns new open handle to manage the file file It manages input if mode is ReadMode output if mode is WriteMode or AppendMode and both input and output if mode is ReadWriteMode If the file does not exist and it is opened for output it should be created as new file If mode is WriteMode and the file already exists then it should be truncated to zero length Some operating systems delete empty files so there is no guarantee that the file will exist following an openFile with mode WriteMode unless it is subsequently written to successfully The handle is positioned at the end of the file if mode is AppendMode and otherwise at the beginning in which case its internal position is The initial buffer mode is implementation-dependent This operation may fail with isAlreadyInUseError if the file is already open and cannot be reopened isDoesNotExistError if the file does not exist or isPermissionError if the user does not have permission to open the file Note if you will be working with files containing binary data you ll want to be using openBinaryFile",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "openFile'",
          "normalized": "FilePath-\u003eIOMode-\u003ea Handle",
          "package": "base-io-access",
          "partial": "File'",
          "signature": "FilePath-\u003eIOMode-\u003eio Handle",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:openFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eopenTempFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe function creates a temporary file in \u003ccode\u003eReadWrite\u003c/code\u003e mode.\n The created file isn't deleted automatically, so you need to delete it\n manually.\n\u003c/p\u003e\u003cp\u003eThe file is creates with permissions such that only the current\n user can read/write it.\n\u003c/p\u003e\u003cp\u003eWith some exceptions (see below), the file will be created securely\n in the sense that an attacker should not be able to cause\n \u003ccode\u003e\u003ca\u003eopenTempFile'\u003c/a\u003e\u003c/code\u003e to overwrite another file on the filesystem using your\n credentials, by putting symbolic links (on Unix) in the place where\n the temporary file is to be created.  On Unix the \u003ccode\u003eO_CREAT\u003c/code\u003e and\n \u003ccode\u003eO_EXCL\u003c/code\u003e flags are used to prevent this attack, but note that\n \u003ccode\u003eO_EXCL\u003c/code\u003e is sometimes not supported on NFS filesystems, so if you\n rely on this behaviour it is best to use local filesystems only.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "openTempFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e String -\u003e io (FilePath, Handle)",
          "source": "src/Access-System-IO.html#openTempFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps openTempFile The function creates temporary file in ReadWrite mode The created file isn deleted automatically so you need to delete it manually The file is creates with permissions such that only the current user can read write it With some exceptions see below the file will be created securely in the sense that an attacker should not be able to cause openTempFile to overwrite another file on the filesystem using your credentials by putting symbolic links on Unix in the place where the temporary file is to be created On Unix the CREAT and EXCL flags are used to prevent this attack but note that EXCL is sometimes not supported on NFS filesystems so if you rely on this behaviour it is best to use local filesystems only",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "openTempFile'",
          "normalized": "FilePath-\u003eString-\u003ea(FilePath,Handle)",
          "package": "base-io-access",
          "partial": "Temp File'",
          "signature": "FilePath-\u003eString-\u003eio(FilePath,Handle)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:openTempFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eopenTempFileWithDefaultPermissions\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eopenTempFile'\u003c/a\u003e\u003c/code\u003e, but uses the default file permissions\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "openTempFileWithDefaultPermissions'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e String -\u003e io (FilePath, Handle)",
          "source": "src/Access-System-IO.html#openTempFileWithDefaultPermissions%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps openTempFileWithDefaultPermissions Like openTempFile but uses the default file permissions",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "openTempFileWithDefaultPermissions'",
          "normalized": "FilePath-\u003eString-\u003ea(FilePath,Handle)",
          "package": "base-io-access",
          "partial": "Temp File With Default Permissions'",
          "signature": "FilePath-\u003eString-\u003eio(FilePath,Handle)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:openTempFileWithDefaultPermissions-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eprint'\u003c/a\u003e\u003c/code\u003e function outputs a value of any printable type to the\n standard output device.\n Printable types are those that are instances of class \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e; \u003ccode\u003e\u003ca\u003eprint'\u003c/a\u003e\u003c/code\u003e\n converts values to strings for output using the \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e operation and\n adds a newline.\n\u003c/p\u003e\u003cp\u003eFor example, a program to print' the first 20 integers and their\n powers of 2 could be written as:\n\u003c/p\u003e\u003cpre\u003e main = print' ([(n, 2^n) | n \u003c- [0..19]])\n\u003c/pre\u003e",
          "module": "Access.System.IO",
          "name": "print'",
          "package": "base-io-access",
          "signature": "a -\u003e io ()",
          "source": "src/Access-System-IO.html#print%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps print The print function outputs value of any printable type to the standard output device Printable types are those that are instances of class Show print converts values to strings for output using the show operation and adds newline For example program to print the first integers and their powers of could be written as main print",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "print'",
          "normalized": "a-\u003eb()",
          "package": "base-io-access",
          "signature": "a-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:print-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eputChar\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWrite a character to the standard output device\n (same as \u003ccode\u003e\u003ca\u003ehPutChar'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdout\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "putChar'",
          "package": "base-io-access",
          "signature": "Char -\u003e io ()",
          "source": "src/Access-System-IO.html#putChar%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps putChar Write character to the standard output device same as hPutChar stdout",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "putChar'",
          "normalized": "Char-\u003ea()",
          "package": "base-io-access",
          "partial": "Char'",
          "signature": "Char-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:putChar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eputStr\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWrite a string to the standard output device\n (same as \u003ccode\u003e\u003ca\u003ehPutStr'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estdout\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "putStr'",
          "package": "base-io-access",
          "signature": "String -\u003e io ()",
          "source": "src/Access-System-IO.html#putStr%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps putStr Write string to the standard output device same as hPutStr stdout",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "putStr'",
          "normalized": "String-\u003ea()",
          "package": "base-io-access",
          "partial": "Str'",
          "signature": "String-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:putStr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003eputStrLn\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eputStr'\u003c/a\u003e\u003c/code\u003e, but adds a newline character.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "putStrLn'",
          "package": "base-io-access",
          "signature": "String -\u003e io ()",
          "source": "src/Access-System-IO.html#putStrLn%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps putStrLn The same as putStr but adds newline character",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "putStrLn'",
          "normalized": "String-\u003ea()",
          "package": "base-io-access",
          "partial": "Str Ln'",
          "signature": "String-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:putStrLn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ereadFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ereadFile'\u003c/a\u003e\u003c/code\u003e function reads a file and\n returns the contents of the file as a string.\n The file is read lazily, on demand, as with \u003ccode\u003e\u003ca\u003egetContents'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "readFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e io String",
          "source": "src/Access-System-IO.html#readFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps readFile The readFile function reads file and returns the contents of the file as string The file is read lazily on demand as with getContents",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "readFile'",
          "normalized": "FilePath-\u003ea String",
          "package": "base-io-access",
          "partial": "File'",
          "signature": "FilePath-\u003eio String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:readFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ereadLn\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ereadLn'\u003c/a\u003e\u003c/code\u003e function combines \u003ccode\u003e\u003ca\u003egetLine'\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereadIO\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "readLn'",
          "package": "base-io-access",
          "signature": "io a",
          "source": "src/Access-System-IO.html#readLn%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps readLn The readLn function combines getLine and readIO",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "readLn'",
          "package": "base-io-access",
          "partial": "Ln'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:readLn-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ewithBinaryFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ewithBinaryFile'\u003c/a\u003e\u003c/code\u003e name mode act\u003c/code\u003e opens a file using \u003ccode\u003e\u003ca\u003eopenBinaryFile'\u003c/a\u003e\u003c/code\u003e\n and passes the resulting handle to the computation \u003ccode\u003eact\u003c/code\u003e.  The handle\n will be closed on exit from \u003ccode\u003e\u003ca\u003ewithBinaryFile'\u003c/a\u003e\u003c/code\u003e, whether by normal\n termination or by raising an exception.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "withBinaryFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e IOMode -\u003e (Handle -\u003e io r) -\u003e io r",
          "source": "src/Access-System-IO.html#withBinaryFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps withBinaryFile withBinaryFile name mode act opens file using openBinaryFile and passes the resulting handle to the computation act The handle will be closed on exit from withBinaryFile whether by normal termination or by raising an exception",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "withBinaryFile'",
          "normalized": "FilePath-\u003eIOMode-\u003e(Handle-\u003ea b)-\u003ea b",
          "package": "base-io-access",
          "partial": "Binary File'",
          "signature": "FilePath-\u003eIOMode-\u003e(Handle-\u003eio r)-\u003eio r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:withBinaryFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ewithFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ewithFile'\u003c/a\u003e\u003c/code\u003e name mode act\u003c/code\u003e opens a file using \u003ccode\u003e\u003ca\u003eopenFile'\u003c/a\u003e\u003c/code\u003e and passes\n the resulting handle to the computation \u003ccode\u003eact\u003c/code\u003e.  The handle will be\n closed on exit from \u003ccode\u003e\u003ca\u003ewithFile'\u003c/a\u003e\u003c/code\u003e, whether by normal termination or by\n raising an exception.  If closing the handle raises an exception, then\n this exception will be raised by \u003ccode\u003e\u003ca\u003ewithFile'\u003c/a\u003e\u003c/code\u003e rather than any exception\n raised by \u003ccode\u003eact\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "withFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e IOMode -\u003e (Handle -\u003e io r) -\u003e io r",
          "source": "src/Access-System-IO.html#withFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps withFile withFile name mode act opens file using openFile and passes the resulting handle to the computation act The handle will be closed on exit from withFile whether by normal termination or by raising an exception If closing the handle raises an exception then this exception will be raised by withFile rather than any exception raised by act",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "withFile'",
          "normalized": "FilePath-\u003eIOMode-\u003e(Handle-\u003ea b)-\u003ea b",
          "package": "base-io-access",
          "partial": "File'",
          "signature": "FilePath-\u003eIOMode-\u003e(Handle-\u003eio r)-\u003eio r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:withFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWraps \u003ccode\u003e\u003ca\u003ewriteFile\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003ewriteFile'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile str\u003c/code\u003e function writes the string \u003ccode\u003estr\u003c/code\u003e,\n to the file \u003ccode\u003efile\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Access.System.IO",
          "name": "writeFile'",
          "package": "base-io-access",
          "signature": "FilePath -\u003e String -\u003e io ()",
          "source": "src/Access-System-IO.html#writeFile%27",
          "type": "method"
        },
        "index": {
          "description": "Wraps writeFile The computation writeFile file str function writes the string str to the file file",
          "hierarchy": "Access System IO",
          "module": "Access.System.IO",
          "name": "writeFile'",
          "normalized": "FilePath-\u003eString-\u003ea()",
          "package": "base-io-access",
          "partial": "File'",
          "signature": "FilePath-\u003eString-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-IO.html#v:writeFile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.StableName",
          "name": "StableName",
          "package": "base-io-access",
          "source": "src/Access-System-Mem-StableName.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System Mem StableName",
          "module": "Access.System.Mem.StableName",
          "name": "StableName",
          "package": "base-io-access",
          "partial": "Stable Name",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-StableName.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.StableName",
          "name": "StableNameAccess",
          "package": "base-io-access",
          "source": "src/Access-System-Mem-StableName.html#StableNameAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System Mem StableName",
          "module": "Access.System.Mem.StableName",
          "name": "StableNameAccess",
          "package": "base-io-access",
          "partial": "Stable Name Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-StableName.html#t:StableNameAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.StableName",
          "name": "makeStableName'",
          "package": "base-io-access",
          "signature": "a -\u003e io (StableName a)",
          "source": "src/Access-System-Mem-StableName.html#makeStableName%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Mem StableName",
          "module": "Access.System.Mem.StableName",
          "name": "makeStableName'",
          "normalized": "a-\u003eb(StableName a)",
          "package": "base-io-access",
          "partial": "Stable Name'",
          "signature": "a-\u003eio(StableName a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-StableName.html#v:makeStableName-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.Weak",
          "name": "Weak",
          "package": "base-io-access",
          "source": "src/Access-System-Mem-Weak.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System Mem Weak",
          "module": "Access.System.Mem.Weak",
          "name": "Weak",
          "package": "base-io-access",
          "partial": "Weak",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-Weak.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.Weak",
          "name": "WeakMemAccess",
          "package": "base-io-access",
          "source": "src/Access-System-Mem-Weak.html#WeakMemAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System Mem Weak",
          "module": "Access.System.Mem.Weak",
          "name": "WeakMemAccess",
          "package": "base-io-access",
          "partial": "Weak Mem Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-Weak.html#t:WeakMemAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.Weak",
          "name": "deRefWeak'",
          "package": "base-io-access",
          "signature": "Weak v -\u003e io (Maybe v)",
          "source": "src/Access-System-Mem-Weak.html#deRefWeak%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Mem Weak",
          "module": "Access.System.Mem.Weak",
          "name": "deRefWeak'",
          "normalized": "Weak a-\u003eb(Maybe a)",
          "package": "base-io-access",
          "partial": "Ref Weak'",
          "signature": "Weak v-\u003eio(Maybe v)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-Weak.html#v:deRefWeak-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.Weak",
          "name": "finalize'",
          "package": "base-io-access",
          "signature": "Weak v -\u003e io ()",
          "source": "src/Access-System-Mem-Weak.html#finalize%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Mem Weak",
          "module": "Access.System.Mem.Weak",
          "name": "finalize'",
          "normalized": "Weak a-\u003eb()",
          "package": "base-io-access",
          "signature": "Weak v-\u003eio()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-Weak.html#v:finalize-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem.Weak",
          "name": "mkWeak'",
          "package": "base-io-access",
          "signature": "k -\u003e v -\u003e Maybe (IO ()) -\u003e io (Weak v)",
          "source": "src/Access-System-Mem-Weak.html#mkWeak%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Mem Weak",
          "module": "Access.System.Mem.Weak",
          "name": "mkWeak'",
          "normalized": "a-\u003eb-\u003eMaybe(IO())-\u003ec(Weak b)",
          "package": "base-io-access",
          "partial": "Weak'",
          "signature": "k-\u003ev-\u003eMaybe(IO())-\u003eio(Weak v)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem-Weak.html#v:mkWeak-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem",
          "name": "Mem",
          "package": "base-io-access",
          "source": "src/Access-System-Mem.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System Mem",
          "module": "Access.System.Mem",
          "name": "Mem",
          "package": "base-io-access",
          "partial": "Mem",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem",
          "name": "MemAccess",
          "package": "base-io-access",
          "source": "src/Access-System-Mem.html#MemAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System Mem",
          "module": "Access.System.Mem",
          "name": "MemAccess",
          "package": "base-io-access",
          "partial": "Mem Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem.html#t:MemAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Mem",
          "name": "performGC'",
          "package": "base-io-access",
          "signature": "io ()",
          "source": "src/Access-System-Mem.html#performGC%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Mem",
          "module": "Access.System.Mem",
          "name": "performGC'",
          "normalized": "a()",
          "package": "base-io-access",
          "partial": "GC'",
          "signature": "io()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Mem.html#v:performGC-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Timeout",
          "name": "Timeout",
          "package": "base-io-access",
          "source": "src/Access-System-Timeout.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Access System Timeout",
          "module": "Access.System.Timeout",
          "name": "Timeout",
          "package": "base-io-access",
          "partial": "Timeout",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Timeout.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Timeout",
          "name": "TimeoutAccess",
          "package": "base-io-access",
          "source": "src/Access-System-Timeout.html#TimeoutAccess",
          "type": "class"
        },
        "index": {
          "hierarchy": "Access System Timeout",
          "module": "Access.System.Timeout",
          "name": "TimeoutAccess",
          "package": "base-io-access",
          "partial": "Timeout Access",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Timeout.html#t:TimeoutAccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Access.System.Timeout",
          "name": "timeout'",
          "package": "base-io-access",
          "signature": "Int -\u003e IO a -\u003e io (Maybe a)",
          "source": "src/Access-System-Timeout.html#timeout%27",
          "type": "method"
        },
        "index": {
          "hierarchy": "Access System Timeout",
          "module": "Access.System.Timeout",
          "name": "timeout'",
          "normalized": "Int-\u003eIO a-\u003eb(Maybe a)",
          "package": "base-io-access",
          "signature": "Int-\u003eIO a-\u003eio(Maybe a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/base-io-access/docs/Access-System-Timeout.html#v:timeout-39-"
      }
    }
  ]
]