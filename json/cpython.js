[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "cpython"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Constants",
          "name": "Constants",
          "package": "cpython",
          "source": "src/CPython-Constants.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "Constants",
          "package": "cpython",
          "partial": "Constants",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Python \u003ccode\u003eFalse\u003c/code\u003e object.\n\u003c/p\u003e",
          "module": "CPython.Constants",
          "name": "false",
          "package": "cpython",
          "signature": "IO SomeObject",
          "source": "src/CPython-Constants.html#false",
          "type": "function"
        },
        "index": {
          "description": "The Python False object",
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "false",
          "package": "cpython",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#v:false"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Constants",
          "name": "isFalse",
          "package": "cpython",
          "signature": "SomeObject -\u003e IO Bool",
          "source": "src/CPython-Constants.html#isFalse",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "isFalse",
          "normalized": "SomeObject-\u003eIO Bool",
          "package": "cpython",
          "partial": "False",
          "signature": "SomeObject-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#v:isFalse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Constants",
          "name": "isNone",
          "package": "cpython",
          "signature": "SomeObject -\u003e IO Bool",
          "source": "src/CPython-Constants.html#isNone",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "isNone",
          "normalized": "SomeObject-\u003eIO Bool",
          "package": "cpython",
          "partial": "None",
          "signature": "SomeObject-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#v:isNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Constants",
          "name": "isTrue",
          "package": "cpython",
          "signature": "SomeObject -\u003e IO Bool",
          "source": "src/CPython-Constants.html#isTrue",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "isTrue",
          "normalized": "SomeObject-\u003eIO Bool",
          "package": "cpython",
          "partial": "True",
          "signature": "SomeObject-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#v:isTrue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Python \u003ccode\u003eNone\u003c/code\u003e object, denoting lack of value.\n\u003c/p\u003e",
          "module": "CPython.Constants",
          "name": "none",
          "package": "cpython",
          "signature": "IO SomeObject",
          "source": "src/CPython-Constants.html#none",
          "type": "function"
        },
        "index": {
          "description": "The Python None object denoting lack of value",
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "none",
          "package": "cpython",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#v:none"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Python \u003ccode\u003eTrue\u003c/code\u003e object.\n\u003c/p\u003e",
          "module": "CPython.Constants",
          "name": "true",
          "package": "cpython",
          "signature": "IO SomeObject",
          "source": "src/CPython-Constants.html#true",
          "type": "function"
        },
        "index": {
          "description": "The Python True object",
          "hierarchy": "CPython Constants",
          "module": "CPython.Constants",
          "name": "true",
          "package": "cpython",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Constants.html#v:true"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Iterator",
          "name": "Iterator",
          "package": "cpython",
          "source": "src/CPython-Protocols-Iterator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Protocols Iterator",
          "module": "CPython.Protocols.Iterator",
          "name": "Iterator",
          "package": "cpython",
          "partial": "Iterator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Iterator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Iterator",
          "name": "Iterator",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Iterator",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Protocols Iterator",
          "module": "CPython.Protocols.Iterator",
          "name": "Iterator",
          "package": "cpython",
          "partial": "Iterator",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Iterator.html#t:Iterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Iterator",
          "name": "SomeIterator",
          "package": "cpython",
          "source": "src/CPython-Internal.html#SomeIterator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Protocols Iterator",
          "module": "CPython.Protocols.Iterator",
          "name": "SomeIterator",
          "package": "cpython",
          "partial": "Some Iterator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Iterator.html#t:SomeIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to convert an object to a generic \u003ccode\u003e\u003ca\u003eIterator\u003c/a\u003e\u003c/code\u003e. If the object does\n not implement the iterator protocol, returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Iterator",
          "name": "castToIterator",
          "package": "cpython",
          "signature": "a -\u003e IO (Maybe SomeIterator)",
          "source": "src/CPython-Protocols-Iterator.html#castToIterator",
          "type": "function"
        },
        "index": {
          "description": "Attempt to convert an object to generic Iterator If the object does not implement the iterator protocol returns Nothing",
          "hierarchy": "CPython Protocols Iterator",
          "module": "CPython.Protocols.Iterator",
          "name": "castToIterator",
          "normalized": "a-\u003eIO(Maybe SomeIterator)",
          "package": "cpython",
          "partial": "To Iterator",
          "signature": "a-\u003eIO(Maybe SomeIterator)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Iterator.html#v:castToIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the next value from the iteration, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there are no\n remaining items.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Iterator",
          "name": "next",
          "package": "cpython",
          "signature": "iter -\u003e IO (Maybe SomeObject)",
          "source": "src/CPython-Protocols-Iterator.html#next",
          "type": "function"
        },
        "index": {
          "description": "Return the next value from the iteration or Nothing if there are no remaining items",
          "hierarchy": "CPython Protocols Iterator",
          "module": "CPython.Protocols.Iterator",
          "name": "next",
          "normalized": "a-\u003eIO(Maybe SomeObject)",
          "package": "cpython",
          "signature": "iter-\u003eIO(Maybe SomeObject)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Iterator.html#v:next"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Iterator",
          "name": "toIterator",
          "package": "cpython",
          "signature": "a -\u003e SomeIterator",
          "source": "src/CPython-Internal.html#toIterator",
          "type": "method"
        },
        "index": {
          "hierarchy": "CPython Protocols Iterator",
          "module": "CPython.Protocols.Iterator",
          "name": "toIterator",
          "normalized": "a-\u003eSomeIterator",
          "package": "cpython",
          "partial": "Iterator",
          "signature": "a-\u003eSomeIterator",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Iterator.html#v:toIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "Mapping",
          "package": "cpython",
          "source": "src/CPython-Protocols-Mapping.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "Mapping",
          "package": "cpython",
          "partial": "Mapping",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "Mapping",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Mapping",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "Mapping",
          "package": "cpython",
          "partial": "Mapping",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#t:Mapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "SomeMapping",
          "package": "cpython",
          "source": "src/CPython-Internal.html#SomeMapping",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "SomeMapping",
          "package": "cpython",
          "partial": "Some Mapping",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#t:SomeMapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "castToMapping",
          "package": "cpython",
          "signature": "a -\u003e IO (Maybe SomeMapping)",
          "source": "src/CPython-Protocols-Mapping.html#castToMapping",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "castToMapping",
          "normalized": "a-\u003eIO(Maybe SomeMapping)",
          "package": "cpython",
          "partial": "To Mapping",
          "signature": "a-\u003eIO(Maybe SomeMapping)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:castToMapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "deleteItem",
          "package": "cpython",
          "signature": "self -\u003e key -\u003e IO ()",
          "source": "src/CPython-Protocols-Mapping.html#deleteItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "deleteItem",
          "normalized": "a-\u003eb-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "self-\u003ekey-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:deleteItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "getItem",
          "package": "cpython",
          "signature": "self -\u003e key -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Mapping.html#getItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "getItem",
          "normalized": "a-\u003eb-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Item",
          "signature": "self-\u003ekey-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:getItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "hasKey",
          "package": "cpython",
          "signature": "self -\u003e key -\u003e IO Bool",
          "source": "src/CPython-Protocols-Mapping.html#hasKey",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "hasKey",
          "normalized": "a-\u003eb-\u003eIO Bool",
          "package": "cpython",
          "partial": "Key",
          "signature": "self-\u003ekey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:hasKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "items",
          "package": "cpython",
          "signature": "self -\u003e IO List",
          "source": "src/CPython-Protocols-Mapping.html#items",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "items",
          "normalized": "a-\u003eIO List",
          "package": "cpython",
          "signature": "self-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:items"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "keys",
          "package": "cpython",
          "signature": "self -\u003e IO List",
          "source": "src/CPython-Protocols-Mapping.html#keys",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "keys",
          "normalized": "a-\u003eIO List",
          "package": "cpython",
          "signature": "self-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "setItem",
          "package": "cpython",
          "signature": "self -\u003e key -\u003e value -\u003e IO ()",
          "source": "src/CPython-Protocols-Mapping.html#setItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "setItem",
          "normalized": "a-\u003eb-\u003ec-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "self-\u003ekey-\u003evalue-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:setItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "size",
          "package": "cpython",
          "signature": "self -\u003e IO Integer",
          "source": "src/CPython-Protocols-Mapping.html#size",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "size",
          "normalized": "a-\u003eIO Integer",
          "package": "cpython",
          "signature": "self-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "toMapping",
          "package": "cpython",
          "signature": "a -\u003e SomeMapping",
          "source": "src/CPython-Internal.html#toMapping",
          "type": "method"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "toMapping",
          "normalized": "a-\u003eSomeMapping",
          "package": "cpython",
          "partial": "Mapping",
          "signature": "a-\u003eSomeMapping",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:toMapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Mapping",
          "name": "values",
          "package": "cpython",
          "signature": "self -\u003e IO List",
          "source": "src/CPython-Protocols-Mapping.html#values",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Mapping",
          "module": "CPython.Protocols.Mapping",
          "name": "values",
          "normalized": "a-\u003eIO List",
          "package": "cpython",
          "signature": "self-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Mapping.html#v:values"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "Number",
          "package": "cpython",
          "source": "src/CPython-Protocols-Number.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "Number",
          "package": "cpython",
          "partial": "Number",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "Number",
          "package": "cpython",
          "source": "src/CPython-Protocols-Number.html#Number",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "Number",
          "package": "cpython",
          "partial": "Number",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#t:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "SomeNumber",
          "package": "cpython",
          "source": "src/CPython-Protocols-Number.html#SomeNumber",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "SomeNumber",
          "package": "cpython",
          "partial": "Some Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#t:SomeNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "absolute",
          "package": "cpython",
          "signature": "a -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#absolute",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "absolute",
          "normalized": "a-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:absolute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "add",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#add",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "add",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "and",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#and",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "and",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:and"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "castToNumber",
          "package": "cpython",
          "signature": "a -\u003e IO (Maybe SomeNumber)",
          "source": "src/CPython-Protocols-Number.html#castToNumber",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "castToNumber",
          "normalized": "a-\u003eIO(Maybe SomeNumber)",
          "package": "cpython",
          "partial": "To Number",
          "signature": "a-\u003eIO(Maybe SomeNumber)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:castToNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "divmod",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#divmod",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "divmod",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:divmod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "floorDivide",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#floorDivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "floorDivide",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Divide",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:floorDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceAdd",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceAdd",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceAdd",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Add",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceAdd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceAnd",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceAnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceAnd",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place And",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceAnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceFloorDivide",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceFloorDivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceFloorDivide",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Floor Divide",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceFloorDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceMultiply",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceMultiply",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceMultiply",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Multiply",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceMultiply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceOr",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceOr",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceOr",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Or",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceOr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlacePower",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e Maybe c -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlacePower",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlacePower",
          "normalized": "a-\u003eb-\u003eMaybe c-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Power",
          "signature": "a-\u003eb-\u003eMaybe c-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlacePower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceRemainder",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceRemainder",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceRemainder",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Remainder",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceRemainder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceShiftL",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceShiftL",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceShiftL",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Shift",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceShiftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceShiftR",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceShiftR",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceShiftR",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Shift",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceShiftR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceSubtract",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceSubtract",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceSubtract",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Subtract",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceSubtract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceTrueDivide",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceTrueDivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceTrueDivide",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place True Divide",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceTrueDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "inPlaceXor",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#inPlaceXor",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "inPlaceXor",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Place Xor",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:inPlaceXor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "invert",
          "package": "cpython",
          "signature": "a -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#invert",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "invert",
          "normalized": "a-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "multiply",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#multiply",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "multiply",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:multiply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "negative",
          "package": "cpython",
          "signature": "a -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#negative",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "negative",
          "normalized": "a-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:negative"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "or",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#or",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "or",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "positive",
          "package": "cpython",
          "signature": "a -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#positive",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "positive",
          "normalized": "a-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:positive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "power",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e Maybe c -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#power",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "power",
          "normalized": "a-\u003eb-\u003eMaybe c-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eMaybe c-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:power"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "remainder",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#remainder",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "remainder",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:remainder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "shiftL",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#shiftL",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "shiftL",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:shiftL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "shiftR",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#shiftR",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "shiftR",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:shiftR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "subtract",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#subtract",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "subtract",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:subtract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "toBase",
          "package": "cpython",
          "signature": "a -\u003e Integer -\u003e IO Unicode",
          "source": "src/CPython-Protocols-Number.html#toBase",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "toBase",
          "normalized": "a-\u003eInteger-\u003eIO Unicode",
          "package": "cpython",
          "partial": "Base",
          "signature": "a-\u003eInteger-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:toBase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "toFloat",
          "package": "cpython",
          "signature": "a -\u003e IO Float",
          "source": "src/CPython-Protocols-Number.html#toFloat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "toFloat",
          "normalized": "a-\u003eIO Float",
          "package": "cpython",
          "partial": "Float",
          "signature": "a-\u003eIO Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:toFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "toInteger",
          "package": "cpython",
          "signature": "a -\u003e IO Integer",
          "source": "src/CPython-Protocols-Number.html#toInteger",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "toInteger",
          "normalized": "a-\u003eIO Integer",
          "package": "cpython",
          "partial": "Integer",
          "signature": "a-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:toInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "toNumber",
          "package": "cpython",
          "signature": "a -\u003e SomeNumber",
          "source": "src/CPython-Protocols-Number.html#toNumber",
          "type": "method"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "toNumber",
          "normalized": "a-\u003eSomeNumber",
          "package": "cpython",
          "partial": "Number",
          "signature": "a-\u003eSomeNumber",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:toNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "trueDivide",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#trueDivide",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "trueDivide",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "partial": "Divide",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:trueDivide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Number",
          "name": "xor",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeNumber",
          "source": "src/CPython-Protocols-Number.html#xor",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Number",
          "module": "CPython.Protocols.Number",
          "name": "xor",
          "normalized": "a-\u003eb-\u003eIO SomeNumber",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeNumber",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Number.html#v:xor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "Object",
          "package": "cpython",
          "source": "src/CPython-Protocols-Object.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "Object",
          "package": "cpython",
          "partial": "Object",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "Comparison",
          "package": "cpython",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "Comparison",
          "package": "cpython",
          "partial": "Comparison",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#t:Comparison"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "Concrete",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Concrete",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "Concrete",
          "package": "cpython",
          "partial": "Concrete",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#t:Concrete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "Object",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Object",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "Object",
          "package": "cpython",
          "partial": "Object",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#t:Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "SomeObject",
          "package": "cpython",
          "source": "src/CPython-Internal.html#SomeObject",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "SomeObject",
          "package": "cpython",
          "partial": "Some Object",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#t:SomeObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "EQ",
          "package": "cpython",
          "signature": "EQ",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "EQ",
          "package": "cpython",
          "partial": "EQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:EQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "GE",
          "package": "cpython",
          "signature": "GE",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "GE",
          "package": "cpython",
          "partial": "GE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:GE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "GT",
          "package": "cpython",
          "signature": "GT",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "GT",
          "package": "cpython",
          "partial": "GT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:GT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "LE",
          "package": "cpython",
          "signature": "LE",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "LE",
          "package": "cpython",
          "partial": "LE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:LE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "LT",
          "package": "cpython",
          "signature": "LT",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "LT",
          "package": "cpython",
          "partial": "LT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:LT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "NE",
          "package": "cpython",
          "signature": "NE",
          "source": "src/CPython-Protocols-Object.html#Comparison",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "NE",
          "package": "cpython",
          "partial": "NE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:NE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "ascii",
          "package": "cpython",
          "signature": "self -\u003e IO Unicode",
          "source": "src/CPython-Protocols-Object.html#ascii",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "ascii",
          "normalized": "a-\u003eIO Unicode",
          "package": "cpython",
          "signature": "self-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:ascii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a bytes representation of object \u003cem\u003eself\u003c/em\u003e, or throw an exception\n on failure. This is equivalent to the Python expression \u003ccode\u003ebytes(self)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "bytes",
          "package": "cpython",
          "signature": "self -\u003e IO Bytes",
          "source": "src/CPython-Protocols-Object.html#bytes",
          "type": "function"
        },
        "index": {
          "description": "Compute bytes representation of object self or throw an exception on failure This is equivalent to the Python expression bytes self",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "bytes",
          "normalized": "a-\u003eIO Bytes",
          "package": "cpython",
          "signature": "self-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall a callable Python object \u003cem\u003eself\u003c/em\u003e, with arguments given by the\n tuple and named arguments given by the dictionary. Returns the result of\n the call on success, or throws an exception on failure. This is the\n equivalent of the Python expression \u003ccode\u003eself(*args, **kw)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "call",
          "package": "cpython",
          "signature": "self -\u003e Tuple -\u003e Dictionary -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Object.html#call",
          "type": "function"
        },
        "index": {
          "description": "Call callable Python object self with arguments given by the tuple and named arguments given by the dictionary Returns the result of the call on success or throws an exception on failure This is the equivalent of the Python expression self args kw",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "call",
          "normalized": "a-\u003eTuple-\u003eDictionary-\u003eIO SomeObject",
          "package": "cpython",
          "signature": "self-\u003eTuple-\u003eDictionary-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:call"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall a callable Python object \u003cem\u003eself\u003c/em\u003e, with arguments given by the list.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "callArgs",
          "package": "cpython",
          "signature": "self -\u003e [SomeObject] -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Object.html#callArgs",
          "type": "function"
        },
        "index": {
          "description": "Call callable Python object self with arguments given by the list",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "callArgs",
          "normalized": "a-\u003e[SomeObject]-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Args",
          "signature": "self-\u003e[SomeObject]-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:callArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall the named method of object \u003cem\u003eself\u003c/em\u003e, with arguments given by the\n tuple and named arguments given by the dictionary. Returns the result of\n the call on success, or throws an exception on failure. This is the\n equivalent of the Python expression \u003ccode\u003eself.method(args)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "callMethod",
          "package": "cpython",
          "signature": "self -\u003e Text -\u003e Tuple -\u003e Dictionary -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Object.html#callMethod",
          "type": "function"
        },
        "index": {
          "description": "Call the named method of object self with arguments given by the tuple and named arguments given by the dictionary Returns the result of the call on success or throws an exception on failure This is the equivalent of the Python expression self.method args",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "callMethod",
          "normalized": "a-\u003eText-\u003eTuple-\u003eDictionary-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Method",
          "signature": "self-\u003eText-\u003eTuple-\u003eDictionary-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:callMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall the named method of object \u003cem\u003eself\u003c/em\u003e, with arguments given by the\n list. Returns the result of the call on success, or throws an exception\n on failure. This is the equivalent of the Python expression\n \u003ccode\u003eself.method(args)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "callMethodArgs",
          "package": "cpython",
          "signature": "self -\u003e Text -\u003e [SomeObject] -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Object.html#callMethodArgs",
          "type": "function"
        },
        "index": {
          "description": "Call the named method of object self with arguments given by the list Returns the result of the call on success or throws an exception on failure This is the equivalent of the Python expression self.method args",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "callMethodArgs",
          "normalized": "a-\u003eText-\u003e[SomeObject]-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Method Args",
          "signature": "self-\u003eText-\u003e[SomeObject]-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:callMethodArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine if the object \u003cem\u003eself\u003c/em\u003e is callable.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "callable",
          "package": "cpython",
          "signature": "self -\u003e IO Bool",
          "source": "src/CPython-Protocols-Object.html#callable",
          "type": "function"
        },
        "index": {
          "description": "Determine if the object self is callable",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "callable",
          "normalized": "a-\u003eIO Bool",
          "package": "cpython",
          "signature": "self-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:callable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to cast an object to some concrete class. If the object\n isn't an instance of the class or subclass, returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "cast",
          "package": "cpython",
          "signature": "a -\u003e IO (Maybe b)",
          "source": "src/CPython-Protocols-Object.html#cast",
          "type": "function"
        },
        "index": {
          "description": "Attempt to cast an object to some concrete class If the object isn an instance of the class or subclass returns Nothing",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "cast",
          "normalized": "a-\u003eIO(Maybe b)",
          "package": "cpython",
          "signature": "a-\u003eIO(Maybe b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete an attribute with the given name, for object \u003cem\u003eself\u003c/em\u003e. Throws an\n exception on failure. This is the equivalent of the Python statement\n \u003ccode\u003edel self.name\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "deleteAttribute",
          "package": "cpython",
          "signature": "self -\u003e Unicode -\u003e IO ()",
          "source": "src/CPython-Protocols-Object.html#deleteAttribute",
          "type": "function"
        },
        "index": {
          "description": "Delete an attribute with the given name for object self Throws an exception on failure This is the equivalent of the Python statement del self.name",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "deleteAttribute",
          "normalized": "a-\u003eUnicode-\u003eIO()",
          "package": "cpython",
          "partial": "Attribute",
          "signature": "self-\u003eUnicode-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:deleteAttribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is equivalent to the Python expression \u003ccode\u003edir(self)\u003c/code\u003e, returning a\n (possibly empty) list of strings appropriate for the object argument,\n or throws an exception if there was an error.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "dir",
          "package": "cpython",
          "signature": "self -\u003e IO List",
          "source": "src/CPython-Protocols-Object.html#dir",
          "type": "function"
        },
        "index": {
          "description": "This is equivalent to the Python expression dir self returning possibly empty list of strings appropriate for the object argument or throws an exception if there was an error",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "dir",
          "normalized": "a-\u003eIO List",
          "package": "cpython",
          "signature": "self-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:dir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve an attribute with the given name from object \u003cem\u003eself\u003c/em\u003e. Returns\n the attribute value on success, and throws an exception on failure. This\n is the equivalent of the Python expression \u003ccode\u003eself.name\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "getAttribute",
          "package": "cpython",
          "signature": "self -\u003e Unicode -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Object.html#getAttribute",
          "type": "function"
        },
        "index": {
          "description": "Retrieve an attribute with the given name from object self Returns the attribute value on success and throws an exception on failure This is the equivalent of the Python expression self.name",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "getAttribute",
          "normalized": "a-\u003eUnicode-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Attribute",
          "signature": "self-\u003eUnicode-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:getAttribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is equivalent to the Python expression \u003ccode\u003eiter(self)\u003c/code\u003e. It returns a\n new iterator for the object argument, or the object itself if the object\n is already an iterator. Throws \u003ccode\u003eTypeError\u003c/code\u003e if the object cannot be\n iterated.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "getIterator",
          "package": "cpython",
          "signature": "self -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Object.html#getIterator",
          "type": "function"
        },
        "index": {
          "description": "This is equivalent to the Python expression iter self It returns new iterator for the object argument or the object itself if the object is already an iterator Throws TypeError if the object cannot be iterated",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "getIterator",
          "normalized": "a-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Iterator",
          "signature": "self-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:getIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a \u003ccode\u003e\u003ca\u003eType\u003c/a\u003e\u003c/code\u003e object corresponding to the object type of \u003cem\u003eself\u003c/em\u003e. On\n failure, throws \u003ccode\u003eSystemError\u003c/code\u003e. This is equivalent to the Python expression\n \u003ccode\u003etype(o)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "getType",
          "package": "cpython",
          "signature": "self -\u003e IO Type",
          "source": "src/CPython-Protocols-Object.html#getType",
          "type": "function"
        },
        "index": {
          "description": "Returns Type object corresponding to the object type of self On failure throws SystemError This is equivalent to the Python expression type",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "getType",
          "normalized": "a-\u003eIO Type",
          "package": "cpython",
          "partial": "Type",
          "signature": "self-\u003eIO Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:getType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if \u003cem\u003eself\u003c/em\u003e has an attribute with the given name, and\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise. This is equivalent to the Python expression\n \u003ccode\u003ehasattr(self, name)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "hasAttribute",
          "package": "cpython",
          "signature": "self -\u003e Unicode -\u003e IO Bool",
          "source": "src/CPython-Protocols-Object.html#hasAttribute",
          "type": "function"
        },
        "index": {
          "description": "Returns True if self has an attribute with the given name and False otherwise This is equivalent to the Python expression hasattr self name",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "hasAttribute",
          "normalized": "a-\u003eUnicode-\u003eIO Bool",
          "package": "cpython",
          "partial": "Attribute",
          "signature": "self-\u003eUnicode-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:hasAttribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute and return the hash value of an object \u003cem\u003eself\u003c/em\u003e. On failure,\n throws an exception. This is the equivalent of the Python expression\n \u003ccode\u003ehash(self)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "hash",
          "package": "cpython",
          "signature": "self -\u003e IO Integer",
          "source": "src/CPython-Protocols-Object.html#hash",
          "type": "function"
        },
        "index": {
          "description": "Compute and return the hash value of an object self On failure throws an exception This is the equivalent of the Python expression hash self",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "hash",
          "normalized": "a-\u003eIO Integer",
          "package": "cpython",
          "signature": "self-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:hash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if \u003cem\u003einst\u003c/em\u003e is an instance of the class \u003cem\u003ecls\u003c/em\u003e or a\n subclass of \u003cem\u003ecls\u003c/em\u003e, or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if not. On error, throws an exception.\n If \u003cem\u003ecls\u003c/em\u003e is a type object rather than a class object, \u003ccode\u003e\u003ca\u003eisInstance\u003c/a\u003e\u003c/code\u003e\n returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if \u003cem\u003einst\u003c/em\u003e is of type \u003cem\u003ecls\u003c/em\u003e. If \u003cem\u003ecls\u003c/em\u003e is a tuple, the check\n will be done against every entry in \u003cem\u003ecls\u003c/em\u003e. The result will be \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n at least one of the checks returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, otherwise it will be \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e. If\n \u003cem\u003einst\u003c/em\u003e is not a class instance and \u003cem\u003ecls\u003c/em\u003e is neither a type object, nor a\n class object, nor a tuple, \u003cem\u003einst\u003c/em\u003e must have a \u003ccode\u003e__class__\u003c/code\u003e attribute &#2014;\n the class relationship of the value of that attribute with \u003cem\u003ecls\u003c/em\u003e will be\n used to determine the result of this function.\n\u003c/p\u003e\u003cp\u003eSubclass determination is done in a fairly straightforward way, but\n includes a wrinkle that implementors of extensions to the class system\n may want to be aware of. If A and B are class objects, B is a subclass of\n A if it inherits from A either directly or indirectly. If either is not a\n class object, a more general mechanism is used to determine the class\n relationship of the two objects. When testing if B is a subclass of A, if\n A is B, \u003ccode\u003e\u003ca\u003eisSubclass\u003c/a\u003e\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e. If A and B are different objects,\n B&#2018;s \u003ccode\u003e__bases__\u003c/code\u003e attribute is searched in a depth-first fashion for\n A &#2014; the presence of the \u003ccode\u003e__bases__\u003c/code\u003e attribute is considered\n sufficient for this determination.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "isInstance",
          "package": "cpython",
          "signature": "self -\u003e cls -\u003e IO Bool",
          "source": "src/CPython-Protocols-Object.html#isInstance",
          "type": "function"
        },
        "index": {
          "description": "Returns True if inst is an instance of the class cls or subclass of cls or False if not On error throws an exception If cls is type object rather than class object isInstance returns True if inst is of type cls If cls is tuple the check will be done against every entry in cls The result will be True when at least one of the checks returns True otherwise it will be False If inst is not class instance and cls is neither type object nor class object nor tuple inst must have class attribute the class relationship of the value of that attribute with cls will be used to determine the result of this function Subclass determination is done in fairly straightforward way but includes wrinkle that implementors of extensions to the class system may want to be aware of If and are class objects is subclass of if it inherits from either directly or indirectly If either is not class object more general mechanism is used to determine the class relationship of the two objects When testing if is subclass of if is isSubclass returns True If and are different objects bases attribute is searched in depth-first fashion for the presence of the bases attribute is considered sufficient for this determination",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "isInstance",
          "normalized": "a-\u003eb-\u003eIO Bool",
          "package": "cpython",
          "partial": "Instance",
          "signature": "self-\u003ecls-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:isInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the class \u003cem\u003ederived\u003c/em\u003e is identical to or derived from\n the class \u003cem\u003ecls\u003c/em\u003e, otherwise returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e. In case of an error, throws\n an exception. If \u003cem\u003ecls\u003c/em\u003e is a tuple, the check will be done against every\n entry in \u003cem\u003ecls\u003c/em\u003e. The result will be \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when at least one of the checks\n returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, otherwise it will be \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e. If either \u003cem\u003ederived\u003c/em\u003e or \u003cem\u003ecls\u003c/em\u003e\n is not an actual class object (or tuple), this function uses the generic\n algorithm described above.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "isSubclass",
          "package": "cpython",
          "signature": "derived -\u003e cls -\u003e IO Bool",
          "source": "src/CPython-Protocols-Object.html#isSubclass",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the class derived is identical to or derived from the class cls otherwise returns False In case of an error throws an exception If cls is tuple the check will be done against every entry in cls The result will be True when at least one of the checks returns True otherwise it will be False If either derived or cls is not an actual class object or tuple this function uses the generic algorithm described above",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "isSubclass",
          "normalized": "a-\u003eb-\u003eIO Bool",
          "package": "cpython",
          "partial": "Subclass",
          "signature": "derived-\u003ecls-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:isSubclass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint \u003ccode\u003erepr(self)\u003c/code\u003e to a handle.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "print",
          "package": "cpython",
          "signature": "self -\u003e Handle -\u003e IO ()",
          "source": "src/CPython-Protocols-Object.html#print",
          "type": "function"
        },
        "index": {
          "description": "Print repr self to handle",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "print",
          "normalized": "a-\u003eHandle-\u003eIO()",
          "package": "cpython",
          "signature": "self-\u003eHandle-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:print"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a string representation of object \u003cem\u003eself\u003c/em\u003e, or throw an exception\n on failure. This is the equivalent of the Python expression \u003ccode\u003erepr(self)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "repr",
          "package": "cpython",
          "signature": "self -\u003e IO Unicode",
          "source": "src/CPython-Protocols-Object.html#repr",
          "type": "function"
        },
        "index": {
          "description": "Compute string representation of object self or throw an exception on failure This is the equivalent of the Python expression repr self",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "repr",
          "normalized": "a-\u003eIO Unicode",
          "package": "cpython",
          "signature": "self-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:repr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompare the values of \u003cem\u003ea\u003c/em\u003e and \u003cem\u003eb\u003c/em\u003e using the specified comparison.\n If an exception is raised, throws an exception.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "richCompare",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e Comparison -\u003e IO Bool",
          "source": "src/CPython-Protocols-Object.html#richCompare",
          "type": "function"
        },
        "index": {
          "description": "Compare the values of and using the specified comparison If an exception is raised throws an exception",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "richCompare",
          "normalized": "a-\u003eb-\u003eComparison-\u003eIO Bool",
          "package": "cpython",
          "partial": "Compare",
          "signature": "a-\u003eb-\u003eComparison-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:richCompare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the value of the attribute with the given name, for object \u003cem\u003eself\u003c/em\u003e,\n to the value \u003cem\u003ev\u003c/em\u003e. THrows an exception on failure. This is the equivalent\n of the Python statement \u003ccode\u003eself.name = v\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "setAttribute",
          "package": "cpython",
          "signature": "self -\u003e Unicode -\u003e v -\u003e IO ()",
          "source": "src/CPython-Protocols-Object.html#setAttribute",
          "type": "function"
        },
        "index": {
          "description": "Set the value of the attribute with the given name for object self to the value THrows an exception on failure This is the equivalent of the Python statement self.name",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "setAttribute",
          "normalized": "a-\u003eUnicode-\u003eb-\u003eIO()",
          "package": "cpython",
          "partial": "Attribute",
          "signature": "self-\u003eUnicode-\u003ev-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:setAttribute"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute a string representation of object \u003cem\u003eself\u003c/em\u003e, or throw an exception\n on failure. This is the equivalent of the Python expression \u003ccode\u003estr(self)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "string",
          "package": "cpython",
          "signature": "self -\u003e IO Unicode",
          "source": "src/CPython-Protocols-Object.html#string",
          "type": "function"
        },
        "index": {
          "description": "Compute string representation of object self or throw an exception on failure This is the equivalent of the Python expression str self",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "string",
          "normalized": "a-\u003eIO Unicode",
          "package": "cpython",
          "signature": "self-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:string"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the object \u003cem\u003eself\u003c/em\u003e is considered to be true, and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n otherwise. This is equivalent to the Python expression \u003ccode\u003enot not self\u003c/code\u003e. On\n failure, throws an exception.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Object",
          "name": "toBool",
          "package": "cpython",
          "signature": "self -\u003e IO Bool",
          "source": "src/CPython-Protocols-Object.html#toBool",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the object self is considered to be true and False otherwise This is equivalent to the Python expression not not self On failure throws an exception",
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "toBool",
          "normalized": "a-\u003eIO Bool",
          "package": "cpython",
          "partial": "Bool",
          "signature": "self-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:toBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Object",
          "name": "toObject",
          "package": "cpython",
          "signature": "a -\u003e SomeObject",
          "source": "src/CPython-Internal.html#toObject",
          "type": "method"
        },
        "index": {
          "hierarchy": "CPython Protocols Object",
          "module": "CPython.Protocols.Object",
          "name": "toObject",
          "normalized": "a-\u003eSomeObject",
          "package": "cpython",
          "partial": "Object",
          "signature": "a-\u003eSomeObject",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Object.html#v:toObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "Sequence",
          "package": "cpython",
          "source": "src/CPython-Protocols-Sequence.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "Sequence",
          "package": "cpython",
          "partial": "Sequence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "Sequence",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Sequence",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "Sequence",
          "package": "cpython",
          "partial": "Sequence",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#t:Sequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "SomeSequence",
          "package": "cpython",
          "source": "src/CPython-Internal.html#SomeSequence",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "SomeSequence",
          "package": "cpython",
          "partial": "Some Sequence",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#t:SomeSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "append",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeSequence",
          "source": "src/CPython-Protocols-Sequence.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "append",
          "normalized": "a-\u003eb-\u003eIO SomeSequence",
          "package": "cpython",
          "signature": "a-\u003eb-\u003eIO SomeSequence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to convert an object to a generic \u003ccode\u003e\u003ca\u003eSequence\u003c/a\u003e\u003c/code\u003e. If the object does\n not implement the sequence protocol, returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Sequence",
          "name": "castToSequence",
          "package": "cpython",
          "signature": "a -\u003e IO (Maybe SomeSequence)",
          "source": "src/CPython-Protocols-Sequence.html#castToSequence",
          "type": "function"
        },
        "index": {
          "description": "Attempt to convert an object to generic Sequence If the object does not implement the sequence protocol returns Nothing",
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "castToSequence",
          "normalized": "a-\u003eIO(Maybe SomeSequence)",
          "package": "cpython",
          "partial": "To Sequence",
          "signature": "a-\u003eIO(Maybe SomeSequence)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:castToSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "contains",
          "package": "cpython",
          "signature": "self -\u003e v -\u003e IO Bool",
          "source": "src/CPython-Protocols-Sequence.html#contains",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "contains",
          "normalized": "a-\u003eb-\u003eIO Bool",
          "package": "cpython",
          "signature": "self-\u003ev-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "count",
          "package": "cpython",
          "signature": "self -\u003e v -\u003e IO Integer",
          "source": "src/CPython-Protocols-Sequence.html#count",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "count",
          "normalized": "a-\u003eb-\u003eIO Integer",
          "package": "cpython",
          "signature": "self-\u003ev-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "deleteItem",
          "package": "cpython",
          "signature": "self -\u003e Integer -\u003e IO ()",
          "source": "src/CPython-Protocols-Sequence.html#deleteItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "deleteItem",
          "normalized": "a-\u003eInteger-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "self-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:deleteItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "deleteSlice",
          "package": "cpython",
          "signature": "self -\u003e Integer -\u003e Integer -\u003e IO ()",
          "source": "src/CPython-Protocols-Sequence.html#deleteSlice",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "deleteSlice",
          "normalized": "a-\u003eInteger-\u003eInteger-\u003eIO()",
          "package": "cpython",
          "partial": "Slice",
          "signature": "self-\u003eInteger-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:deleteSlice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the sequence \u003cem\u003eseq\u003c/em\u003e as a tuple, unless it is already a tuple or\n list, in which case \u003cem\u003eseq\u003c/em\u003e is returned. If an error occurs, throws\n \u003ccode\u003eTypeError\u003c/code\u003e with the given text as the exception text.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Sequence",
          "name": "fast",
          "package": "cpython",
          "signature": "seq -\u003e Text -\u003e IO SomeSequence",
          "source": "src/CPython-Protocols-Sequence.html#fast",
          "type": "function"
        },
        "index": {
          "description": "Returns the sequence seq as tuple unless it is already tuple or list in which case seq is returned If an error occurs throws TypeError with the given text as the exception text",
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "fast",
          "normalized": "a-\u003eText-\u003eIO SomeSequence",
          "package": "cpython",
          "signature": "seq-\u003eText-\u003eIO SomeSequence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:fast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "getItem",
          "package": "cpython",
          "signature": "self -\u003e Integer -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Sequence.html#getItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "getItem",
          "normalized": "a-\u003eInteger-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Item",
          "signature": "self-\u003eInteger-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:getItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "getSlice",
          "package": "cpython",
          "signature": "self -\u003e Integer -\u003e Integer -\u003e IO SomeObject",
          "source": "src/CPython-Protocols-Sequence.html#getSlice",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "getSlice",
          "normalized": "a-\u003eInteger-\u003eInteger-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Slice",
          "signature": "self-\u003eInteger-\u003eInteger-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:getSlice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "inPlaceAppend",
          "package": "cpython",
          "signature": "a -\u003e b -\u003e IO SomeSequence",
          "source": "src/CPython-Protocols-Sequence.html#inPlaceAppend",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "inPlaceAppend",
          "normalized": "a-\u003eb-\u003eIO SomeSequence",
          "package": "cpython",
          "partial": "Place Append",
          "signature": "a-\u003eb-\u003eIO SomeSequence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:inPlaceAppend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "inPlaceRepeat",
          "package": "cpython",
          "signature": "a -\u003e Integer -\u003e IO a",
          "source": "src/CPython-Protocols-Sequence.html#inPlaceRepeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "inPlaceRepeat",
          "normalized": "a-\u003eInteger-\u003eIO a",
          "package": "cpython",
          "partial": "Place Repeat",
          "signature": "a-\u003eInteger-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:inPlaceRepeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the first index \u003cem\u003ei\u003c/em\u003e for which \u003ccode\u003eself[i] == v\u003c/code\u003e. This is equivalent\n to the Python expression \u003ccode\u003eself.index(v)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Sequence",
          "name": "index",
          "package": "cpython",
          "signature": "self -\u003e v -\u003e IO Integer",
          "source": "src/CPython-Protocols-Sequence.html#index",
          "type": "function"
        },
        "index": {
          "description": "Return the first index for which self This is equivalent to the Python expression self.index",
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "index",
          "normalized": "a-\u003eb-\u003eIO Integer",
          "package": "cpython",
          "signature": "self-\u003ev-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "length",
          "package": "cpython",
          "signature": "self -\u003e IO Integer",
          "source": "src/CPython-Protocols-Sequence.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "length",
          "normalized": "a-\u003eIO Integer",
          "package": "cpython",
          "signature": "self-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "repeat",
          "package": "cpython",
          "signature": "a -\u003e Integer -\u003e IO a",
          "source": "src/CPython-Protocols-Sequence.html#repeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "repeat",
          "normalized": "a-\u003eInteger-\u003eIO a",
          "package": "cpython",
          "signature": "a-\u003eInteger-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "setItem",
          "package": "cpython",
          "signature": "self -\u003e Integer -\u003e v -\u003e IO ()",
          "source": "src/CPython-Protocols-Sequence.html#setItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "setItem",
          "normalized": "a-\u003eInteger-\u003eb-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "self-\u003eInteger-\u003ev-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:setItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "setSlice",
          "package": "cpython",
          "signature": "self -\u003e Integer -\u003e Integer -\u003e v -\u003e IO ()",
          "source": "src/CPython-Protocols-Sequence.html#setSlice",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "setSlice",
          "normalized": "a-\u003eInteger-\u003eInteger-\u003eb-\u003eIO()",
          "package": "cpython",
          "partial": "Slice",
          "signature": "self-\u003eInteger-\u003eInteger-\u003ev-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:setSlice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list object with the same contents as the arbitrary sequence\n \u003cem\u003eseq\u003c/em\u003e. The returned list is guaranteed to be new.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Sequence",
          "name": "toList",
          "package": "cpython",
          "signature": "seq -\u003e IO List",
          "source": "src/CPython-Protocols-Sequence.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Return list object with the same contents as the arbitrary sequence seq The returned list is guaranteed to be new",
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "toList",
          "normalized": "a-\u003eIO List",
          "package": "cpython",
          "partial": "List",
          "signature": "seq-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Protocols.Sequence",
          "name": "toSequence",
          "package": "cpython",
          "signature": "a -\u003e SomeSequence",
          "source": "src/CPython-Internal.html#toSequence",
          "type": "method"
        },
        "index": {
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "toSequence",
          "normalized": "a-\u003eSomeSequence",
          "package": "cpython",
          "partial": "Sequence",
          "signature": "a-\u003eSomeSequence",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:toSequence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a tuple object with the same contents as the arbitrary sequence\n \u003cem\u003eseq\u003c/em\u003e. If \u003cem\u003eseq\u003c/em\u003e is already a tuple, it is re-used rather than copied.\n\u003c/p\u003e",
          "module": "CPython.Protocols.Sequence",
          "name": "toTuple",
          "package": "cpython",
          "signature": "seq -\u003e IO Tuple",
          "source": "src/CPython-Protocols-Sequence.html#toTuple",
          "type": "function"
        },
        "index": {
          "description": "Return tuple object with the same contents as the arbitrary sequence seq If seq is already tuple it is re-used rather than copied",
          "hierarchy": "CPython Protocols Sequence",
          "module": "CPython.Protocols.Sequence",
          "name": "toTuple",
          "normalized": "a-\u003eIO Tuple",
          "package": "cpython",
          "partial": "Tuple",
          "signature": "seq-\u003eIO Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Protocols-Sequence.html#v:toTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Reflection",
          "name": "Reflection",
          "package": "cpython",
          "source": "src/CPython-Reflection.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "Reflection",
          "package": "cpython",
          "partial": "Reflection",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ccode\u003e\u003ca\u003eDictionary\u003c/a\u003e\u003c/code\u003e of the builtins in the current execution frame,\n or the interpreter of the thread state if no frame is currently executing.\n\u003c/p\u003e",
          "module": "CPython.Reflection",
          "name": "getBuiltins",
          "package": "cpython",
          "signature": "IO Dictionary",
          "source": "src/CPython-Reflection.html#getBuiltins",
          "type": "function"
        },
        "index": {
          "description": "Return Dictionary of the builtins in the current execution frame or the interpreter of the thread state if no frame is currently executing",
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "getBuiltins",
          "package": "cpython",
          "partial": "Builtins",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#v:getBuiltins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current thread state's frame, which is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no frame\n is currently executing.\n\u003c/p\u003e",
          "module": "CPython.Reflection",
          "name": "getFrame",
          "package": "cpython",
          "signature": "IO (Maybe SomeObject)",
          "source": "src/CPython-Reflection.html#getFrame",
          "type": "function"
        },
        "index": {
          "description": "Return the current thread state frame which is Nothing if no frame is currently executing",
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "getFrame",
          "package": "cpython",
          "partial": "Frame",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#v:getFrame"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a description string, depending on the type of func. Return\n values include \u003ccode\u003e\"()\"\u003c/code\u003e for functions and methods, \u003ccode\u003e\"constructor\"\u003c/code\u003e,\n \u003ccode\u003e\"instance\"\u003c/code\u003e, and \u003ccode\u003e\"object\"\u003c/code\u003e. Concatenated with the result of\n \u003ccode\u003e\u003ca\u003egetFunctionName\u003c/a\u003e\u003c/code\u003e, the result will be a description of \u003cem\u003efunc\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "CPython.Reflection",
          "name": "getFunctionDescription",
          "package": "cpython",
          "signature": "func -\u003e IO Text",
          "source": "src/CPython-Reflection.html#getFunctionDescription",
          "type": "function"
        },
        "index": {
          "description": "Return description string depending on the type of func Return values include for functions and methods constructor instance and object Concatenated with the result of getFunctionName the result will be description of func",
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "getFunctionDescription",
          "normalized": "a-\u003eIO Text",
          "package": "cpython",
          "partial": "Function Description",
          "signature": "func-\u003eIO Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#v:getFunctionDescription"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the name of \u003cem\u003efunc\u003c/em\u003e if it is a function, class or instance object,\n else the name of \u003cem\u003efunc\u003c/em\u003e's type.\n\u003c/p\u003e",
          "module": "CPython.Reflection",
          "name": "getFunctionName",
          "package": "cpython",
          "signature": "func -\u003e IO Text",
          "source": "src/CPython-Reflection.html#getFunctionName",
          "type": "function"
        },
        "index": {
          "description": "Return the name of func if it is function class or instance object else the name of func type",
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "getFunctionName",
          "normalized": "a-\u003eIO Text",
          "package": "cpython",
          "partial": "Function Name",
          "signature": "func-\u003eIO Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#v:getFunctionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ccode\u003e\u003ca\u003eDictionary\u003c/a\u003e\u003c/code\u003e of the global variables in the current execution\n frame, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no frame is currently executing.\n\u003c/p\u003e",
          "module": "CPython.Reflection",
          "name": "getGlobals",
          "package": "cpython",
          "signature": "IO (Maybe Dictionary)",
          "source": "src/CPython-Reflection.html#getGlobals",
          "type": "function"
        },
        "index": {
          "description": "Return Dictionary of the global variables in the current execution frame or Nothing if no frame is currently executing",
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "getGlobals",
          "package": "cpython",
          "partial": "Globals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#v:getGlobals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ccode\u003e\u003ca\u003eDictionary\u003c/a\u003e\u003c/code\u003e of the local variables in the current execution\n frame, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if no frame is currently executing.\n\u003c/p\u003e",
          "module": "CPython.Reflection",
          "name": "getLocals",
          "package": "cpython",
          "signature": "IO (Maybe Dictionary)",
          "source": "src/CPython-Reflection.html#getLocals",
          "type": "function"
        },
        "index": {
          "description": "Return Dictionary of the local variables in the current execution frame or Nothing if no frame is currently executing",
          "hierarchy": "CPython Reflection",
          "module": "CPython.Reflection",
          "name": "getLocals",
          "package": "cpython",
          "partial": "Locals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Reflection.html#v:getLocals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.System",
          "name": "System",
          "package": "cpython",
          "source": "src/CPython-System.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "System",
          "package": "cpython",
          "partial": "System",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an entry to \u003ccode\u003esys.warnoptions\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.System",
          "name": "addWarnOption",
          "package": "cpython",
          "signature": "Text -\u003e IO ()",
          "source": "src/CPython-System.html#addWarnOption",
          "type": "function"
        },
        "index": {
          "description": "Add an entry to sys.warnoptions",
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "addWarnOption",
          "normalized": "Text-\u003eIO()",
          "package": "cpython",
          "partial": "Warn Option",
          "signature": "Text-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#v:addWarnOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete \u003cem\u003ename\u003c/em\u003e from the \u003ccode\u003esys\u003c/code\u003e module.\n\u003c/p\u003e",
          "module": "CPython.System",
          "name": "deleteObject",
          "package": "cpython",
          "signature": "Text -\u003e IO ()",
          "source": "src/CPython-System.html#deleteObject",
          "type": "function"
        },
        "index": {
          "description": "Delete name from the sys module",
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "deleteObject",
          "normalized": "Text-\u003eIO()",
          "package": "cpython",
          "partial": "Object",
          "signature": "Text-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#v:deleteObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the object \u003cem\u003ename\u003c/em\u003e from the \u003ccode\u003esys\u003c/code\u003e module, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if it does\n not exist.\n\u003c/p\u003e",
          "module": "CPython.System",
          "name": "getObject",
          "package": "cpython",
          "signature": "Text -\u003e IO (Maybe SomeObject)",
          "source": "src/CPython-System.html#getObject",
          "type": "function"
        },
        "index": {
          "description": "Return the object name from the sys module or Nothing if it does not exist",
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "getObject",
          "normalized": "Text-\u003eIO(Maybe SomeObject)",
          "package": "cpython",
          "partial": "Object",
          "signature": "Text-\u003eIO(Maybe SomeObject)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#v:getObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset \u003ccode\u003esys.warnoptions\u003c/code\u003e to an empty list.\n\u003c/p\u003e",
          "module": "CPython.System",
          "name": "resetWarnOptions",
          "package": "cpython",
          "signature": "IO ()",
          "source": "src/CPython-System.html#resetWarnOptions",
          "type": "function"
        },
        "index": {
          "description": "Reset sys.warnoptions to an empty list",
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "resetWarnOptions",
          "normalized": "IO()",
          "package": "cpython",
          "partial": "Warn Options",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#v:resetWarnOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet \u003cem\u003ename\u003c/em\u003e in the \u003ccode\u003esys\u003c/code\u003e module to a value.\n\u003c/p\u003e",
          "module": "CPython.System",
          "name": "setObject",
          "package": "cpython",
          "signature": "Text -\u003e a -\u003e IO ()",
          "source": "src/CPython-System.html#setObject",
          "type": "function"
        },
        "index": {
          "description": "Set name in the sys module to value",
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "setObject",
          "normalized": "Text-\u003ea-\u003eIO()",
          "package": "cpython",
          "partial": "Object",
          "signature": "Text-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#v:setObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet \u003ccode\u003esys.path\u003c/code\u003e to a list object of paths found in the parameter, which\n should be a list of paths separated with the platform's search path\n delimiter (\u003ccode\u003e':'\u003c/code\u003e on Unix, \u003ccode\u003e';'\u003c/code\u003e on Windows).\n\u003c/p\u003e",
          "module": "CPython.System",
          "name": "setPath",
          "package": "cpython",
          "signature": "Text -\u003e IO ()",
          "source": "src/CPython-System.html#setPath",
          "type": "function"
        },
        "index": {
          "description": "Set sys.path to list object of paths found in the parameter which should be list of paths separated with the platform search path delimiter on Unix on Windows",
          "hierarchy": "CPython System",
          "module": "CPython.System",
          "name": "setPath",
          "normalized": "Text-\u003eIO()",
          "package": "cpython",
          "partial": "Path",
          "signature": "Text-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-System.html#v:setPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.ByteArray",
          "name": "ByteArray",
          "package": "cpython",
          "source": "src/CPython-Types-ByteArray.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "ByteArray",
          "package": "cpython",
          "partial": "Byte Array",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.ByteArray",
          "name": "ByteArray",
          "package": "cpython",
          "source": "src/CPython-Types-ByteArray.html#ByteArray",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "ByteArray",
          "package": "cpython",
          "partial": "Byte Array",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#t:ByteArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.ByteArray",
          "name": "append",
          "package": "cpython",
          "signature": "ByteArray -\u003e ByteArray -\u003e IO ByteArray",
          "source": "src/CPython-Types-ByteArray.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "append",
          "normalized": "ByteArray-\u003eByteArray-\u003eIO ByteArray",
          "package": "cpython",
          "signature": "ByteArray-\u003eByteArray-\u003eIO ByteArray",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.ByteArray\",\"CPython.Types\"]",
          "name": "byteArrayType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-ByteArray.html#byteArrayType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:byteArrayType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:byteArrayType\"]"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "byteArrayType",
          "package": "cpython",
          "partial": "Array Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:byteArrayType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.ByteArray\",\"CPython.Types\"]",
          "name": "fromByteArray",
          "package": "cpython",
          "signature": "ByteArray -\u003e IO ByteString",
          "source": "src/CPython-Types-ByteArray.html#fromByteArray",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:fromByteArray\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromByteArray\"]"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "fromByteArray",
          "normalized": "ByteArray-\u003eIO ByteString",
          "package": "cpython",
          "partial": "Byte Array",
          "signature": "ByteArray-\u003eIO ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:fromByteArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new byte array from any object which implements the buffer\n protocol.\n\u003c/p\u003e",
          "module": "CPython.Types.ByteArray",
          "name": "fromObject",
          "package": "cpython",
          "signature": "self -\u003e IO ByteArray",
          "source": "src/CPython-Types-ByteArray.html#fromObject",
          "type": "function"
        },
        "index": {
          "description": "Create new byte array from any object which implements the buffer protocol",
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "fromObject",
          "normalized": "a-\u003eIO ByteArray",
          "package": "cpython",
          "partial": "Object",
          "signature": "self-\u003eIO ByteArray",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:fromObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.ByteArray",
          "name": "length",
          "package": "cpython",
          "signature": "ByteArray -\u003e IO Integer",
          "source": "src/CPython-Types-ByteArray.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "length",
          "normalized": "ByteArray-\u003eIO Integer",
          "package": "cpython",
          "signature": "ByteArray-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.ByteArray",
          "name": "resize",
          "package": "cpython",
          "signature": "ByteArray -\u003e Integer -\u003e IO ()",
          "source": "src/CPython-Types-ByteArray.html#resize",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "resize",
          "normalized": "ByteArray-\u003eInteger-\u003eIO()",
          "package": "cpython",
          "signature": "ByteArray-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:resize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.ByteArray\",\"CPython.Types\"]",
          "name": "toByteArray",
          "package": "cpython",
          "signature": "ByteString -\u003e IO ByteArray",
          "source": "src/CPython-Types-ByteArray.html#toByteArray",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:toByteArray\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toByteArray\"]"
        },
        "index": {
          "hierarchy": "CPython Types ByteArray",
          "module": "CPython.Types.ByteArray",
          "name": "toByteArray",
          "normalized": "ByteString-\u003eIO ByteArray",
          "package": "cpython",
          "partial": "Byte Array",
          "signature": "ByteString-\u003eIO ByteArray",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-ByteArray.html#v:toByteArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Bytes",
          "name": "Bytes",
          "package": "cpython",
          "source": "src/CPython-Types-Bytes.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "Bytes",
          "package": "cpython",
          "partial": "Bytes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Bytes",
          "name": "Bytes",
          "package": "cpython",
          "source": "src/CPython-Types-Bytes.html#Bytes",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "Bytes",
          "package": "cpython",
          "partial": "Bytes",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#t:Bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Bytes",
          "name": "append",
          "package": "cpython",
          "signature": "Bytes -\u003e Bytes -\u003e IO Bytes",
          "source": "src/CPython-Types-Bytes.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "append",
          "normalized": "Bytes-\u003eBytes-\u003eIO Bytes",
          "package": "cpython",
          "signature": "Bytes-\u003eBytes-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Bytes\",\"CPython.Types\"]",
          "name": "bytesType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Bytes.html#bytesType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:bytesType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:bytesType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "bytesType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:bytesType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Bytes\",\"CPython.Types\"]",
          "name": "fromBytes",
          "package": "cpython",
          "signature": "Bytes -\u003e IO ByteString",
          "source": "src/CPython-Types-Bytes.html#fromBytes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:fromBytes\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromBytes\"]"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "fromBytes",
          "normalized": "Bytes-\u003eIO ByteString",
          "package": "cpython",
          "partial": "Bytes",
          "signature": "Bytes-\u003eIO ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:fromBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new byte string from any object which implements the buffer\n protocol.\n\u003c/p\u003e",
          "module": "CPython.Types.Bytes",
          "name": "fromObject",
          "package": "cpython",
          "signature": "self -\u003e IO Bytes",
          "source": "src/CPython-Types-Bytes.html#fromObject",
          "type": "function"
        },
        "index": {
          "description": "Create new byte string from any object which implements the buffer protocol",
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "fromObject",
          "normalized": "a-\u003eIO Bytes",
          "package": "cpython",
          "partial": "Object",
          "signature": "self-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:fromObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Bytes",
          "name": "length",
          "package": "cpython",
          "signature": "Bytes -\u003e IO Integer",
          "source": "src/CPython-Types-Bytes.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "length",
          "normalized": "Bytes-\u003eIO Integer",
          "package": "cpython",
          "signature": "Bytes-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Bytes\",\"CPython.Types\"]",
          "name": "toBytes",
          "package": "cpython",
          "signature": "ByteString -\u003e IO Bytes",
          "source": "src/CPython-Types-Bytes.html#toBytes",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:toBytes\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toBytes\"]"
        },
        "index": {
          "hierarchy": "CPython Types Bytes",
          "module": "CPython.Types.Bytes",
          "name": "toBytes",
          "normalized": "ByteString-\u003eIO Bytes",
          "package": "cpython",
          "partial": "Bytes",
          "signature": "ByteString-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Bytes.html#v:toBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Capsule",
          "name": "Capsule",
          "package": "cpython",
          "source": "src/CPython-Types-Capsule.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "Capsule",
          "package": "cpython",
          "partial": "Capsule",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Capsule",
          "name": "Capsule",
          "package": "cpython",
          "source": "src/CPython-Types-Capsule.html#Capsule",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "Capsule",
          "package": "cpython",
          "partial": "Capsule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#t:Capsule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Capsule\",\"CPython.Types\"]",
          "name": "capsuleType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Capsule.html#capsuleType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:capsuleType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:capsuleType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "capsuleType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:capsuleType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current context stored in the capsule, which might be \u003ccode\u003eNULL\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "getContext",
          "package": "cpython",
          "signature": "Capsule -\u003e IO (Ptr ())",
          "source": "src/CPython-Types-Capsule.html#getContext",
          "type": "function"
        },
        "index": {
          "description": "Return the current context stored in the capsule which might be NULL",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "getContext",
          "normalized": "Capsule-\u003eIO(Ptr())",
          "package": "cpython",
          "partial": "Context",
          "signature": "Capsule-\u003eIO(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:getContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current name stored in the capsule, which might be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "getName",
          "package": "cpython",
          "signature": "Capsule -\u003e IO (Maybe Text)",
          "source": "src/CPython-Types-Capsule.html#getName",
          "type": "function"
        },
        "index": {
          "description": "Return the current name stored in the capsule which might be Nothing",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "getName",
          "normalized": "Capsule-\u003eIO(Maybe Text)",
          "package": "cpython",
          "partial": "Name",
          "signature": "Capsule-\u003eIO(Maybe Text)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:getName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the pointer stored in the capsule. On failure, throws an\n exception.\n\u003c/p\u003e\u003cp\u003eThe name parameter must compare exactly to the name stored in the capsule.\n If the name stored in the capsule is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the name passed in must\n also be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e. Python uses the C function strcmp() to compare capsule\n names.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "getPointer",
          "package": "cpython",
          "signature": "Capsule -\u003e Maybe Text -\u003e IO (Ptr ())",
          "source": "src/CPython-Types-Capsule.html#getPointer",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the pointer stored in the capsule On failure throws an exception The name parameter must compare exactly to the name stored in the capsule If the name stored in the capsule is Nothing the name passed in must also be Nothing Python uses the function strcmp to compare capsule names",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "getPointer",
          "normalized": "Capsule-\u003eMaybe Text-\u003eIO(Ptr())",
          "package": "cpython",
          "partial": "Pointer",
          "signature": "Capsule-\u003eMaybe Text-\u003eIO(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:getPointer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImport a pointer to a C object from a capsule attribute in a module.\n The name parameter should specify the full name to the attribute, as in\n \u003ccode\u003e\"module.attribute\"\u003c/code\u003e. The name stored in the capsule must match this\n string exactly. If the second parameter is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, import the module\n without blocking (using \u003ccode\u003ePyImport_ImportModuleNoBlock()\u003c/code\u003e). Otherwise,\n imports the module conventionally (using \u003ccode\u003ePyImport_ImportModule()\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eReturn the capsule&#8217;s internal pointer on success. On failure, throw\n an exception. If the module could not be imported, and if importing in\n non-blocking mode, returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "importNamed",
          "package": "cpython",
          "signature": "Text -\u003e Bool -\u003e IO (Maybe (Ptr ()))",
          "source": "src/CPython-Types-Capsule.html#importNamed",
          "type": "function"
        },
        "index": {
          "description": "Import pointer to object from capsule attribute in module The name parameter should specify the full name to the attribute as in module.attribute The name stored in the capsule must match this string exactly If the second parameter is False import the module without blocking using PyImport ImportModuleNoBlock Otherwise imports the module conventionally using PyImport ImportModule Return the capsule internal pointer on success On failure throw an exception If the module could not be imported and if importing in non-blocking mode returns Nothing",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "importNamed",
          "normalized": "Text-\u003eBool-\u003eIO(Maybe(Ptr()))",
          "package": "cpython",
          "partial": "Named",
          "signature": "Text-\u003eBool-\u003eIO(Maybe(Ptr()))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:importNamed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines whether or not a capsule is valid. A valid capsule's type is\n \u003ccode\u003e\u003ca\u003ecapsuleType\u003c/a\u003e\u003c/code\u003e, has a non-NULL pointer stored in it, and its internal name\n matches the name parameter. (See \u003ccode\u003e\u003ca\u003egetPointer\u003c/a\u003e\u003c/code\u003e for information on how\n capsule names are compared.)\n\u003c/p\u003e\u003cp\u003eIn other words, if \u003ccode\u003e\u003ca\u003eisValid\u003c/a\u003e\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, calls to any of the\n accessors (any function starting with \u003ccode\u003eget\u003c/code\u003e) are guaranteed to succeed.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "isValid",
          "package": "cpython",
          "signature": "Capsule -\u003e Maybe Text -\u003e IO Bool",
          "source": "src/CPython-Types-Capsule.html#isValid",
          "type": "function"
        },
        "index": {
          "description": "Determines whether or not capsule is valid valid capsule type is capsuleType has non-NULL pointer stored in it and its internal name matches the name parameter See getPointer for information on how capsule names are compared In other words if isValid returns True calls to any of the accessors any function starting with get are guaranteed to succeed",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "isValid",
          "normalized": "Capsule-\u003eMaybe Text-\u003eIO Bool",
          "package": "cpython",
          "partial": "Valid",
          "signature": "Capsule-\u003eMaybe Text-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:isValid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the context pointer inside the capsule.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "setContext",
          "package": "cpython",
          "signature": "Capsule -\u003e Ptr () -\u003e IO ()",
          "source": "src/CPython-Types-Capsule.html#setContext",
          "type": "function"
        },
        "index": {
          "description": "Set the context pointer inside the capsule",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "setContext",
          "normalized": "Capsule-\u003ePtr()-\u003eIO()",
          "package": "cpython",
          "partial": "Context",
          "signature": "Capsule-\u003ePtr()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:setContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the void pointer inside the capsule. The pointer may not be \u003ccode\u003eNULL\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Capsule",
          "name": "setPointer",
          "package": "cpython",
          "signature": "Capsule -\u003e Ptr () -\u003e IO ()",
          "source": "src/CPython-Types-Capsule.html#setPointer",
          "type": "function"
        },
        "index": {
          "description": "Set the void pointer inside the capsule The pointer may not be NULL",
          "hierarchy": "CPython Types Capsule",
          "module": "CPython.Types.Capsule",
          "name": "setPointer",
          "normalized": "Capsule-\u003ePtr()-\u003eIO()",
          "package": "cpython",
          "partial": "Pointer",
          "signature": "Capsule-\u003ePtr()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Capsule.html#v:setPointer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Cell",
          "name": "Cell",
          "package": "cpython",
          "source": "src/CPython-Types-Cell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Cell",
          "module": "CPython.Types.Cell",
          "name": "Cell",
          "package": "cpython",
          "partial": "Cell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Cell",
          "name": "Cell",
          "package": "cpython",
          "source": "src/CPython-Types-Cell.html#Cell",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Cell",
          "module": "CPython.Types.Cell",
          "name": "Cell",
          "package": "cpython",
          "partial": "Cell",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#t:Cell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Cell\",\"CPython.Types\"]",
          "name": "cellType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Cell.html#cellType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#v:cellType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:cellType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Cell",
          "module": "CPython.Types.Cell",
          "name": "cellType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#v:cellType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the contents of a cell.\n\u003c/p\u003e",
          "module": "CPython.Types.Cell",
          "name": "get",
          "package": "cpython",
          "signature": "Cell -\u003e IO (Maybe SomeObject)",
          "source": "src/CPython-Types-Cell.html#get",
          "type": "function"
        },
        "index": {
          "description": "Return the contents of cell",
          "hierarchy": "CPython Types Cell",
          "module": "CPython.Types.Cell",
          "name": "get",
          "normalized": "Cell-\u003eIO(Maybe SomeObject)",
          "package": "cpython",
          "signature": "Cell-\u003eIO(Maybe SomeObject)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#v:get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate and return a new cell containing the value \u003cem\u003eobj\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Cell",
          "name": "new",
          "package": "cpython",
          "signature": "Maybe obj -\u003e IO Cell",
          "source": "src/CPython-Types-Cell.html#new",
          "type": "function"
        },
        "index": {
          "description": "Create and return new cell containing the value obj",
          "hierarchy": "CPython Types Cell",
          "module": "CPython.Types.Cell",
          "name": "new",
          "normalized": "Maybe a-\u003eIO Cell",
          "package": "cpython",
          "signature": "Maybe obj-\u003eIO Cell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the contents of a cell to \u003cem\u003eobj\u003c/em\u003e. This releases the reference to any\n current content of the cell.\n\u003c/p\u003e",
          "module": "CPython.Types.Cell",
          "name": "set",
          "package": "cpython",
          "signature": "Cell -\u003e Maybe obj -\u003e IO ()",
          "source": "src/CPython-Types-Cell.html#set",
          "type": "function"
        },
        "index": {
          "description": "Set the contents of cell to obj This releases the reference to any current content of the cell",
          "hierarchy": "CPython Types Cell",
          "module": "CPython.Types.Cell",
          "name": "set",
          "normalized": "Cell-\u003eMaybe a-\u003eIO()",
          "package": "cpython",
          "signature": "Cell-\u003eMaybe obj-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Cell.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Code",
          "name": "Code",
          "package": "cpython",
          "source": "src/CPython-Types-Code.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Code",
          "module": "CPython.Types.Code",
          "name": "Code",
          "package": "cpython",
          "partial": "Code",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Code.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Code",
          "name": "Code",
          "package": "cpython",
          "source": "src/CPython-Types-Code.html#Code",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Code",
          "module": "CPython.Types.Code",
          "name": "Code",
          "package": "cpython",
          "partial": "Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Code.html#t:Code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Code\",\"CPython.Types\"]",
          "name": "codeType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Code.html#codeType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Code.html#v:codeType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:codeType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Code",
          "module": "CPython.Types.Code",
          "name": "codeType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Code.html#v:codeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Complex",
          "name": "Complex",
          "package": "cpython",
          "source": "src/CPython-Types-Complex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Complex",
          "module": "CPython.Types.Complex",
          "name": "Complex",
          "package": "cpython",
          "partial": "Complex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Complex",
          "name": "Complex",
          "package": "cpython",
          "source": "src/CPython-Types-Complex.html#Complex",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Complex",
          "module": "CPython.Types.Complex",
          "name": "Complex",
          "package": "cpython",
          "partial": "Complex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#t:Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Complex\",\"CPython.Types\"]",
          "name": "complexType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Complex.html#complexType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#v:complexType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:complexType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Complex",
          "module": "CPython.Types.Complex",
          "name": "complexType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#v:complexType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Complex\",\"CPython.Types\"]",
          "name": "fromComplex",
          "package": "cpython",
          "signature": "Complex -\u003e IO (Complex Double)",
          "source": "src/CPython-Types-Complex.html#fromComplex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#v:fromComplex\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromComplex\"]"
        },
        "index": {
          "hierarchy": "CPython Types Complex",
          "module": "CPython.Types.Complex",
          "name": "fromComplex",
          "normalized": "Complex-\u003eIO(Complex Double)",
          "package": "cpython",
          "partial": "Complex",
          "signature": "Complex-\u003eIO(Complex Double)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#v:fromComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Complex\",\"CPython.Types\"]",
          "name": "toComplex",
          "package": "cpython",
          "signature": "Complex Double -\u003e IO Complex",
          "source": "src/CPython-Types-Complex.html#toComplex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#v:toComplex\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toComplex\"]"
        },
        "index": {
          "hierarchy": "CPython Types Complex",
          "module": "CPython.Types.Complex",
          "name": "toComplex",
          "normalized": "Complex Double-\u003eIO Complex",
          "package": "cpython",
          "partial": "Complex",
          "signature": "Complex Double-\u003eIO Complex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Complex.html#v:toComplex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Dictionary",
          "name": "Dictionary",
          "package": "cpython",
          "source": "src/CPython-Types-Dictionary.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "Dictionary",
          "package": "cpython",
          "partial": "Dictionary",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Dictionary",
          "name": "Dictionary",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Dictionary",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "Dictionary",
          "package": "cpython",
          "partial": "Dictionary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#t:Dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEmpty an existing dictionary of all key-value pairs.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "clear",
          "package": "cpython",
          "signature": "Dictionary -\u003e IO ()",
          "source": "src/CPython-Types-Dictionary.html#clear",
          "type": "function"
        },
        "index": {
          "description": "Empty an existing dictionary of all key-value pairs",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "clear",
          "normalized": "Dictionary-\u003eIO()",
          "package": "cpython",
          "signature": "Dictionary-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:clear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermine if a dictionary contains \u003cem\u003ekey\u003c/em\u003e. If an item in the dictionary\n matches \u003cem\u003ekey\u003c/em\u003e, return \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, otherwise return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e. On error, throws\n an exception. This is equivalent to the Python expression \u003ccode\u003ekey in d\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "contains",
          "package": "cpython",
          "signature": "Dictionary -\u003e key -\u003e IO Bool",
          "source": "src/CPython-Types-Dictionary.html#contains",
          "type": "function"
        },
        "index": {
          "description": "Determine if dictionary contains key If an item in the dictionary matches key return True otherwise return False On error throws an exception This is equivalent to the Python expression key in",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "contains",
          "normalized": "Dictionary-\u003ea-\u003eIO Bool",
          "package": "cpython",
          "signature": "Dictionary-\u003ekey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new dictionary that contains the same key-value pairs as the\n old dictionary.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "copy",
          "package": "cpython",
          "signature": "Dictionary -\u003e IO Dictionary",
          "source": "src/CPython-Types-Dictionary.html#copy",
          "type": "function"
        },
        "index": {
          "description": "Return new dictionary that contains the same key-value pairs as the old dictionary",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "copy",
          "normalized": "Dictionary-\u003eIO Dictionary",
          "package": "cpython",
          "signature": "Dictionary-\u003eIO Dictionary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:copy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove the entry in a dictionary with key \u003cem\u003ekey\u003c/em\u003e. \u003cem\u003ekey\u003c/em\u003e must be hashable;\n if it isn&#8217;t, throws \u003ccode\u003eTypeError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "deleteItem",
          "package": "cpython",
          "signature": "Dictionary -\u003e key -\u003e IO ()",
          "source": "src/CPython-Types-Dictionary.html#deleteItem",
          "type": "function"
        },
        "index": {
          "description": "Remove the entry in dictionary with key key key must be hashable if it isn throws TypeError",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "deleteItem",
          "normalized": "Dictionary-\u003ea-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "Dictionary-\u003ekey-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:deleteItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Dictionary\",\"CPython.Types\"]",
          "name": "dictionaryType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Dictionary.html#dictionaryType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:dictionaryType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:dictionaryType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "dictionaryType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:dictionaryType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the object from a dictionary which has a key \u003cem\u003ekey\u003c/em\u003e. Return\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the key is not present.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "getItem",
          "package": "cpython",
          "signature": "Dictionary -\u003e key -\u003e IO (Maybe SomeObject)",
          "source": "src/CPython-Types-Dictionary.html#getItem",
          "type": "function"
        },
        "index": {
          "description": "Return the object from dictionary which has key key Return Nothing if the key is not present",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "getItem",
          "normalized": "Dictionary-\u003ea-\u003eIO(Maybe SomeObject)",
          "package": "cpython",
          "partial": "Item",
          "signature": "Dictionary-\u003ekey-\u003eIO(Maybe SomeObject)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:getItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e containing all the items in the dictionary, as in\n the Python method \u003ccode\u003edict.items()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "items",
          "package": "cpython",
          "signature": "Dictionary -\u003e IO List",
          "source": "src/CPython-Types-Dictionary.html#items",
          "type": "function"
        },
        "index": {
          "description": "Return List containing all the items in the dictionary as in the Python method dict.items",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "items",
          "normalized": "Dictionary-\u003eIO List",
          "package": "cpython",
          "signature": "Dictionary-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:items"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e containing all the keys in the dictionary, as in\n the Python method \u003ccode\u003edict.keys()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "keys",
          "package": "cpython",
          "signature": "Dictionary -\u003e IO List",
          "source": "src/CPython-Types-Dictionary.html#keys",
          "type": "function"
        },
        "index": {
          "description": "Return List containing all the keys in the dictionary as in the Python method dict.keys",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "keys",
          "normalized": "Dictionary-\u003eIO List",
          "package": "cpython",
          "signature": "Dictionary-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIterate over mapping object \u003cem\u003eb\u003c/em\u003e adding key-value pairs to a dictionary.\n \u003cem\u003eb\u003c/em\u003e may be a dictionary, or any object supporting \u003ccode\u003e\u003ca\u003ekeys\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003egetItem\u003c/a\u003e\u003c/code\u003e.\n If the third parameter is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, existing pairs in will be replaced if a\n matching key is found in \u003cem\u003eb\u003c/em\u003e, otherwise pairs will only be added if there\n is not already a matching key.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "merge",
          "package": "cpython",
          "signature": "Dictionary -\u003e b -\u003e Bool -\u003e IO ()",
          "source": "src/CPython-Types-Dictionary.html#merge",
          "type": "function"
        },
        "index": {
          "description": "Iterate over mapping object adding key-value pairs to dictionary may be dictionary or any object supporting keys and getItem If the third parameter is True existing pairs in will be replaced if matching key is found in otherwise pairs will only be added if there is not already matching key",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "merge",
          "normalized": "Dictionary-\u003ea-\u003eBool-\u003eIO()",
          "package": "cpython",
          "signature": "Dictionary-\u003eb-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:merge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpdate or merge into a dictionary, from the key-value pairs in \u003cem\u003eseq2\u003c/em\u003e.\n \u003cem\u003eseq2\u003c/em\u003e must be an iterable object producing iterable objects of length 2,\n viewed as key-value pairs. In case of duplicate keys, the last wins if\n the third parameter is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, otherwise the first wins. Equivalent\n Python:\n\u003c/p\u003e\u003cpre\u003e\n def mergeFromSeq2(a, seq2, override):\n \tfor key, value in seq2:\n \t\tif override or key not in a:\n \t\t\ta[key] = value\n\u003c/pre\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "mergeFromSeq2",
          "package": "cpython",
          "signature": "Dictionary -\u003e seq2 -\u003e Bool -\u003e IO ()",
          "source": "src/CPython-Types-Dictionary.html#mergeFromSeq2",
          "type": "function"
        },
        "index": {
          "description": "Update or merge into dictionary from the key-value pairs in seq2 seq2 must be an iterable object producing iterable objects of length viewed as key-value pairs In case of duplicate keys the last wins if the third parameter is True otherwise the first wins Equivalent Python def mergeFromSeq2 seq2 override for key value in seq2 if override or key not in key value",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "mergeFromSeq2",
          "normalized": "Dictionary-\u003ea-\u003eBool-\u003eIO()",
          "package": "cpython",
          "partial": "From Seq",
          "signature": "Dictionary-\u003eseq-\u003eBool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:mergeFromSeq2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Dictionary",
          "name": "new",
          "package": "cpython",
          "signature": "IO Dictionary",
          "source": "src/CPython-Types-Dictionary.html#new",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "new",
          "package": "cpython",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts \u003cem\u003evalue\u003c/em\u003e into a dictionary with a key of \u003cem\u003ekey\u003c/em\u003e. \u003cem\u003ekey\u003c/em\u003e must be\n hashable; if it isn&#8217;t, throws \u003ccode\u003eTypeError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "setItem",
          "package": "cpython",
          "signature": "Dictionary -\u003e key -\u003e value -\u003e IO ()",
          "source": "src/CPython-Types-Dictionary.html#setItem",
          "type": "function"
        },
        "index": {
          "description": "Inserts value into dictionary with key of key key must be hashable if it isn throws TypeError",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "setItem",
          "normalized": "Dictionary-\u003ea-\u003eb-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "Dictionary-\u003ekey-\u003evalue-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:setItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of items in the dictionary. This is equivalent to\n \u003ccode\u003elen(d)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "size",
          "package": "cpython",
          "signature": "Dictionary -\u003e IO Integer",
          "source": "src/CPython-Types-Dictionary.html#size",
          "type": "function"
        },
        "index": {
          "description": "Return the number of items in the dictionary This is equivalent to len",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "size",
          "normalized": "Dictionary-\u003eIO Integer",
          "package": "cpython",
          "signature": "Dictionary-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the same as \u003ccode\u003e(\\a b -\u003e \u003ccode\u003e\u003ca\u003emerge\u003c/a\u003e\u003c/code\u003e a b True)\u003c/code\u003e in Haskell, or\n \u003ccode\u003ea.update(b)\u003c/code\u003e in Python.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "update",
          "package": "cpython",
          "signature": "Dictionary -\u003e b -\u003e IO ()",
          "source": "src/CPython-Types-Dictionary.html#update",
          "type": "function"
        },
        "index": {
          "description": "This is the same as merge True in Haskell or a.update in Python",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "update",
          "normalized": "Dictionary-\u003ea-\u003eIO()",
          "package": "cpython",
          "signature": "Dictionary-\u003eb-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e containing all the values in the dictionary, as in\n the Python method \u003ccode\u003edict.values()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Dictionary",
          "name": "values",
          "package": "cpython",
          "signature": "Dictionary -\u003e IO List",
          "source": "src/CPython-Types-Dictionary.html#values",
          "type": "function"
        },
        "index": {
          "description": "Return List containing all the values in the dictionary as in the Python method dict.values",
          "hierarchy": "CPython Types Dictionary",
          "module": "CPython.Types.Dictionary",
          "name": "values",
          "normalized": "Dictionary-\u003eIO List",
          "package": "cpython",
          "signature": "Dictionary-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Dictionary.html#v:values"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Exception",
          "name": "Exception",
          "package": "cpython",
          "source": "src/CPython-Types-Exception.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Exception",
          "module": "CPython.Types.Exception",
          "name": "Exception",
          "package": "cpython",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Exception",
          "name": "Exception",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Exception",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Exception",
          "module": "CPython.Types.Exception",
          "name": "Exception",
          "package": "cpython",
          "partial": "Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Exception.html#t:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Exception",
          "name": "exceptionTraceback",
          "package": "cpython",
          "signature": "Exception -\u003e Maybe SomeObject",
          "source": "src/CPython-Internal.html#exceptionTraceback",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Exception",
          "module": "CPython.Types.Exception",
          "name": "exceptionTraceback",
          "normalized": "Exception-\u003eMaybe SomeObject",
          "package": "cpython",
          "partial": "Traceback",
          "signature": "Exception-\u003eMaybe SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Exception.html#v:exceptionTraceback"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Exception",
          "name": "exceptionType",
          "package": "cpython",
          "signature": "Exception -\u003e SomeObject",
          "source": "src/CPython-Internal.html#exceptionType",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Exception",
          "module": "CPython.Types.Exception",
          "name": "exceptionType",
          "normalized": "Exception-\u003eSomeObject",
          "package": "cpython",
          "partial": "Type",
          "signature": "Exception-\u003eSomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Exception.html#v:exceptionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Exception",
          "name": "exceptionValue",
          "package": "cpython",
          "signature": "Exception -\u003e SomeObject",
          "source": "src/CPython-Internal.html#exceptionValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Exception",
          "module": "CPython.Types.Exception",
          "name": "exceptionValue",
          "normalized": "Exception-\u003eSomeObject",
          "package": "cpython",
          "partial": "Value",
          "signature": "Exception-\u003eSomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Exception.html#v:exceptionValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Float",
          "name": "Float",
          "package": "cpython",
          "source": "src/CPython-Types-Float.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Float",
          "module": "CPython.Types.Float",
          "name": "Float",
          "package": "cpython",
          "partial": "Float",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Float",
          "name": "Float",
          "package": "cpython",
          "source": "src/CPython-Types-Float.html#Float",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Float",
          "module": "CPython.Types.Float",
          "name": "Float",
          "package": "cpython",
          "partial": "Float",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#t:Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Float\",\"CPython.Types\"]",
          "name": "floatType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Float.html#floatType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#v:floatType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:floatType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Float",
          "module": "CPython.Types.Float",
          "name": "floatType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#v:floatType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Float\",\"CPython.Types\"]",
          "name": "fromFloat",
          "package": "cpython",
          "signature": "Float -\u003e IO Double",
          "source": "src/CPython-Types-Float.html#fromFloat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#v:fromFloat\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromFloat\"]"
        },
        "index": {
          "hierarchy": "CPython Types Float",
          "module": "CPython.Types.Float",
          "name": "fromFloat",
          "normalized": "Float-\u003eIO Double",
          "package": "cpython",
          "partial": "Float",
          "signature": "Float-\u003eIO Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#v:fromFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Float\",\"CPython.Types\"]",
          "name": "toFloat",
          "package": "cpython",
          "signature": "Double -\u003e IO Float",
          "source": "src/CPython-Types-Float.html#toFloat",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#v:toFloat\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toFloat\"]"
        },
        "index": {
          "hierarchy": "CPython Types Float",
          "module": "CPython.Types.Float",
          "name": "toFloat",
          "normalized": "Double-\u003eIO Float",
          "package": "cpython",
          "partial": "Float",
          "signature": "Double-\u003eIO Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Float.html#v:toFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Function",
          "name": "Function",
          "package": "cpython",
          "source": "src/CPython-Types-Function.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "Function",
          "package": "cpython",
          "partial": "Function",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Function",
          "name": "Function",
          "package": "cpython",
          "source": "src/CPython-Types-Function.html#Function",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "Function",
          "package": "cpython",
          "partial": "Function",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#t:Function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Function\",\"CPython.Types\"]",
          "name": "functionType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Function.html#functionType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:functionType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:functionType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "functionType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:functionType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the annotations for a function. This can be a mutable dictionary,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "getAnnotations",
          "package": "cpython",
          "signature": "Function -\u003e IO (Maybe Dictionary)",
          "source": "src/CPython-Types-Function.html#getAnnotations",
          "type": "function"
        },
        "index": {
          "description": "Return the annotations for function This can be mutable dictionary or Nothing",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "getAnnotations",
          "normalized": "Function-\u003eIO(Maybe Dictionary)",
          "package": "cpython",
          "partial": "Annotations",
          "signature": "Function-\u003eIO(Maybe Dictionary)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:getAnnotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the closure associated with a function. This can be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n or a tuple of \u003ccode\u003eCell\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "getClosure",
          "package": "cpython",
          "signature": "Function -\u003e IO (Maybe Tuple)",
          "source": "src/CPython-Types-Function.html#getClosure",
          "type": "function"
        },
        "index": {
          "description": "Return the closure associated with function This can be Nothing or tuple of Cell",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "getClosure",
          "normalized": "Function-\u003eIO(Maybe Tuple)",
          "package": "cpython",
          "partial": "Closure",
          "signature": "Function-\u003eIO(Maybe Tuple)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:getClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the code object associated with a function.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "getCode",
          "package": "cpython",
          "signature": "Function -\u003e IO Code",
          "source": "src/CPython-Types-Function.html#getCode",
          "type": "function"
        },
        "index": {
          "description": "Return the code object associated with function",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "getCode",
          "normalized": "Function-\u003eIO Code",
          "package": "cpython",
          "partial": "Code",
          "signature": "Function-\u003eIO Code",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:getCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the default parameter values for a function. This can be a tuple\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "getDefaults",
          "package": "cpython",
          "signature": "Function -\u003e IO (Maybe Tuple)",
          "source": "src/CPython-Types-Function.html#getDefaults",
          "type": "function"
        },
        "index": {
          "description": "Return the default parameter values for function This can be tuple or Nothing",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "getDefaults",
          "normalized": "Function-\u003eIO(Maybe Tuple)",
          "package": "cpython",
          "partial": "Defaults",
          "signature": "Function-\u003eIO(Maybe Tuple)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:getDefaults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the globals dictionary associated with a function.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "getGlobals",
          "package": "cpython",
          "signature": "Function -\u003e IO Dictionary",
          "source": "src/CPython-Types-Function.html#getGlobals",
          "type": "function"
        },
        "index": {
          "description": "Return the globals dictionary associated with function",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "getGlobals",
          "normalized": "Function-\u003eIO Dictionary",
          "package": "cpython",
          "partial": "Globals",
          "signature": "Function-\u003eIO Dictionary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:getGlobals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the \u003ccode\u003e__module__\u003c/code\u003e attribute of a function. This is normally\n a \u003ccode\u003eUnicode\u003c/code\u003e containing the module name, but can be set to any other\n object by Python code.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "getModule",
          "package": "cpython",
          "signature": "Function -\u003e IO SomeObject",
          "source": "src/CPython-Types-Function.html#getModule",
          "type": "function"
        },
        "index": {
          "description": "Return the module attribute of function This is normally Unicode containing the module name but can be set to any other object by Python code",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "getModule",
          "normalized": "Function-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Module",
          "signature": "Function-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:getModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new function associated with the given code object. The second\n parameter will be used as the globals accessible to the function.\n\u003c/p\u003e\u003cp\u003eThe function's docstring, name, and \u003ccode\u003e__module__\u003c/code\u003e are retrieved from the\n code object. The parameter defaults and closure are set to \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "new",
          "package": "cpython",
          "signature": "Code -\u003e Dictionary -\u003e IO Function",
          "source": "src/CPython-Types-Function.html#new",
          "type": "function"
        },
        "index": {
          "description": "Return new function associated with the given code object The second parameter will be used as the globals accessible to the function The function docstring name and module are retrieved from the code object The parameter defaults and closure are set to Nothing",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "new",
          "normalized": "Code-\u003eDictionary-\u003eIO Function",
          "package": "cpython",
          "signature": "Code-\u003eDictionary-\u003eIO Function",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the annotations for a function object.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "setAnnotations",
          "package": "cpython",
          "signature": "Function -\u003e Maybe Dictionary -\u003e IO ()",
          "source": "src/CPython-Types-Function.html#setAnnotations",
          "type": "function"
        },
        "index": {
          "description": "Set the annotations for function object",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "setAnnotations",
          "normalized": "Function-\u003eMaybe Dictionary-\u003eIO()",
          "package": "cpython",
          "partial": "Annotations",
          "signature": "Function-\u003eMaybe Dictionary-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:setAnnotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the closure associated with a function. The tuple should contain\n \u003ccode\u003eCell\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "setClosure",
          "package": "cpython",
          "signature": "Function -\u003e Maybe Tuple -\u003e IO ()",
          "source": "src/CPython-Types-Function.html#setClosure",
          "type": "function"
        },
        "index": {
          "description": "Set the closure associated with function The tuple should contain Cell",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "setClosure",
          "normalized": "Function-\u003eMaybe Tuple-\u003eIO()",
          "package": "cpython",
          "partial": "Closure",
          "signature": "Function-\u003eMaybe Tuple-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:setClosure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the default values for a function.\n\u003c/p\u003e",
          "module": "CPython.Types.Function",
          "name": "setDefaults",
          "package": "cpython",
          "signature": "Function -\u003e Maybe Tuple -\u003e IO ()",
          "source": "src/CPython-Types-Function.html#setDefaults",
          "type": "function"
        },
        "index": {
          "description": "Set the default values for function",
          "hierarchy": "CPython Types Function",
          "module": "CPython.Types.Function",
          "name": "setDefaults",
          "normalized": "Function-\u003eMaybe Tuple-\u003eIO()",
          "package": "cpython",
          "partial": "Defaults",
          "signature": "Function-\u003eMaybe Tuple-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Function.html#v:setDefaults"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.InstanceMethod",
          "name": "InstanceMethod",
          "package": "cpython",
          "source": "src/CPython-Types-InstanceMethod.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types InstanceMethod",
          "module": "CPython.Types.InstanceMethod",
          "name": "InstanceMethod",
          "package": "cpython",
          "partial": "Instance Method",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-InstanceMethod.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.InstanceMethod",
          "name": "InstanceMethod",
          "package": "cpython",
          "source": "src/CPython-Types-InstanceMethod.html#InstanceMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types InstanceMethod",
          "module": "CPython.Types.InstanceMethod",
          "name": "InstanceMethod",
          "package": "cpython",
          "partial": "Instance Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-InstanceMethod.html#t:InstanceMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.InstanceMethod",
          "name": "function",
          "package": "cpython",
          "signature": "InstanceMethod -\u003e IO SomeObject",
          "source": "src/CPython-Types-InstanceMethod.html#function",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types InstanceMethod",
          "module": "CPython.Types.InstanceMethod",
          "name": "function",
          "normalized": "InstanceMethod-\u003eIO SomeObject",
          "package": "cpython",
          "signature": "InstanceMethod-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-InstanceMethod.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.InstanceMethod\",\"CPython.Types\"]",
          "name": "instanceMethodType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-InstanceMethod.html#instanceMethodType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-InstanceMethod.html#v:instanceMethodType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:instanceMethodType\"]"
        },
        "index": {
          "hierarchy": "CPython Types InstanceMethod",
          "module": "CPython.Types.InstanceMethod",
          "name": "instanceMethodType",
          "package": "cpython",
          "partial": "Method Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-InstanceMethod.html#v:instanceMethodType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.InstanceMethod",
          "name": "new",
          "package": "cpython",
          "signature": "func -\u003e IO InstanceMethod",
          "source": "src/CPython-Types-InstanceMethod.html#new",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types InstanceMethod",
          "module": "CPython.Types.InstanceMethod",
          "name": "new",
          "normalized": "a-\u003eIO InstanceMethod",
          "package": "cpython",
          "signature": "func-\u003eIO InstanceMethod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-InstanceMethod.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Integer",
          "name": "Integer",
          "package": "cpython",
          "source": "src/CPython-Types-Integer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Integer",
          "module": "CPython.Types.Integer",
          "name": "Integer",
          "package": "cpython",
          "partial": "Integer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Integer",
          "name": "Integer",
          "package": "cpython",
          "source": "src/CPython-Types-Integer.html#Integer",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Integer",
          "module": "CPython.Types.Integer",
          "name": "Integer",
          "package": "cpython",
          "partial": "Integer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#t:Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Integer\",\"CPython.Types\"]",
          "name": "fromInteger",
          "package": "cpython",
          "signature": "Integer -\u003e IO Integer",
          "source": "src/CPython-Types-Integer.html#fromInteger",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#v:fromInteger\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromInteger\"]"
        },
        "index": {
          "hierarchy": "CPython Types Integer",
          "module": "CPython.Types.Integer",
          "name": "fromInteger",
          "normalized": "Integer-\u003eIO Integer",
          "package": "cpython",
          "partial": "Integer",
          "signature": "Integer-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Integer\",\"CPython.Types\"]",
          "name": "integerType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Integer.html#integerType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#v:integerType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:integerType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Integer",
          "module": "CPython.Types.Integer",
          "name": "integerType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#v:integerType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Integer\",\"CPython.Types\"]",
          "name": "toInteger",
          "package": "cpython",
          "signature": "Integer -\u003e IO Integer",
          "source": "src/CPython-Types-Integer.html#toInteger",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#v:toInteger\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toInteger\"]"
        },
        "index": {
          "hierarchy": "CPython Types Integer",
          "module": "CPython.Types.Integer",
          "name": "toInteger",
          "normalized": "Integer-\u003eIO Integer",
          "package": "cpython",
          "partial": "Integer",
          "signature": "Integer-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Integer.html#v:toInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Iterator",
          "name": "Iterator",
          "package": "cpython",
          "source": "src/CPython-Types-Iterator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "Iterator",
          "package": "cpython",
          "partial": "Iterator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Iterator",
          "name": "CallableIterator",
          "package": "cpython",
          "source": "src/CPython-Types-Iterator.html#CallableIterator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "CallableIterator",
          "package": "cpython",
          "partial": "Callable Iterator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#t:CallableIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Iterator",
          "name": "SequenceIterator",
          "package": "cpython",
          "source": "src/CPython-Types-Iterator.html#SequenceIterator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "SequenceIterator",
          "package": "cpython",
          "partial": "Sequence Iterator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#t:SequenceIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new \u003ccode\u003e\u003ca\u003eIterator\u003c/a\u003e\u003c/code\u003e. The first parameter, \u003cem\u003ecallable\u003c/em\u003e, can be any\n Python callable object that can be called with no parameters; each call\n to it should return the next item in the iteration. When \u003cem\u003ecallable\u003c/em\u003e\n returns a value equal to \u003cem\u003esentinel\u003c/em\u003e, the iteration will be terminated.\n\u003c/p\u003e",
          "module": "CPython.Types.Iterator",
          "name": "callableIteratorNew",
          "package": "cpython",
          "signature": "callable -\u003e sentinel -\u003e IO CallableIterator",
          "source": "src/CPython-Types-Iterator.html#callableIteratorNew",
          "type": "function"
        },
        "index": {
          "description": "Return new Iterator The first parameter callable can be any Python callable object that can be called with no parameters each call to it should return the next item in the iteration When callable returns value equal to sentinel the iteration will be terminated",
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "callableIteratorNew",
          "normalized": "a-\u003eb-\u003eIO CallableIterator",
          "package": "cpython",
          "partial": "Iterator New",
          "signature": "callable-\u003esentinel-\u003eIO CallableIterator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#v:callableIteratorNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Iterator\",\"CPython.Types\"]",
          "name": "callableIteratorType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Iterator.html#callableIteratorType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#v:callableIteratorType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:callableIteratorType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "callableIteratorType",
          "package": "cpython",
          "partial": "Iterator Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#v:callableIteratorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an \u003ccode\u003e\u003ca\u003eIterator\u003c/a\u003e\u003c/code\u003e that works with a general sequence object, \u003cem\u003eseq\u003c/em\u003e.\n The iteration ends when the sequence raises \u003ccode\u003eIndexError\u003c/code\u003e for the\n subscripting operation.\n\u003c/p\u003e",
          "module": "CPython.Types.Iterator",
          "name": "sequenceIteratorNew",
          "package": "cpython",
          "signature": "seq -\u003e IO SequenceIterator",
          "source": "src/CPython-Types-Iterator.html#sequenceIteratorNew",
          "type": "function"
        },
        "index": {
          "description": "Return an Iterator that works with general sequence object seq The iteration ends when the sequence raises IndexError for the subscripting operation",
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "sequenceIteratorNew",
          "normalized": "a-\u003eIO SequenceIterator",
          "package": "cpython",
          "partial": "Iterator New",
          "signature": "seq-\u003eIO SequenceIterator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#v:sequenceIteratorNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Iterator\",\"CPython.Types\"]",
          "name": "sequenceIteratorType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Iterator.html#sequenceIteratorType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#v:sequenceIteratorType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:sequenceIteratorType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Iterator",
          "module": "CPython.Types.Iterator",
          "name": "sequenceIteratorType",
          "package": "cpython",
          "partial": "Iterator Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Iterator.html#v:sequenceIteratorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.List",
          "name": "List",
          "package": "cpython",
          "source": "src/CPython-Types-List.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "List",
          "package": "cpython",
          "partial": "List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.List",
          "name": "List",
          "package": "cpython",
          "source": "src/CPython-Internal.html#List",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "List",
          "package": "cpython",
          "partial": "List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#t:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend \u003cem\u003eitem\u003c/em\u003e to the end of th list. Throws an exception if unsuccessful.\n Analogous to \u003ccode\u003elist.append(item)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "append",
          "package": "cpython",
          "signature": "List -\u003e item -\u003e IO ()",
          "source": "src/CPython-Types-List.html#append",
          "type": "function"
        },
        "index": {
          "description": "Append item to the end of th list Throws an exception if unsuccessful Analogous to list.append item",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "append",
          "normalized": "List-\u003ea-\u003eIO()",
          "package": "cpython",
          "signature": "List-\u003eitem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.List\",\"CPython.Types\"]",
          "name": "fromList",
          "package": "cpython",
          "signature": "List -\u003e IO [SomeObject]",
          "source": "src/CPython-Types-List.html#fromList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:fromList\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromList\"]"
        },
        "index": {
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "fromList",
          "normalized": "List-\u003eIO[SomeObject]",
          "package": "cpython",
          "partial": "List",
          "signature": "List-\u003eIO[SomeObject]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the object at a given position in the list. The position must be\n positive; indexing from the end of the list is not supported. If the\n position is out of bounds, throws an \u003ccode\u003eIndexError\u003c/code\u003e exception.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "getItem",
          "package": "cpython",
          "signature": "List -\u003e Integer -\u003e IO SomeObject",
          "source": "src/CPython-Types-List.html#getItem",
          "type": "function"
        },
        "index": {
          "description": "Returns the object at given position in the list The position must be positive indexing from the end of the list is not supported If the position is out of bounds throws an IndexError exception",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "getItem",
          "normalized": "List-\u003eInteger-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Item",
          "signature": "List-\u003eInteger-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:getItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of the objects in list containing the objects between\n the given indexes. Throws an exception if unsuccessful. Analogous to\n \u003ccode\u003elist[low:high]\u003c/code\u003e. Negative indices, as when slicing from Python, are not\n supported.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "getSlice",
          "package": "cpython",
          "signature": "List -\u003e Integer -\u003e Integer -\u003e IO List",
          "source": "src/CPython-Types-List.html#getSlice",
          "type": "function"
        },
        "index": {
          "description": "Return list of the objects in list containing the objects between the given indexes Throws an exception if unsuccessful Analogous to list low high Negative indices as when slicing from Python are not supported",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "getSlice",
          "normalized": "List-\u003eInteger-\u003eInteger-\u003eIO List",
          "package": "cpython",
          "partial": "Slice",
          "signature": "List-\u003eInteger-\u003eInteger-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:getSlice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInserts \u003cem\u003eitem\u003c/em\u003e into the list in front of the given index. Throws an\n exception if unsuccessful. Analogous to \u003ccode\u003elist.insert(index, item)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "insert",
          "package": "cpython",
          "signature": "List -\u003e Integer -\u003e item -\u003e IO ()",
          "source": "src/CPython-Types-List.html#insert",
          "type": "function"
        },
        "index": {
          "description": "Inserts item into the list in front of the given index Throws an exception if unsuccessful Analogous to list.insert index item",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "insert",
          "normalized": "List-\u003eInteger-\u003ea-\u003eIO()",
          "package": "cpython",
          "signature": "List-\u003eInteger-\u003eitem-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any object implementing the iterator protocol to a \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"CPython.Types.List\",\"CPython.Types\"]",
          "name": "iterableToList",
          "package": "cpython",
          "signature": "iter -\u003e IO List",
          "source": "src/CPython-Types-List.html#iterableToList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:iterableToList\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:iterableToList\"]"
        },
        "index": {
          "description": "Convert any object implementing the iterator protocol to List",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "iterableToList",
          "normalized": "a-\u003eIO List",
          "package": "cpython",
          "partial": "To List",
          "signature": "iter-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:iterableToList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.List",
          "name": "length",
          "package": "cpython",
          "signature": "List -\u003e IO Integer",
          "source": "src/CPython-Types-List.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "length",
          "normalized": "List-\u003eIO Integer",
          "package": "cpython",
          "signature": "List-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.List\",\"CPython.Types\"]",
          "name": "listType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-List.html#listType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:listType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:listType\"]"
        },
        "index": {
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "listType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:listType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReverses the items of a list in place. This is equivalent to\n \u003ccode\u003elist.reverse()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "reverse",
          "package": "cpython",
          "signature": "List -\u003e IO ()",
          "source": "src/CPython-Types-List.html#reverse",
          "type": "function"
        },
        "index": {
          "description": "Reverses the items of list in place This is equivalent to list.reverse",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "reverse",
          "normalized": "List-\u003eIO()",
          "package": "cpython",
          "signature": "List-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the item at a given index.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "setItem",
          "package": "cpython",
          "signature": "List -\u003e Integer -\u003e o -\u003e IO ()",
          "source": "src/CPython-Types-List.html#setItem",
          "type": "function"
        },
        "index": {
          "description": "Set the item at given index",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "setItem",
          "normalized": "List-\u003eInteger-\u003ea-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "List-\u003eInteger-\u003eo-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:setItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the slice of a list between \u003cem\u003elow\u003c/em\u003e and \u003cem\u003ehigh\u003c/em\u003e to the contents of\n a replacement list. Analogous to \u003ccode\u003elist[low:high] = replacement\u003c/code\u003e. The\n replacement may be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, indicating the assignment of an empty list\n (slice deletion). Negative indices, as when slicing from Python, are not\n supported.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "setSlice",
          "package": "cpython",
          "signature": "List-\u003e Integer-\u003e Integer-\u003e Maybe List-\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Sets the slice of list between low and high to the contents of replacement list Analogous to list low high replacement The replacement may be Nothing indicating the assignment of an empty list slice deletion Negative indices as when slicing from Python are not supported",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "setSlice",
          "normalized": "List-\u003eInteger-\u003eInteger-\u003eMaybe List-\u003eIO()",
          "package": "cpython",
          "partial": "Slice",
          "signature": "List-\u003eInteger-\u003eInteger-\u003eMaybe List-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:setSlice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort the items of a list in place. This is equivalent to \u003ccode\u003elist.sort()\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "sort",
          "package": "cpython",
          "signature": "List -\u003e IO ()",
          "source": "src/CPython-Types-List.html#sort",
          "type": "function"
        },
        "index": {
          "description": "Sort the items of list in place This is equivalent to list.sort",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "sort",
          "normalized": "List-\u003eIO()",
          "package": "cpython",
          "signature": "List-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.List\",\"CPython.Types\"]",
          "name": "toList",
          "package": "cpython",
          "signature": "[SomeObject] -\u003e IO List",
          "source": "src/CPython-Types-List.html#toList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:toList\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toList\"]"
        },
        "index": {
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "toList",
          "normalized": "[SomeObject]-\u003eIO List",
          "package": "cpython",
          "partial": "List",
          "signature": "[SomeObject]-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new \u003ccode\u003e\u003ca\u003eTuple\u003c/a\u003e\u003c/code\u003e containing the contents of a list; equivalent to\n \u003ccode\u003etuple(list)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.List",
          "name": "toTuple",
          "package": "cpython",
          "signature": "List -\u003e IO Tuple",
          "source": "src/CPython-Types-List.html#toTuple",
          "type": "function"
        },
        "index": {
          "description": "Return new Tuple containing the contents of list equivalent to tuple list",
          "hierarchy": "CPython Types List",
          "module": "CPython.Types.List",
          "name": "toTuple",
          "normalized": "List-\u003eIO Tuple",
          "package": "cpython",
          "partial": "Tuple",
          "signature": "List-\u003eIO Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-List.html#v:toTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Method",
          "name": "Method",
          "package": "cpython",
          "source": "src/CPython-Types-Method.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Method",
          "module": "CPython.Types.Method",
          "name": "Method",
          "package": "cpython",
          "partial": "Method",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Method",
          "name": "Method",
          "package": "cpython",
          "source": "src/CPython-Types-Method.html#Method",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Method",
          "module": "CPython.Types.Method",
          "name": "Method",
          "package": "cpython",
          "partial": "Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#t:Method"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Method",
          "name": "function",
          "package": "cpython",
          "signature": "Method -\u003e IO SomeObject",
          "source": "src/CPython-Types-Method.html#function",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Method",
          "module": "CPython.Types.Method",
          "name": "function",
          "normalized": "Method-\u003eIO SomeObject",
          "package": "cpython",
          "signature": "Method-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Method\",\"CPython.Types\"]",
          "name": "methodType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Method.html#methodType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#v:methodType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:methodType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Method",
          "module": "CPython.Types.Method",
          "name": "methodType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#v:methodType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Method",
          "name": "new",
          "package": "cpython",
          "signature": "func -\u003e self -\u003e IO Method",
          "source": "src/CPython-Types-Method.html#new",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Method",
          "module": "CPython.Types.Method",
          "name": "new",
          "normalized": "a-\u003eb-\u003eIO Method",
          "package": "cpython",
          "signature": "func-\u003eself-\u003eIO Method",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Method",
          "name": "self",
          "package": "cpython",
          "signature": "Method -\u003e IO SomeObject",
          "source": "src/CPython-Types-Method.html#self",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Method",
          "module": "CPython.Types.Method",
          "name": "self",
          "normalized": "Method-\u003eIO SomeObject",
          "package": "cpython",
          "signature": "Method-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Method.html#v:self"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Module",
          "name": "Module",
          "package": "cpython",
          "source": "src/CPython-Types-Module.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "Module",
          "package": "cpython",
          "partial": "Module",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Module",
          "name": "Module",
          "package": "cpython",
          "source": "src/CPython-Types-Module.html#Module",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "Module",
          "package": "cpython",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an integer constant to a module. This convenience computation can be\n used from the module&#8217;s initialization computation.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "addIntegerConstant",
          "package": "cpython",
          "signature": "Module -\u003e Text -\u003e Integer -\u003e IO ()",
          "source": "src/CPython-Types-Module.html#addIntegerConstant",
          "type": "function"
        },
        "index": {
          "description": "Add an integer constant to module This convenience computation can be used from the module initialization computation",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "addIntegerConstant",
          "normalized": "Module-\u003eText-\u003eInteger-\u003eIO()",
          "package": "cpython",
          "partial": "Integer Constant",
          "signature": "Module-\u003eText-\u003eInteger-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:addIntegerConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an object to a module with the given name. This is a convenience\n computation which can be used from the module&#8217;s initialization\n computation.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "addObject",
          "package": "cpython",
          "signature": "Module -\u003e Text -\u003e value -\u003e IO ()",
          "source": "src/CPython-Types-Module.html#addObject",
          "type": "function"
        },
        "index": {
          "description": "Add an object to module with the given name This is convenience computation which can be used from the module initialization computation",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "addObject",
          "normalized": "Module-\u003eText-\u003ea-\u003eIO()",
          "package": "cpython",
          "partial": "Object",
          "signature": "Module-\u003eText-\u003evalue-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:addObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a string constant to a module. This convenience computation can be\n used from the module&#8217;s initialization computation.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "addTextConstant",
          "package": "cpython",
          "signature": "Module -\u003e Text -\u003e Text -\u003e IO ()",
          "source": "src/CPython-Types-Module.html#addTextConstant",
          "type": "function"
        },
        "index": {
          "description": "Add string constant to module This convenience computation can be used from the module initialization computation",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "addTextConstant",
          "normalized": "Module-\u003eText-\u003eText-\u003eIO()",
          "package": "cpython",
          "partial": "Text Constant",
          "signature": "Module-\u003eText-\u003eText-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:addTextConstant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the dictionary object that implements a module&#8217;s namespace;\n this object is the same as the \u003ccode\u003e__dict__\u003c/code\u003e attribute of the module. This\n computation never fails. It is recommended extensions use other\n computations rather than directly manipulate a module&#8217;s \u003ccode\u003e__dict__\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "getDictionary",
          "package": "cpython",
          "signature": "Module -\u003e IO Dictionary",
          "source": "src/CPython-Types-Module.html#getDictionary",
          "type": "function"
        },
        "index": {
          "description": "Return the dictionary object that implements module namespace this object is the same as the dict attribute of the module This computation never fails It is recommended extensions use other computations rather than directly manipulate module dict",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "getDictionary",
          "normalized": "Module-\u003eIO Dictionary",
          "package": "cpython",
          "partial": "Dictionary",
          "signature": "Module-\u003eIO Dictionary",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:getDictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the name of the file from which a module was loaded using the\n module&#8217;s \u003ccode\u003e__file__\u003c/code\u003e attribute. If this is not defined, or if it is\n not a string, throws \u003ccode\u003eSystemError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "getFilename",
          "package": "cpython",
          "signature": "Module -\u003e IO Text",
          "source": "src/CPython-Types-Module.html#getFilename",
          "type": "function"
        },
        "index": {
          "description": "Returns the name of the file from which module was loaded using the module file attribute If this is not defined or if it is not string throws SystemError",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "getFilename",
          "normalized": "Module-\u003eIO Text",
          "package": "cpython",
          "partial": "Filename",
          "signature": "Module-\u003eIO Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:getFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a module&#8217;s \u003ccode\u003e__name__\u003c/code\u003e value. If the module does not\n provide one, or if it is not a string, throws \u003ccode\u003eSystemError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "getName",
          "package": "cpython",
          "signature": "Module -\u003e IO Text",
          "source": "src/CPython-Types-Module.html#getName",
          "type": "function"
        },
        "index": {
          "description": "Returns module name value If the module does not provide one or if it is not string throws SystemError",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "getName",
          "normalized": "Module-\u003eIO Text",
          "package": "cpython",
          "partial": "Name",
          "signature": "Module-\u003eIO Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:getName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a higher-level interface that calls the current &#8220;import\n hook&#8221; (with an explicit level of \u003ccode\u003e0\u003c/code\u003e, meaning absolute import). It\n invokes the \u003ccode\u003e__import__()\u003c/code\u003e computation from the \u003ccode\u003e__builtins__\u003c/code\u003e of the\n current globals. This means that the import is done using whatever import\n hooks are installed in the current environment.\n\u003c/p\u003e\u003cp\u003eThis computation always uses absolute imports.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "importModule",
          "package": "cpython",
          "signature": "Text -\u003e IO Module",
          "source": "src/CPython-Types-Module.html#importModule",
          "type": "function"
        },
        "index": {
          "description": "This is higher-level interface that calls the current import hook with an explicit level of meaning absolute import It invokes the import computation from the builtins of the current globals This means that the import is done using whatever import hooks are installed in the current environment This computation always uses absolute imports",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "importModule",
          "normalized": "Text-\u003eIO Module",
          "package": "cpython",
          "partial": "Module",
          "signature": "Text-\u003eIO Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:importModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Module\",\"CPython.Types\"]",
          "name": "moduleType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Module.html#moduleType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:moduleType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:moduleType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "moduleType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:moduleType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new module object with the \u003ccode\u003e__name__\u003c/code\u003e attribute set. Only the\n module&#8217;s \u003ccode\u003e__doc__\u003c/code\u003e and \u003ccode\u003e__name__\u003c/code\u003e attributes are filled in; the\n caller is responsible for providing a \u003ccode\u003e__file__\u003c/code\u003e attribute.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "new",
          "package": "cpython",
          "signature": "Text -\u003e IO Module",
          "source": "src/CPython-Types-Module.html#new",
          "type": "function"
        },
        "index": {
          "description": "Return new module object with the name attribute set Only the module doc and name attributes are filled in the caller is responsible for providing file attribute",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "new",
          "normalized": "Text-\u003eIO Module",
          "package": "cpython",
          "signature": "Text-\u003eIO Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReload a module. If an error occurs, an exception is thrown and the old\n module still exists.\n\u003c/p\u003e",
          "module": "CPython.Types.Module",
          "name": "reload",
          "package": "cpython",
          "signature": "Module -\u003e IO Module",
          "source": "src/CPython-Types-Module.html#reload",
          "type": "function"
        },
        "index": {
          "description": "Reload module If an error occurs an exception is thrown and the old module still exists",
          "hierarchy": "CPython Types Module",
          "module": "CPython.Types.Module",
          "name": "reload",
          "normalized": "Module-\u003eIO Module",
          "package": "cpython",
          "signature": "Module-\u003eIO Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Module.html#v:reload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAny functionality not listed below is best accessed using the either\n the \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e protocol (including \u003ccode\u003ecallMethod\u003c/code\u003e, \u003ccode\u003erichCompare\u003c/code\u003e, \u003ccode\u003ehash\u003c/code\u003e,\n \u003ccode\u003erepr\u003c/code\u003e, \u003ccode\u003eisTrue\u003c/code\u003e, and \u003ccode\u003egetIter\u003c/code\u003e) or the \u003ccode\u003eNumber\u003c/code\u003e protocol (including \u003ccode\u003e\u003ca\u003eand\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003esubtract\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003exor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003einPlaceAnd\u003c/code\u003e, \u003ccode\u003einPlaceSubtract\u003c/code\u003e, \u003ccode\u003einPlaceOr\u003c/code\u003e,\n and \u003ccode\u003einPlaceXor\u003c/code\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "CPython.Types.Set",
          "name": "Set",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html",
          "type": "module"
        },
        "index": {
          "description": "Any functionality not listed below is best accessed using the either the Object protocol including callMethod richCompare hash repr isTrue and getIter or the Number protocol including and subtract or xor inPlaceAnd inPlaceSubtract inPlaceOr and inPlaceXor",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "Set",
          "package": "cpython",
          "partial": "Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Set",
          "name": "AnySet",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html#AnySet",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "AnySet",
          "package": "cpython",
          "partial": "Any Set",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#t:AnySet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Set",
          "name": "FrozenSet",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html#FrozenSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "FrozenSet",
          "package": "cpython",
          "partial": "Frozen Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#t:FrozenSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Set",
          "name": "Set",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html#Set",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "Set",
          "package": "cpython",
          "partial": "Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd \u003cem\u003ekey\u003c/em\u003e to a \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e. Also works with \u003ccode\u003e\u003ca\u003eFrozenSet\u003c/a\u003e\u003c/code\u003e (like\n \u003ccode\u003e\u003ca\u003esetItem\u003c/a\u003e\u003c/code\u003e it can be used to fill-in the values of\n brand new \u003ccode\u003e\u003ca\u003eFrozenSet\u003c/a\u003e\u003c/code\u003es before they are exposed to other code). Throws a\n \u003ccode\u003eTypeError\u003c/code\u003e if the key is unhashable. Throws a \u003ccode\u003eMemoryError\u003c/code\u003e if there is\n no room to grow.\n\u003c/p\u003e",
          "module": "CPython.Types.Set",
          "name": "add",
          "package": "cpython",
          "signature": "set -\u003e key -\u003e IO ()",
          "source": "src/CPython-Types-Set.html#add",
          "type": "function"
        },
        "index": {
          "description": "Add key to Set Also works with FrozenSet like setItem it can be used to fill-in the values of brand new FrozenSet before they are exposed to other code Throws TypeError if the key is unhashable Throws MemoryError if there is no room to grow",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "add",
          "normalized": "a-\u003eb-\u003eIO()",
          "package": "cpython",
          "signature": "set-\u003ekey-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove all elements from a set.\n\u003c/p\u003e",
          "module": "CPython.Types.Set",
          "name": "clear",
          "package": "cpython",
          "signature": "Set -\u003e IO ()",
          "source": "src/CPython-Types-Set.html#clear",
          "type": "function"
        },
        "index": {
          "description": "Remove all elements from set",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "clear",
          "normalized": "Set-\u003eIO()",
          "package": "cpython",
          "signature": "Set-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:clear"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if found, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if not found. Unlike the Python\n \u003ccode\u003e__contains__()\u003c/code\u003e method, this computation does not automatically convert\n unhashable \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003es into temporary \u003ccode\u003e\u003ca\u003eFrozenSet\u003c/a\u003e\u003c/code\u003es. Throws a \u003ccode\u003eTypeError\u003c/code\u003e if the\n key is unhashable.\n\u003c/p\u003e",
          "module": "CPython.Types.Set",
          "name": "contains",
          "package": "cpython",
          "signature": "set -\u003e key -\u003e IO Bool",
          "source": "src/CPython-Types-Set.html#contains",
          "type": "function"
        },
        "index": {
          "description": "Return True if found False if not found Unlike the Python contains method this computation does not automatically convert unhashable Set into temporary FrozenSet Throws TypeError if the key is unhashable",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "contains",
          "normalized": "a-\u003eb-\u003eIO Bool",
          "package": "cpython",
          "signature": "set-\u003ekey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if found and removed, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if not found (no action\n taken). Does not throw \u003ccode\u003eKeyError\u003c/code\u003e for missing keys. Throws a \u003ccode\u003eTypeError\u003c/code\u003e\n if \u003cem\u003ekey\u003c/em\u003e is unhashable. Unlike the Python \u003ccode\u003ediscard()\u003c/code\u003e method, this\n computation does not automatically convert unhashable sets into temporary\n \u003ccode\u003e\u003ca\u003eFrozenSet\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "CPython.Types.Set",
          "name": "discard",
          "package": "cpython",
          "signature": "Set -\u003e key -\u003e IO Bool",
          "source": "src/CPython-Types-Set.html#discard",
          "type": "function"
        },
        "index": {
          "description": "Return True if found and removed False if not found no action taken Does not throw KeyError for missing keys Throws TypeError if key is unhashable Unlike the Python discard method this computation does not automatically convert unhashable sets into temporary FrozenSet",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "discard",
          "normalized": "Set-\u003ea-\u003eIO Bool",
          "package": "cpython",
          "signature": "Set-\u003ekey-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:discard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "fromSet",
          "package": "cpython",
          "signature": "set -\u003e IO [SomeObject]",
          "source": "src/CPython-Types-Set.html#fromSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:fromSet\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromSet\"]"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "fromSet",
          "normalized": "a-\u003eIO[SomeObject]",
          "package": "cpython",
          "partial": "Set",
          "signature": "set-\u003eIO[SomeObject]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:fromSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "frozenSetType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Set.html#frozenSetType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:frozenSetType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:frozenSetType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "frozenSetType",
          "package": "cpython",
          "partial": "Set Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:frozenSetType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new \u003ccode\u003e\u003ca\u003eFrozenSet\u003c/a\u003e\u003c/code\u003e from the contents of an iterable \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e. The\n object may be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e to create an empty frozen set. Throws a \u003ccode\u003eTypeError\u003c/code\u003e\n if the object is not iterable.\n\u003c/p\u003e",
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "iterableToFrozenSet",
          "package": "cpython",
          "signature": "obj -\u003e IO FrozenSet",
          "source": "src/CPython-Types-Set.html#iterableToFrozenSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:iterableToFrozenSet\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:iterableToFrozenSet\"]"
        },
        "index": {
          "description": "Return new FrozenSet from the contents of an iterable Object The object may be Nothing to create an empty frozen set Throws TypeError if the object is not iterable",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "iterableToFrozenSet",
          "normalized": "a-\u003eIO FrozenSet",
          "package": "cpython",
          "partial": "To Frozen Set",
          "signature": "obj-\u003eIO FrozenSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:iterableToFrozenSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e from the contents of an iterable \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e. The object\n may be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e to create an empty set. Throws a \u003ccode\u003eTypeError\u003c/code\u003e if the object\n is not iterable.\n\u003c/p\u003e",
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "iterableToSet",
          "package": "cpython",
          "signature": "obj -\u003e IO Set",
          "source": "src/CPython-Types-Set.html#iterableToSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:iterableToSet\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:iterableToSet\"]"
        },
        "index": {
          "description": "Return new Set from the contents of an iterable Object The object may be Nothing to create an empty set Throws TypeError if the object is not iterable",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "iterableToSet",
          "normalized": "a-\u003eIO Set",
          "package": "cpython",
          "partial": "To Set",
          "signature": "obj-\u003eIO Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:iterableToSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an arbitrary object in the set, and removes the object from the\n set. Throws \u003ccode\u003eKeyError\u003c/code\u003e if the set is empty.\n\u003c/p\u003e",
          "module": "CPython.Types.Set",
          "name": "pop",
          "package": "cpython",
          "signature": "Set -\u003e IO SomeObject",
          "source": "src/CPython-Types-Set.html#pop",
          "type": "function"
        },
        "index": {
          "description": "Return an arbitrary object in the set and removes the object from the set Throws KeyError if the set is empty",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "pop",
          "normalized": "Set-\u003eIO SomeObject",
          "package": "cpython",
          "signature": "Set-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:pop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "setType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Set.html#setType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:setType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:setType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "setType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:setType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the size of a \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFrozenSet\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Set",
          "name": "size",
          "package": "cpython",
          "signature": "set -\u003e IO Integer",
          "source": "src/CPython-Types-Set.html#size",
          "type": "function"
        },
        "index": {
          "description": "Return the size of Set or FrozenSet",
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "size",
          "normalized": "a-\u003eIO Integer",
          "package": "cpython",
          "signature": "set-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "toFrozenSet",
          "package": "cpython",
          "signature": "[SomeObject] -\u003e IO FrozenSet",
          "source": "src/CPython-Types-Set.html#toFrozenSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:toFrozenSet\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toFrozenSet\"]"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "toFrozenSet",
          "normalized": "[SomeObject]-\u003eIO FrozenSet",
          "package": "cpython",
          "partial": "Frozen Set",
          "signature": "[SomeObject]-\u003eIO FrozenSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:toFrozenSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Set\",\"CPython.Types\"]",
          "name": "toSet",
          "package": "cpython",
          "signature": "[SomeObject] -\u003e IO Set",
          "source": "src/CPython-Types-Set.html#toSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:toSet\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toSet\"]"
        },
        "index": {
          "hierarchy": "CPython Types Set",
          "module": "CPython.Types.Set",
          "name": "toSet",
          "normalized": "[SomeObject]-\u003eIO Set",
          "package": "cpython",
          "partial": "Set",
          "signature": "[SomeObject]-\u003eIO Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Set.html#v:toSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Slice",
          "name": "Slice",
          "package": "cpython",
          "source": "src/CPython-Types-Slice.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Slice",
          "module": "CPython.Types.Slice",
          "name": "Slice",
          "package": "cpython",
          "partial": "Slice",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Slice.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Slice",
          "name": "Slice",
          "package": "cpython",
          "source": "src/CPython-Types-Slice.html#Slice",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Slice",
          "module": "CPython.Types.Slice",
          "name": "Slice",
          "package": "cpython",
          "partial": "Slice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Slice.html#t:Slice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the start, stop, step, and slice length from a \u003ccode\u003e\u003ca\u003eSlice\u003c/a\u003e\u003c/code\u003e,\n assuming a sequence of the given length.\n\u003c/p\u003e",
          "module": "CPython.Types.Slice",
          "name": "getIndices",
          "package": "cpython",
          "signature": "Slice-\u003e Integer-\u003e IO (Integer, Integer, Integer, Integer)",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the start stop step and slice length from Slice assuming sequence of the given length",
          "hierarchy": "CPython Types Slice",
          "module": "CPython.Types.Slice",
          "name": "getIndices",
          "normalized": "Slice-\u003eInteger-\u003eIO(Integer,Integer,Integer,Integer)",
          "package": "cpython",
          "partial": "Indices",
          "signature": "Slice-\u003eInteger-\u003eIO(Integer,Integer,Integer,Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Slice.html#v:getIndices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new slice object with the given values. The \u003cem\u003estart\u003c/em\u003e, \u003cem\u003estop\u003c/em\u003e,\n and \u003cem\u003estep\u003c/em\u003e parameters are used as the values of the slice object\n attributes of the same names. Any of the values may be \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, in which\n case \u003ccode\u003eNone\u003c/code\u003e will be used for the corresponding attribute.\n\u003c/p\u003e",
          "module": "CPython.Types.Slice",
          "name": "new",
          "package": "cpython",
          "signature": "Maybe start -\u003e Maybe stop -\u003e Maybe step -\u003e IO Slice",
          "source": "src/CPython-Types-Slice.html#new",
          "type": "function"
        },
        "index": {
          "description": "Return new slice object with the given values The start stop and step parameters are used as the values of the slice object attributes of the same names Any of the values may be Nothing in which case None will be used for the corresponding attribute",
          "hierarchy": "CPython Types Slice",
          "module": "CPython.Types.Slice",
          "name": "new",
          "normalized": "Maybe a-\u003eMaybe b-\u003eMaybe c-\u003eIO Slice",
          "package": "cpython",
          "signature": "Maybe start-\u003eMaybe stop-\u003eMaybe step-\u003eIO Slice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Slice.html#v:new"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Slice\",\"CPython.Types\"]",
          "name": "sliceType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Slice.html#sliceType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Slice.html#v:sliceType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:sliceType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Slice",
          "module": "CPython.Types.Slice",
          "name": "sliceType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Slice.html#v:sliceType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Tuple",
          "name": "Tuple",
          "package": "cpython",
          "source": "src/CPython-Types-Tuple.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "Tuple",
          "package": "cpython",
          "partial": "Tuple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Tuple",
          "name": "Tuple",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Tuple",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "Tuple",
          "package": "cpython",
          "partial": "Tuple",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#t:Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Tuple\",\"CPython.Types\"]",
          "name": "fromTuple",
          "package": "cpython",
          "signature": "Tuple -\u003e IO [SomeObject]",
          "source": "src/CPython-Types-Tuple.html#fromTuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:fromTuple\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromTuple\"]"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "fromTuple",
          "normalized": "Tuple-\u003eIO[SomeObject]",
          "package": "cpython",
          "partial": "Tuple",
          "signature": "Tuple-\u003eIO[SomeObject]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:fromTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the object at a given index from a tuple, or throws \u003ccode\u003eIndexError\u003c/code\u003e\n if the index is out of bounds.\n\u003c/p\u003e",
          "module": "CPython.Types.Tuple",
          "name": "getItem",
          "package": "cpython",
          "signature": "Tuple -\u003e Integer -\u003e IO SomeObject",
          "source": "src/CPython-Types-Tuple.html#getItem",
          "type": "function"
        },
        "index": {
          "description": "Return the object at given index from tuple or throws IndexError if the index is out of bounds",
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "getItem",
          "normalized": "Tuple-\u003eInteger-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Item",
          "signature": "Tuple-\u003eInteger-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:getItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake a slice of a tuple from \u003cem\u003elow\u003c/em\u003e to \u003cem\u003ehigh\u003c/em\u003e, and return it as a new\n tuple.\n\u003c/p\u003e",
          "module": "CPython.Types.Tuple",
          "name": "getSlice",
          "package": "cpython",
          "signature": "Tuple -\u003e Integer -\u003e Integer -\u003e IO Tuple",
          "source": "src/CPython-Types-Tuple.html#getSlice",
          "type": "function"
        },
        "index": {
          "description": "Take slice of tuple from low to high and return it as new tuple",
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "getSlice",
          "normalized": "Tuple-\u003eInteger-\u003eInteger-\u003eIO Tuple",
          "package": "cpython",
          "partial": "Slice",
          "signature": "Tuple-\u003eInteger-\u003eInteger-\u003eIO Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:getSlice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert any object implementing the iterator protocol to a \u003ccode\u003e\u003ca\u003eTuple\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"CPython.Types.Tuple\",\"CPython.Types\"]",
          "name": "iterableToTuple",
          "package": "cpython",
          "signature": "iter -\u003e IO Tuple",
          "source": "src/CPython-Types-Tuple.html#iterableToTuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:iterableToTuple\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:iterableToTuple\"]"
        },
        "index": {
          "description": "Convert any object implementing the iterator protocol to Tuple",
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "iterableToTuple",
          "normalized": "a-\u003eIO Tuple",
          "package": "cpython",
          "partial": "To Tuple",
          "signature": "iter-\u003eIO Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:iterableToTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Tuple",
          "name": "length",
          "package": "cpython",
          "signature": "Tuple -\u003e IO Integer",
          "source": "src/CPython-Types-Tuple.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "length",
          "normalized": "Tuple-\u003eIO Integer",
          "package": "cpython",
          "signature": "Tuple-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Tuple",
          "name": "setItem",
          "package": "cpython",
          "signature": "Tuple -\u003e Integer -\u003e o -\u003e IO ()",
          "source": "src/CPython-Types-Tuple.html#setItem",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "setItem",
          "normalized": "Tuple-\u003eInteger-\u003ea-\u003eIO()",
          "package": "cpython",
          "partial": "Item",
          "signature": "Tuple-\u003eInteger-\u003eo-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:setItem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Tuple\",\"CPython.Types\"]",
          "name": "toTuple",
          "package": "cpython",
          "signature": "[SomeObject] -\u003e IO Tuple",
          "source": "src/CPython-Types-Tuple.html#toTuple",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:toTuple\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toTuple\"]"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "toTuple",
          "normalized": "[SomeObject]-\u003eIO Tuple",
          "package": "cpython",
          "partial": "Tuple",
          "signature": "[SomeObject]-\u003eIO Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:toTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Tuple\",\"CPython.Types\"]",
          "name": "tupleType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Tuple.html#tupleType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:tupleType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:tupleType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Tuple",
          "module": "CPython.Types.Tuple",
          "name": "tupleType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Tuple.html#v:tupleType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Type",
          "name": "Type",
          "package": "cpython",
          "source": "src/CPython-Types-Type.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Type",
          "module": "CPython.Types.Type",
          "name": "Type",
          "package": "cpython",
          "partial": "Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Type.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Type",
          "name": "Type",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Type",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Type",
          "module": "CPython.Types.Type",
          "name": "Type",
          "package": "cpython",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Type.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the first parameter is a subtype of the second\n parameter.\n\u003c/p\u003e",
          "module": "CPython.Types.Type",
          "name": "isSubtype",
          "package": "cpython",
          "signature": "Type -\u003e Type -\u003e IO Bool",
          "source": "src/CPython-Types-Type.html#isSubtype",
          "type": "function"
        },
        "index": {
          "description": "Returns True if the first parameter is subtype of the second parameter",
          "hierarchy": "CPython Types Type",
          "module": "CPython.Types.Type",
          "name": "isSubtype",
          "normalized": "Type-\u003eType-\u003eIO Bool",
          "package": "cpython",
          "partial": "Subtype",
          "signature": "Type-\u003eType-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Type.html#v:isSubtype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Type\",\"CPython.Types\"]",
          "name": "typeType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Type.html#typeType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Type.html#v:typeType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:typeType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Type",
          "module": "CPython.Types.Type",
          "name": "typeType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Type.html#v:typeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Unicode",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Unicode",
          "package": "cpython",
          "partial": "Unicode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Encoding",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html#Encoding",
          "type": "type"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Encoding",
          "package": "cpython",
          "partial": "Encoding",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#t:Encoding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "ErrorHandling",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html#ErrorHandling",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "ErrorHandling",
          "package": "cpython",
          "partial": "Error Handling",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#t:ErrorHandling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "FindDirection",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html#FindDirection",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "FindDirection",
          "package": "cpython",
          "partial": "Find Direction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#t:FindDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "MatchDirection",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html#MatchDirection",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "MatchDirection",
          "package": "cpython",
          "partial": "Match Direction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#t:MatchDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Unicode",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html#Unicode",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Unicode",
          "package": "cpython",
          "partial": "Unicode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#t:Unicode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Backwards",
          "package": "cpython",
          "signature": "Backwards",
          "source": "src/CPython-Types-Unicode.html#FindDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Backwards",
          "package": "cpython",
          "partial": "Backwards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Backwards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Forwards",
          "package": "cpython",
          "signature": "Forwards",
          "source": "src/CPython-Types-Unicode.html#FindDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Forwards",
          "package": "cpython",
          "partial": "Forwards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Forwards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Ignore",
          "package": "cpython",
          "signature": "Ignore",
          "source": "src/CPython-Types-Unicode.html#ErrorHandling",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Ignore",
          "package": "cpython",
          "partial": "Ignore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Ignore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Prefix",
          "package": "cpython",
          "signature": "Prefix",
          "source": "src/CPython-Types-Unicode.html#MatchDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Prefix",
          "package": "cpython",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Prefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Replace",
          "package": "cpython",
          "signature": "Replace",
          "source": "src/CPython-Types-Unicode.html#ErrorHandling",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Replace",
          "package": "cpython",
          "partial": "Replace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Strict",
          "package": "cpython",
          "signature": "Strict",
          "source": "src/CPython-Types-Unicode.html#ErrorHandling",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Strict",
          "package": "cpython",
          "partial": "Strict",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Strict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "Suffix",
          "package": "cpython",
          "signature": "Suffix",
          "source": "src/CPython-Types-Unicode.html#MatchDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "Suffix",
          "package": "cpython",
          "partial": "Suffix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:Suffix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "append",
          "package": "cpython",
          "signature": "Unicode -\u003e Unicode -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#append",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "append",
          "normalized": "Unicode-\u003eUnicode-\u003eIO Unicode",
          "package": "cpython",
          "signature": "Unicode-\u003eUnicode-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether \u003cem\u003eelement\u003c/em\u003e is contained in a string.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eelement\u003c/em\u003e has to coerce to a one element string.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "contains",
          "package": "cpython",
          "signature": "Unicode -\u003e element -\u003e IO Bool",
          "source": "src/CPython-Types-Unicode.html#contains",
          "type": "function"
        },
        "index": {
          "description": "Check whether element is contained in string element has to coerce to one element string",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "contains",
          "normalized": "Unicode-\u003ea-\u003eIO Bool",
          "package": "cpython",
          "signature": "Unicode-\u003eelement-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of non-overlapping occurrences of the substring in\n \u003ccode\u003estring[start:end]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "count",
          "package": "cpython",
          "signature": "Unicode-\u003e Unicode-\u003e Integer-\u003e Integer-\u003e IO Integer",
          "type": "function"
        },
        "index": {
          "description": "Return the number of non-overlapping occurrences of the substring in string start end",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "count",
          "normalized": "Unicode-\u003eUnicode-\u003eInteger-\u003eInteger-\u003eIO Integer",
          "package": "cpython",
          "signature": "Unicode-\u003eUnicode-\u003eInteger-\u003eInteger-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e object by decoding a \u003ccode\u003e\u003ca\u003eBytes\u003c/a\u003e\u003c/code\u003e object. The encoding and\n error mode have the same meaning as the parameters of the the\n \u003ccode\u003estr.encode()\u003c/code\u003e method. The codec to be used is looked up using the Python\n codec registry.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "decode",
          "package": "cpython",
          "signature": "Bytes -\u003e Encoding -\u003e ErrorHandling -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#decode",
          "type": "function"
        },
        "index": {
          "description": "Create Unicode object by decoding Bytes object The encoding and error mode have the same meaning as the parameters of the the str.encode method The codec to be used is looked up using the Python codec registry",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "decode",
          "normalized": "Bytes-\u003eEncoding-\u003eErrorHandling-\u003eIO Unicode",
          "package": "cpython",
          "signature": "Bytes-\u003eEncoding-\u003eErrorHandling-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:decode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncode a \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e object and return the result as \u003ccode\u003e\u003ca\u003eBytes\u003c/a\u003e\u003c/code\u003e object.\n The encoding and error mode have the same meaning as the parameters of\n the the \u003ccode\u003estr.encode()\u003c/code\u003e method. The codec to be used is looked up using\n the Python codec registry.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "encode",
          "package": "cpython",
          "signature": "Unicode -\u003e Encoding -\u003e ErrorHandling -\u003e IO Bytes",
          "source": "src/CPython-Types-Unicode.html#encode",
          "type": "function"
        },
        "index": {
          "description": "Encode Unicode object and return the result as Bytes object The encoding and error mode have the same meaning as the parameters of the the str.encode method The codec to be used is looked up using the Python codec registry",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "encode",
          "normalized": "Unicode-\u003eEncoding-\u003eErrorHandling-\u003eIO Bytes",
          "package": "cpython",
          "signature": "Unicode-\u003eEncoding-\u003eErrorHandling-\u003eIO Bytes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:encode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the first position of the substring in \u003ccode\u003estring*[*start:end]\u003c/code\u003e\n using the given direction. The return value is the index of the first\n match; a value of \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e indicates that no match was found.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "find",
          "package": "cpython",
          "signature": "Unicode-\u003e Unicode-\u003e Integer-\u003e Integer-\u003e FindDirection-\u003e IO (Maybe Integer)",
          "type": "function"
        },
        "index": {
          "description": "Return the first position of the substring in string start end using the given direction The return value is the index of the first match value of Nothing indicates that no match was found",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "find",
          "normalized": "Unicode-\u003eUnicode-\u003eInteger-\u003eInteger-\u003eFindDirection-\u003eIO(Maybe Integer)",
          "package": "cpython",
          "signature": "Unicode-\u003eUnicode-\u003eInteger-\u003eInteger-\u003eFindDirection-\u003eIO(Maybe Integer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:find"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a new \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e object from the given format and args; this is\n analogous to \u003ccode\u003eformat % args\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "format",
          "package": "cpython",
          "signature": "Unicode -\u003e Tuple -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#format",
          "type": "function"
        },
        "index": {
          "description": "Return new Unicode object from the given format and args this is analogous to format args",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "format",
          "normalized": "Unicode-\u003eTuple-\u003eIO Unicode",
          "package": "cpython",
          "signature": "Unicode-\u003eTuple-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoerce an encoded object \u003cem\u003eobj\u003c/em\u003e to an Unicode object.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eBytes\u003c/a\u003e\u003c/code\u003e and other char buffer compatible objects are decoded according to\n the given encoding and error handling mode.\n\u003c/p\u003e\u003cp\u003eAll other objects, including \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e objects, cause a \u003ccode\u003eTypeError\u003c/code\u003e to be\n thrown.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "fromEncodedObject",
          "package": "cpython",
          "signature": "obj -\u003e Encoding -\u003e ErrorHandling -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#fromEncodedObject",
          "type": "function"
        },
        "index": {
          "description": "Coerce an encoded object obj to an Unicode object Bytes and other char buffer compatible objects are decoded according to the given encoding and error handling mode All other objects including Unicode objects cause TypeError to be thrown",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "fromEncodedObject",
          "normalized": "a-\u003eEncoding-\u003eErrorHandling-\u003eIO Unicode",
          "package": "cpython",
          "partial": "Encoded Object",
          "signature": "obj-\u003eEncoding-\u003eErrorHandling-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:fromEncodedObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShortcut for \u003ccode\u003e\u003ccode\u003e\u003ca\u003efromEncodedObject\u003c/a\u003e\u003c/code\u003e \"utf-8\" \u003ccode\u003e\u003ca\u003eStrict\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "fromObject",
          "package": "cpython",
          "signature": "obj -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#fromObject",
          "type": "function"
        },
        "index": {
          "description": "Shortcut for fromEncodedObject utf-8 Strict",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "fromObject",
          "normalized": "a-\u003eIO Unicode",
          "package": "cpython",
          "partial": "Object",
          "signature": "obj-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:fromObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Unicode\",\"CPython.Types\"]",
          "name": "fromUnicode",
          "package": "cpython",
          "signature": "Unicode -\u003e IO Text",
          "source": "src/CPython-Types-Unicode.html#fromUnicode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:fromUnicode\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:fromUnicode\"]"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "fromUnicode",
          "normalized": "Unicode-\u003eIO Text",
          "package": "cpython",
          "partial": "Unicode",
          "signature": "Unicode-\u003eIO Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:fromUnicode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin a sequence of strings using the given separator.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "join",
          "package": "cpython",
          "signature": "Unicode -\u003e seq -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#join",
          "type": "function"
        },
        "index": {
          "description": "Join sequence of strings using the given separator",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "join",
          "normalized": "Unicode-\u003ea-\u003eIO Unicode",
          "package": "cpython",
          "signature": "Unicode-\u003eseq-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:join"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.Unicode",
          "name": "length",
          "package": "cpython",
          "signature": "Unicode -\u003e IO Integer",
          "source": "src/CPython-Types-Unicode.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "length",
          "normalized": "Unicode-\u003eIO Integer",
          "package": "cpython",
          "signature": "Unicode-\u003eIO Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace occurrences of the substring with a given replacement. If the\n maximum count is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, replace all occurences.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "replace",
          "package": "cpython",
          "signature": "Unicode-\u003e Unicode-\u003e Unicode-\u003e Maybe Integer-\u003e IO Unicode",
          "type": "function"
        },
        "index": {
          "description": "Replace occurrences of the substring with given replacement If the maximum count is Nothing replace all occurences",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "replace",
          "normalized": "Unicode-\u003eUnicode-\u003eUnicode-\u003eMaybe Integer-\u003eIO Unicode",
          "package": "cpython",
          "signature": "Unicode-\u003eUnicode-\u003eUnicode-\u003eMaybe Integer-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a string giving a \u003ccode\u003e\u003ca\u003eList\u003c/a\u003e\u003c/code\u003e of \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e objects. If the separator is\n \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, splitting will be done at all whitespace substrings. Otherwise,\n splits occur at the given separator. Separators are not included in the\n resulting list.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "split",
          "package": "cpython",
          "signature": "Unicode-\u003e Maybe Unicode-\u003e Maybe Integer-\u003e IO List",
          "type": "function"
        },
        "index": {
          "description": "Split string giving List of Unicode objects If the separator is Nothing splitting will be done at all whitespace substrings Otherwise splits occur at the given separator Separators are not included in the resulting list",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "split",
          "normalized": "Unicode-\u003eMaybe Unicode-\u003eMaybe Integer-\u003eIO List",
          "package": "cpython",
          "signature": "Unicode-\u003eMaybe Unicode-\u003eMaybe Integer-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e string at line breaks, returning a list of \u003ccode\u003e\u003ca\u003eUnicode\u003c/a\u003e\u003c/code\u003e\n strings. CRLF is considered to be one line break. If the second parameter\n is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e, the line break characters are not included in the resulting\n strings.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "splitLines",
          "package": "cpython",
          "signature": "Unicode -\u003e Bool -\u003e IO List",
          "source": "src/CPython-Types-Unicode.html#splitLines",
          "type": "function"
        },
        "index": {
          "description": "Split Unicode string at line breaks returning list of Unicode strings CRLF is considered to be one line break If the second parameter is False the line break characters are not included in the resulting strings",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "splitLines",
          "normalized": "Unicode-\u003eBool-\u003eIO List",
          "package": "cpython",
          "partial": "Lines",
          "signature": "Unicode-\u003eBool-\u003eIO List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:splitLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the substring matches \u003ccode\u003estring*[*start:end]\u003c/code\u003e at the\n given tail end (either a \u003ccode\u003e\u003ca\u003ePrefix\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSuffix\u003c/a\u003e\u003c/code\u003e match), \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "tailMatch",
          "package": "cpython",
          "signature": "Unicode-\u003e Unicode-\u003e Integer-\u003e Integer-\u003e MatchDirection-\u003e IO Bool",
          "type": "function"
        },
        "index": {
          "description": "Return True if the substring matches string start end at the given tail end either Prefix or Suffix match False otherwise",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "tailMatch",
          "normalized": "Unicode-\u003eUnicode-\u003eInteger-\u003eInteger-\u003eMatchDirection-\u003eIO Bool",
          "package": "cpython",
          "partial": "Match",
          "signature": "Unicode-\u003eUnicode-\u003eInteger-\u003eInteger-\u003eMatchDirection-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:tailMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Unicode\",\"CPython.Types\"]",
          "name": "toUnicode",
          "package": "cpython",
          "signature": "Text -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#toUnicode",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:toUnicode\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:toUnicode\"]"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "toUnicode",
          "normalized": "Text-\u003eIO Unicode",
          "package": "cpython",
          "partial": "Unicode",
          "signature": "Text-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:toUnicode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate a string by applying a character mapping table to it.\n\u003c/p\u003e\u003cp\u003eThe mapping table must map Unicode ordinal integers to Unicode ordinal\n integers or \u003ccode\u003eNone\u003c/code\u003e (causing deletion of the character).\n\u003c/p\u003e\u003cp\u003eMapping tables need only provide the \u003ccode\u003e__getitem__()\u003c/code\u003e interface;\n dictionaries and sequences work well. Unmapped character ordinals (ones\n which cause a \u003ccode\u003eLookupError\u003c/code\u003e) are left untouched and are copied as-is.\n\u003c/p\u003e\u003cp\u003eThe error mode has the usual meaning for codecs.\n\u003c/p\u003e",
          "module": "CPython.Types.Unicode",
          "name": "translate",
          "package": "cpython",
          "signature": "Unicode -\u003e table -\u003e ErrorHandling -\u003e IO Unicode",
          "source": "src/CPython-Types-Unicode.html#translate",
          "type": "function"
        },
        "index": {
          "description": "Translate string by applying character mapping table to it The mapping table must map Unicode ordinal integers to Unicode ordinal integers or None causing deletion of the character Mapping tables need only provide the getitem interface dictionaries and sequences work well Unmapped character ordinals ones which cause LookupError are left untouched and are copied as-is The error mode has the usual meaning for codecs",
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "translate",
          "normalized": "Unicode-\u003ea-\u003eErrorHandling-\u003eIO Unicode",
          "package": "cpython",
          "signature": "Unicode-\u003etable-\u003eErrorHandling-\u003eIO Unicode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:translate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"CPython.Types.Unicode\",\"CPython.Types\"]",
          "name": "unicodeType",
          "package": "cpython",
          "signature": "Type",
          "source": "src/CPython-Types-Unicode.html#unicodeType",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:unicodeType\",\"http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#v:unicodeType\"]"
        },
        "index": {
          "hierarchy": "CPython Types Unicode",
          "module": "CPython.Types.Unicode",
          "name": "unicodeType",
          "package": "cpython",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-Unicode.html#v:unicodeType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.WeakReference",
          "name": "WeakReference",
          "package": "cpython",
          "source": "src/CPython-Types-WeakReference.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types WeakReference",
          "module": "CPython.Types.WeakReference",
          "name": "WeakReference",
          "package": "cpython",
          "partial": "Weak Reference",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-WeakReference.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.WeakReference",
          "name": "Proxy",
          "package": "cpython",
          "source": "src/CPython-Types-WeakReference.html#Proxy",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types WeakReference",
          "module": "CPython.Types.WeakReference",
          "name": "Proxy",
          "package": "cpython",
          "partial": "Proxy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-WeakReference.html#t:Proxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types.WeakReference",
          "name": "Reference",
          "package": "cpython",
          "source": "src/CPython-Types-WeakReference.html#Reference",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types WeakReference",
          "module": "CPython.Types.WeakReference",
          "name": "Reference",
          "package": "cpython",
          "partial": "Reference",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-WeakReference.html#t:Reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the referenced object from a weak reference. If the referent is\n no longer live, returns \u003ccode\u003eNone\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.WeakReference",
          "name": "getObject",
          "package": "cpython",
          "signature": "Reference -\u003e IO SomeObject",
          "source": "src/CPython-Types-WeakReference.html#getObject",
          "type": "function"
        },
        "index": {
          "description": "Return the referenced object from weak reference If the referent is no longer live returns None",
          "hierarchy": "CPython Types WeakReference",
          "module": "CPython.Types.WeakReference",
          "name": "getObject",
          "normalized": "Reference-\u003eIO SomeObject",
          "package": "cpython",
          "partial": "Object",
          "signature": "Reference-\u003eIO SomeObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-WeakReference.html#v:getObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a weak reference proxy for the object. This will always return a\n new reference, but is not guaranteed to create a new object; an existing\n proxy may be returned. The second parameter, \u003cem\u003ecallback\u003c/em\u003e, can be a callable\n object that receives notification when \u003cem\u003eobj\u003c/em\u003e is garbage collected; it\n should accept a single parameter, which will be the weak reference object\n itself. If ob is not a weakly-referencable object, or if \u003cem\u003ecallback\u003c/em\u003e is not\n callable, this will throw a \u003ccode\u003eTypeError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.WeakReference",
          "name": "newProxy",
          "package": "cpython",
          "signature": "obj -\u003e Maybe callback -\u003e IO Proxy",
          "source": "src/CPython-Types-WeakReference.html#newProxy",
          "type": "function"
        },
        "index": {
          "description": "Return weak reference proxy for the object This will always return new reference but is not guaranteed to create new object an existing proxy may be returned The second parameter callback can be callable object that receives notification when obj is garbage collected it should accept single parameter which will be the weak reference object itself If ob is not weakly-referencable object or if callback is not callable this will throw TypeError",
          "hierarchy": "CPython Types WeakReference",
          "module": "CPython.Types.WeakReference",
          "name": "newProxy",
          "normalized": "a-\u003eMaybe b-\u003eIO Proxy",
          "package": "cpython",
          "partial": "Proxy",
          "signature": "obj-\u003eMaybe callback-\u003eIO Proxy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-WeakReference.html#v:newProxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a weak reference for the object. This will always return a new\n reference, but is not guaranteed to create a new object; an existing\n reference object may be returned. The second parameter, \u003cem\u003ecallback\u003c/em\u003e, can\n be a callable object that receives notification when \u003cem\u003eobj\u003c/em\u003e is garbage\n collected; it should accept a single parameter, which will be the weak\n reference object itself. If ob is not a weakly-referencable object, or if\n \u003cem\u003ecallback\u003c/em\u003e is not callable, this will throw a \u003ccode\u003eTypeError\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython.Types.WeakReference",
          "name": "newReference",
          "package": "cpython",
          "signature": "obj -\u003e Maybe callback -\u003e IO Reference",
          "source": "src/CPython-Types-WeakReference.html#newReference",
          "type": "function"
        },
        "index": {
          "description": "Return weak reference for the object This will always return new reference but is not guaranteed to create new object an existing reference object may be returned The second parameter callback can be callable object that receives notification when obj is garbage collected it should accept single parameter which will be the weak reference object itself If ob is not weakly-referencable object or if callback is not callable this will throw TypeError",
          "hierarchy": "CPython Types WeakReference",
          "module": "CPython.Types.WeakReference",
          "name": "newReference",
          "normalized": "a-\u003eMaybe b-\u003eIO Reference",
          "package": "cpython",
          "partial": "Reference",
          "signature": "obj-\u003eMaybe callback-\u003eIO Reference",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types-WeakReference.html#v:newReference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Types",
          "package": "cpython",
          "source": "src/CPython-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Types",
          "package": "cpython",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "AnySet",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html#AnySet",
          "type": "class"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "AnySet",
          "package": "cpython",
          "partial": "Any Set",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:AnySet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "ByteArray",
          "package": "cpython",
          "source": "src/CPython-Types-ByteArray.html#ByteArray",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "ByteArray",
          "package": "cpython",
          "partial": "Byte Array",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:ByteArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Bytes",
          "package": "cpython",
          "source": "src/CPython-Types-Bytes.html#Bytes",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Bytes",
          "package": "cpython",
          "partial": "Bytes",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "CallableIterator",
          "package": "cpython",
          "source": "src/CPython-Types-Iterator.html#CallableIterator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "CallableIterator",
          "package": "cpython",
          "partial": "Callable Iterator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:CallableIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Capsule",
          "package": "cpython",
          "source": "src/CPython-Types-Capsule.html#Capsule",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Capsule",
          "package": "cpython",
          "partial": "Capsule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Capsule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Cell",
          "package": "cpython",
          "source": "src/CPython-Types-Cell.html#Cell",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Cell",
          "package": "cpython",
          "partial": "Cell",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Cell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Code",
          "package": "cpython",
          "source": "src/CPython-Types-Code.html#Code",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Code",
          "package": "cpython",
          "partial": "Code",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Code"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Complex",
          "package": "cpython",
          "source": "src/CPython-Types-Complex.html#Complex",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Complex",
          "package": "cpython",
          "partial": "Complex",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Complex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Dictionary",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Dictionary",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Dictionary",
          "package": "cpython",
          "partial": "Dictionary",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Exception",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Exception",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Exception",
          "package": "cpython",
          "partial": "Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Float",
          "package": "cpython",
          "source": "src/CPython-Types-Float.html#Float",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Float",
          "package": "cpython",
          "partial": "Float",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Float"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "FrozenSet",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html#FrozenSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "FrozenSet",
          "package": "cpython",
          "partial": "Frozen Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:FrozenSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Function",
          "package": "cpython",
          "source": "src/CPython-Types-Function.html#Function",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Function",
          "package": "cpython",
          "partial": "Function",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "InstanceMethod",
          "package": "cpython",
          "source": "src/CPython-Types-InstanceMethod.html#InstanceMethod",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "InstanceMethod",
          "package": "cpython",
          "partial": "Instance Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:InstanceMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Integer",
          "package": "cpython",
          "source": "src/CPython-Types-Integer.html#Integer",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Integer",
          "package": "cpython",
          "partial": "Integer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "List",
          "package": "cpython",
          "source": "src/CPython-Internal.html#List",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "List",
          "package": "cpython",
          "partial": "List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Method",
          "package": "cpython",
          "source": "src/CPython-Types-Method.html#Method",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Method",
          "package": "cpython",
          "partial": "Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Method"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Module",
          "package": "cpython",
          "source": "src/CPython-Types-Module.html#Module",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Module",
          "package": "cpython",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Proxy",
          "package": "cpython",
          "source": "src/CPython-Types-WeakReference.html#Proxy",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Proxy",
          "package": "cpython",
          "partial": "Proxy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Proxy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Reference",
          "package": "cpython",
          "source": "src/CPython-Types-WeakReference.html#Reference",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Reference",
          "package": "cpython",
          "partial": "Reference",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Reference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "SequenceIterator",
          "package": "cpython",
          "source": "src/CPython-Types-Iterator.html#SequenceIterator",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "SequenceIterator",
          "package": "cpython",
          "partial": "Sequence Iterator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:SequenceIterator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Set",
          "package": "cpython",
          "source": "src/CPython-Types-Set.html#Set",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Set",
          "package": "cpython",
          "partial": "Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Slice",
          "package": "cpython",
          "source": "src/CPython-Types-Slice.html#Slice",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Slice",
          "package": "cpython",
          "partial": "Slice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Slice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Tuple",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Tuple",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Tuple",
          "package": "cpython",
          "partial": "Tuple",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Type",
          "package": "cpython",
          "source": "src/CPython-Internal.html#Type",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Type",
          "package": "cpython",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython.Types",
          "name": "Unicode",
          "package": "cpython",
          "source": "src/CPython-Types-Unicode.html#Unicode",
          "type": "data"
        },
        "index": {
          "hierarchy": "CPython Types",
          "module": "CPython.Types",
          "name": "Unicode",
          "package": "cpython",
          "partial": "Unicode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython-Types.html#t:Unicode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "CPython",
          "name": "CPython",
          "package": "cpython",
          "source": "src/CPython.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "CPython",
          "package": "cpython",
          "partial": "CPython",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDestroy the (sub-)interpreter represented by the given thread state.\n The given thread state must be the current thread state. See the\n discussion of thread states below. When the call returns, the current\n thread state is \u003ccode\u003eNULL\u003c/code\u003e. All thread states associated with this\n interpreter are destroyed. (The global interpreter lock must be held\n before calling this computation and is still held when it returns.)\n \u003ccode\u003e\u003ca\u003efinalize\u003c/a\u003e\u003c/code\u003e will destroy all sub-interpreters that haven&#8217;t been\n explicitly destroyed at that point.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "endInterpreter",
          "package": "cpython",
          "signature": "ThreadState -\u003e IO ()",
          "source": "src/CPython.html#endInterpreter",
          "type": "function"
        },
        "index": {
          "description": "Destroy the sub interpreter represented by the given thread state The given thread state must be the current thread state See the discussion of thread states below When the call returns the current thread state is NULL All thread states associated with this interpreter are destroyed The global interpreter lock must be held before calling this computation and is still held when it returns finalize will destroy all sub-interpreters that haven been explicitly destroyed at that point",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "endInterpreter",
          "normalized": "ThreadState-\u003eIO()",
          "package": "cpython",
          "partial": "Interpreter",
          "signature": "ThreadState-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:endInterpreter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUndo all initializations made by \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e and subsequent use of\n Python/C API computations, and destroy all sub-interpreters (see\n \u003ccode\u003e\u003ca\u003enewInterpreter\u003c/a\u003e\u003c/code\u003e below) that were created and not yet destroyed since the\n last call to \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e. Ideally, this frees all memory allocated by the\n Python interpreter. This is a no-op when called for a second time (without\n calling \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e again first). There is no return value; errors during\n finalization are ignored.\n\u003c/p\u003e\u003cp\u003eThis computation is provided for a number of reasons. An embedding\n application might want to restart Python without having to restart the\n application itself. An application that has loaded the Python interpreter\n from a dynamically loadable library (or DLL) might want to free all memory\n allocated by Python before unloading the DLL. During a hunt for memory\n leaks in an application a developer might want to free all memory\n allocated by Python before exiting from the application.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eBugs and caveats\u003c/em\u003e: The destruction of modules and objects in modules is\n done in arbitrary order; this may cause destructors (\u003ccode\u003e__del__()\u003c/code\u003e methods)\n to fail when they depend on other objects (even functions) or modules.\n Dynamically loaded extension modules loaded by Python are not unloaded.\n Small amounts of memory allocated by the Python interpreter may not be\n freed (if you find a leak, please report it). Memory tied up in circular\n references between objects is not freed. Some memory allocated by extension\n modules may not be freed. Some extensions may not work properly if their\n initialization routine is called more than once; this can happen if an\n application calls \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efinalize\u003c/a\u003e\u003c/code\u003e more than once.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "finalize",
          "package": "cpython",
          "signature": "IO ()",
          "source": "src/CPython.html#finalize",
          "type": "function"
        },
        "index": {
          "description": "Undo all initializations made by initialize and subsequent use of Python API computations and destroy all sub-interpreters see newInterpreter below that were created and not yet destroyed since the last call to initialize Ideally this frees all memory allocated by the Python interpreter This is no-op when called for second time without calling initialize again first There is no return value errors during finalization are ignored This computation is provided for number of reasons An embedding application might want to restart Python without having to restart the application itself An application that has loaded the Python interpreter from dynamically loadable library or DLL might want to free all memory allocated by Python before unloading the DLL During hunt for memory leaks in an application developer might want to free all memory allocated by Python before exiting from the application Bugs and caveats The destruction of modules and objects in modules is done in arbitrary order this may cause destructors del methods to fail when they depend on other objects even functions or modules Dynamically loaded extension modules loaded by Python are not unloaded Small amounts of memory allocated by the Python interpreter may not be freed if you find leak please report it Memory tied up in circular references between objects is not freed Some memory allocated by extension modules may not be freed Some extensions may not work properly if their initialization routine is called more than once this can happen if an application calls initialize and finalize more than once",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "finalize",
          "normalized": "IO()",
          "package": "cpython",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:finalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn information about the sequence number and build date and time of\n the current Python interpreter instance, for example\n\u003c/p\u003e\u003cpre\u003e\n  \"#67, Aug  1 1997, 22:34:28\"\n\u003c/pre\u003e\u003cp\u003eThe value is available to Python code as part of the variable\n \u003ccode\u003esys.version\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getBuildInfo",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getBuildInfo",
          "type": "function"
        },
        "index": {
          "description": "Return information about the sequence number and build date and time of the current Python interpreter instance for example Aug The value is available to Python code as part of the variable sys.version",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getBuildInfo",
          "package": "cpython",
          "partial": "Build Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getBuildInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an indication of the compiler used to build the current Python\n version, in square brackets, for example:\n\u003c/p\u003e\u003cpre\u003e\n  \"[GCC 2.7.2.2]\"\n\u003c/pre\u003e\u003cp\u003eThe value is available to Python code as part of the variable\n \u003ccode\u003esys.version\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getCompiler",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getCompiler",
          "type": "function"
        },
        "index": {
          "description": "Return an indication of the compiler used to build the current Python version in square brackets for example GCC The value is available to Python code as part of the variable sys.version",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getCompiler",
          "package": "cpython",
          "partial": "Compiler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getCompiler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the official copyright string for the current Python version,\n for example\n\u003c/p\u003e\u003cpre\u003e\n  \"Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam\"\n\u003c/pre\u003e\u003cp\u003eThe value is available to Python code as \u003ccode\u003esys.copyright\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getCopyright",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getCopyright",
          "type": "function"
        },
        "index": {
          "description": "Return the official copyright string for the current Python version for example Copyright Stichting Mathematisch Centrum Amsterdam The value is available to Python code as sys.copyright",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getCopyright",
          "package": "cpython",
          "partial": "Copyright",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getCopyright"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the \u003cem\u003eexec-prefix\u003c/em\u003e for installed platform-\u003cem\u003edependent\u003c/em\u003e files. This\n is derived through a number of complicated rules from the program name\n set with setProgramName' and some environment variables; for example, if\n the program name is \u003ccode\u003e\"/usr/local/bin/python\"\u003c/code\u003e, the exec-prefix is\n \u003ccode\u003e\"/usr/local\"\u003c/code\u003e. This corresponds to the \u003ccode\u003eexec_prefix\u003c/code\u003e variable in the\n top-level Makefile and the \u003cem\u003e--exec-prefix\u003c/em\u003e argument to the \u003ccode\u003econfigure\u003c/code\u003e\n script at build time. The value is available to Python code as\n \u003ccode\u003esys.exec_prefix\u003c/code\u003e. It is only useful on UNIX.\n\u003c/p\u003e\u003cp\u003eBackground: The exec-prefix differs from the prefix when platform\n dependent files (such as executables and shared libraries) are installed\n in a different directory tree. In a typical installation, platform\n dependent files may be installed in the \u003ccode\u003e/usr/local/plat\u003c/code\u003e subtree while\n platform independent may be installed in \u003ccode\u003e/usr/local\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eGenerally speaking, a platform is a combination of hardware and software\n families, e.g. Sparc machines running the Solaris 2.x operating system\n are considered the same platform, but Intel machines running Solaris\n 2.x are another platform, and Intel machines running Linux are yet\n another platform. Different major revisions of the same operating system\n generally also form different platforms. Non-UNIX operating systems are a\n different story; the installation strategies on those systems are so\n different that the prefix and exec-prefix are meaningless, and set to the\n empty string. Note that compiled Python bytecode files are platform\n independent (but not independent from the Python version by which they\n were compiled!).\n\u003c/p\u003e\u003cp\u003eSystem administrators will know how to configure the \u003ccode\u003emount\u003c/code\u003e or \u003ccode\u003eautomount\u003c/code\u003e\n programs to share \u003ccode\u003e/usr/local\u003c/code\u003e between platforms while having\n \u003ccode\u003e/usr/local/plat\u003c/code\u003e be a different filesystem for each platform.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getExecPrefix",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getExecPrefix",
          "type": "function"
        },
        "index": {
          "description": "Return the exec-prefix for installed platform dependent files This is derived through number of complicated rules from the program name set with setProgramName and some environment variables for example if the program name is usr local bin python the exec-prefix is usr local This corresponds to the exec prefix variable in the top-level Makefile and the exec-prefix argument to the configure script at build time The value is available to Python code as sys.exec prefix It is only useful on UNIX Background The exec-prefix differs from the prefix when platform dependent files such as executables and shared libraries are installed in different directory tree In typical installation platform dependent files may be installed in the usr local plat subtree while platform independent may be installed in usr local Generally speaking platform is combination of hardware and software families e.g Sparc machines running the Solaris operating system are considered the same platform but Intel machines running Solaris are another platform and Intel machines running Linux are yet another platform Different major revisions of the same operating system generally also form different platforms Non-UNIX operating systems are different story the installation strategies on those systems are so different that the prefix and exec-prefix are meaningless and set to the empty string Note that compiled Python bytecode files are platform independent but not independent from the Python version by which they were compiled System administrators will know how to configure the mount or automount programs to share usr local between platforms while having usr local plat be different filesystem for each platform",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getExecPrefix",
          "package": "cpython",
          "partial": "Exec Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getExecPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the default module search path; this is computed from the\n program name (set by \u003ccode\u003e\u003ca\u003esetProgramName\u003c/a\u003e\u003c/code\u003e above) and some environment\n variables. The returned string consists of a series of directory names\n separated by a platform dependent delimiter character. The delimiter\n character is \u003ccode\u003e':'\u003c/code\u003e on Unix and Mac OS X, \u003ccode\u003e';'\u003c/code\u003e on Windows. The value\n is available to Python code as the list \u003ccode\u003esys.path\u003c/code\u003e, which may be modified\n to change the future search path for loaded modules.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getPath",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getPath",
          "type": "function"
        },
        "index": {
          "description": "Return the default module search path this is computed from the program name set by setProgramName above and some environment variables The returned string consists of series of directory names separated by platform dependent delimiter character The delimiter character is on Unix and Mac OS on Windows The value is available to Python code as the list sys.path which may be modified to change the future search path for loaded modules",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getPath",
          "package": "cpython",
          "partial": "Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the platform identifier for the current platform. On Unix, this\n is formed from the &#8220;official&#8221; name of the operating system,\n converted to lower case, followed by the major revision number; e.g., for\n Solaris 2.x, which is also known as SunOS 5.x, the value is \u003ccode\u003e\"sunos5\"\u003c/code\u003e.\n On Mac OS X, it is \u003ccode\u003e\"darwin\"\u003c/code\u003e. On Windows, it is \u003ccode\u003e\"win\"\u003c/code\u003e. The value\n is available to Python code as \u003ccode\u003esys.platform\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getPlatform",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getPlatform",
          "type": "function"
        },
        "index": {
          "description": "Return the platform identifier for the current platform On Unix this is formed from the official name of the operating system converted to lower case followed by the major revision number e.g for Solaris which is also known as SunOS the value is sunos5 On Mac OS it is darwin On Windows it is win The value is available to Python code as sys.platform",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getPlatform",
          "package": "cpython",
          "partial": "Platform",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getPlatform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the prefix for installed platform-independent files. This is\n derived through a number of complicated rules from the program name set\n with \u003ccode\u003e\u003ca\u003esetProgramName\u003c/a\u003e\u003c/code\u003e and some environment variables; for example, if the\n program name is \u003ccode\u003e\"/usr/local/bin/python\"\u003c/code\u003e, the prefix is\n \u003ccode\u003e\"/usr/local\"\u003c/code\u003e. This corresponds to the \u003ccode\u003eprefix\u003c/code\u003e variable in the\n top-level Makefile and the \u003cem\u003e--prefix\u003c/em\u003e argument to the \u003ccode\u003econfigure\u003c/code\u003e script\n at build time. The value is available to Python code as \u003ccode\u003esys.prefix\u003c/code\u003e. It\n is only useful on UNIX. See also \u003ccode\u003e\u003ca\u003egetExecPrefix\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getPrefix",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getPrefix",
          "type": "function"
        },
        "index": {
          "description": "Return the prefix for installed platform-independent files This is derived through number of complicated rules from the program name set with setProgramName and some environment variables for example if the program name is usr local bin python the prefix is usr local This corresponds to the prefix variable in the top-level Makefile and the prefix argument to the configure script at build time The value is available to Python code as sys.prefix It is only useful on UNIX See also getExecPrefix",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getPrefix",
          "package": "cpython",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the full program name of the Python executable; this is computed\n as a side-effect of deriving the default module search path from the\n program name (set by \u003ccode\u003e\u003ca\u003esetProgramName\u003c/a\u003e\u003c/code\u003e above). The value is available to\n Python code as \u003ccode\u003esys.executable\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getProgramFullPath",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getProgramFullPath",
          "type": "function"
        },
        "index": {
          "description": "Return the full program name of the Python executable this is computed as side-effect of deriving the default module search path from the program name set by setProgramName above The value is available to Python code as sys.executable",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getProgramFullPath",
          "package": "cpython",
          "partial": "Program Full Path",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getProgramFullPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the program name set with \u003ccode\u003e\u003ca\u003esetProgramName\u003c/a\u003e\u003c/code\u003e, or the default.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getProgramName",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getProgramName",
          "type": "function"
        },
        "index": {
          "description": "Return the program name set with setProgramName or the default",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getProgramName",
          "package": "cpython",
          "partial": "Program Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getProgramName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the default &#8220;home&#8221;, that is, the value set by a\n previous call to \u003ccode\u003e\u003ca\u003esetPythonHome\u003c/a\u003e\u003c/code\u003e, or the value of the \u003ccode\u003ePYTHONHOME\u003c/code\u003e\n environment variable if it is set.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getPythonHome",
          "package": "cpython",
          "signature": "IO (Maybe Text)",
          "source": "src/CPython.html#getPythonHome",
          "type": "function"
        },
        "index": {
          "description": "Return the default home that is the value set by previous call to setPythonHome or the value of the PYTHONHOME environment variable if it is set",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getPythonHome",
          "package": "cpython",
          "partial": "Python Home",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getPythonHome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the version of this Python interpreter. This is a string that\n looks something like\n\u003c/p\u003e\u003cpre\u003e\n  \"3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \\n[GCC 4.2.3]\"\n\u003c/pre\u003e\u003cp\u003eThe first word (up to the first space character) is the current Python\n version; the first three characters are the major and minor version\n separated by a period. The value is available to Python code as\n \u003ccode\u003esys.version\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "getVersion",
          "package": "cpython",
          "signature": "IO Text",
          "source": "src/CPython.html#getVersion",
          "type": "function"
        },
        "index": {
          "description": "Return the version of this Python interpreter This is string that looks something like a5 py3k May GCC The first word up to the first space character is the current Python version the first three characters are the major and minor version separated by period The value is available to Python code as sys.version",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "getVersion",
          "package": "cpython",
          "partial": "Version",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:getVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialize the Python interpreter. In an application embedding Python,\n this should be called before using any other Python/C API computations;\n with the exception of \u003ccode\u003e\u003ca\u003esetProgramName\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003einitThreads\u003c/code\u003e,\n \u003ccode\u003ereleaseLock\u003c/code\u003e, and \u003ccode\u003eacquireLock\u003c/code\u003e. This initializes the table\n of loaded modules (\u003ccode\u003esys.modules\u003c/code\u003e), and creates the fundamental modules\n \u003ccode\u003ebuiltins\u003c/code\u003e, \u003ccode\u003e__main__\u003c/code\u003e and \u003ccode\u003esys\u003c/code\u003e. It also initializes the module search\n path (\u003ccode\u003esys.path\u003c/code\u003e). It does not set \u003ccode\u003esys.argv\u003c/code\u003e; use \u003ccode\u003e\u003ca\u003esetArgv\u003c/a\u003e\u003c/code\u003e for that. This\n is a no-op when called for a second time (without calling \u003ccode\u003e\u003ca\u003efinalize\u003c/a\u003e\u003c/code\u003e\n first). There is no return value; it is a fatal error if the initialization\n fails.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "initialize",
          "package": "cpython",
          "signature": "IO ()",
          "source": "src/CPython.html#initialize",
          "type": "function"
        },
        "index": {
          "description": "Initialize the Python interpreter In an application embedding Python this should be called before using any other Python API computations with the exception of setProgramName initThreads releaseLock and acquireLock This initializes the table of loaded modules sys.modules and creates the fundamental modules builtins main and sys It also initializes the module search path sys.path It does not set sys.argv use setArgv for that This is no-op when called for second time without calling finalize first There is no return value it is fatal error if the initialization fails",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "initialize",
          "normalized": "IO()",
          "package": "cpython",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:initialize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when the Python interpreter has been initialized, \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n if not. After \u003ccode\u003e\u003ca\u003efinalize\u003c/a\u003e\u003c/code\u003e is called, this returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e until\n \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e is called again.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "isInitialized",
          "package": "cpython",
          "signature": "IO Bool",
          "source": "src/CPython.html#isInitialized",
          "type": "function"
        },
        "index": {
          "description": "Return True when the Python interpreter has been initialized False if not After finalize is called this returns False until initialize is called again",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "isInitialized",
          "package": "cpython",
          "partial": "Initialized",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:isInitialized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new sub-interpreter. This is an (almost) totally separate\n environment for the execution of Python code. In particular, the new\n interpreter has separate, independent versions of all imported modules,\n including the fundamental modules \u003ccode\u003ebuiltins\u003c/code\u003e, \u003ccode\u003e__main__\u003c/code\u003e and \u003ccode\u003esys\u003c/code\u003e. The\n table of loaded modules (\u003ccode\u003esys.modules\u003c/code\u003e) and the module search path\n (\u003ccode\u003esys.path\u003c/code\u003e) are also separate. The new environment has no \u003ccode\u003esys.argv\u003c/code\u003e\n variable. It has new standard I/O stream file objects \u003ccode\u003esys.stdin\u003c/code\u003e,\n \u003ccode\u003esys.stdout\u003c/code\u003e and \u003ccode\u003esys.stderr\u003c/code\u003e (however these refer to the same underlying\n \u003ccode\u003eFILE\u003c/code\u003e structures in the C library).\n\u003c/p\u003e\u003cp\u003eThe return value points to the first thread state created in the new\n sub-interpreter. This thread state is made in the current thread state.\n Note that no actual thread is created; see the discussion of thread states\n below. If creation of the new interpreter is unsuccessful, \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e is\n returned; no exception is set since the exception state is stored in the\n current thread state and there may not be a current thread state. (Like\n all other Python/C API computations, the global interpreter lock must be\n held before calling this computation and is still held when it returns;\n however, unlike most other Python/C API computations, there\n needn&#8217;t be a current thread state on entry.)\n\u003c/p\u003e\u003cp\u003eExtension modules are shared between (sub-)interpreters as follows: the\n first time a particular extension is imported, it is initialized normally,\n and a (shallow) copy of its module&#8217;s dictionary is squirreled away.\n When the same extension is imported by another (sub-)interpreter, a new\n module is initialized and filled with the contents of this copy; the\n extension&#8217;s \u003ccode\u003einit\u003c/code\u003e procedure is not called. Note that this is\n different from what happens when an extension is imported after the\n interpreter has been completely re-initialized by calling \u003ccode\u003e\u003ca\u003efinalize\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e; in that case, the extension&#8217;s \u003ccode\u003einit\u003cem\u003emodule\u003c/em\u003e\u003c/code\u003e\n procedure is called again.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eBugs and caveats\u003c/em\u003e: Because sub-interpreters (and the main interpreter)\n are part of the same process, the insulation between them isn&#8217;t\n perfect &#8212; for example, using low-level file operations like\n \u003ccode\u003eos.close()\u003c/code\u003e they can (accidentally or maliciously) affect each\n other&#8217;s open files. Because of the way extensions are shared\n between (sub-)interpreters, some extensions may not work properly; this\n is especially likely when the extension makes use of (static) global\n variables, or when the extension manipulates its module&#8217;s\n dictionary after its initialization. It is possible to insert objects\n created in one sub-interpreter into a namespace of another\n sub-interpreter; this should be done with great care to avoid sharing\n user-defined functions, methods, instances or classes between\n sub-interpreters, since import operations executed by such objects may\n affect the wrong (sub-)interpreter&#8217;s dictionary of loaded modules.\n (XXX This is a hard-to-fix bug that will be addressed in a future release.)\n\u003c/p\u003e\u003cp\u003eAlso note that the use of this functionality is incompatible with\n extension modules such as PyObjC and ctypes that use the \u003ccode\u003ePyGILState_*()\u003c/code\u003e\n APIs (and this is inherent in the way the \u003ccode\u003ePyGILState_*()\u003c/code\u003e procedures\n work). Simple things may work, but confusing behavior will always be near.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "newInterpreter",
          "package": "cpython",
          "signature": "IO (Maybe ThreadState)",
          "source": "src/CPython.html#newInterpreter",
          "type": "function"
        },
        "index": {
          "description": "Create new sub-interpreter This is an almost totally separate environment for the execution of Python code In particular the new interpreter has separate independent versions of all imported modules including the fundamental modules builtins main and sys The table of loaded modules sys.modules and the module search path sys.path are also separate The new environment has no sys.argv variable It has new standard stream file objects sys.stdin sys.stdout and sys.stderr however these refer to the same underlying FILE structures in the library The return value points to the first thread state created in the new sub-interpreter This thread state is made in the current thread state Note that no actual thread is created see the discussion of thread states below If creation of the new interpreter is unsuccessful Nothing is returned no exception is set since the exception state is stored in the current thread state and there may not be current thread state Like all other Python API computations the global interpreter lock must be held before calling this computation and is still held when it returns however unlike most other Python API computations there needn be current thread state on entry Extension modules are shared between sub interpreters as follows the first time particular extension is imported it is initialized normally and shallow copy of its module dictionary is squirreled away When the same extension is imported by another sub interpreter new module is initialized and filled with the contents of this copy the extension init procedure is not called Note that this is different from what happens when an extension is imported after the interpreter has been completely re-initialized by calling finalize and initialize in that case the extension init module procedure is called again Bugs and caveats Because sub-interpreters and the main interpreter are part of the same process the insulation between them isn perfect for example using low-level file operations like os.close they can accidentally or maliciously affect each other open files Because of the way extensions are shared between sub interpreters some extensions may not work properly this is especially likely when the extension makes use of static global variables or when the extension manipulates its module dictionary after its initialization It is possible to insert objects created in one sub-interpreter into namespace of another sub-interpreter this should be done with great care to avoid sharing user-defined functions methods instances or classes between sub-interpreters since import operations executed by such objects may affect the wrong sub interpreter dictionary of loaded modules XXX This is hard-to-fix bug that will be addressed in future release Also note that the use of this functionality is incompatible with extension modules such as PyObjC and ctypes that use the PyGILState APIs and this is inherent in the way the PyGILState procedures work Simple things may work but confusing behavior will always be near",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "newInterpreter",
          "package": "cpython",
          "partial": "Interpreter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:newInterpreter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet \u003ccode\u003esys.argv\u003c/code\u003e. The first parameter is similar to the result of\n \u003ccode\u003egetProgName\u003c/code\u003e, with the difference that it should refer to the script\n file to be executed rather than the executable hosting the Python\n interpreter. If there isn&#8217;t a script that will be run, the first\n parameter can be an empty string. If this function fails to initialize\n \u003ccode\u003esys.argv\u003c/code\u003e, a fatal condition is signalled using \u003ccode\u003ePy_FatalError()\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function also prepends the executed script&#8217;s path to\n \u003ccode\u003esys.path\u003c/code\u003e. If no script is executed (in the case of calling \u003ccode\u003epython -c\u003c/code\u003e\n or just the interactive interpreter), the empty string is used instead.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "setArgv",
          "package": "cpython",
          "signature": "Text -\u003e [Text] -\u003e IO ()",
          "source": "src/CPython.html#setArgv",
          "type": "function"
        },
        "index": {
          "description": "Set sys.argv The first parameter is similar to the result of getProgName with the difference that it should refer to the script file to be executed rather than the executable hosting the Python interpreter If there isn script that will be run the first parameter can be an empty string If this function fails to initialize sys.argv fatal condition is signalled using Py FatalError This function also prepends the executed script path to sys.path If no script is executed in the case of calling python or just the interactive interpreter the empty string is used instead",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "setArgv",
          "normalized": "Text-\u003e[Text]-\u003eIO()",
          "package": "cpython",
          "partial": "Argv",
          "signature": "Text-\u003e[Text]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:setArgv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis computation should be called before \u003ccode\u003e\u003ca\u003einitialize\u003c/a\u003e\u003c/code\u003e is called for the\n first time, if it is called at all. It tells the interpreter the value of\n the \u003ccode\u003eargv[0]\u003c/code\u003e argument to the \u003ccode\u003emain\u003c/code\u003e procedure of the program. This is\n used by \u003ccode\u003e\u003ca\u003egetPath\u003c/a\u003e\u003c/code\u003e and some other computations below to find the Python\n run-time libraries relative to the interpreter executable. The default\n value is \u003ccode\u003e\"python\"\u003c/code\u003e. No code in the Python interpreter will change the\n program name.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "setProgramName",
          "package": "cpython",
          "signature": "Text -\u003e IO ()",
          "source": "src/CPython.html#setProgramName",
          "type": "function"
        },
        "index": {
          "description": "This computation should be called before initialize is called for the first time if it is called at all It tells the interpreter the value of the argv argument to the main procedure of the program This is used by getPath and some other computations below to find the Python run-time libraries relative to the interpreter executable The default value is python No code in the Python interpreter will change the program name",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "setProgramName",
          "normalized": "Text-\u003eIO()",
          "package": "cpython",
          "partial": "Program Name",
          "signature": "Text-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:setProgramName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the default &#8220;home&#8221; directory, that is, the location\n of the standard Python libraries. The libraries are searched in\n \u003ccode\u003e\u003cem\u003ehome\u003c/em\u003e/lib/\u003cem\u003epython version\u003c/em\u003e\u003c/code\u003e and \u003ccode\u003e\u003cem\u003ehome\u003c/em\u003e/lib/\u003cem\u003epython version\u003c/em\u003e\u003c/code\u003e. No\n code in the Python interpreter will change the Python home.\n\u003c/p\u003e",
          "module": "CPython",
          "name": "setPythonHome",
          "package": "cpython",
          "signature": "Maybe Text -\u003e IO ()",
          "source": "src/CPython.html#setPythonHome",
          "type": "function"
        },
        "index": {
          "description": "Set the default home directory that is the location of the standard Python libraries The libraries are searched in home lib python version and home lib python version No code in the Python interpreter will change the Python home",
          "hierarchy": "CPython",
          "module": "CPython",
          "name": "setPythonHome",
          "normalized": "Maybe Text-\u003eIO()",
          "package": "cpython",
          "partial": "Python Home",
          "signature": "Maybe Text-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/cpython/docs/CPython.html#v:setPythonHome"
      }
    }
  ]
]