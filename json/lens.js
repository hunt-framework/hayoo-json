[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "lens"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003elens\u003c/code\u003e support for the \u003ccode\u003ezlib\u003c/code\u003e library\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Codec-Compression-Zlib-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "lens support for the zlib library",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe compression level parameter controls the amount of compression. This\n is a trade-off between the amount of compression and the time required to do\n the compression.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "CompressionLevel",
          "package": "lens",
          "type": "data"
        },
        "index": {
          "description": "The compression level parameter controls the amount of compression This is trade-off between the amount of compression and the time required to do the compression",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "CompressionLevel",
          "package": "lens",
          "partial": "Compression Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:CompressionLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strategy parameter is used to tune the compression algorithm.\n\u003c/p\u003e\u003cp\u003eThe strategy parameter only affects the compression ratio but not the\n correctness of the compressed output even if it is not set appropriately.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "CompressionStrategy",
          "package": "lens",
          "type": "data"
        },
        "index": {
          "description": "The strategy parameter is used to tune the compression algorithm The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "CompressionStrategy",
          "package": "lens",
          "partial": "Compression Strategy",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:CompressionStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe format used for compression or decompression. There are three\n variations.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Format",
          "package": "lens",
          "type": "data"
        },
        "index": {
          "description": "The format used for compression or decompression There are three variations",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Format",
          "package": "lens",
          "partial": "Format",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:Format"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMemoryLevel\u003c/a\u003e\u003c/code\u003e parameter specifies how much memory should be allocated\n for the internal compression state. It is a tradoff between memory usage,\n compression ratio and compression speed. Using more memory allows faster\n compression and a better compression ratio.\n\u003c/p\u003e\u003cp\u003eThe total amount of memory used for compression depends on the \u003ccode\u003e\u003ca\u003eWindowBits\u003c/a\u003e\u003c/code\u003e\n and the \u003ccode\u003e\u003ca\u003eMemoryLevel\u003c/a\u003e\u003c/code\u003e. For decompression it depends only on the\n \u003ccode\u003e\u003ca\u003eWindowBits\u003c/a\u003e\u003c/code\u003e. The totals are given by the functions:\n\u003c/p\u003e\u003cpre\u003e compressTotal windowBits memLevel = 4 * 2^windowBits + 512 * 2^memLevel\n decompressTotal windowBits = 2^windowBits\n\u003c/pre\u003e\u003cp\u003eFor example, for compression with the default \u003ccode\u003ewindowBits = 15\u003c/code\u003e and\n \u003ccode\u003ememLevel = 8\u003c/code\u003e uses \u003ccode\u003e256Kb\u003c/code\u003e. So for example a network server with 100\n concurrent compressed streams would use \u003ccode\u003e25Mb\u003c/code\u003e. The memory per stream can be\n halved (at the cost of somewhat degraded and slower compressionby) by\n reducing the \u003ccode\u003ewindowBits\u003c/code\u003e and \u003ccode\u003ememLevel\u003c/code\u003e by one.\n\u003c/p\u003e\u003cp\u003eDecompression takes less memory, the default \u003ccode\u003ewindowBits = 15\u003c/code\u003e corresponds\n to just \u003ccode\u003e32Kb\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "MemoryLevel",
          "package": "lens",
          "type": "data"
        },
        "index": {
          "description": "The MemoryLevel parameter specifies how much memory should be allocated for the internal compression state It is tradoff between memory usage compression ratio and compression speed Using more memory allows faster compression and better compression ratio The total amount of memory used for compression depends on the WindowBits and the MemoryLevel For decompression it depends only on the WindowBits The totals are given by the functions compressTotal windowBits memLevel windowBits memLevel decompressTotal windowBits windowBits For example for compression with the default windowBits and memLevel uses Kb So for example network server with concurrent compressed streams would use Mb The memory per stream can be halved at the cost of somewhat degraded and slower compressionby by reducing the windowBits and memLevel by one Decompression takes less memory the default windowBits corresponds to just Kb",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "MemoryLevel",
          "package": "lens",
          "partial": "Memory Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:MemoryLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe compression method\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Method",
          "package": "lens",
          "type": "data"
        },
        "index": {
          "description": "The compression method",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Method",
          "package": "lens",
          "partial": "Method",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:Method"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe advanced parameters needed by \u003ccode\u003e\u003ca\u003egzipped'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ezlibbed'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edeflated'\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003ecompressed'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eUse \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e and the provided \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003ees to construct custom \u003ccode\u003e\u003ca\u003eParams\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Params",
          "package": "lens",
          "source": "src/Codec-Compression-Zlib-Lens.html#Params",
          "type": "data"
        },
        "index": {
          "description": "The advanced parameters needed by gzipped zlibbed deflated and compressed Use defaultParams and the provided Lens es to construct custom Params",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "Params",
          "package": "lens",
          "partial": "Params",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:Params"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis specifies the size of the compression window. Larger values of this\n parameter result in better compression at the expense of higher memory\n usage.\n\u003c/p\u003e\u003cp\u003eThe compression window size is the value of the the window bits raised to\n the power 2. The window bits must be in the range \u003ccode\u003e8..15\u003c/code\u003e which corresponds\n to compression window sizes of 256b to 32Kb. The default is 15 which is also\n the maximum size.\n\u003c/p\u003e\u003cp\u003eThe total amount of memory used depends on the window bits and the\n \u003ccode\u003e\u003ca\u003eMemoryLevel\u003c/a\u003e\u003c/code\u003e. See the \u003ccode\u003e\u003ca\u003eMemoryLevel\u003c/a\u003e\u003c/code\u003e for the details.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "WindowBits",
          "package": "lens",
          "type": "data"
        },
        "index": {
          "description": "This specifies the size of the compression window Larger values of this parameter result in better compression at the expense of higher memory usage The compression window size is the value of the the window bits raised to the power The window bits must be in the range which corresponds to compression window sizes of to Kb The default is which is also the maximum size The total amount of memory used depends on the window bits and the MemoryLevel See the MemoryLevel for the details",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "WindowBits",
          "package": "lens",
          "partial": "Window Bits",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#t:WindowBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe slowest compression method (best compression).\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bestCompression",
          "package": "lens",
          "signature": "CompressionLevel",
          "type": "function"
        },
        "index": {
          "description": "The slowest compression method best compression",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bestCompression",
          "package": "lens",
          "partial": "Compression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:bestCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe fastest compression method (less compression)\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bestSpeed",
          "package": "lens",
          "signature": "CompressionLevel",
          "type": "function"
        },
        "index": {
          "description": "The fastest compression method less compression",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bestSpeed",
          "package": "lens",
          "partial": "Speed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:bestSpeed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe initial buffer size during compression.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bufferSizeC",
          "package": "lens",
          "signature": "Lens' Params Int",
          "source": "src/Codec-Compression-Zlib-Lens.html#bufferSizeC",
          "type": "function"
        },
        "index": {
          "description": "The initial buffer size during compression",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bufferSizeC",
          "package": "lens",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:bufferSizeC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe initial buffer size during decompression.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bufferSizeD",
          "package": "lens",
          "signature": "Lens' Params Int",
          "source": "src/Codec-Compression-Zlib-Lens.html#bufferSizeD",
          "type": "function"
        },
        "index": {
          "description": "The initial buffer size during decompression",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "bufferSizeD",
          "package": "lens",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:bufferSizeD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the given compression format.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e fmt = \u003ccode\u003e\u003ca\u003ecompressed'\u003c/a\u003e\u003c/code\u003e fmt \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "compressed",
          "package": "lens",
          "signature": "Format -\u003e Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#compressed",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the given compression format compressed fmt compressed fmt defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "compressed",
          "normalized": "Format-\u003eIso' ByteString ByteString",
          "package": "lens",
          "signature": "Format-\u003eIso' ByteString ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:compressed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the given compression format and the given advanced parameters.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "compressed'",
          "package": "lens",
          "signature": "Format -\u003e Params -\u003e Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#compressed%27",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the given compression format and the given advanced parameters",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "compressed'",
          "normalized": "Format-\u003eParams-\u003eIso' ByteString ByteString",
          "package": "lens",
          "signature": "Format-\u003eParams-\u003eIso' ByteString ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:compressed-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specific compression level between 0 and 9.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "compressionLevel",
          "package": "lens",
          "signature": "Int -\u003e CompressionLevel",
          "type": "function"
        },
        "index": {
          "description": "specific compression level between and",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "compressionLevel",
          "normalized": "Int-\u003eCompressionLevel",
          "package": "lens",
          "partial": "Level",
          "signature": "Int-\u003eCompressionLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:compressionLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default compression level is 6 (that is, biased towards higher\n compression at expense of speed).\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultCompression",
          "package": "lens",
          "signature": "CompressionLevel",
          "type": "function"
        },
        "index": {
          "description": "The default compression level is that is biased towards higher compression at expense of speed",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultCompression",
          "package": "lens",
          "partial": "Compression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:defaultCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default memory level. (Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ememoryLevel\u003c/a\u003e\u003c/code\u003e 8\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultMemoryLevel",
          "package": "lens",
          "signature": "MemoryLevel",
          "type": "function"
        },
        "index": {
          "description": "The default memory level Equivalent to memoryLevel",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultMemoryLevel",
          "package": "lens",
          "partial": "Memory Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:defaultMemoryLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default advanced parameters for compression and decompression.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultParams",
          "package": "lens",
          "signature": "Params",
          "source": "src/Codec-Compression-Zlib-Lens.html#defaultParams",
          "type": "function"
        },
        "index": {
          "description": "The default advanced parameters for compression and decompression",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultParams",
          "package": "lens",
          "partial": "Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:defaultParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse this default compression strategy for normal data.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultStrategy",
          "package": "lens",
          "signature": "CompressionStrategy",
          "type": "function"
        },
        "index": {
          "description": "Use this default compression strategy for normal data",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultStrategy",
          "package": "lens",
          "partial": "Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:defaultStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default \u003ccode\u003e\u003ca\u003eWindowBits\u003c/a\u003e\u003c/code\u003e is 15 which is also the maximum size.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultWindowBits",
          "package": "lens",
          "signature": "WindowBits",
          "type": "function"
        },
        "index": {
          "description": "The default WindowBits is which is also the maximum size",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "defaultWindowBits",
          "package": "lens",
          "partial": "Window Bits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:defaultWindowBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edeflate\u003c/a\u003e\u003c/code\u003e compression format.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflate",
          "package": "lens",
          "signature": "Format",
          "source": "src/Codec-Compression-Zlib-Lens.html#deflate",
          "type": "function"
        },
        "index": {
          "description": "The deflate compression format",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflate",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:deflate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e'Deflate' is the only method supported in this version of zlib.\n Indeed it is likely to be the only method that ever will be supported.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflateMethod",
          "package": "lens",
          "signature": "Method",
          "type": "function"
        },
        "index": {
          "description": "Deflate is the only method supported in this version of zlib Indeed it is likely to be the only method that ever will be supported",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflateMethod",
          "package": "lens",
          "partial": "Method",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:deflateMethod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003edeflate\u003c/a\u003e\u003c/code\u003e compression format.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edeflated\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edeflate\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edeflated\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003edeflated'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflated",
          "package": "lens",
          "signature": "Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#deflated",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the deflate compression format deflated compressed deflate deflated deflated defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflated",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:deflated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003edeflate\u003c/a\u003e\u003c/code\u003e compression format and the given advanced parameters.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edeflated\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edeflate\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003edeflated\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003edeflated'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflated'",
          "package": "lens",
          "signature": "Params -\u003e Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#deflated%27",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the deflate compression format and the given advanced parameters deflated compressed deflate deflated deflated defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "deflated'",
          "normalized": "Params-\u003eIso' ByteString ByteString",
          "package": "lens",
          "signature": "Params-\u003eIso' ByteString ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:deflated-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the custom (de)compression dictionary to use, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e to not use a custom dictionary.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "dictionary",
          "package": "lens",
          "signature": "Lens' Params (Maybe ByteString)",
          "source": "src/Codec-Compression-Zlib-Lens.html#dictionary",
          "type": "function"
        },
        "index": {
          "description": "Just the custom de compression dictionary to use or Nothing to not use custom dictionary",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "dictionary",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:dictionary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the filtered compression strategy for data produced by a filter (or\n predictor). Filtered data consists mostly of small values with a somewhat\n random distribution. In this case, the compression algorithm is tuned to\n compress them better. The effect of this strategy is to force more Huffman\n coding and less string matching; it is somewhat intermediate between\n \u003ccode\u003edefaultCompressionStrategy\u003c/code\u003e and \u003ccode\u003ehuffmanOnlyCompressionStrategy\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "filteredStrategy",
          "package": "lens",
          "signature": "CompressionStrategy",
          "type": "function"
        },
        "index": {
          "description": "Use the filtered compression strategy for data produced by filter or predictor Filtered data consists mostly of small values with somewhat random distribution In this case the compression algorithm is tuned to compress them better The effect of this strategy is to force more Huffman coding and less string matching it is somewhat intermediate between defaultCompressionStrategy and huffmanOnlyCompressionStrategy",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "filteredStrategy",
          "package": "lens",
          "partial": "Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:filteredStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003egzip\u003c/a\u003e\u003c/code\u003e compression format.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "gzip",
          "package": "lens",
          "signature": "Format",
          "source": "src/Codec-Compression-Zlib-Lens.html#gzip",
          "type": "function"
        },
        "index": {
          "description": "The gzip compression format",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "gzip",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:gzip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003egzip\u003c/a\u003e\u003c/code\u003e compression format.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003egzipped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003egzip\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003egzipped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003egzipped'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "gzipped",
          "package": "lens",
          "signature": "Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#gzipped",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the gzip compression format gzipped compressed gzip gzipped gzipped defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "gzipped",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:gzipped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003egzip\u003c/a\u003e\u003c/code\u003e compression format and the given advanced parameters.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003egzipped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003egzip\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003egzipped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003egzipped'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "gzipped'",
          "package": "lens",
          "signature": "Params -\u003e Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#gzipped%27",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the gzip compression format and the given advanced parameters gzipped compressed gzip gzipped gzipped defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "gzipped'",
          "normalized": "Params-\u003eIso' ByteString ByteString",
          "package": "lens",
          "signature": "Params-\u003eIso' ByteString ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:gzipped-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the Huffman-only compression strategy to force Huffman encoding only\n (no string match).\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "huffmanOnlyStrategy",
          "package": "lens",
          "signature": "CompressionStrategy",
          "type": "function"
        },
        "index": {
          "description": "Use the Huffman-only compression strategy to force Huffman encoding only no string match",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "huffmanOnlyStrategy",
          "package": "lens",
          "partial": "Only Strategy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:huffmanOnlyStrategy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe compression level.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "levelC",
          "package": "lens",
          "signature": "Lens' Params CompressionLevel",
          "source": "src/Codec-Compression-Zlib-Lens.html#levelC",
          "type": "function"
        },
        "index": {
          "description": "The compression level",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "levelC",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:levelC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse maximum memory for optimal compression speed.\n (Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ememoryLevel\u003c/a\u003e\u003c/code\u003e 9\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "maxMemoryLevel",
          "package": "lens",
          "signature": "MemoryLevel",
          "type": "function"
        },
        "index": {
          "description": "Use maximum memory for optimal compression speed Equivalent to memoryLevel",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "maxMemoryLevel",
          "package": "lens",
          "partial": "Memory Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:maxMemoryLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specific level in the range \u003ccode\u003e1..9\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "memoryLevel",
          "package": "lens",
          "signature": "Int -\u003e MemoryLevel",
          "type": "function"
        },
        "index": {
          "description": "specific level in the range",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "memoryLevel",
          "normalized": "Int-\u003eMemoryLevel",
          "package": "lens",
          "partial": "Level",
          "signature": "Int-\u003eMemoryLevel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:memoryLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe amount of memory allowed for the internal compression state.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "memoryLevelC",
          "package": "lens",
          "signature": "Lens' Params MemoryLevel",
          "source": "src/Codec-Compression-Zlib-Lens.html#memoryLevelC",
          "type": "function"
        },
        "index": {
          "description": "The amount of memory allowed for the internal compression state",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "memoryLevelC",
          "package": "lens",
          "partial": "Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:memoryLevelC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe compression method.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "methodC",
          "package": "lens",
          "signature": "Lens' Params Method",
          "source": "src/Codec-Compression-Zlib-Lens.html#methodC",
          "type": "function"
        },
        "index": {
          "description": "The compression method",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "methodC",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:methodC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse minimum memory. This is slow and reduces the compression ratio.\n (Equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ememoryLevel\u003c/a\u003e\u003c/code\u003e 1\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "minMemoryLevel",
          "package": "lens",
          "signature": "MemoryLevel",
          "type": "function"
        },
        "index": {
          "description": "Use minimum memory This is slow and reduces the compression ratio Equivalent to memoryLevel",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "minMemoryLevel",
          "package": "lens",
          "partial": "Memory Level",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:minMemoryLevel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo compression, just a block copy.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "noCompression",
          "package": "lens",
          "signature": "CompressionLevel",
          "type": "function"
        },
        "index": {
          "description": "No compression just block copy",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "noCompression",
          "package": "lens",
          "partial": "Compression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:noCompression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe compression strategy.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "strategyC",
          "package": "lens",
          "signature": "Lens' Params CompressionStrategy",
          "source": "src/Codec-Compression-Zlib-Lens.html#strategyC",
          "type": "function"
        },
        "index": {
          "description": "The compression strategy",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "strategyC",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:strategyC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specific compression window size, specified in bits in the range \u003ccode\u003e8..15\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "windowBits",
          "package": "lens",
          "signature": "Int -\u003e WindowBits",
          "type": "function"
        },
        "index": {
          "description": "specific compression window size specified in bits in the range",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "windowBits",
          "normalized": "Int-\u003eWindowBits",
          "package": "lens",
          "partial": "Bits",
          "signature": "Int-\u003eWindowBits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:windowBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of bits in the compression window.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "windowBitsC",
          "package": "lens",
          "signature": "Lens' Params WindowBits",
          "source": "src/Codec-Compression-Zlib-Lens.html#windowBitsC",
          "type": "function"
        },
        "index": {
          "description": "The number of bits in the compression window",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "windowBitsC",
          "package": "lens",
          "partial": "Bits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:windowBitsC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of bits in the decompression window.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "windowBitsD",
          "package": "lens",
          "signature": "Lens' Params WindowBits",
          "source": "src/Codec-Compression-Zlib-Lens.html#windowBitsD",
          "type": "function"
        },
        "index": {
          "description": "The number of bits in the decompression window",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "windowBitsD",
          "package": "lens",
          "partial": "Bits",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:windowBitsD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezlib\u003c/a\u003e\u003c/code\u003e compression format.\n\u003c/p\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "zlib",
          "package": "lens",
          "signature": "Format",
          "source": "src/Codec-Compression-Zlib-Lens.html#zlib",
          "type": "function"
        },
        "index": {
          "description": "The zlib compression format",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "zlib",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:zlib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003ezlib\u003c/a\u003e\u003c/code\u003e compression format.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ezlibbed\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ezlib\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ezlibbed\u003c/a\u003e\u003c/code\u003e = 'zlibbed\\'' \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "zlibbed",
          "package": "lens",
          "signature": "Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#zlibbed",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the zlib compression format zlibbed compressed zlib zlibbed zlibbed defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "zlibbed",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:zlibbed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompresses a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003ezlib\u003c/a\u003e\u003c/code\u003e compression format and the given advanced parameters.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ezlibbed\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ecompressed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ezlib\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ezlibbed\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ezlibbed'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultParams\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "zlibbed'",
          "package": "lens",
          "signature": "Params -\u003e Iso' ByteString ByteString",
          "source": "src/Codec-Compression-Zlib-Lens.html#zlibbed%27",
          "type": "function"
        },
        "index": {
          "description": "Compresses ByteString using the zlib compression format and the given advanced parameters zlibbed compressed zlib zlibbed zlibbed defaultParams",
          "hierarchy": "Codec Compression Zlib Lens",
          "module": "Codec.Compression.Zlib.Lens",
          "name": "zlibbed'",
          "normalized": "Params-\u003eIso' ByteString ByteString",
          "package": "lens",
          "signature": "Params-\u003eIso' ByteString ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Codec-Compression-Zlib-Lens.html#v:zlibbed-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003ccode\u003eControl.Exception\u003c/code\u003e provides an example of a large open hierarchy\n that we can model with prisms and isomorphisms.\n\u003c/p\u003e\u003cp\u003eAdditional combinators for working with \u003ccode\u003e\u003ca\u003eIOException\u003c/a\u003e\u003c/code\u003e results can\n be found in \u003ca\u003eSystem.IO.Error.Lens\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThe combinators in this module have been generalized to work with\n \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e instead of just \u003ccode\u003eIO\u003c/code\u003e. This enables them to be used\n more easily in \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stacks.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Exception.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Control.Exception provides an example of large open hierarchy that we can model with prisms and isomorphisms Additional combinators for working with IOException results can be found in System.IO.Error.Lens The combinators in this module have been generalized to work with MonadCatch instead of just IO This enables them to be used more easily in Monad transformer stacks",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArithmetic exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsArithException",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsArithException",
          "type": "class"
        },
        "index": {
          "description": "Arithmetic exceptions",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsArithException",
          "package": "lens",
          "partial": "As Arith Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsArithException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions generated by array operations.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsArrayException",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsArrayException",
          "type": "class"
        },
        "index": {
          "description": "Exceptions generated by array operations",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsArrayException",
          "package": "lens",
          "partial": "As Array Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsArrayException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eassert\u003c/a\u003e\u003c/code\u003e was applied to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsAssertionFailed",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsAssertionFailed",
          "type": "class"
        },
        "index": {
          "description": "assert was applied to False",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsAssertionFailed",
          "package": "lens",
          "partial": "As Assertion Failed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsAssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAsynchronous exceptions.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsAsyncException",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsAsyncException",
          "type": "class"
        },
        "index": {
          "description": "Asynchronous exceptions",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsAsyncException",
          "package": "lens",
          "partial": "As Async Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsAsyncException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is blocked on an \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e, but there\n are no other references to the \u003ccode\u003e\u003ca\u003eMVar\u003c/a\u003e\u003c/code\u003e so it can't\n ever continue.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsBlockedIndefinitelyOnMVar",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsBlockedIndefinitelyOnMVar",
          "type": "class"
        },
        "index": {
          "description": "The thread is blocked on an MVar but there are no other references to the MVar so it can ever continue",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsBlockedIndefinitelyOnMVar",
          "package": "lens",
          "partial": "As Blocked Indefinitely On MVar",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsBlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe thread is waiting to retry an \u003ccode\u003e\u003ca\u003eSTM\u003c/a\u003e\u003c/code\u003e transaction,\n but there are no other references to any TVars involved, so it can't ever\n continue.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsBlockedIndefinitelyOnSTM",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsBlockedIndefinitelyOnSTM",
          "type": "class"
        },
        "index": {
          "description": "The thread is waiting to retry an STM transaction but there are no other references to any TVars involved so it can ever continue",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsBlockedIndefinitelyOnSTM",
          "package": "lens",
          "partial": "As Blocked Indefinitely On STM",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsBlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are no runnable threads, so the program is deadlocked. The\n \u003ccode\u003e\u003ca\u003eDeadlock\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e is raised in the main thread only.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsDeadlock",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsDeadlock",
          "type": "class"
        },
        "index": {
          "description": "There are no runnable threads so the program is deadlocked The Deadlock Exception is raised in the main thread only",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsDeadlock",
          "package": "lens",
          "partial": "As Deadlock",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsDeadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is thrown when the user calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsErrorCall",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsErrorCall",
          "type": "class"
        },
        "index": {
          "description": "This is thrown when the user calls error",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsErrorCall",
          "package": "lens",
          "partial": "As Error Call",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e is thrown by \u003ccode\u003elens\u003c/code\u003e when the user somehow manages to rethrow\n an internal \u003ccode\u003e\u003ca\u003eHandlingException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsHandlingException",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsHandlingException",
          "type": "class"
        },
        "index": {
          "description": "This Exception is thrown by lens when the user somehow manages to rethrow an internal HandlingException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsHandlingException",
          "package": "lens",
          "partial": "As Handling Exception",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsHandlingException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExceptions that occur in the \u003ccode\u003eIO\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e. An \u003ccode\u003e\u003ca\u003eIOException\u003c/a\u003e\u003c/code\u003e records a\n more specific error type, a descriptive string and maybe the handle that was\n used when the error was flagged.\n\u003c/p\u003e\u003cp\u003eDue to their richer structure relative to other exceptions, these have\n a more carefully overloaded signature.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsIOException",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsIOException",
          "type": "class"
        },
        "index": {
          "description": "Exceptions that occur in the IO Monad An IOException records more specific error type descriptive string and maybe the handle that was used when the error was flagged Due to their richer structure relative to other exceptions these have more carefully overloaded signature",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsIOException",
          "package": "lens",
          "partial": "As IOException",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsIOException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the program attempts to call atomically, from the\n \u003ccode\u003e\u003ca\u003eSTM\u003c/a\u003e\u003c/code\u003e package, inside another call to atomically.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsNestedAtomically",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsNestedAtomically",
          "type": "class"
        },
        "index": {
          "description": "Thrown when the program attempts to call atomically from the STM package inside another call to atomically",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsNestedAtomically",
          "package": "lens",
          "partial": "As Nested Atomically",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsNestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class method without a definition (neither a default definition,\n nor a definition in the appropriate instance) was called.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsNoMethodError",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsNoMethodError",
          "type": "class"
        },
        "index": {
          "description": "class method without definition neither default definition nor definition in the appropriate instance was called",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsNoMethodError",
          "package": "lens",
          "partial": "As No Method Error",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsNoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when the runtime system detects that the computation is guaranteed\n not to terminate. Note that there is no guarantee that the runtime system\n will notice whether any given computation is guaranteed to terminate or not.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsNonTermination",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsNonTermination",
          "type": "class"
        },
        "index": {
          "description": "Thrown when the runtime system detects that the computation is guaranteed not to terminate Note that there is no guarantee that the runtime system will notice whether any given computation is guaranteed to terminate or not",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsNonTermination",
          "package": "lens",
          "partial": "As Non Termination",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsNonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern match failed.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsPatternMatchFail",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsPatternMatchFail",
          "type": "class"
        },
        "index": {
          "description": "pattern match failed",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsPatternMatchFail",
          "package": "lens",
          "partial": "As Pattern Match Fail",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsPatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn uninitialised record field was used.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsRecConError",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsRecConError",
          "type": "class"
        },
        "index": {
          "description": "An uninitialised record field was used",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsRecConError",
          "package": "lens",
          "partial": "As Rec Con Error",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsRecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record selector was applied to a constructor without the appropriate\n field. This can only happen with a datatype with multiple constructors,\n where some fields are in one constructor but not another.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsRecSelError",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsRecSelError",
          "type": "class"
        },
        "index": {
          "description": "record selector was applied to constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsRecSelError",
          "package": "lens",
          "partial": "As Rec Sel Error",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsRecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA record update was performed on a constructor without the\n appropriate field. This can only happen with a datatype with multiple\n constructors, where some fields are in one constructor but not another.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "AsRecUpdError",
          "package": "lens",
          "source": "src/Control-Exception-Lens.html#AsRecUpdError",
          "type": "class"
        },
        "index": {
          "description": "record update was performed on constructor without the appropriate field This can only happen with datatype with multiple constructors where some fields are in one constructor but not another",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "AsRecUpdError",
          "package": "lens",
          "partial": "As Rec Upd Error",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:AsRecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoth \u003ccode\u003eexceptions\u003c/code\u003e and \u003ca\u003eControl.Exception\u003c/a\u003e provide a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e\u003cp\u003eThis lets us write combinators to build handlers that are agnostic about the choice of\n which of these they use.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "Handleable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Exception.html#Handleable",
          "type": "class"
        },
        "index": {
          "description": "Both exceptions and Control.Exception provide Handler type This lets us write combinators to build handlers that are agnostic about the choice of which of these they use",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "Handleable",
          "package": "lens",
          "partial": "Handleable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#t:Handleable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Exception.Lens",
          "name": "_ArithException",
          "package": "lens",
          "signature": "Prism' t ArithException",
          "source": "src/Control-Exception-Lens.html#_ArithException",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_ArithException",
          "package": "lens",
          "partial": "Arith Exception",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_ArithException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract information about an \u003ccode\u003e\u003ca\u003eArrayException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_ArrayException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArrayException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArrayException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_ArrayException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArrayException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_ArrayException",
          "package": "lens",
          "signature": "Prism' t ArrayException",
          "source": "src/Control-Exception-Lens.html#_ArrayException",
          "type": "method"
        },
        "index": {
          "description": "Extract information about an ArrayException ArrayException Prism ArrayException ArrayException ArrayException Prism SomeException ArrayException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_ArrayException",
          "package": "lens",
          "partial": "Array Exception",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_ArrayException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e contains provides information about what assertion failed in the \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehandling _AssertionFailed (\\ xs -\u003e \"caught\" \u003c$ guard (\"\u003cinteractive\u003e\" `isInfixOf` xs) ) $ assert False (return \"uncaught\")\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_AssertionFailed\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAssertionFailed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_AssertionFailed\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e   \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_AssertionFailed",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_AssertionFailed",
          "type": "method"
        },
        "index": {
          "description": "This Exception contains provides information about what assertion failed in the String handling AssertionFailed xs caught guard interactive isInfixOf xs assert False return uncaught caught AssertionFailed Prism AssertionFailed String AssertionFailed Prism SomeException String",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_AssertionFailed",
          "package": "lens",
          "partial": "Assertion Failed",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_AssertionFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere are several types of \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_AsyncException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEquality'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_AsyncException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e    \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_AsyncException",
          "package": "lens",
          "signature": "Prism' t AsyncException",
          "source": "src/Control-Exception-Lens.html#_AsyncException",
          "type": "method"
        },
        "index": {
          "description": "There are several types of AsyncException AsyncException Equality AsyncException AsyncException AsyncException Prism SomeException AsyncException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_AsyncException",
          "package": "lens",
          "partial": "Async Exception",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_AsyncException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no additional information carried in a \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnMVar\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_BlockedIndefinitelyOnMVar\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnMVar\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_BlockedIndefinitelyOnMVar\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e             ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_BlockedIndefinitelyOnMVar",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_BlockedIndefinitelyOnMVar",
          "type": "method"
        },
        "index": {
          "description": "There is no additional information carried in BlockedIndefinitelyOnMVar Exception BlockedIndefinitelyOnMVar Prism BlockedIndefinitelyOnMVar BlockedIndefinitelyOnMVar Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_BlockedIndefinitelyOnMVar",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Blocked Indefinitely On MVar",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_BlockedIndefinitelyOnMVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no additional information carried in a \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnSTM\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_BlockedIndefinitelyOnSTM\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eBlockedIndefinitelyOnSTM\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_BlockedIndefinitelyOnSTM\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e            ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_BlockedIndefinitelyOnSTM",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_BlockedIndefinitelyOnSTM",
          "type": "method"
        },
        "index": {
          "description": "There is no additional information carried in BlockedIndefinitelyOnSTM Exception BlockedIndefinitelyOnSTM Prism BlockedIndefinitelyOnSTM BlockedIndefinitelyOnSTM Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_BlockedIndefinitelyOnSTM",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Blocked Indefinitely On STM",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_BlockedIndefinitelyOnSTM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no information carried in a \u003ccode\u003e\u003ca\u003eDeadlock\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Deadlock\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDeadlock\u003c/a\u003e\u003c/code\u003e      ()\n \u003ccode\u003e\u003ca\u003e_Deadlock\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_Deadlock",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_Deadlock",
          "type": "method"
        },
        "index": {
          "description": "There is no information carried in Deadlock Exception Deadlock Prism Deadlock Deadlock Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_Deadlock",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Deadlock",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_Deadlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle exceptional _Denormalized floating pure.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Denormal\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Denormal\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Denormal\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_Denormal\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_Denormal",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_Denormal",
          "type": "function"
        },
        "index": {
          "description": "Handle exceptional Denormalized floating pure Denormal ArithException Denormal Denormal Prism ArithException ArithException Denormal Prism SomeException ArithException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_Denormal",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Denormal",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_Denormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle division by zero.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_DivideByZero\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_DivideByZero\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_DivideByZero\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_DivideByZero\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_DivideByZero",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_DivideByZero",
          "type": "function"
        },
        "index": {
          "description": "Handle division by zero DivideByZero ArithException DivideByZero DivideByZero Prism ArithException ArithException DivideByZero Prism SomeException ArithException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_DivideByZero",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Divide By Zero",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_DivideByZero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the argument given to \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eErrorCall\u003c/a\u003e\u003c/code\u003e is isomorphic to a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecatching _ErrorCall (error \"touch down!\") return\n\u003c/code\u003e\u003c/strong\u003e\"touch down!\"\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_ErrorCall",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_ErrorCall",
          "type": "method"
        },
        "index": {
          "description": "Retrieve the argument given to error ErrorCall is isomorphic to String catching ErrorCall error touch down return touch down",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_ErrorCall",
          "package": "lens",
          "partial": "Error Call",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_ErrorCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no information carried in a \u003ccode\u003e\u003ca\u003eHandlingException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_HandlingException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eHandlingException\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_HandlingException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e     ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_HandlingException",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_HandlingException",
          "type": "method"
        },
        "index": {
          "description": "There is no information carried in HandlingException HandlingException Prism HandlingException HandlingException Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_HandlingException",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Handling Exception",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_HandlingException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe program's heap is reaching its limit, and the program should take action\n to reduce the amount of live data it has.\n\u003c/p\u003e\u003cp\u003eNotes:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e It is undefined which thread receives this \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e GHC currently does not throw \u003ccode\u003e\u003ca\u003eHeapOverflow\u003c/a\u003e\u003c/code\u003e exceptions.\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_HeapOverflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_HeapOverflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_HeapOverflow",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_HeapOverflow",
          "type": "function"
        },
        "index": {
          "description": "The program heap is reaching its limit and the program should take action to reduce the amount of live data it has Notes It is undefined which thread receives this Exception GHC currently does not throw HeapOverflow exceptions HeapOverflow Prism AsyncException HeapOverflow Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_HeapOverflow",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Heap Overflow",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_HeapOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnfortunately the name \u003ccode\u003eioException\u003c/code\u003e is taken by \u003ccode\u003ebase\u003c/code\u003e for\n throwing IOExceptions.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_IOException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIOException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIOException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_IOException\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIOException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eMany combinators for working with an \u003ccode\u003e\u003ca\u003eIOException\u003c/a\u003e\u003c/code\u003e are available\n in \u003ca\u003eSystem.IO.Error.Lens\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "_IOException",
          "package": "lens",
          "signature": "Prism' t IOException",
          "source": "src/Control-Exception-Lens.html#_IOException",
          "type": "method"
        },
        "index": {
          "description": "Unfortunately the name ioException is taken by base for throwing IOExceptions IOException Prism IOException IOException IOException Prism SomeException IOException Many combinators for working with an IOException are available in System.IO.Error.Lens",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_IOException",
          "package": "lens",
          "partial": "IOException",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_IOException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt was made to index an array outside its declared bounds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_IndexOutOfBounds\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArrayException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_IndexOutOfBounds\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_IndexOutOfBounds\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArrayException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_IndexOutOfBounds\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_IndexOutOfBounds",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_IndexOutOfBounds",
          "type": "function"
        },
        "index": {
          "description": "An attempt was made to index an array outside its declared bounds IndexOutOfBounds ArrayException IndexOutOfBounds IndexOutOfBounds Prism ArrayException String IndexOutOfBounds Prism SomeException String",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_IndexOutOfBounds",
          "package": "lens",
          "partial": "Index Out Of Bounds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_IndexOutOfBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle arithmetic loss of precision.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_LossOfPrecision\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_LossOfPrecision\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_LossOfPrecision\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_LossOfPrecision\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_LossOfPrecision",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_LossOfPrecision",
          "type": "function"
        },
        "index": {
          "description": "Handle arithmetic loss of precision LossOfPrecision ArithException LossOfPrecision LossOfPrecision Prism ArithException ArithException LossOfPrecision Prism SomeException ArithException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_LossOfPrecision",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Loss Of Precision",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_LossOfPrecision"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no additional information carried in a \u003ccode\u003e\u003ca\u003eNestedAtomically\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_NestedAtomically\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNestedAtomically\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_NestedAtomically\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e    ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_NestedAtomically",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_NestedAtomically",
          "type": "method"
        },
        "index": {
          "description": "There is no additional information carried in NestedAtomically Exception NestedAtomically Prism NestedAtomically NestedAtomically Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_NestedAtomically",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Nested Atomically",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_NestedAtomically"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a description of the missing method.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_NoMethodError\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNoMethodError\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_NoMethodError\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_NoMethodError",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_NoMethodError",
          "type": "method"
        },
        "index": {
          "description": "Extract description of the missing method NoMethodError Prism NoMethodError String NoMethodError Prism SomeException String",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_NoMethodError",
          "package": "lens",
          "partial": "No Method Error",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_NoMethodError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is no additional information carried in a \u003ccode\u003e\u003ca\u003eNonTermination\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_NonTermination\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNonTermination\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_NonTermination\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_NonTermination",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_NonTermination",
          "type": "method"
        },
        "index": {
          "description": "There is no additional information carried in NonTermination Exception NonTermination Prism NonTermination NonTermination Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_NonTermination",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Non Termination",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_NonTermination"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle arithmetic \u003ccode\u003e\u003ca\u003e_Overflow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Overflow\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Overflow\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Overflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_Overflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_Overflow",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_Overflow",
          "type": "function"
        },
        "index": {
          "description": "Handle arithmetic Overflow Overflow ArithException Overflow Overflow Prism ArithException ArithException Overflow Prism SomeException ArithException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_Overflow",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Overflow",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_Overflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInformation about the source location of the pattern.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_PatternMatchFail\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ePatternMatchFail\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_PatternMatchFail\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e    \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_PatternMatchFail",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_PatternMatchFail",
          "type": "method"
        },
        "index": {
          "description": "Information about the source location of the pattern PatternMatchFail Prism PatternMatchFail String PatternMatchFail Prism SomeException String",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_PatternMatchFail",
          "package": "lens",
          "partial": "Pattern Match Fail",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_PatternMatchFail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdded in \u003ccode\u003ebase\u003c/code\u003e 4.6 in response to this libraries discussion:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://haskell.1045720.n5.nabble.com/Data-Ratio-and-exceptions-td5711246.html\u003c/a\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_RatioZeroDenominator\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_RatioZeroDenominator\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_RatioZeroDenominator\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_RatioZeroDenominator\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_RatioZeroDenominator",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_RatioZeroDenominator",
          "type": "function"
        },
        "index": {
          "description": "Added in base in response to this libraries discussion http haskell.1045720.n5.nabble.com Data-Ratio-and-exceptions-td5711246.html RatioZeroDenominator ArithException RatioZeroDenominator RatioZeroDenominator Prism ArithException ArithException RatioZeroDenominator Prism SomeException ArithException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_RatioZeroDenominator",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Ratio Zero Denominator",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_RatioZeroDenominator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInformation about the source location where the record was\n constructed.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_RecConError\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eRecConError\u003c/a\u003e\u003c/code\u003e   \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_RecConError\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_RecConError",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_RecConError",
          "type": "method"
        },
        "index": {
          "description": "Information about the source location where the record was constructed RecConError Prism RecConError String RecConError Prism SomeException String",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_RecConError",
          "package": "lens",
          "partial": "Rec Con Error",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_RecConError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInformation about the source location where the record selection occurred.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "_RecSelError",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_RecSelError",
          "type": "method"
        },
        "index": {
          "description": "Information about the source location where the record selection occurred",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_RecSelError",
          "package": "lens",
          "partial": "Rec Sel Error",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_RecSelError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInformation about the source location where the record was updated.\n\u003c/p\u003e",
          "module": "Control.Exception.Lens",
          "name": "_RecUpdError",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_RecUpdError",
          "type": "method"
        },
        "index": {
          "description": "Information about the source location where the record was updated",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_RecUpdError",
          "package": "lens",
          "partial": "Rec Upd Error",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_RecUpdError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe current thread's stack exceeded its limit. Since an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e has\n been raised, the thread's stack will certainly be below its limit again,\n but the programmer should take remedial action immediately.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_StackOverflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_StackOverflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_StackOverflow",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_StackOverflow",
          "type": "function"
        },
        "index": {
          "description": "The current thread stack exceeded its limit Since an Exception has been raised the thread stack will certainly be below its limit again but the programmer should take remedial action immediately StackOverflow Prism AsyncException StackOverflow Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_StackOverflow",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Stack Overflow",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_StackOverflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e is raised by another thread calling\n \u003ccode\u003e\u003ca\u003ekillThread\u003c/a\u003e\u003c/code\u003e, or by the system if it needs to terminate\n the thread for some reason.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_ThreadKilled\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_ThreadKilled\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_ThreadKilled",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_ThreadKilled",
          "type": "function"
        },
        "index": {
          "description": "This Exception is raised by another thread calling killThread or by the system if it needs to terminate the thread for some reason ThreadKilled Prism AsyncException ThreadKilled Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_ThreadKilled",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Thread Killed",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_ThreadKilled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn attempt was made to evaluate an element of an array that had not been initialized.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_UndefinedElement\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArrayException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_UndefinedElement\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_UndefinedElement\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArrayException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_UndefinedElement\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_UndefinedElement",
          "package": "lens",
          "signature": "Prism' t String",
          "source": "src/Control-Exception-Lens.html#_UndefinedElement",
          "type": "function"
        },
        "index": {
          "description": "An attempt was made to evaluate an element of an array that had not been initialized UndefinedElement ArrayException UndefinedElement UndefinedElement Prism ArrayException String UndefinedElement Prism SomeException String",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_UndefinedElement",
          "package": "lens",
          "partial": "Undefined Element",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_UndefinedElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle arithmetic \u003ccode\u003e\u003ca\u003e_Underflow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Underflow\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003e_ArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Underflow\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Underflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_Underflow\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003eArithException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_Underflow",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_Underflow",
          "type": "function"
        },
        "index": {
          "description": "Handle arithmetic Underflow Underflow ArithException Underflow Underflow Prism ArithException ArithException Underflow Prism SomeException ArithException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_Underflow",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Underflow",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_Underflow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e is raised by default in the main thread of the program when\n the user requests to terminate the program via the usual mechanism(s)\n (\u003cem\u003ee.g.\u003c/em\u003e Control-C in the console).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_UserInterrupt\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAsyncException\u003c/a\u003e\u003c/code\u003e ()\n \u003ccode\u003e\u003ca\u003e_UserInterrupt\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e  ()\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "_UserInterrupt",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Control-Exception-Lens.html#_UserInterrupt",
          "type": "function"
        },
        "index": {
          "description": "This Exception is raised by default in the main thread of the program when the user requests to terminate the program via the usual mechanism e.g Control-C in the console UserInterrupt Prism AsyncException UserInterrupt Prism SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "_UserInterrupt",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "User Interrupt",
          "signature": "Prism' t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:_UserInterrupt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatch exceptions that match a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecatching _AssertionFailed (assert False (return \"uncaught\")) $ \\ _ -\u003e return \"caught\"\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a      -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "catching",
          "package": "lens",
          "signature": "Getting (First a) SomeException a -\u003e m r -\u003e (a -\u003e m r) -\u003e m r",
          "source": "src/Control-Exception-Lens.html#catching",
          "type": "function"
        },
        "index": {
          "description": "Catch exceptions that match given Prism or any Getter really catching AssertionFailed assert False return uncaught return caught caught catching MonadCatch Prism SomeException catching MonadCatch Lens SomeException catching MonadCatch Traversal SomeException catching MonadCatch Iso SomeException catching MonadCatch Getter SomeException catching MonadCatch Fold SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "catching",
          "normalized": "Getting(First a)SomeException a-\u003eb c-\u003e(a-\u003eb c)-\u003eb c",
          "package": "lens",
          "signature": "Getting(First a)SomeException a-\u003em r-\u003e(a-\u003em r)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:catching"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatch exceptions that match a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e), discarding\n the information about the match. This is particuarly useful when you have\n a \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e ()\u003c/code\u003e where the result of the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e isn't\n particularly valuable, just the fact that it matches.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ecatching_ _AssertionFailed (assert False (return \"uncaught\")) $ return \"caught\"\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a      -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e m r -\u003e m r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "catching_",
          "package": "lens",
          "signature": "Getting (First a) SomeException a -\u003e m r -\u003e m r -\u003e m r",
          "source": "src/Control-Exception-Lens.html#catching_",
          "type": "function"
        },
        "index": {
          "description": "Catch exceptions that match given Prism or any Getter discarding the information about the match This is particuarly useful when you have Prism where the result of the Prism or Fold isn particularly valuable just the fact that it matches catching AssertionFailed assert False return uncaught return caught caught catching MonadCatch Prism SomeException catching MonadCatch Lens SomeException catching MonadCatch Traversal SomeException catching MonadCatch Iso SomeException catching MonadCatch Getter SomeException catching MonadCatch Fold SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "catching_",
          "normalized": "Getting(First a)SomeException a-\u003eb c-\u003eb c-\u003eb c",
          "package": "lens",
          "signature": "Getting(First a)SomeException a-\u003em r-\u003em r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:catching_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the strongly typed \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e contained in \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e where the type of your function matches\n the desired \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eexception\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f, \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e a)\n           =\u003e (a -\u003e f a) -\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e -\u003e f \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "exception",
          "package": "lens",
          "signature": "Prism' SomeException a",
          "source": "src/Control-Exception-Lens.html#exception",
          "type": "function"
        },
        "index": {
          "description": "Traverse the strongly typed Exception contained in SomeException where the type of your function matches the desired Exception exception Applicative Exception SomeException SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "exception",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:exception"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis builds a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e for just the targets of a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e ... [ \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_AssertionFailed\u003c/a\u003e\u003c/code\u003e (s -\u003e \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \"Assertion Failed\\n\" \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e s)\n             , \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_ErrorCall\u003c/a\u003e\u003c/code\u003e (s -\u003e \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \"Error\\n\" \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e s)\n             ]\n\u003c/pre\u003e\u003cp\u003eThis works ith both the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Exception\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Catch\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Error.Lens\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "handler",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e (a -\u003e m r) -\u003e h r",
          "source": "src/Control-Lens-Internal-Exception.html#handler",
          "type": "method"
        },
        "index": {
          "description": "This builds Handler for just the targets of given Prism or any Getter really catches handler AssertionFailed print Assertion Failed handler ErrorCall print Error This works ith both the Handler type provided by Control.Exception handler Getter SomeException IO Handler handler Fold SomeException IO Handler handler Prism SomeException IO Handler handler Lens SomeException IO Handler handler Traversal SomeException IO Handler and with the Handler type provided by Control.Monad.Catch handler Getter SomeException Handler handler Fold SomeException Handler handler Prism SomeException Handler handler Lens SomeException Handler handler Traversal SomeException Handler and with the Handler type provided by Control.Monad.Error.Lens handler Getter Handler handler Fold Handler handler Prism Handler handler Lens Handler handler Traversal Handler",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "handler",
          "normalized": "Getting(First a)b a-\u003e(a-\u003ec d)-\u003ee d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003e(a-\u003em r)-\u003eh r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis builds a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e for just the targets of a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n that ignores its input and just recovers with the stated monadic action.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e ... [ \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_NonTermination\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e \"looped\")\n             , \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_StackOverflow\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e \"overflow\")\n             ]\n\u003c/pre\u003e\u003cp\u003eThis works with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Exception\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Catch\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Error.Lens\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "handler_",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e h r",
          "source": "src/Control-Lens-Internal-Exception.html#handler_",
          "type": "method"
        },
        "index": {
          "description": "This builds Handler for just the targets of given Prism or any Getter really that ignores its input and just recovers with the stated monadic action catches handler NonTermination return looped handler StackOverflow return overflow This works with the Handler type provided by Control.Exception handler Getter SomeException IO Handler handler Fold SomeException IO Handler handler Prism SomeException IO Handler handler Lens SomeException IO Handler handler Traversal SomeException IO Handler and with the Handler type provided by Control.Monad.Catch handler Getter SomeException Handler handler Fold SomeException Handler handler Prism SomeException Handler handler Lens SomeException Handler handler Traversal SomeException Handler and with the Handler type provided by Control.Monad.Error.Lens handler Getter Handler handler Fold Handler handler Prism Handler handler Lens Handler handler Traversal Handler",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "handler_",
          "normalized": "Getting(First a)b a-\u003ec d-\u003ee d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003eh r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:handler_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e with the arguments swapped around; useful in\n situations where the code for the handler is shorter.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehandling _NonTermination (\\_ -\u003e return \"caught\") $ throwIO NonTermination\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a      -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "handling",
          "package": "lens",
          "signature": "Getting (First a) SomeException a -\u003e (a -\u003e m r) -\u003e m r -\u003e m r",
          "source": "src/Control-Exception-Lens.html#handling",
          "type": "function"
        },
        "index": {
          "description": "version of catching with the arguments swapped around useful in situations where the code for the handler is shorter handling NonTermination return caught throwIO NonTermination caught handling MonadCatch Prism SomeException handling MonadCatch Lens SomeException handling MonadCatch Traversal SomeException handling MonadCatch Iso SomeException handling MonadCatch Fold SomeException handling MonadCatch Getter SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "handling",
          "normalized": "Getting(First a)SomeException a-\u003e(a-\u003eb c)-\u003eb c-\u003eb c",
          "package": "lens",
          "signature": "Getting(First a)SomeException a-\u003e(a-\u003em r)-\u003em r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:handling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e with the arguments swapped around; useful in\n situations where the code for the handler is shorter.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehandling_ _NonTermination (return \"caught\") $ throwIO NonTermination\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a      -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a       -\u003e m r -\u003e m r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "handling_",
          "package": "lens",
          "signature": "Getting (First a) SomeException a -\u003e m r -\u003e m r -\u003e m r",
          "source": "src/Control-Exception-Lens.html#handling_",
          "type": "function"
        },
        "index": {
          "description": "version of catching with the arguments swapped around useful in situations where the code for the handler is shorter handling NonTermination return caught throwIO NonTermination caught handling MonadCatch Prism SomeException handling MonadCatch Lens SomeException handling MonadCatch Traversal SomeException handling MonadCatch Iso SomeException handling MonadCatch Getter SomeException handling MonadCatch Fold SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "handling_",
          "normalized": "Getting(First a)SomeException a-\u003eb c-\u003eb c-\u003eb c",
          "package": "lens",
          "signature": "Getting(First a)SomeException a-\u003em r-\u003em r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:handling_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to purely map over the \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003es an\n arbitrary expression might throw; it is a variant of \u003ccode\u003e\u003ca\u003emapException\u003c/a\u003e\u003c/code\u003e in\n the same way that \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e 'mapException' &#8801; 'over' 'mappedException'\n\u003c/pre\u003e\u003cp\u003eThis view that every Haskell expression can be regarded as carrying a bag\n of \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003es is detailed in &#8220;A Semantics for Imprecise Exceptions&#8221; by\n Peyton Jones & al. at PLDI &#8217;99.\n\u003c/p\u003e\u003cp\u003eThe following maps failed assertions to arithmetic overflow:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehandling _Overflow (\\_ -\u003e return \"caught\") $ assert False (return \"uncaught\") & mappedException %~ \\ (AssertionFailed _) -\u003e Overflow\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "mappedException",
          "package": "lens",
          "signature": "Setter s s e e'",
          "source": "src/Control-Exception-Lens.html#mappedException",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to purely map over the Exception an arbitrary expression might throw it is variant of mapException in the same way that mapped is variant of fmap mapException over mappedException This view that every Haskell expression can be regarded as carrying bag of Exception is detailed in Semantics for Imprecise Exceptions by Peyton Jones al at PLDI The following maps failed assertions to arithmetic overflow handling Overflow return caught assert False return uncaught mappedException AssertionFailed Overflow caught",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "mappedException",
          "package": "lens",
          "partial": "Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:mappedException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a type restricted version of \u003ccode\u003e\u003ca\u003emappedException\u003c/a\u003e\u003c/code\u003e, which avoids\n the type ambiguity in the input \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e when using \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe following maps any exception to arithmetic overflow:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehandling _Overflow (\\_ -\u003e return \"caught\") $ assert False (return \"uncaught\") & mappedException' .~ Overflow\n\u003c/code\u003e\u003c/strong\u003e\"caught\"\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "mappedException'",
          "package": "lens",
          "signature": "Setter s s SomeException e'",
          "source": "src/Control-Exception-Lens.html#mappedException%27",
          "type": "function"
        },
        "index": {
          "description": "This is type restricted version of mappedException which avoids the type ambiguity in the input Exception when using set The following maps any exception to arithmetic overflow handling Overflow return caught assert False return uncaught mappedException Overflow caught",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "mappedException'",
          "package": "lens",
          "partial": "Exception'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:mappedException-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e described by a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e. Exceptions may be thrown from\n purely functional code, but may only be caught within the \u003ccode\u003eIO\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e t -\u003e t -\u003e r\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e t   -\u003e t -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "throwing",
          "package": "lens",
          "signature": "AReview s SomeException a b -\u003e b -\u003e r",
          "source": "src/Control-Exception-Lens.html#throwing",
          "type": "function"
        },
        "index": {
          "description": "Throw an Exception described by Prism Exceptions may be thrown from purely functional code but may only be caught within the IO Monad throwing reviews throw throwing Prism SomeException throwing Iso SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "throwing",
          "normalized": "AReview a SomeException b c-\u003ec-\u003ed",
          "package": "lens",
          "signature": "AReview s SomeException a b-\u003eb-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:throwing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e that can only be used within the \u003ccode\u003eIO\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e\n (or any other \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e instance) to throw an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e described\n by a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAlthough \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e has a type that is a specialization of the type of\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e, the two functions are subtly different:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e l e `seq` x  &#8801; \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e e\n \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e l e `seq` x &#8801; x\n\u003c/pre\u003e\u003cp\u003eThe first example will cause the \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ee\u003c/code\u003e to be raised, whereas the\n second one won't. In fact, \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e will only cause an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e to\n be raised when it is used within the \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e instance. The \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e\n variant should be used in preference to \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e to raise an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e\n within the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e because it guarantees ordering with respect to other\n monadic operations, whereas \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e does not.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003ethrow\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e t -\u003e t -\u003e m r\n \u003ccode\u003e\u003ca\u003ethrowingM\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e t   -\u003e t -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "throwingM",
          "package": "lens",
          "signature": "AReview s SomeException a b -\u003e b -\u003e m r",
          "source": "src/Control-Exception-Lens.html#throwingM",
          "type": "function"
        },
        "index": {
          "description": "variant of throwing that can only be used within the IO Monad or any other MonadCatch instance to throw an Exception described by Prism Although throwingM has type that is specialization of the type of throwing the two functions are subtly different throwing seq throwing throwingM seq The first example will cause the Exception to be raised whereas the second one won In fact throwingM will only cause an Exception to be raised when it is used within the MonadCatch instance The throwingM variant should be used in preference to throwing to raise an Exception within the Monad because it guarantees ordering with respect to other monadic operations whereas throwing does not throwingM reviews throw throwingM MonadCatch Prism SomeException throwingM MonadCatch Iso SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "throwingM",
          "normalized": "AReview a SomeException b c-\u003ec-\u003ed e",
          "package": "lens",
          "signature": "AReview s SomeException a b-\u003eb-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:throwingM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ethrowingTo\u003c/a\u003e\u003c/code\u003e raises an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e specified by a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e in the target thread.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowingTo\u003c/a\u003e\u003c/code\u003e thread l &#8801; \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003ethrowTo\u003c/a\u003e\u003c/code\u003e thread)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowingTo\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e t -\u003e t -\u003e m a\n \u003ccode\u003e\u003ca\u003ethrowingTo\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eThreadId\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e t   -\u003e t -\u003e m a\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "throwingTo",
          "package": "lens",
          "signature": "ThreadId -\u003e AReview s SomeException a b -\u003e b -\u003e m ()",
          "source": "src/Control-Exception-Lens.html#throwingTo",
          "type": "function"
        },
        "index": {
          "description": "throwingTo raises an Exception specified by Prism in the target thread throwingTo thread reviews throwTo thread throwingTo ThreadId Prism SomeException throwingTo ThreadId Iso SomeException",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "throwingTo",
          "normalized": "ThreadId-\u003eAReview a SomeException b c-\u003ec-\u003ed()",
          "package": "lens",
          "partial": "To",
          "signature": "ThreadId-\u003eAReview s SomeException a b-\u003eb-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:throwingTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e that takes a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e) to select which\n exceptions are caught (c.f. \u003ccode\u003e\u003ca\u003etryJust\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecatchJust\u003c/a\u003e\u003c/code\u003e). If the\n \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e does not match the predicate, it is re-thrown.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "trying",
          "package": "lens",
          "signature": "Getting (First a) SomeException a -\u003e m r -\u003e m (Either a r)",
          "source": "src/Control-Exception-Lens.html#trying",
          "type": "function"
        },
        "index": {
          "description": "variant of try that takes Prism or any Getter to select which exceptions are caught c.f tryJust catchJust If the Exception does not match the predicate it is re-thrown trying MonadCatch Prism SomeException Either trying MonadCatch Lens SomeException Either trying MonadCatch Traversal SomeException Either trying MonadCatch Iso SomeException Either trying MonadCatch Getter SomeException Either trying MonadCatch Fold SomeException Either",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "trying",
          "normalized": "Getting(First a)SomeException a-\u003eb c-\u003eb(Either a c)",
          "package": "lens",
          "signature": "Getting(First a)SomeException a-\u003em r-\u003em(Either a r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:trying"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e that discards the specific exception thrown.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etrying_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (Maybe r)\n \u003ccode\u003e\u003ca\u003etrying_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (Maybe r)\n \u003ccode\u003e\u003ca\u003etrying_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (Maybe r)\n \u003ccode\u003e\u003ca\u003etrying_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (Maybe r)\n \u003ccode\u003e\u003ca\u003etrying_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (Maybe r)\n \u003ccode\u003e\u003ca\u003etrying_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadCatch\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e m (Maybe r)\n\u003c/pre\u003e",
          "module": "Control.Exception.Lens",
          "name": "trying_",
          "package": "lens",
          "signature": "Getting (First a) SomeException a -\u003e m r -\u003e m (Maybe r)",
          "source": "src/Control-Exception-Lens.html#trying_",
          "type": "function"
        },
        "index": {
          "description": "version of trying that discards the specific exception thrown trying MonadCatch Prism SomeException Maybe trying MonadCatch Lens SomeException Maybe trying MonadCatch Traversal SomeException Maybe trying MonadCatch Iso SomeException Maybe trying MonadCatch Getter SomeException Maybe trying MonadCatch Fold SomeException Maybe",
          "hierarchy": "Control Exception Lens",
          "module": "Control.Exception.Lens",
          "name": "trying_",
          "normalized": "Getting(First a)SomeException a-\u003eb c-\u003eb(Maybe c)",
          "package": "lens",
          "signature": "Getting(First a)SomeException a-\u003em r-\u003em(Maybe r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Exception-Lens.html#v:trying_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Action",
          "name": "Action",
          "package": "lens",
          "source": "src/Control-Lens-Action.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "Action",
          "package": "lens",
          "partial": "Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to evaluate an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "Acting",
          "package": "lens",
          "source": "src/Control-Lens-Action.html#Acting",
          "type": "type"
        },
        "index": {
          "description": "Used to evaluate an Action",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "Acting",
          "package": "lens",
          "partial": "Acting",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:Acting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e can be used as an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "Action",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Action",
          "type": "type"
        },
        "index": {
          "description": "An Action is Getter enriched with access to Monad for side-effects Every Getter can be used as an Action You can compose an Action with another Action using from the Prelude",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "Action",
          "package": "lens",
          "partial": "Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eEffective\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e ignores its argument and is isomorphic to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e wrapped around a value.\n\u003c/p\u003e\u003cp\u003eThat said, the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e is possibly rather unrelated to any \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e structure.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "Effective",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Action.html#Effective",
          "type": "class"
        },
        "index": {
          "description": "An Effective Functor ignores its argument and is isomorphic to Monad wrapped around value That said the Monad is possibly rather unrelated to any Applicative structure",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "Effective",
          "package": "lens",
          "partial": "Effective",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:Effective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to evaluate an \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "IndexedActing",
          "package": "lens",
          "source": "src/Control-Lens-Action.html#IndexedActing",
          "type": "type"
        },
        "index": {
          "description": "Used to evaluate an IndexedAction",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "IndexedActing",
          "package": "lens",
          "partial": "Indexed Acting",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:IndexedActing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e can be used as an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "IndexedAction",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedAction",
          "type": "type"
        },
        "index": {
          "description": "An IndexedAction is an IndexedGetter enriched with access to Monad for side-effects Every Getter can be used as an Action You can compose an Action with another Action using from the Prelude",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "IndexedAction",
          "package": "lens",
          "partial": "Indexed Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:IndexedAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e can be used as an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e, that simply ignores the access to the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "IndexedMonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedMonadicFold",
          "type": "type"
        },
        "index": {
          "description": "An IndexedMonadicFold is an IndexedFold enriched with access to Monad for side-effects Every IndexedFold can be used as an IndexedMonadicFold that simply ignores the access to the Monad You can compose an IndexedMonadicFold with another IndexedMonadicFold using from the Prelude",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "IndexedMonadicFold",
          "package": "lens",
          "partial": "Indexed Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:IndexedMonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e can be used as a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e, that simply ignores the access to the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "MonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#MonadicFold",
          "type": "type"
        },
        "index": {
          "description": "MonadicFold is Fold enriched with access to Monad for side-effects Every Fold can be used as MonadicFold that simply ignores the access to the Monad You can compose MonadicFold with another MonadicFold using from the Prelude",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "MonadicFold",
          "package": "lens",
          "partial": "Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#t:MonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"world\"]^!folded.act putStrLn\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Action\",\"Control.Lens.Operators\"]",
          "name": "(^!)",
          "package": "lens",
          "signature": "s -\u003e Acting m a s a -\u003e m a",
          "source": "src/Control-Lens-Action.html#%5E%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--33-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--33-\"]"
        },
        "index": {
          "description": "Perform an Action hello world folded.act putStrLn hello world",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "(^!) ^!",
          "normalized": "a-\u003eActing b c a c-\u003eb c",
          "package": "lens",
          "signature": "s-\u003eActing m a s a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e and collect all of the results in a list.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"ab\",\"cd\",\"ef\"]^!!folded.acts\n\u003c/code\u003e\u003c/strong\u003e[\"ace\",\"acf\",\"ade\",\"adf\",\"bce\",\"bcf\",\"bde\",\"bdf\"]\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Action\",\"Control.Lens.Operators\"]",
          "name": "(^!!)",
          "package": "lens",
          "signature": "s -\u003e Acting m [a] s a -\u003e m [a]",
          "source": "src/Control-Lens-Action.html#%5E%21%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--33--33-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--33--33-\"]"
        },
        "index": {
          "description": "Perform MonadicFold and collect all of the results in list ab cd ef folded.acts ace acf ade adf bce bcf bde bdf",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "(^!!) ^!!",
          "normalized": "a-\u003eActing b[c]a c-\u003eb[c]",
          "package": "lens",
          "signature": "s-\u003eActing m[a]s a-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e and collect the leftmost result.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e this still causes all effects for all elements.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[Just 1, Just 2, Just 3]^!?folded.acts\n\u003c/code\u003e\u003c/strong\u003eJust (Just 1)\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[Just 1, Nothing]^!?folded.acts\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Action\",\"Control.Lens.Operators\"]",
          "name": "(^!?)",
          "package": "lens",
          "signature": "s -\u003e Acting m (Leftmost a) s a -\u003e m (Maybe a)",
          "source": "src/Control-Lens-Action.html#%5E%21%3F",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--33--63-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--33--63-\"]"
        },
        "index": {
          "description": "Perform MonadicFold and collect the leftmost result Note this still causes all effects for all elements Just Just Just folded.acts Just Just Just Nothing folded.acts Nothing",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "(^!?) ^!?",
          "normalized": "a-\u003eActing b(Leftmost c)a c-\u003eb(Maybe c)",
          "package": "lens",
          "signature": "s-\u003eActing m(Leftmost a)s a-\u003em(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--33--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Action\",\"Control.Lens.Operators\"]",
          "name": "(^@!)",
          "package": "lens",
          "signature": "s -\u003e IndexedActing i m (i, a) s a -\u003e m (i, a)",
          "source": "src/Control-Lens-Action.html#%5E%40%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--64--33-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64--33-\"]"
        },
        "index": {
          "description": "Perform an IndexedAction",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "(^@!) ^@!",
          "normalized": "a-\u003eIndexedActing b c(b,d)a d-\u003ec(b,d)",
          "package": "lens",
          "signature": "s-\u003eIndexedActing i m(i,a)s a-\u003em(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--64--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a list of all of the results of an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Action\",\"Control.Lens.Operators\"]",
          "name": "(^@!!)",
          "package": "lens",
          "signature": "s -\u003e IndexedActing i m [(i, a)] s a -\u003e m [(i, a)]",
          "source": "src/Control-Lens-Action.html#%5E%40%21%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--64--33--33-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64--33--33-\"]"
        },
        "index": {
          "description": "Obtain list of all of the results of an IndexedMonadicFold",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "(^@!!) ^@!!",
          "normalized": "a-\u003eIndexedActing b c[(b,d)]a d-\u003ec[(b,d)]",
          "package": "lens",
          "signature": "s-\u003eIndexedActing i m[(i,a)]s a-\u003em[(i,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--64--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e and collect the \u003ccode\u003e\u003ca\u003eLeftmost\u003c/a\u003e\u003c/code\u003e result.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e this still causes all effects for all elements.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Action\",\"Control.Lens.Operators\"]",
          "name": "(^@!?)",
          "package": "lens",
          "signature": "s -\u003e IndexedActing i m (Leftmost (i, a)) s a -\u003e m (Maybe (i, a))",
          "source": "src/Control-Lens-Action.html#%5E%40%21%3F",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--64--33--63-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64--33--63-\"]"
        },
        "index": {
          "description": "Perform an IndexedMonadicFold and collect the Leftmost result Note this still causes all effects for all elements",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "(^@!?) ^@!?",
          "normalized": "a-\u003eIndexedActing b c(Leftmost(b,d))a d-\u003ec(Maybe(b,d))",
          "package": "lens",
          "signature": "s-\u003eIndexedActing i m(Leftmost(i,a))s a-\u003em(Maybe(i,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:-94--64--33--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e from a monadic side-effect.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"world\"]^!folded.act (\\x -\u003e [x,x ++ \"!\"])\n\u003c/code\u003e\u003c/strong\u003e[\"helloworld\",\"helloworld!\",\"hello!world\",\"hello!world!\"]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eact\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e (s -\u003e m a) -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003eact\u003c/a\u003e\u003c/code\u003e sma afb a = \u003ccode\u003e\u003ca\u003eeffective\u003c/a\u003e\u003c/code\u003e (sma a \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eineffective\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e afb)\n\u003c/pre\u003e",
          "module": "Control.Lens.Action",
          "name": "act",
          "package": "lens",
          "signature": "(s -\u003e m a) -\u003e IndexPreservingAction m s a",
          "source": "src/Control-Lens-Action.html#act",
          "type": "function"
        },
        "index": {
          "description": "Construct an Action from monadic side-effect hello world folded.act helloworld helloworld hello world hello world act Monad Action act sma afb effective sma ineffective afb",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "act",
          "normalized": "(a-\u003eb c)-\u003eIndexPreservingAction b a c",
          "package": "lens",
          "signature": "(s-\u003em a)-\u003eIndexPreservingAction m s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:act"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA self-running \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e, analogous to \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eacts\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eact\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,\"hello\")^!_2.acts.to succ\n\u003c/code\u003e\u003c/strong\u003e\"ifmmp\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Action",
          "name": "acts",
          "package": "lens",
          "signature": "IndexPreservingAction m (m a) a",
          "source": "src/Control-Lens-Action.html#acts",
          "type": "function"
        },
        "index": {
          "description": "self-running Action analogous to join acts act id hello acts.to succ ifmmp",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "acts",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:acts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e from a monadic side-effect.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "iact",
          "package": "lens",
          "signature": "(s -\u003e m (i, a)) -\u003e IndexedAction i m s a",
          "source": "src/Control-Lens-Action.html#iact",
          "type": "function"
        },
        "index": {
          "description": "Construct an IndexedAction from monadic side-effect",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "iact",
          "normalized": "(a-\u003eb(c,d))-\u003eIndexedAction c b a d",
          "package": "lens",
          "signature": "(s-\u003em(i,a))-\u003eIndexedAction i m s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:iact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiperform\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e^@!\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Control.Lens.Action",
          "name": "iperform",
          "package": "lens",
          "signature": "IndexedActing i m (i, a) s a -\u003e s -\u003e m (i, a)",
          "source": "src/Control-Lens-Action.html#iperform",
          "type": "function"
        },
        "index": {
          "description": "Perform an IndexedAction iperform flip",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "iperform",
          "normalized": "IndexedActing a b(a,c)d c-\u003ed-\u003eb(a,c)",
          "package": "lens",
          "signature": "IndexedActing i m(i,a)s a-\u003es-\u003em(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:iperform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e and modify the result.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "iperforms",
          "package": "lens",
          "signature": "IndexedActing i m e s a -\u003e (i -\u003e a -\u003e e) -\u003e s -\u003e m e",
          "source": "src/Control-Lens-Action.html#iperforms",
          "type": "function"
        },
        "index": {
          "description": "Perform an IndexedAction and modify the result",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "iperforms",
          "normalized": "IndexedActing a b c d e-\u003e(a-\u003ee-\u003ec)-\u003ed-\u003eb c",
          "package": "lens",
          "signature": "IndexedActing i m e s a-\u003e(i-\u003ea-\u003ee)-\u003es-\u003em e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:iperforms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer to an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Action",
          "name": "liftAct",
          "package": "lens",
          "signature": "Acting m a s a -\u003e IndexPreservingAction (trans m) s a",
          "source": "src/Control-Lens-Action.html#liftAct",
          "type": "function"
        },
        "index": {
          "description": "Apply Monad transformer to an Action",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "liftAct",
          "normalized": "Acting a b c b-\u003eIndexPreservingAction(d a)c b",
          "package": "lens",
          "partial": "Act",
          "signature": "Acting m a s a-\u003eIndexPreservingAction(trans m)s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:liftAct"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eperform\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e^!\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Control.Lens.Action",
          "name": "perform",
          "package": "lens",
          "signature": "Acting m a s a -\u003e s -\u003e m a",
          "source": "src/Control-Lens-Action.html#perform",
          "type": "function"
        },
        "index": {
          "description": "Perform an Action perform flip",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "perform",
          "normalized": "Acting a b c b-\u003ec-\u003ea b",
          "package": "lens",
          "signature": "Acting m a s a-\u003es-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:perform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e and modify the result.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eperforms\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eActing\u003c/a\u003e\u003c/code\u003e m e s a -\u003e (a -\u003e e) -\u003e s -\u003e m e\n\u003c/pre\u003e",
          "module": "Control.Lens.Action",
          "name": "performs",
          "package": "lens",
          "signature": "Over p (Effect m e) s t a b -\u003e p a e -\u003e s -\u003e m e",
          "source": "src/Control-Lens-Action.html#performs",
          "type": "function"
        },
        "index": {
          "description": "Perform an Action and modify the result performs Monad Acting",
          "hierarchy": "Control Lens Action",
          "module": "Control.Lens.Action",
          "name": "performs",
          "normalized": "Over a(Effect b c)d e f g-\u003ea f c-\u003ed-\u003eb c",
          "package": "lens",
          "signature": "Over p(Effect m e)s t a b-\u003ep a e-\u003es-\u003em e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Action.html#v:performs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.At",
          "name": "At",
          "package": "lens",
          "source": "src/Control-Lens-At.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "At",
          "package": "lens",
          "partial": "At",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eAt\u003c/a\u003e\u003c/code\u003e provides a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that can be used to read,\n write or delete the value associated with a key in a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e-like\n container on an ad hoc basis.\n\u003c/p\u003e\u003cp\u003eAn instance of \u003ccode\u003e\u003ca\u003eAt\u003c/a\u003e\u003c/code\u003e should satisfy:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e k &#8801; \u003ccode\u003e\u003ca\u003eat\u003c/a\u003e\u003c/code\u003e k \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.At",
          "name": "At",
          "package": "lens",
          "source": "src/Control-Lens-At.html#At",
          "type": "class"
        },
        "index": {
          "description": "At provides Lens that can be used to read write or delete the value associated with key in Map like container on an ad hoc basis An instance of At should satisfy ix at traverse",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "At",
          "package": "lens",
          "partial": "At",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#t:At"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides a simple \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e) that lets you view (and modify)\n information about whether or not a container contains a given \u003ccode\u003e\u003ca\u003eIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.At",
          "name": "Contains",
          "package": "lens",
          "source": "src/Control-Lens-At.html#Contains",
          "type": "class"
        },
        "index": {
          "description": "This class provides simple IndexedFold or IndexedTraversal that lets you view and modify information about whether or not container contains given Index",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "Contains",
          "package": "lens",
          "partial": "Contains",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#t:Contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.At",
          "name": "Index",
          "package": "lens",
          "signature": "Index",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "Index",
          "package": "lens",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#t:Index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis provides a common notion of a value at an index that is shared by both \u003ccode\u003e\u003ca\u003eIxed\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eAt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.At",
          "name": "IxValue",
          "package": "lens",
          "signature": "IxValue",
          "type": "function"
        },
        "index": {
          "description": "This provides common notion of value at an index that is shared by both Ixed and At",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "IxValue",
          "package": "lens",
          "partial": "Ix Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#t:IxValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis simple \u003ccode\u003eAffineTraversal\u003c/code\u003e lets you \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the value at a given\n key in a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e or element at an ordinal position in a list or \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.At",
          "name": "Ixed",
          "package": "lens",
          "source": "src/Control-Lens-At.html#Ixed",
          "type": "class"
        },
        "index": {
          "description": "This simple AffineTraversal lets you traverse the value at given key in Map or element at an ordinal position in list or Seq",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "Ixed",
          "package": "lens",
          "partial": "Ixed",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#t:Ixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.fromList [(1,\"world\")] ^.at 1\n\u003c/code\u003e\u003c/strong\u003eJust \"world\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eat 1 ?~ \"hello\" $ Map.empty\n\u003c/code\u003e\u003c/strong\u003efromList [(1,\"hello\")]\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e-like containers form a reasonable instance, but not \u003ccode\u003e\u003ca\u003eArray\u003c/a\u003e\u003c/code\u003e-like ones, where\n you cannot satisfy the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e",
          "module": "Control.Lens.At",
          "name": "at",
          "package": "lens",
          "signature": "Index m -\u003e Lens' m (Maybe (IxValue m))",
          "source": "src/Control-Lens-At.html#at",
          "type": "method"
        },
        "index": {
          "description": "Map.fromList world at Just world at hello Map.empty fromList hello Note Map like containers form reasonable instance but not Array like ones where you cannot satisfy the Lens laws",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "at",
          "normalized": "Index a-\u003eLens' a(Maybe(IxValue a))",
          "package": "lens",
          "signature": "Index m-\u003eLens' m(Maybe(IxValue m))",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#v:at"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eIntSet.fromList [1,2,3,4] ^. contains 3\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eIntSet.fromList [1,2,3,4] ^. contains 5\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eIntSet.fromList [1,2,3,4] & contains 3 .~ False\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,4]\n\u003c/pre\u003e",
          "module": "Control.Lens.At",
          "name": "contains",
          "package": "lens",
          "signature": "Index m -\u003e Lens' m Bool",
          "source": "src/Control-Lens-At.html#contains",
          "type": "method"
        },
        "index": {
          "description": "IntSet.fromList contains True IntSet.fromList contains False IntSet.fromList contains False fromList",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "contains",
          "normalized": "Index a-\u003eLens' a Bool",
          "package": "lens",
          "signature": "Index m-\u003eLens' m Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#v:contains"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis simple \u003ccode\u003eAffineTraversal\u003c/code\u003e lets you \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the value at a given\n key in a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e or element at an ordinal position in a list or \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNB:\u003c/em\u003e Setting the value of this \u003ccode\u003eAffineTraversal\u003c/code\u003e will only set the value in the\n \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e if it is already present.\n\u003c/p\u003e\u003cp\u003eIf you want to be able to insert \u003cem\u003emissing\u003c/em\u003e values, you want \u003ccode\u003e\u003ca\u003eat\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c,d] & ix 2 %~ f\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,f c,d]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c,d] & ix 2 .~ e\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,e,d]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c,d] ^? ix 2\n\u003c/code\u003e\u003c/strong\u003eJust c\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [] ^? ix 2\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Control.Lens.At",
          "name": "ix",
          "package": "lens",
          "signature": "Index m -\u003e Traversal' m (IxValue m)",
          "source": "src/Control-Lens-At.html#ix",
          "type": "method"
        },
        "index": {
          "description": "This simple AffineTraversal lets you traverse the value at given key in Map or element at an ordinal position in list or Seq NB Setting the value of this AffineTraversal will only set the value in the Lens if it is already present If you want to be able to insert missing values you want at Seq.fromList ix fromList Seq.fromList ix fromList Seq.fromList ix Just Seq.fromList ix Nothing",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "ix",
          "normalized": "Index a-\u003eTraversal' a(IxValue a)",
          "package": "lens",
          "signature": "Index m-\u003eTraversal' m(IxValue m)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#v:ix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA definition of \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e for types with an \u003ccode\u003e\u003ca\u003eAt\u003c/a\u003e\u003c/code\u003e instance. This is the default\n if you don't specify a definition for \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.At",
          "name": "ixAt",
          "package": "lens",
          "signature": "Index m -\u003e Traversal' m (IxValue m)",
          "source": "src/Control-Lens-At.html#ixAt",
          "type": "function"
        },
        "index": {
          "description": "definition of ix for types with an At instance This is the default if you don specify definition for ix",
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "ixAt",
          "normalized": "Index a-\u003eTraversal' a(IxValue a)",
          "package": "lens",
          "partial": "At",
          "signature": "Index m-\u003eTraversal' m(IxValue m)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#v:ixAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.At",
          "name": "sans",
          "package": "lens",
          "signature": "Index m -\u003e m -\u003e m",
          "source": "src/Control-Lens-At.html#sans",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens At",
          "module": "Control.Lens.At",
          "name": "sans",
          "normalized": "Index a-\u003ea-\u003ea",
          "package": "lens",
          "signature": "Index m-\u003em-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#v:sans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis lets the subset of users who vociferously disagree about the full\n scope and set of operators that should be exported from lens to not have\n to look at any operator with which they disagree.\n\u003c/p\u003e\u003cpre\u003e import Control.Lens.Combinators\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Control.Lens.Combinators",
          "name": "Combinators",
          "package": "lens",
          "source": "src/Control-Lens-Combinators.html",
          "type": "module"
        },
        "index": {
          "description": "This lets the subset of users who vociferously disagree about the full scope and set of operators that should be exported from lens to not have to look at any operator with which they disagree import Control.Lens.Combinators",
          "hierarchy": "Control Lens Combinators",
          "module": "Control.Lens.Combinators",
          "name": "Combinators",
          "package": "lens",
          "partial": "Combinators",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Combinators.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Cons",
          "name": "Cons",
          "package": "lens",
          "source": "src/Control-Lens-Cons.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "Cons",
          "package": "lens",
          "partial": "Cons",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides a way to attach or detach elements on the left\n side of a structure in a flexible manner.\n\u003c/p\u003e",
          "module": "Control.Lens.Cons",
          "name": "Cons",
          "package": "lens",
          "source": "src/Control-Lens-Cons.html#Cons",
          "type": "class"
        },
        "index": {
          "description": "This class provides way to attach or detach elements on the left side of structure in flexible manner",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "Cons",
          "package": "lens",
          "partial": "Cons",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#t:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides a way to attach or detach elements on the right\n side of a structure in a flexible manner.\n\u003c/p\u003e",
          "module": "Control.Lens.Cons",
          "name": "Snoc",
          "package": "lens",
          "source": "src/Control-Lens-Cons.html#Snoc",
          "type": "class"
        },
        "index": {
          "description": "This class provides way to attach or detach elements on the right side of structure in flexible manner",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "Snoc",
          "package": "lens",
          "partial": "Snoc",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#t:Snoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esnoc\u003c/a\u003e\u003c/code\u003e an element onto the end of a container.\n\u003c/p\u003e\u003cp\u003eThis is an infix alias for \u003ccode\u003e\u003ca\u003esnoc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [] |\u003e a\n\u003c/code\u003e\u003c/strong\u003efromList [a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [b, c] |\u003e a\n\u003c/code\u003e\u003c/strong\u003efromList [b,c,a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLazyT.pack \"hello\" |\u003e '!'\n\u003c/code\u003e\u003c/strong\u003e\"hello!\"\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Cons\",\"Control.Lens.Operators\"]",
          "name": "(|\u003e)",
          "package": "lens",
          "signature": "s -\u003e a -\u003e s",
          "source": "src/Control-Lens-Cons.html#%7C%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:-124--62-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-124--62-\"]"
        },
        "index": {
          "description": "snoc an element onto the end of container This is an infix alias for snoc Seq.fromList fromList Seq.fromList fromList LazyT.pack hello hello",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "(|\u003e) |\u003e",
          "normalized": "a-\u003eb-\u003ea",
          "package": "lens",
          "signature": "s-\u003ea-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:-124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e an element onto a container.\n\u003c/p\u003e\u003cp\u003eThis is an infix alias for \u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea \u003c| []\n\u003c/code\u003e\u003c/strong\u003e[a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea \u003c| [b, c]\n\u003c/code\u003e\u003c/strong\u003e[a,b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea \u003c| Seq.fromList []\n\u003c/code\u003e\u003c/strong\u003efromList [a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea \u003c| Seq.fromList [b, c]\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,c]\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Cons\",\"Control.Lens.Operators\"]",
          "name": "(\u003c|)",
          "package": "lens",
          "signature": "a -\u003e s -\u003e s",
          "source": "src/Control-Lens-Cons.html#%3C%7C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:-60--124-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--124-\"]"
        },
        "index": {
          "description": "cons an element onto container This is an infix alias for cons Seq.fromList fromList Seq.fromList fromList",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "(\u003c|) \u003c|",
          "normalized": "a-\u003eb-\u003eb",
          "package": "lens",
          "signature": "a-\u003es-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:-60--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Cons\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e [a] [b] (a, [a]) (b, [b])\n \u003ccode\u003e\u003ca\u003e_Cons\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e b) (a, \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) (b, \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e b)\n \u003ccode\u003e\u003ca\u003e_Cons\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e b) (a, \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) (b, \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e b)\n \u003ccode\u003e\u003ca\u003e_Cons\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e)\n \u003ccode\u003e\u003ca\u003e_Cons\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e)\n \u003ccode\u003e\u003ca\u003e_Cons\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "_Cons",
          "package": "lens",
          "signature": "Prism s t (a, s) (b, t)",
          "source": "src/Control-Lens-Cons.html#_Cons",
          "type": "method"
        },
        "index": {
          "description": "Cons Prism Cons Prism Seq Seq Seq Seq Cons Prism Vector Vector Vector Vector Cons Prism String Char String Cons Prism Text Char Text Cons Prism ByteString Word8 ByteString",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "_Cons",
          "normalized": "Prism a b(c,a)(d,b)",
          "package": "lens",
          "partial": "Cons",
          "signature": "Prism s t(a,s)(b,t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Snoc\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e [a] [b] ([a], a) ([b], b)\n \u003ccode\u003e\u003ca\u003e_Snoc\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e b) (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a, a) (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e b, b)\n \u003ccode\u003e\u003ca\u003e_Snoc\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e b) (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a, a) (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e b, b)\n \u003ccode\u003e\u003ca\u003e_Snoc\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e)\n \u003ccode\u003e\u003ca\u003e_Snoc\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e)\n \u003ccode\u003e\u003ca\u003e_Snoc\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "_Snoc",
          "package": "lens",
          "signature": "Prism s t (s, a) (t, b)",
          "source": "src/Control-Lens-Cons.html#_Snoc",
          "type": "method"
        },
        "index": {
          "description": "Snoc Prism Snoc Prism Seq Seq Seq Seq Snoc Prism Vector Vector Vector Vector Snoc Prism String String Char Snoc Prism Text Text Char Snoc Prism ByteString ByteString Word8",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "_Snoc",
          "normalized": "Prism a b(a,c)(b,d)",
          "package": "lens",
          "partial": "Snoc",
          "signature": "Prism s t(s,a)(t,b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_Snoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e reading and writing to the \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e of a \u003cem\u003enon-empty\u003c/em\u003e container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c]^? _head\n\u003c/code\u003e\u003c/strong\u003eJust a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c] & _head .~ d\n\u003c/code\u003e\u003c/strong\u003e[d,b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c] & _head %~ f\n\u003c/code\u003e\u003c/strong\u003e[f a,b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & _head %~ f\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3]^?!_head\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[]^?_head\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2]^?_head\n\u003c/code\u003e\u003c/strong\u003eJust 1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & _head .~ 1\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[0] & _head .~ 2\n\u003c/code\u003e\u003c/strong\u003e[2]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[0,1] & _head .~ 2\n\u003c/code\u003e\u003c/strong\u003e[2,1]\n\u003c/pre\u003e\u003cp\u003eThis isn't limited to lists.\n\u003c/p\u003e\u003cp\u003eFor instance you can also \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the head of a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c,d] & _head %~ f\n\u003c/code\u003e\u003c/strong\u003efromList [f a,b,c,d]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [] ^? _head\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c,d] ^? _head\n\u003c/code\u003e\u003c/strong\u003eJust a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_head\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e [a] a\n \u003ccode\u003e\u003ca\u003e_head\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) a\n \u003ccode\u003e\u003ca\u003e_head\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) a\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "_head",
          "package": "lens",
          "signature": "Traversal' s a",
          "source": "src/Control-Lens-Cons.html#_head",
          "type": "function"
        },
        "index": {
          "description": "Traversal reading and writing to the head of non-empty container head Just head head head head head Nothing head Just head head head This isn limited to lists For instance you can also traverse the head of Seq Seq.fromList head fromList Seq.fromList head Nothing Seq.fromList head Just head Traversal head Traversal Seq head Traversal Vector",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "_head",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e reading and replacing all but the a last element of a \u003cem\u003enon-empty\u003c/em\u003e container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c,d]^?_init\n\u003c/code\u003e\u003c/strong\u003eJust [a,b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[]^?_init\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b] & _init .~ [c,d,e]\n\u003c/code\u003e\u003c/strong\u003e[c,d,e,b]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & _init .~ [a,b]\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c,d] & _init.traverse %~ f\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c,d]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3]^?_init\n\u003c/code\u003e\u003c/strong\u003eJust [1,2]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3,4]^?!_init\n\u003c/code\u003e\u003c/strong\u003e[1,2,3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^._init\n\u003c/code\u003e\u003c/strong\u003e\"hell\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"\"^._init\n\u003c/code\u003e\u003c/strong\u003e\"\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_init\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e [a] [a]\n \u003ccode\u003e\u003ca\u003e_init\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003e_init\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "_init",
          "package": "lens",
          "signature": "Traversal' s s",
          "source": "src/Control-Lens-Cons.html#_init",
          "type": "function"
        },
        "index": {
          "description": "Traversal reading and replacing all but the last element of non-empty container init Just init Nothing init init init.traverse init Just init hello init hell init init Traversal init Traversal Seq Seq init Traversal Vector Vector",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "_init",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e reading and writing to the last element of a \u003cem\u003enon-empty\u003c/em\u003e container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c]^?!_last\n\u003c/code\u003e\u003c/strong\u003ec\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[]^?_last\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c] & _last %~ f\n\u003c/code\u003e\u003c/strong\u003e[a,b,f c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2]^?_last\n\u003c/code\u003e\u003c/strong\u003eJust 2\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & _last .~ 1\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[0] & _last .~ 2\n\u003c/code\u003e\u003c/strong\u003e[2]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[0,1] & _last .~ 2\n\u003c/code\u003e\u003c/strong\u003e[0,2]\n\u003c/pre\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e is not limited to lists, however. We can also work with other containers, such as a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList \"abcde\" ^? _last\n\u003c/code\u003e\u003c/strong\u003eJust 'e'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.empty ^? _last\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList \"abcde\" & _last .~ 'Q'\n\u003c/code\u003e\u003c/strong\u003efromList \"abcdQ\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_last\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e [a] a\n \u003ccode\u003e\u003ca\u003e_last\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) a\n \u003ccode\u003e\u003ca\u003e_last\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) a\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "_last",
          "package": "lens",
          "signature": "Traversal' s a",
          "source": "src/Control-Lens-Cons.html#_last",
          "type": "function"
        },
        "index": {
          "description": "Traversal reading and writing to the last element of non-empty container last last Nothing last last Just last last last This Traversal is not limited to lists however We can also work with other containers such as Vector Vector.fromList abcde last Just Vector.empty last Nothing Vector.fromList abcde last fromList abcdQ last Traversal last Traversal Seq last Traversal Vector",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "_last",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e reading and writing to the \u003ccode\u003e\u003ca\u003etail\u003c/a\u003e\u003c/code\u003e of a \u003cem\u003enon-empty\u003c/em\u003e container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b] & _tail .~ [c,d,e]\n\u003c/code\u003e\u003c/strong\u003e[a,c,d,e]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & _tail .~ [a,b]\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c,d,e] & _tail.traverse %~ f\n\u003c/code\u003e\u003c/strong\u003e[a,f b,f c,f d,f e]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2] & _tail .~ [3,4,5]\n\u003c/code\u003e\u003c/strong\u003e[1,3,4,5]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & _tail .~ [1,2]\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[a,b,c]^?_tail\n\u003c/code\u003e\u003c/strong\u003eJust [b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2]^?!_tail\n\u003c/code\u003e\u003c/strong\u003e[2]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^._tail\n\u003c/code\u003e\u003c/strong\u003e\"ello\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"\"^._tail\n\u003c/code\u003e\u003c/strong\u003e\"\"\n\u003c/pre\u003e\u003cp\u003eThis isn't limited to lists. For instance you can also \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the tail of a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b] & _tail .~ Seq.fromList [c,d,e]\n\u003c/code\u003e\u003c/strong\u003efromList [a,c,d,e]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c] ^? _tail\n\u003c/code\u003e\u003c/strong\u003eJust (fromList [b,c])\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [] ^? _tail\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_tail\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e [a] [a]\n \u003ccode\u003e\u003ca\u003e_tail\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003e_tail\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a) (\u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "_tail",
          "package": "lens",
          "signature": "Traversal' s s",
          "source": "src/Control-Lens-Cons.html#_tail",
          "type": "function"
        },
        "index": {
          "description": "Traversal reading and writing to the tail of non-empty container tail tail tail.traverse tail tail tail Just tail hello tail ello tail This isn limited to lists For instance you can also traverse the tail of Seq Seq.fromList tail Seq.fromList fromList Seq.fromList tail Just fromList Seq.fromList tail Nothing tail Traversal tail Traversal Seq Seq tail Traversal Vector Vector",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "_tail",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003econs\u003c/a\u003e\u003c/code\u003e an element onto a container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econs a []\n\u003c/code\u003e\u003c/strong\u003e[a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econs a [b, c]\n\u003c/code\u003e\u003c/strong\u003e[a,b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econs a (Seq.fromList [])\n\u003c/code\u003e\u003c/strong\u003efromList [a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econs a (Seq.fromList [b, c])\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,c]\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "cons",
          "package": "lens",
          "signature": "a -\u003e s -\u003e s",
          "source": "src/Control-Lens-Cons.html#cons",
          "type": "function"
        },
        "index": {
          "description": "cons an element onto container cons cons cons Seq.fromList fromList cons Seq.fromList fromList",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "cons",
          "normalized": "a-\u003eb-\u003eb",
          "package": "lens",
          "signature": "a-\u003es-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003esnoc\u003c/a\u003e\u003c/code\u003e an element onto the end of a container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esnoc (Seq.fromList []) a\n\u003c/code\u003e\u003c/strong\u003efromList [a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esnoc (Seq.fromList [b, c]) a\n\u003c/code\u003e\u003c/strong\u003efromList [b,c,a]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esnoc (LazyT.pack \"hello\") '!'\n\u003c/code\u003e\u003c/strong\u003e\"hello!\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "snoc",
          "package": "lens",
          "signature": "s -\u003e a -\u003e s",
          "source": "src/Control-Lens-Cons.html#snoc",
          "type": "function"
        },
        "index": {
          "description": "snoc an element onto the end of container snoc Seq.fromList fromList snoc Seq.fromList fromList snoc LazyT.pack hello hello",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "snoc",
          "normalized": "a-\u003eb-\u003ea",
          "package": "lens",
          "signature": "s-\u003ea-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:snoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to extract the left-most element from a container, and a version of the container without that element.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003euncons []\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003euncons [a, b, c]\n\u003c/code\u003e\u003c/strong\u003eJust (a,[b,c])\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "uncons",
          "package": "lens",
          "signature": "s -\u003e Maybe (a, s)",
          "source": "src/Control-Lens-Cons.html#uncons",
          "type": "function"
        },
        "index": {
          "description": "Attempt to extract the left-most element from container and version of the container without that element uncons Nothing uncons Just",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "uncons",
          "normalized": "a-\u003eMaybe(b,a)",
          "package": "lens",
          "signature": "s-\u003eMaybe(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:uncons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttempt to extract the right-most element from a container, and a version of the container without that element.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eunsnoc (LazyT.pack \"hello!\")\n\u003c/code\u003e\u003c/strong\u003eJust (\"hello\",'!')\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eunsnoc (LazyT.pack \"\")\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eunsnoc (Seq.fromList [b,c,a])\n\u003c/code\u003e\u003c/strong\u003eJust (fromList [b,c],a)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eunsnoc (Seq.fromList [])\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Control.Lens.Cons",
          "name": "unsnoc",
          "package": "lens",
          "signature": "s -\u003e Maybe (s, a)",
          "source": "src/Control-Lens-Cons.html#unsnoc",
          "type": "function"
        },
        "index": {
          "description": "Attempt to extract the right-most element from container and version of the container without that element unsnoc LazyT.pack hello Just hello unsnoc LazyT.pack Nothing unsnoc Seq.fromList Just fromList unsnoc Seq.fromList Nothing",
          "hierarchy": "Control Lens Cons",
          "module": "Control.Lens.Cons",
          "name": "unsnoc",
          "normalized": "a-\u003eMaybe(a,b)",
          "package": "lens",
          "signature": "s-\u003eMaybe(s,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:unsnoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Each",
          "name": "Each",
          "package": "lens",
          "source": "src/Control-Lens-Each.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Each",
          "module": "Control.Lens.Each",
          "name": "Each",
          "package": "lens",
          "partial": "Each",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Each.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract \u003ccode\u003e\u003ca\u003eeach\u003c/a\u003e\u003c/code\u003e element of a (potentially monomorphic) container.\n\u003c/p\u003e\u003cp\u003eNotably, when applied to a tuple, this generalizes \u003ccode\u003e\u003ca\u003eboth\u003c/a\u003e\u003c/code\u003e to arbitrary homogeneous tuples.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2,3) & each *~ 10\n\u003c/code\u003e\u003c/strong\u003e(10,20,30)\n\u003c/pre\u003e\u003cp\u003eIt can also be used on monomorphic containers like \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover each Char.toUpper (\"hello\"^.Text.packed)\n\u003c/code\u003e\u003c/strong\u003e\"HELLO\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") & each.each %~ Char.toUpper\n\u003c/code\u003e\u003c/strong\u003e(\"HELLO\",\"WORLD\")\n\u003c/pre\u003e",
          "module": "Control.Lens.Each",
          "name": "Each",
          "package": "lens",
          "source": "src/Control-Lens-Each.html#Each",
          "type": "class"
        },
        "index": {
          "description": "Extract each element of potentially monomorphic container Notably when applied to tuple this generalizes both to arbitrary homogeneous tuples each It can also be used on monomorphic containers like Text or ByteString over each Char.toUpper hello Text.packed HELLO hello world each.each Char.toUpper HELLO WORLD",
          "hierarchy": "Control Lens Each",
          "module": "Control.Lens.Each",
          "name": "Each",
          "package": "lens",
          "partial": "Each",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Each.html#t:Each"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Each",
          "name": "each",
          "package": "lens",
          "signature": "Traversal s t a b",
          "source": "src/Control-Lens-Each.html#each",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Each",
          "module": "Control.Lens.Each",
          "name": "each",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Each.html#v:each"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Empty",
          "name": "Empty",
          "package": "lens",
          "source": "src/Control-Lens-Empty.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Empty",
          "module": "Control.Lens.Empty",
          "name": "Empty",
          "package": "lens",
          "partial": "Empty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Empty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Empty",
          "name": "AsEmpty",
          "package": "lens",
          "source": "src/Control-Lens-Empty.html#AsEmpty",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Lens Empty",
          "module": "Control.Lens.Empty",
          "name": "AsEmpty",
          "package": "lens",
          "partial": "As Empty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Empty.html#t:AsEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eisn't _Empty [1,2,3]\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Control.Lens.Empty",
          "name": "_Empty",
          "package": "lens",
          "signature": "Prism' a ()",
          "source": "src/Control-Lens-Empty.html#_Empty",
          "type": "method"
        },
        "index": {
          "description": "isn Empty True",
          "hierarchy": "Control Lens Empty",
          "module": "Control.Lens.Empty",
          "name": "_Empty",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Empty",
          "signature": "Prism' a()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Empty.html#v:_Empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Equality",
          "name": "Equality",
          "package": "lens",
          "source": "src/Control-Lens-Equality.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "Equality",
          "package": "lens",
          "partial": "Equality",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects an \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "AnEquality",
          "package": "lens",
          "source": "src/Control-Lens-Equality.html#AnEquality",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects an Equality",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "AnEquality",
          "package": "lens",
          "partial": "An Equality",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#t:AnEquality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAnEquality\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "AnEquality'",
          "package": "lens",
          "source": "src/Control-Lens-Equality.html#AnEquality%27",
          "type": "type"
        },
        "index": {
          "description": "Simple AnEquality",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "AnEquality'",
          "package": "lens",
          "partial": "An Equality'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#t:AnEquality-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA witness that \u003ccode\u003e(a ~ s, b ~ t)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Composition with an \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e is index-preserving.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "Equality",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Equality",
          "type": "type"
        },
        "index": {
          "description": "witness that Note Composition with an Equality is index-preserving",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "Equality",
          "package": "lens",
          "partial": "Equality",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#t:Equality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "Equality'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Equality%27",
          "type": "type"
        },
        "index": {
          "description": "Simple Equality",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "Equality'",
          "package": "lens",
          "partial": "Equality'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#t:Equality-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides witness that \u003ccode\u003e(s ~ a, b ~ t)\u003c/code\u003e holds.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "Identical",
          "package": "lens",
          "source": "src/Control-Lens-Equality.html#Identical",
          "type": "data"
        },
        "index": {
          "description": "Provides witness that holds",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "Identical",
          "package": "lens",
          "partial": "Identical",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#t:Identical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Equality",
          "name": "Identical",
          "package": "lens",
          "signature": "Identical a b a b",
          "source": "src/Control-Lens-Equality.html#Identical",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "Identical",
          "package": "lens",
          "partial": "Identical",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#v:Identical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e is symmetric.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "fromEq",
          "package": "lens",
          "signature": "AnEquality s t a b -\u003e Equality b a t s",
          "source": "src/Control-Lens-Equality.html#fromEq",
          "type": "function"
        },
        "index": {
          "description": "Equality is symmetric",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "fromEq",
          "normalized": "AnEquality a b c d-\u003eEquality d c b a",
          "package": "lens",
          "partial": "Eq",
          "signature": "AnEquality s t a b-\u003eEquality b a t s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#v:fromEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can use \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e to do substitution into anything.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "mapEq",
          "package": "lens",
          "signature": "AnEquality s t a b -\u003e f s -\u003e f a",
          "source": "src/Control-Lens-Equality.html#mapEq",
          "type": "function"
        },
        "index": {
          "description": "We can use Equality to do substitution into anything",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "mapEq",
          "normalized": "AnEquality a b c d-\u003ee a-\u003ee c",
          "package": "lens",
          "partial": "Eq",
          "signature": "AnEquality s t a b-\u003ef s-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#v:mapEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a witness of type \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "runEq",
          "package": "lens",
          "signature": "AnEquality s t a b -\u003e Identical s t a b",
          "source": "src/Control-Lens-Equality.html#runEq",
          "type": "function"
        },
        "index": {
          "description": "Extract witness of type Equality",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "runEq",
          "normalized": "AnEquality a b c d-\u003eIdentical a b c d",
          "package": "lens",
          "partial": "Eq",
          "signature": "AnEquality s t a b-\u003eIdentical s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#v:runEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an adverb that can be used to modify many other \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e combinators to make them require\n simple lenses, simple traversals, simple prisms or simple isos as input.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "simply",
          "package": "lens",
          "signature": "(Optic' p f s a -\u003e r) -\u003e Optic' p f s a -\u003e r",
          "source": "src/Control-Lens-Equality.html#simply",
          "type": "function"
        },
        "index": {
          "description": "This is an adverb that can be used to modify many other Lens combinators to make them require simple lenses simple traversals simple prisms or simple isos as input",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "simply",
          "normalized": "(Optic' a b c d-\u003ee)-\u003eOptic' a b c d-\u003ee",
          "package": "lens",
          "signature": "(Optic' p f s a-\u003er)-\u003eOptic' p f s a-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#v:simply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstituting types with \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Equality",
          "name": "substEq",
          "package": "lens",
          "signature": "r) -\u003e r",
          "source": "src/Control-Lens-Equality.html#substEq",
          "type": "function"
        },
        "index": {
          "description": "Substituting types with Equality",
          "hierarchy": "Control Lens Equality",
          "module": "Control.Lens.Equality",
          "name": "substEq",
          "normalized": "a)-\u003ea",
          "package": "lens",
          "partial": "Eq",
          "signature": "r)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Equality.html#v:substEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA few extra names that didn't make it into Control.Lens.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Extras",
          "name": "Extras",
          "package": "lens",
          "source": "src/Control-Lens-Extras.html",
          "type": "module"
        },
        "index": {
          "description": "few extra names that didn make it into Control.Lens",
          "hierarchy": "Control Lens Extras",
          "module": "Control.Lens.Extras",
          "name": "Extras",
          "package": "lens",
          "partial": "Extras",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Extras.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if this \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e matches.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eis _Left (Right 12)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eis hex \"3f79\"\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Control.Lens.Extras",
          "name": "is",
          "package": "lens",
          "signature": "APrism s t a b -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Extras.html#is",
          "type": "function"
        },
        "index": {
          "description": "Check to see if this Prism matches is Left Right False is hex f79 True",
          "hierarchy": "Control Lens Extras",
          "module": "Control.Lens.Extras",
          "name": "is",
          "normalized": "APrism a b c d-\u003ea-\u003eBool",
          "package": "lens",
          "signature": "APrism s t a b-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Extras.html#v:is"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e is a generalization of something \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e. It allows\n you to extract multiple results from a container. A \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e container\n can be characterized by the behavior of\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e t, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m) =\u003e (a -\u003e m) -\u003e t a -\u003e m\u003c/code\u003e.\n Since we want to be able to work with monomorphic containers, we could\n generalize this signature to \u003ccode\u003eforall m. \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e (a -\u003e m) -\u003e s -\u003e m\u003c/code\u003e,\n and then decorate it with \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e to obtain\n\u003c/p\u003e\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a = forall m. \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e m s a\u003c/pre\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that simply doesn't use the \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e\n it is passed.\n\u003c/p\u003e\u003cp\u003eIn practice the type we use is slightly more complicated to allow for\n better error messages and for it to be transformed by certain\n \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e transformers.\n\u003c/p\u003e\u003cp\u003eEverything you can do with a \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e container, you can with with a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e and there are\n combinators that generalize the usual \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e operations here.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Fold",
          "name": "Fold",
          "package": "lens",
          "source": "src/Control-Lens-Fold.html",
          "type": "module"
        },
        "index": {
          "description": "Fold is generalization of something Foldable It allows you to extract multiple results from container Foldable container can be characterized by the behavior of foldMap Foldable Monoid Since we want to be able to work with monomorphic containers we could generalize this signature to forall Monoid and then decorate it with Const to obtain type Fold forall Monoid Getting Every Getter is valid Fold that simply doesn use the Monoid it is passed In practice the type we use is slightly more complicated to allow for better error messages and for it to be transformed by certain Applicative transformers Everything you can do with Foldable container you can with with Fold and there are combinators that generalize the usual Foldable operations here",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "Fold",
          "package": "lens",
          "partial": "Fold",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e describes how to retrieve multiple values in a way that can be composed\n with other \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e constructions.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e provides a structure with operations very similar to those of the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e\n typeclass, see \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e and the other \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e combinators.\n\u003c/p\u003e\u003cp\u003eBy convention, if there exists a \u003ccode\u003efoo\u003c/code\u003e method that expects a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e (f a)\u003c/code\u003e, then there should be a\n \u003ccode\u003efooOf\u003c/code\u003e method that takes a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e and a value of type \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e is a legal \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that just ignores the supplied \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eUnlike a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e is read-only. Since a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e cannot be used to write back\n there are no \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws that apply.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "Fold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Fold",
          "type": "type"
        },
        "index": {
          "description": "Fold describes how to retrieve multiple values in way that can be composed with other LensLike constructions Fold provides structure with operations very similar to those of the Foldable typeclass see foldMapOf and the other Fold combinators By convention if there exists foo method that expects Foldable then there should be fooOf method that takes Fold and value of type Getter is legal Fold that just ignores the supplied Monoid Unlike Traversal Fold is read-only Since Fold cannot be used to write back there are no Lens laws that apply",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "Fold",
          "package": "lens",
          "partial": "Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#t:Fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e and can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "IndexedFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedFold",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedFold is valid Fold and can be used for Getting",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "IndexedFold",
          "package": "lens",
          "partial": "Indexed Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#t:IndexedFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "Leftmost",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Leftmost",
          "type": "data"
        },
        "index": {
          "description": "Used for preview",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "Leftmost",
          "package": "lens",
          "partial": "Leftmost",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#t:Leftmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "Rightmost",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Rightmost",
          "type": "data"
        },
        "index": {
          "description": "Used for lastOf",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "Rightmost",
          "package": "lens",
          "partial": "Rightmost",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#t:Rightmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed internally by \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e and the like.\n\u003c/p\u003e\u003cp\u003eThe argument \u003ccode\u003ea\u003c/code\u003e of the result should not be used!\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "Sequenced",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Sequenced",
          "type": "data"
        },
        "index": {
          "description": "Used internally by mapM and the like The argument of the result should not be used",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "Sequenced",
          "package": "lens",
          "partial": "Sequenced",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#t:Sequenced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed internally by \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e and the like.\n\u003c/p\u003e\u003cp\u003eThe argument \u003ccode\u003ea\u003c/code\u003e of the result should not be used!\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "Traversed",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Traversed",
          "type": "data"
        },
        "index": {
          "description": "Used internally by traverseOf and the like The argument of the result should not be used",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "Traversed",
          "package": "lens",
          "partial": "Traversed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#t:Traversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a safe \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or retrieve \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result\n from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen using a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e as a partial \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, or a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e as a partial \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e this can be a convenient\n way to extract the optional value.\n\u003c/p\u003e\u003cp\u003eNote: if you get stack overflows due to this, you may want to use \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e instead, which can deal\n more gracefully with heavily left-biased trees.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft 4 ^?_Left\n\u003c/code\u003e\u003c/strong\u003eJust 4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eRight 4 ^?_Left\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"world\" ^? ix 3\n\u003c/code\u003e\u003c/strong\u003eJust 'l'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"world\" ^? ix 20\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Fold\",\"Control.Lens.Operators\"]",
          "name": "(^?)",
          "package": "lens",
          "signature": "s -\u003e Getting (First a) s a -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#%5E%3F",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--63-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--63-\"]"
        },
        "index": {
          "description": "Perform safe head of Fold or Traversal or retrieve Just the result from Getter or Lens When using Traversal as partial Lens or Fold as partial Getter this can be convenient way to extract the optional value Note if you get stack overflows due to this you may want to use firstOf instead which can deal more gracefully with heavily left-biased trees Left Left Just Right Left Nothing world ix Just world ix Nothing flip preview Getter Maybe Fold Maybe Lens Maybe Iso Maybe Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "(^?) ^?",
          "normalized": "a-\u003eGetting(First b)a b-\u003eMaybe b",
          "package": "lens",
          "signature": "s-\u003eGetting(First a)s a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an *UNSAFE* \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e assuming that it is there.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft 4 ^?! _Left\n\u003c/code\u003e\u003c/strong\u003e4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"world\" ^?! ix 3\n\u003c/code\u003e\u003c/strong\u003e'l'\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e a\n (\u003ccode\u003e\u003ca\u003e^?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e a\n (\u003ccode\u003e\u003ca\u003e^?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a\n (\u003ccode\u003e\u003ca\u003e^?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a\n (\u003ccode\u003e\u003ca\u003e^?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Fold\",\"Control.Lens.Operators\"]",
          "name": "(^?!)",
          "package": "lens",
          "signature": "s -\u003e Getting (Endo a) s a -\u003e a",
          "source": "src/Control-Lens-Fold.html#%5E%3F%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--63--33-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--63--33-\"]"
        },
        "index": {
          "description": "Perform an UNSAFE head of Fold or Traversal assuming that it is there Left Left world ix Getter Fold Lens Iso Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "(^?!) ^?!",
          "normalized": "a-\u003eGetting(Endo b)a b-\u003eb",
          "package": "lens",
          "signature": "s-\u003eGetting(Endo a)s a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--63--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a safe \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e (with index) of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e or retrieve \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index and result\n from an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen using a \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e as a partial \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e, or an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e as a partial \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e this can be a convenient\n way to extract the optional value.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^@?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@?\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Fold\",\"Control.Lens.Operators\"]",
          "name": "(^@?)",
          "package": "lens",
          "signature": "s -\u003e IndexedGetting i (Endo (Maybe (i, a))) s a -\u003e Maybe (i, a)",
          "source": "src/Control-Lens-Fold.html#%5E%40%3F",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--64--63-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64--63-\"]"
        },
        "index": {
          "description": "Perform safe head with index of an IndexedFold or IndexedTraversal or retrieve Just the index and result from an IndexedGetter or IndexedLens When using IndexedTraversal as partial IndexedLens or an IndexedFold as partial IndexedGetter this can be convenient way to extract the optional value IndexedGetter Maybe IndexedFold Maybe IndexedLens Maybe IndexedTraversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "(^@?) ^@?",
          "normalized": "a-\u003eIndexedGetting b(Endo(Maybe(b,c)))a c-\u003eMaybe(b,c)",
          "package": "lens",
          "signature": "s-\u003eIndexedGetting i(Endo(Maybe(i,a)))s a-\u003eMaybe(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--64--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform an *UNSAFE* \u003ccode\u003e\u003ca\u003ehead\u003c/a\u003e\u003c/code\u003e (with index) of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e assuming that it is there.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^@?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@?!\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i, a)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Fold\",\"Control.Lens.Operators\"]",
          "name": "(^@?!)",
          "package": "lens",
          "signature": "s -\u003e IndexedGetting i (Endo (i, a)) s a -\u003e (i, a)",
          "source": "src/Control-Lens-Fold.html#%5E%40%3F%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--64--63--33-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64--63--33-\"]"
        },
        "index": {
          "description": "Perform an UNSAFE head with index of an IndexedFold or IndexedTraversal assuming that it is there IndexedGetter IndexedFold IndexedLens IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "(^@?!) ^@?!",
          "normalized": "a-\u003eIndexedGetting b(Endo(b,c))a c-\u003e(b,c)",
          "package": "lens",
          "signature": "s-\u003eIndexedGetting i(Endo(i,a))s a-\u003e(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--64--63--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix version of \u003ccode\u003e\u003ca\u003eitoListOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Fold\",\"Control.Lens.Operators\"]",
          "name": "(^@..)",
          "package": "lens",
          "signature": "s -\u003e IndexedGetting i (Endo [(i, a)]) s a -\u003e [(i, a)]",
          "source": "src/Control-Lens-Fold.html#%5E%40..",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--64-..\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64-..\"]"
        },
        "index": {
          "description": "An infix version of itoListOf",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "(^@..) ^@..",
          "normalized": "a-\u003eIndexedGetting b(Endo[(b,c)])a c-\u003e[(b,c)]",
          "package": "lens",
          "signature": "s-\u003eIndexedGetting i(Endo[(i,a)])s a-\u003e[(i,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94--64-.."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA convenient infix (flipped) version of \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[[1,2],[3]]^..traverse.traverse\n\u003c/code\u003e\u003c/strong\u003e[1,2,3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2)^..both\n\u003c/code\u003e\u003c/strong\u003e[1,2]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e xs &#8801; xs \u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e [a]\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e [a]\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e [a]\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e [a]\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e [a]\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e [a]\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Fold\",\"Control.Lens.Operators\"]",
          "name": "(^..)",
          "package": "lens",
          "signature": "s -\u003e Getting (Endo [a]) s a -\u003e [a]",
          "source": "src/Control-Lens-Fold.html#%5E..",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94-..\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94-..\"]"
        },
        "index": {
          "description": "convenient infix flipped version of toListOf traverse.traverse both toList xs xs folded flip toListOf Getter Fold Lens Iso Traversal Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "(^..) ^..",
          "normalized": "a-\u003eGetting(Endo[b])a b-\u003e[b]",
          "package": "lens",
          "signature": "s-\u003eGetting(Endo[a])s a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:-94-.."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if every target of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e satisfies a predicate.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eallOf both (\u003e=3) (4,5)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eallOf folded (\u003e=2) [1..10]\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiallOf\u003c/a\u003e\u003c/code\u003e l = \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "allOf",
          "package": "lens",
          "signature": "Accessing p All s a -\u003e p a Bool -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#allOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True if every target of Fold satisfies predicate allOf both True allOf folded False all allOf folded iallOf allOf Indexed allOf Getter Bool Bool allOf Fold Bool Bool allOf Lens Bool Bool allOf Iso Bool Bool allOf Traversal Bool Bool allOf Prism Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "allOf",
          "normalized": "Accessing a All b c-\u003ea c Bool-\u003eb-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p All s a-\u003ep a Bool-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:allOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if every target of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eandOf both (True,False)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eandOf both (True,True)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eand\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eandOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "andOf",
          "package": "lens",
          "signature": "Getting All s Bool -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#andOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True if every target of Fold is True andOf both True False False andOf both True True True and andOf folded andOf Getter Bool Bool andOf Fold Bool Bool andOf Lens Bool Bool andOf Iso Bool Bool andOf Traversal Bool Bool andOf Prism Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "andOf",
          "normalized": "Getting All a Bool-\u003ea-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting All s Bool-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:andOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if any target of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e satisfies a predicate.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf both (=='x') ('x','y')\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Data.Lens\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf biplate (== \"world\") (((),2::Int),\"hello\",(\"world\",11::Int))\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eianyOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "anyOf",
          "package": "lens",
          "signature": "Accessing p Any s a -\u003e p a Bool -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#anyOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True if any target of Fold satisfies predicate anyOf both True import Data.Data.Lens anyOf biplate world Int hello world Int True any anyOf folded ianyOf allOf Indexed anyOf Getter Bool Bool anyOf Fold Bool Bool anyOf Lens Bool Bool anyOf Iso Bool Bool anyOf Traversal Bool Bool anyOf Prism Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "anyOf",
          "normalized": "Accessing a Any b c-\u003ea c Bool-\u003eb-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p Any s a-\u003ep a Bool-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:anyOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of a collection of actions, generalizing \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003easumOf both (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e\"helloworld\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003easumOf each (Nothing, Just \"hello\", Nothing)\n\u003c/code\u003e\u003c/strong\u003eJust \"hello\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003easum\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s (f a)     -\u003e s -\u003e f a\n \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s (f a)       -\u003e s -\u003e f a\n \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s (f a)      -\u003e s -\u003e f a\n \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s (f a)       -\u003e s -\u003e f a\n \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s (f a) -\u003e s -\u003e f a\n \u003ccode\u003e\u003ca\u003easumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAlternative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s (f a)     -\u003e s -\u003e f a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "asumOf",
          "package": "lens",
          "signature": "Getting (Endo (f a)) s (f a) -\u003e s -\u003e f a",
          "source": "src/Control-Lens-Fold.html#asumOf",
          "type": "function"
        },
        "index": {
          "description": "The sum of collection of actions generalizing concatOf asumOf both hello world helloworld asumOf each Nothing Just hello Nothing Just hello asum asumOf folded asumOf Alternative Getter asumOf Alternative Fold asumOf Alternative Lens asumOf Alternative Iso asumOf Alternative Traversal asumOf Alternative Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "asumOf",
          "normalized": "Getting(Endo(a b))c(a b)-\u003ec-\u003ea b",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(f a))s(f a)-\u003es-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:asumOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis allows you to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the elements of a pretty much any \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e construction in the opposite order.\n\u003c/p\u003e\u003cp\u003eThis will preserve indexes on \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e types and will give you the elements of a (finite) \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in the opposite order.\n\u003c/p\u003e\u003cp\u003eThis has no practical impact on a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNB:\u003c/em\u003e To write back through an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, you want to use \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e.\n Similarly, to write back through an \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, you want to use \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "backwards",
          "package": "lens",
          "signature": "Optical p q (Backwards f) s t a b -\u003e Optical p q f s t a b",
          "source": "src/Control-Lens-Fold.html#backwards",
          "type": "function"
        },
        "index": {
          "description": "This allows you to traverse the elements of pretty much any LensLike construction in the opposite order This will preserve indexes on Indexed types and will give you the elements of finite Fold or Traversal in the opposite order This has no practical impact on Getter Setter Lens or Iso NB To write back through an Iso you want to use from Similarly to write back through an Prism you want to use re",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "backwards",
          "normalized": "Optical a b(Backwards c)d e f g-\u003eOptical a b c d e f g",
          "package": "lens",
          "signature": "Optical p q(Backwards f)s t a b-\u003eOptical p q f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:backwards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a function over all the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e of a container and concatenate the resulting lists.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econcatMapOf both (\\x -\u003e [x, x + 1]) (1,3)\n\u003c/code\u003e\u003c/strong\u003e[1,2,3,4]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e [r]) -\u003e s -\u003e [r]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "concatMapOf",
          "package": "lens",
          "signature": "Accessing p [r] s a -\u003e p a [r] -\u003e s -\u003e [r]",
          "source": "src/Control-Lens-Fold.html#concatMapOf",
          "type": "function"
        },
        "index": {
          "description": "Map function over all the targets of Fold of container and concatenate the resulting lists concatMapOf both concatMap concatMapOf folded concatMapOf Getter concatMapOf Fold concatMapOf Lens concatMapOf Iso concatMapOf Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "concatMapOf",
          "normalized": "Accessing a[b]c d-\u003ea d[b]-\u003ec-\u003e[b]",
          "package": "lens",
          "partial": "Map Of",
          "signature": "Accessing p[r]s a-\u003ep a[r]-\u003es-\u003e[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:concatMapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenate all of the lists targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e into a longer list.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003econcatOf both (\"pan\",\"ama\")\n\u003c/code\u003e\u003c/strong\u003e\"panama\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econcat\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s [r]     -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [r]       -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s [r]       -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s [r]      -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s [r] -\u003e s -\u003e [r]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "concatOf",
          "package": "lens",
          "signature": "Getting [r] s [r] -\u003e s -\u003e [r]",
          "source": "src/Control-Lens-Fold.html#concatOf",
          "type": "function"
        },
        "index": {
          "description": "Concatenate all of the lists targeted by Fold into longer list concatOf both pan ama panama concat concatOf folded concatOf view concatOf Getter concatOf Fold concatOf Iso concatOf Lens concatOf Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "concatOf",
          "normalized": "Getting[a]b[a]-\u003eb-\u003e[a]",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting[r]s[r]-\u003es-\u003e[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:concatOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a non-empty \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eFold1\u003c/a\u003e\u003c/code\u003e that loops over its elements over and over.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etimingOut $ [1,2,3]^..taking 7 (cycled traverse)\n\u003c/code\u003e\u003c/strong\u003e[1,2,3,1,2,3,1]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "cycled",
          "package": "lens",
          "signature": "LensLike f s t a b -\u003e LensLike f s t a b",
          "source": "src/Control-Lens-Fold.html#cycled",
          "type": "function"
        },
        "index": {
          "description": "Transform non-empty Fold into Fold1 that loops over its elements over and over timingOut taking cycled traverse",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "cycled",
          "normalized": "LensLike a b c d e-\u003eLensLike a b c d e",
          "package": "lens",
          "signature": "LensLike f s t a b-\u003eLensLike f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:cycled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by dropping elements from another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e while a predicate holds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e p &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e p \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoListOf (droppingWhile (\u003c=3) folded) [1..6]\n\u003c/code\u003e\u003c/strong\u003e[4,5,6]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoListOf (droppingWhile (\u003c=3) folded) [1,6,1]\n\u003c/code\u003e\u003c/strong\u003e[6,1]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a                   -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a                        -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                -- see notes\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal'\u003c/a\u003e\u003c/code\u003e s a    -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingLens'\u003c/a\u003e\u003c/code\u003e s a         -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingAction\u003c/a\u003e\u003c/code\u003e m s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingMonadicFold\u003c/a\u003e\u003c/code\u003e m s a -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a               -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -- see notes\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a              -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a                -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a            -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edroppingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a       -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e\u003cp\u003eNote: Many uses of this combinator will yield something that meets the types, but not the laws of a valid\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e. The \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e laws are only satisfied if the\n new values you assign also pass the predicate! Otherwise subsequent traversals will visit fewer elements\n and \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e fusion is not sound.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "droppingWhile",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e Optical p q (Compose (State Bool) f) s t a a -\u003e Optical p q f s t a a",
          "source": "src/Control-Lens-Fold.html#droppingWhile",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by dropping elements from another Fold Lens Iso Getter or Traversal while predicate holds dropWhile toListOf droppingWhile folded toListOf droppingWhile folded toListOf droppingWhile folded droppingWhile Bool Fold Fold droppingWhile Bool Getter Fold droppingWhile Bool Traversal Fold see notes droppingWhile Bool Lens Fold see notes droppingWhile Bool Prism Fold see notes droppingWhile Bool Iso Fold see notes droppingWhile Bool IndexPreservingTraversal IndexPreservingFold see notes droppingWhile Bool IndexPreservingLens IndexPreservingFold see notes droppingWhile Bool IndexPreservingGetter IndexPreservingFold droppingWhile Bool IndexPreservingFold IndexPreservingFold droppingWhile Bool IndexPreservingAction IndexPreservingFold droppingWhile Bool IndexPreservingMonadicFold IndexPreservingMonadicFold droppingWhile Bool IndexedTraversal IndexedFold see notes droppingWhile Bool IndexedLens IndexedFold see notes droppingWhile Bool IndexedGetter IndexedFold droppingWhile Bool IndexedFold IndexedFold droppingWhile Bool IndexedAction IndexedFold droppingWhile Bool IndexedMonadicFold IndexedMonadicFold Note Many uses of this combinator will yield something that meets the types but not the laws of valid Traversal or IndexedTraversal The Traversal and IndexedTraversal laws are only satisfied if the new values you assign also pass the predicate Otherwise subsequent traversals will visit fewer elements and Traversal fusion is not sound",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "droppingWhile",
          "normalized": "(a-\u003eBool)-\u003eOptical b c(Compose(State Bool)d)e f a a-\u003eOptical b c d e f a a",
          "package": "lens",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eOptical p q(Compose(State Bool)f)s t a a-\u003eOptical p q f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:droppingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the element occur anywhere within a given \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e of the structure?\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eelemOf both \"hello\" (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eelemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "elemOf",
          "package": "lens",
          "signature": "Getting Any s a -\u003e a -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#elemOf",
          "type": "function"
        },
        "index": {
          "description": "Does the element occur anywhere within given Fold of the structure elemOf both hello hello world True elem elemOf folded elemOf Eq Getter Bool elemOf Eq Fold Bool elemOf Eq Lens Bool elemOf Eq Iso Bool elemOf Eq Traversal Bool elemOf Eq Prism Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "elemOf",
          "normalized": "Getting Any a b-\u003eb-\u003ea-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting Any s a-\u003ea-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:elemOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain an \u003ccode\u003eAffineFold\u003c/code\u003e that can be composed with to filter another \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eNote: This is \u003cem\u003enot\u003c/em\u003e a legal \u003ccode\u003eAffineTraversal\u003c/code\u003e, unless you are very careful not to invalidate the predicate on the target.\n\u003c/p\u003e\u003cp\u003eNote: This is also \u003cem\u003enot\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, unless you are very careful not to inject a value that matches the predicate.\n\u003c/p\u003e\u003cp\u003eAs a counter example, consider that given \u003ccode\u003eevens = \u003ccode\u003e\u003ca\u003efiltered\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eeven\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e the second \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e law is violated:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e evens \u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e evens \u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e evens (\u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cp\u003eSo, in order for this to qualify as a legal \u003ccode\u003eAffineTraversal\u003c/code\u003e you can only use it for actions that preserve the result of the predicate!\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1..10]^..folded.filtered even\n\u003c/code\u003e\u003c/strong\u003e[2,4,6,8,10]\n\u003c/pre\u003e\u003cp\u003eThis will preserve an index if it is present.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "filtered",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e Optic' p f a a",
          "source": "src/Control-Lens-Fold.html#filtered",
          "type": "function"
        },
        "index": {
          "description": "Obtain an AffineFold that can be composed with to filter another Lens Iso Getter Fold or Traversal Note This is not legal AffineTraversal unless you are very careful not to invalidate the predicate on the target Note This is also not legal Prism unless you are very careful not to inject value that matches the predicate As counter example consider that given evens filtered even the second Traversal law is violated over evens succ over evens succ over evens succ succ So in order for this to qualify as legal AffineTraversal you can only use it for actions that preserve the result of the predicate folded.filtered even This will preserve an index if it is present",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "filtered",
          "normalized": "(a-\u003eBool)-\u003eOptic' b c a a",
          "package": "lens",
          "signature": "(a-\u003eBool)-\u003eOptic' p f a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:filtered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e),\n a monadic predicate and a structure and returns in the monad the leftmost element of the structure\n matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efindMOf each ( \\x -\u003e print (\"Checking \" ++ show x) \u003e\u003e return (even x)) (1,3,4,6)\n\u003c/code\u003e\u003c/strong\u003e\"Checking 1\"\n\"Checking 3\"\n\"Checking 4\"\nJust 4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efindMOf each ( \\x -\u003e print (\"Checking \" ++ show x) \u003e\u003e return (even x)) (1,3,5,7)\n\u003c/code\u003e\u003c/strong\u003e\"Checking 1\"\n\"Checking 3\"\n\"Checking 5\"\n\"Checking 7\"\nNothing\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a)     -\u003e (a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a)       -\u003e (a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a)       -\u003e (a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a)      -\u003e (a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a) -\u003e (a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e :: (Monad m, Foldable f) =\u003e (a -\u003e m Bool) -\u003e f a -\u003e m (Maybe a)\n \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eA simpler version that didn't permit indexing, would be:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e :: Monad m =\u003e \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEndo\u003c/a\u003e\u003c/code\u003e (m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a))) s a -\u003e (a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e l p = \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e l (a y -\u003e p a \u003e\u003e= x -\u003e if x then return (\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a) else y) $ return \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "findMOf",
          "package": "lens",
          "signature": "Accessing p (Endo (m (Maybe a))) s a -\u003e p a (m Bool) -\u003e s -\u003e m (Maybe a)",
          "source": "src/Control-Lens-Fold.html#findMOf",
          "type": "function"
        },
        "index": {
          "description": "The findMOf function takes Lens or Getter Iso Fold or Traversal monadic predicate and structure and returns in the monad the leftmost element of the structure matching the predicate or Nothing if there is no such element findMOf each print Checking show return even Checking Checking Checking Just findMOf each print Checking show return even Checking Checking Checking Checking Nothing findMOf Monad Getter Bool Maybe findMOf Monad Fold Bool Maybe findMOf Monad Iso Bool Maybe findMOf Monad Lens Bool Maybe findMOf Monad Traversal Bool Maybe findMOf folded Monad Foldable Bool Maybe ifindMOf findMOf Indexed simpler version that didn permit indexing would be findMOf Monad Getting Endo Maybe Bool Maybe findMOf foldrOf if then return Just else return Nothing",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "findMOf",
          "normalized": "Accessing a(Endo(b(Maybe c)))d c-\u003ea c(b Bool)-\u003ed-\u003eb(Maybe c)",
          "package": "lens",
          "partial": "MOf",
          "signature": "Accessing p(Endo(m(Maybe a)))s a-\u003ep a(m Bool)-\u003es-\u003em(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:findMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e function takes a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e),\n a predicate and a structure and returns the leftmost element of the structure\n matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efindOf each even (1,3,4,6)\n\u003c/code\u003e\u003c/strong\u003eJust 4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efindOf folded even [1,3,5,7]\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eA simpler version that didn't permit indexing, would be:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEndo\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)) s a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e l p = \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e l (a y -\u003e if p a then \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a else y) \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "findOf",
          "package": "lens",
          "signature": "Accessing p (Endo (Maybe a)) s a -\u003e p a Bool -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#findOf",
          "type": "function"
        },
        "index": {
          "description": "The findOf function takes Lens or Getter Iso Fold or Traversal predicate and structure and returns the leftmost element of the structure matching the predicate or Nothing if there is no such element findOf each even Just findOf folded even Nothing findOf Getter Bool Maybe findOf Fold Bool Maybe findOf Iso Bool Maybe findOf Lens Bool Maybe findOf Traversal Bool Maybe find findOf folded ifindOf findOf Indexed simpler version that didn permit indexing would be findOf Getting Endo Maybe Bool Maybe findOf foldrOf if then Just else Nothing",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "findOf",
          "normalized": "Accessing a(Endo(Maybe b))c b-\u003ea b Bool-\u003ec-\u003eMaybe b",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p(Endo(Maybe a))s a-\u003ep a Bool-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:findOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the \u003ccode\u003e\u003ca\u003eFirst\u003c/a\u003e\u003c/code\u003e entry of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or retrieve \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result\n from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe answer is computed in a manner that leaks space less than \u003ccode\u003e\u003ccode\u003eala\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFirst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n and gives you back access to the outermost \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e constructor more quickly, but may have worse\n constant factors.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efirstOf traverse [1..10]\n\u003c/code\u003e\u003c/strong\u003eJust 1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efirstOf both (1,2)\n\u003c/code\u003e\u003c/strong\u003eJust 1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efirstOf ignored ()\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "firstOf",
          "package": "lens",
          "signature": "Getting (Leftmost a) s a -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#firstOf",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the First entry of Fold or Traversal or retrieve Just the result from Getter or Lens The answer is computed in manner that leaks space less than ala First foldMapOf and gives you back access to the outermost Just constructor more quickly but may have worse constant factors firstOf traverse Just firstOf both Just firstOf ignored Nothing firstOf Getter Maybe firstOf Fold Maybe firstOf Lens Maybe firstOf Iso Maybe firstOf Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "firstOf",
          "normalized": "Getting(Leftmost a)b a-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Leftmost a)s a-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:firstOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Fold",
          "name": "foldBy",
          "package": "lens",
          "signature": "(a -\u003e a -\u003e a) -\u003e a -\u003e t a -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldBy",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003eb a-\u003ea",
          "package": "lens",
          "partial": "By",
          "signature": "(a-\u003ea-\u003ea)-\u003ea-\u003et a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Fold",
          "name": "foldByOf",
          "package": "lens",
          "signature": "(forall i.  Getting (M a i) s a) -\u003e (a -\u003e a -\u003e a) -\u003e a -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldByOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldByOf",
          "normalized": "(a b Getting(M c d)e c)-\u003e(c-\u003ec-\u003ec)-\u003ec-\u003ee-\u003ec",
          "package": "lens",
          "partial": "By Of",
          "signature": "(forall i. Getting(M a i)s a)-\u003e(a-\u003ea-\u003ea)-\u003ea-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldByOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Fold",
          "name": "foldMapBy",
          "package": "lens",
          "signature": "(r -\u003e r -\u003e r) -\u003e r -\u003e (a -\u003e r) -\u003e t a -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldMapBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldMapBy",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003e(b-\u003ea)-\u003ec b-\u003ea",
          "package": "lens",
          "partial": "Map By",
          "signature": "(r-\u003er-\u003er)-\u003er-\u003e(a-\u003er)-\u003et a-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldMapBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Fold",
          "name": "foldMapByOf",
          "package": "lens",
          "signature": "(forall s.  Getting (M r s) t a) -\u003e (r -\u003e r -\u003e r) -\u003e r -\u003e (a -\u003e r) -\u003e t -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldMapByOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldMapByOf",
          "normalized": "(a b Getting(M c d)e f)-\u003e(c-\u003ec-\u003ec)-\u003ec-\u003e(f-\u003ec)-\u003ee-\u003ec",
          "package": "lens",
          "partial": "Map By Of",
          "signature": "(forall s. Getting(M r s)t a)-\u003e(r-\u003er-\u003er)-\u003er-\u003e(a-\u003er)-\u003et-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldMapByOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e l = \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r) -\u003e s -\u003e r\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e r s a -\u003e (a -\u003e r) -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldMapOf",
          "package": "lens",
          "signature": "Accessing p r s a -\u003e p a r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldMapOf",
          "type": "function"
        },
        "index": {
          "description": "foldMap foldMapOf folded foldMapOf views ifoldMapOf foldMapOf Indexed foldMapOf Getter foldMapOf Monoid Fold foldMapOf Lens foldMapOf Iso foldMapOf Monoid Traversal foldMapOf Monoid Prism foldMapOf Getting",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldMapOf",
          "normalized": "Accessing a b c d-\u003ea d b-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Map Of",
          "signature": "Accessing p r s a-\u003ep a r-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldMapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efold\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s m     -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s m       -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s m      -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s m       -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s m -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003efoldOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s m     -\u003e s -\u003e m\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldOf",
          "package": "lens",
          "signature": "Getting a s a -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldOf",
          "type": "function"
        },
        "index": {
          "description": "fold foldOf folded foldOf view foldOf Getter foldOf Monoid Fold foldOf Lens foldOf Iso foldOf Monoid Traversal foldOf Monoid Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldOf",
          "normalized": "Getting a b a-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting a s a-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e from any \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e indexed by ordinal position.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eJust 3^..folded\n\u003c/code\u003e\u003c/strong\u003e[3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eNothing^..folded\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[(1,2),(3,4)]^..folded.both\n\u003c/code\u003e\u003c/strong\u003e[1,2,3,4]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "folded",
          "package": "lens",
          "signature": "IndexedFold Int (f a) a",
          "source": "src/Control-Lens-Fold.html#folded",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold from any Foldable indexed by ordinal position Just folded Nothing folded folded.both",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "folded",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:folded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e from any \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e indexed by ordinal position.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "folded64",
          "package": "lens",
          "signature": "IndexedFold Int64 (f a) a",
          "source": "src/Control-Lens-Fold.html#folded64",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold from any Foldable indexed by ordinal position",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "folded64",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:folded64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by lifting an operation that returns a \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e result.\n\u003c/p\u003e\u003cp\u003eThis can be useful to lift operations from \u003ccode\u003eData.List\u003c/code\u003e and elsewhere into a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3,4]^..folding tail\n\u003c/code\u003e\u003c/strong\u003e[2,3,4]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "folding",
          "package": "lens",
          "signature": "(s -\u003e f a) -\u003e LensLike g s t a b",
          "source": "src/Control-Lens-Fold.html#folding",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by lifting an operation that returns Foldable result This can be useful to lift operations from Data.List and elsewhere into Fold folding tail",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "folding",
          "normalized": "(a-\u003eb c)-\u003eLensLike d a e c f",
          "package": "lens",
          "signature": "(s-\u003ef a)-\u003eLensLike g s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:folding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e that has no base case and thus may only be applied to lenses and structures such\n that the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e views at least one element of the structure.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efoldl1Of each (+) (1,2,3,4)\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e l f &#8801; \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e l\n \u003ccode\u003e\u003ca\u003efoldl1\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldl1Of",
          "package": "lens",
          "signature": "Getting (Dual (Endo (Maybe a))) s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldl1Of",
          "type": "function"
        },
        "index": {
          "description": "variant of foldlOf that has no base case and thus may only be applied to lenses and structures such that the Lens views at least one element of the structure foldl1Of each foldl1Of foldl1 toListOf foldl1 foldl1Of folded foldl1Of Getter foldl1Of Fold foldl1Of Iso foldl1Of Lens foldl1Of Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldl1Of",
          "normalized": "Getting(Dual(Endo(Maybe a)))b a-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Dual(Endo(Maybe a)))s a-\u003e(a-\u003ea-\u003ea)-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldl1Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e that has no base case and thus may only be applied\n to folds and structures such that the fold views at least one element of\n the structure.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl1Of'\u003c/a\u003e\u003c/code\u003e l f &#8801; \u003ccode\u003e\u003ca\u003efoldl1'\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e l\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldl1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldl1Of'",
          "package": "lens",
          "signature": "Getting (Endo (Endo (Maybe a))) s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldl1Of%27",
          "type": "function"
        },
        "index": {
          "description": "variant of foldlOf that has no base case and thus may only be applied to folds and structures such that the fold views at least one element of the structure foldl1Of foldl1 toListOf foldl1Of Getter foldl1Of Fold foldl1Of Iso foldl1Of Lens foldl1Of Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldl1Of'",
          "normalized": "Getting(Endo(Endo(Maybe a)))b a-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of'",
          "signature": "Getting(Endo(Endo(Maybe a)))s a-\u003e(a-\u003ea-\u003ea)-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldl1Of-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold over the elements of a structure, associating to the left,\n i.e. from left to right.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldlMOf",
          "package": "lens",
          "signature": "Getting (Endo (r -\u003e m r)) s a -\u003e (r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r",
          "source": "src/Control-Lens-Fold.html#foldlMOf",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over the elements of structure associating to the left i.e from left to right foldlM foldlMOf folded foldlMOf Monad Getter foldlMOf Monad Fold foldlMOf Monad Iso foldlMOf Monad Lens foldlMOf Monad Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldlMOf",
          "normalized": "Getting(Endo(a-\u003eb a))c d-\u003e(a-\u003ed-\u003eb a)-\u003ea-\u003ec-\u003eb a",
          "package": "lens",
          "partial": "MOf",
          "signature": "Getting(Endo(r-\u003em r))s a-\u003e(r-\u003ea-\u003em r)-\u003er-\u003es-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldlMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of the parts of a structure that are viewed through a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldlOf",
          "package": "lens",
          "signature": "Getting (Dual (Endo r)) s a -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldlOf",
          "type": "function"
        },
        "index": {
          "description": "Left-associative fold of the parts of structure that are viewed through Lens Getter Fold or Traversal foldl foldlOf folded foldlOf Getter foldlOf Fold foldlOf Lens foldlOf Iso foldlOf Traversal foldlOf Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldlOf",
          "normalized": "Getting(Dual(Endo a))b c-\u003e(a-\u003ec-\u003ea)-\u003ea-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Dual(Endo r))s a-\u003e(r-\u003ea-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldlOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold over the elements of a structure, associating to the left, but strictly.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl'\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldlOf'",
          "package": "lens",
          "signature": "Getting (Endo (Endo r)) s a -\u003e (r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldlOf%27",
          "type": "function"
        },
        "index": {
          "description": "Fold over the elements of structure associating to the left but strictly foldl foldlOf folded foldlOf Getter foldlOf Fold foldlOf Iso foldlOf Lens foldlOf Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldlOf'",
          "normalized": "Getting(Endo(Endo a))b c-\u003e(a-\u003ec-\u003ea)-\u003ea-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of'",
          "signature": "Getting(Endo(Endo r))s a-\u003e(r-\u003ea-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldlOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e that has no base case and thus may only be applied\n to lenses and structures such that the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e views at least one element of\n the structure.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efoldr1Of each (+) (1,2,3,4)\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e l f &#8801; \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e l\n \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldr1Of",
          "package": "lens",
          "signature": "Getting (Endo (Maybe a)) s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldr1Of",
          "type": "function"
        },
        "index": {
          "description": "variant of foldrOf that has no base case and thus may only be applied to lenses and structures such that the Lens views at least one element of the structure foldr1Of each foldr1Of foldr1 toListOf foldr1 foldr1Of folded foldr1Of Getter foldr1Of Fold foldr1Of Iso foldr1Of Lens foldr1Of Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldr1Of",
          "normalized": "Getting(Endo(Maybe a))b a-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(Maybe a))s a-\u003e(a-\u003ea-\u003ea)-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldr1Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA variant of \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e that has no base case and thus may only be applied\n to folds and structures such that the fold views at least one element of the\n structure.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr1Of\u003c/a\u003e\u003c/code\u003e l f &#8801; \u003ccode\u003e\u003ca\u003efoldr1\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e l\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003efoldr1Of'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldr1Of'",
          "package": "lens",
          "signature": "Getting (Dual (Endo (Endo (Maybe a)))) s a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#foldr1Of%27",
          "type": "function"
        },
        "index": {
          "description": "variant of foldrOf that has no base case and thus may only be applied to folds and structures such that the fold views at least one element of the structure foldr1Of foldr1 toListOf foldr1Of Getter foldr1Of Fold foldr1Of Iso foldr1Of Lens foldr1Of Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldr1Of'",
          "normalized": "Getting(Dual(Endo(Endo(Maybe a))))b a-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of'",
          "signature": "Getting(Dual(Endo(Endo(Maybe a))))s a-\u003e(a-\u003ea-\u003ea)-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldr1Of-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold over the elements of a structure, associating to the right,\n i.e. from right to left.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldrMOf",
          "package": "lens",
          "signature": "Getting (Dual (Endo (r -\u003e m r))) s a -\u003e (a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r",
          "source": "src/Control-Lens-Fold.html#foldrMOf",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over the elements of structure associating to the right i.e from right to left foldrM foldrMOf folded foldrMOf Monad Getter foldrMOf Monad Fold foldrMOf Monad Iso foldrMOf Monad Lens foldrMOf Monad Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldrMOf",
          "normalized": "Getting(Dual(Endo(a-\u003eb a)))c d-\u003e(d-\u003ea-\u003eb a)-\u003ea-\u003ec-\u003eb a",
          "package": "lens",
          "partial": "MOf",
          "signature": "Getting(Dual(Endo(r-\u003em r)))s a-\u003e(a-\u003er-\u003em r)-\u003er-\u003es-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldrMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of parts of a structure that are viewed through a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldrOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEndo\u003c/a\u003e\u003c/code\u003e r) s a -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldrOf",
          "package": "lens",
          "signature": "Accessing p (Endo r) s a -\u003e p a (r -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldrOf",
          "type": "function"
        },
        "index": {
          "description": "Right-associative fold of parts of structure that are viewed through Lens Getter Fold or Traversal foldr foldrOf folded foldrOf Getter foldrOf Fold foldrOf Lens foldrOf Iso foldrOf Traversal foldrOf Prism ifoldrOf foldrOf Indexed foldrOf Getting Endo",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldrOf",
          "normalized": "Accessing a(Endo b)c d-\u003ea d(b-\u003eb)-\u003eb-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p(Endo r)s a-\u003ep a(r-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldrOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrictly fold right over the elements of a structure.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr'\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "foldrOf'",
          "package": "lens",
          "signature": "Getting (Dual (Endo (Endo r))) s a -\u003e (a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#foldrOf%27",
          "type": "function"
        },
        "index": {
          "description": "Strictly fold right over the elements of structure foldr foldrOf folded foldrOf Getter foldrOf Fold foldrOf Iso foldrOf Lens foldrOf Traversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "foldrOf'",
          "normalized": "Getting(Dual(Endo(Endo a)))b c-\u003e(c-\u003ea-\u003ea)-\u003ea-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of'",
          "signature": "Getting(Dual(Endo(Endo r)))s a-\u003e(a-\u003er-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:foldrOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e with two of its arguments flipped.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eforMOf_ both (\"hello\",\"world\") putStrLn\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforM_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e (a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e (a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e (a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e (a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e (a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e (a -\u003e m r) -\u003e m ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "forMOf_",
          "package": "lens",
          "signature": "Accessing p (Sequenced r m) s a -\u003e s -\u003e p a (m r) -\u003e m ()",
          "source": "src/Control-Lens-Fold.html#forMOf_",
          "type": "function"
        },
        "index": {
          "description": "forMOf is mapMOf with two of its arguments flipped forMOf both hello world putStrLn hello world forM forMOf folded forMOf Monad Getter forMOf Monad Fold forMOf Monad Lens forMOf Monad Iso forMOf Monad Traversal forMOf Monad Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "forMOf_",
          "normalized": "Accessing a(Sequenced b c)d e-\u003ed-\u003ea e(c b)-\u003ec()",
          "package": "lens",
          "partial": "MOf",
          "signature": "Accessing p(Sequenced r m)s a-\u003es-\u003ep a(m r)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:forMOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse over all of the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e), computing an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e)-based answer,\n but unlike \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e do not construct a new structure. \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e generalizes\n \u003ccode\u003e\u003ca\u003efor_\u003c/a\u003e\u003c/code\u003e to work over any \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen passed a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e can work over any \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, but when passed a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e requires\n an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efor_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eforOf_ both (\"hello\",\"world\") putStrLn\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e\u003cp\u003eThe rather specific signature of \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e allows it to be used as if the signature was any of:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e l s &#8801; \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e l s \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e (a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e (a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e (a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e (a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e (a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e (a -\u003e f r) -\u003e f ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "forOf_",
          "package": "lens",
          "signature": "Accessing p (Traversed r f) s a -\u003e s -\u003e p a (f r) -\u003e f ()",
          "source": "src/Control-Lens-Fold.html#forOf_",
          "type": "function"
        },
        "index": {
          "description": "Traverse over all of the targets of Fold or Getter computing an Applicative or Functor based answer but unlike forOf do not construct new structure forOf generalizes for to work over any Fold When passed Getter forOf can work over any Functor but when passed Fold forOf requires an Applicative for forOf folded forOf both hello world putStrLn hello world The rather specific signature of forOf allows it to be used as if the signature was any of iforOf forOf Indexed forOf Functor Getter forOf Applicative Fold forOf Functor Lens forOf Functor Iso forOf Applicative Traversal forOf Applicative Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "forOf_",
          "normalized": "Accessing a(Traversed b c)d e-\u003ed-\u003ea e(c b)-\u003ec()",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p(Traversed r f)s a-\u003es-\u003ep a(f r)-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:forOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if this \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e matches 1 or more entries.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehas (element 0) []\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehas _Left (Left 12)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehas _Right (Left 12)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cp\u003eThis will always return \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehas _1 (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehas\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ehas\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ehas\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ehas\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ehas\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "has",
          "package": "lens",
          "signature": "Getting Any s a -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#has",
          "type": "function"
        },
        "index": {
          "description": "Check to see if this Fold or Traversal matches or more entries has element False has Left Left True has Right Left False This will always return True for Lens or Getter has hello world True has Getter Bool has Fold Bool has Iso Bool has Lens Bool has Traversal Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "has",
          "normalized": "Getting Any a b-\u003ea-\u003eBool",
          "package": "lens",
          "signature": "Getting Any s a-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:has"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if this \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e has no matches.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehasn't _Left (Right 12)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ehasn't _Left (Left 12)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "hasn't",
          "package": "lens",
          "signature": "Getting All s a -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#hasn%27t",
          "type": "function"
        },
        "index": {
          "description": "Check to see if this Fold or Traversal has no matches hasn Left Right True hasn Left Left False",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "hasn't",
          "normalized": "Getting All a b-\u003ea-\u003eBool",
          "package": "lens",
          "signature": "Getting All s a-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:hasn-39-t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: \u003ccode\u003e\u003ca\u003eheadOf\u003c/a\u003e\u003c/code\u003e will be removed after GHC 7.8 is released. (Use \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eA deprecated alias for \u003ccode\u003e\u003ca\u003efirstOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "headOf",
          "package": "lens",
          "signature": "Getting (First a) s a -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#headOf",
          "type": "function"
        },
        "index": {
          "description": "Deprecated headOf will be removed after GHC is released Use preview or firstOf deprecated alias for firstOf",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "headOf",
          "normalized": "Getting(First a)b a-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(First a)s a-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:headOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not all elements viewed through an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n satisfy a predicate, with access to the \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eallOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eiallOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiallOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "iallOf",
          "package": "lens",
          "signature": "IndexedGetting i All s a -\u003e (i -\u003e a -\u003e Bool) -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#iallOf",
          "type": "function"
        },
        "index": {
          "description": "Return whether or not all elements viewed through an IndexedFold or IndexedTraversal satisfy predicate with access to the When you don need access to the index then allOf is more flexible in what it accepts allOf iallOf const iallOf IndexedGetter Bool Bool iallOf IndexedFold Bool Bool iallOf IndexedLens Bool Bool iallOf IndexedTraversal Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "iallOf",
          "normalized": "IndexedGetting a All b c-\u003e(a-\u003ec-\u003eBool)-\u003eb-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i All s a-\u003e(i-\u003ea-\u003eBool)-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:iallOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not any element viewed through an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n satisfy a predicate, with access to the \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eianyOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eianyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eianyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eianyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eianyOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ianyOf",
          "package": "lens",
          "signature": "IndexedGetting i Any s a -\u003e (i -\u003e a -\u003e Bool) -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#ianyOf",
          "type": "function"
        },
        "index": {
          "description": "Return whether or not any element viewed through an IndexedFold or IndexedTraversal satisfy predicate with access to the When you don need access to the index then anyOf is more flexible in what it accepts anyOf ianyOf const ianyOf IndexedGetter Bool Bool ianyOf IndexedFold Bool Bool ianyOf IndexedLens Bool Bool ianyOf IndexedTraversal Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ianyOf",
          "normalized": "IndexedGetting a Any b c-\u003e(a-\u003ec-\u003eBool)-\u003eb-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i Any s a-\u003e(i-\u003ea-\u003eBool)-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ianyOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenate the results of a function of the elements of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n with access to the index.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e  is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econcatMapOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eiconcatMapOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiconcatMapOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiconcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003eiconcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003eiconcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e [r]) -\u003e s -\u003e [r]\n \u003ccode\u003e\u003ca\u003eiconcatMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e [r]) -\u003e s -\u003e [r]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "iconcatMapOf",
          "package": "lens",
          "signature": "IndexedGetting i [r] s a -\u003e (i -\u003e a -\u003e [r]) -\u003e s -\u003e [r]",
          "source": "src/Control-Lens-Fold.html#iconcatMapOf",
          "type": "function"
        },
        "index": {
          "description": "Concatenate the results of function of the elements of an IndexedFold or IndexedTraversal with access to the index When you don need access to the index then concatMapOf is more flexible in what it accepts concatMapOf iconcatMapOf const iconcatMapOf ifoldMapOf iconcatMapOf IndexedGetter iconcatMapOf IndexedFold iconcatMapOf IndexedLens iconcatMapOf IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "iconcatMapOf",
          "normalized": "IndexedGetting a[b]c d-\u003e(a-\u003ed-\u003e[b])-\u003ec-\u003e[b]",
          "package": "lens",
          "partial": "Map Of",
          "signature": "IndexedGetting i[r]s a-\u003e(i-\u003ea-\u003e[r])-\u003es-\u003e[r]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:iconcatMapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e by dropping elements from another \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e while a predicate holds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a    -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a -- see notes\n \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a         -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a -- see notes\n \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e\u003cp\u003eApplying \u003ccode\u003e\u003ca\u003eidroppingWhile\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e will still allow you to use it as a\n pseudo-\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e, but if you change the value of the targets to ones where the predicate returns\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, then you will break the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws and \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e fusion will no longer be sound.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "idroppingWhile",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e Optical (Indexed i) q (Compose (State Bool) f) s t a a -\u003e Optical p q f s t a a",
          "source": "src/Control-Lens-Fold.html#idroppingWhile",
          "type": "function"
        },
        "index": {
          "description": "Obtain an IndexedFold by dropping elements from another IndexedFold IndexedLens IndexedGetter or IndexedTraversal while predicate holds idroppingWhile Bool IndexedFold IndexedFold idroppingWhile Bool IndexedTraversal IndexedFold see notes idroppingWhile Bool IndexedLens IndexedFold see notes idroppingWhile Bool IndexedGetter IndexedFold idroppingWhile Bool IndexedMonadicFold IndexedMonadicFold idroppingWhile Bool IndexedAction IndexedMonadicFold Applying idroppingWhile to an IndexedLens or IndexedTraversal will still allow you to use it as pseudo IndexedTraversal but if you change the value of the targets to ones where the predicate returns True then you will break the Traversal laws and Traversal fusion will no longer be sound",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "idroppingWhile",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eOptical(Indexed a)c(Compose(State Bool)d)e f b b-\u003eOptical g c d e f b b",
          "package": "lens",
          "partial": "While",
          "signature": "(i-\u003ea-\u003eBool)-\u003eOptical(Indexed i)q(Compose(State Bool)f)s t a a-\u003eOptical p q f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:idroppingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e, obtaining an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[0,0,0,5,5,5]^..traversed.ifiltered (\\i a -\u003e i \u003c= a)\n\u003c/code\u003e\u003c/strong\u003e[0,5,5,5]\n\u003c/pre\u003e\u003cp\u003eCompose with \u003ccode\u003e\u003ca\u003efiltered\u003c/a\u003e\u003c/code\u003e to filter another \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003eIndexedIso\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e) with\n access to both the value and the index.\n\u003c/p\u003e\u003cp\u003eNote: As with \u003ccode\u003e\u003ca\u003efiltered\u003c/a\u003e\u003c/code\u003e, this is \u003cem\u003enot\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e, unless you are very careful not to invalidate the predicate on the target!\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifiltered",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e Optical' p (Indexed i) f a a",
          "source": "src/Control-Lens-Fold.html#ifiltered",
          "type": "function"
        },
        "index": {
          "description": "Filter an IndexedFold or IndexedGetter obtaining an IndexedFold traversed.ifiltered Compose with filtered to filter another IndexedLens IndexedIso IndexedGetter IndexedFold or IndexedTraversal with access to both the value and the index Note As with filtered this is not legal IndexedTraversal unless you are very careful not to invalidate the predicate on the target",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifiltered",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eOptical' c(Indexed a)d b b",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eBool)-\u003eOptical' p(Indexed i)f a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifiltered"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e function takes an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e, a monadic predicate that is also\n supplied the index, a structure and returns in the monad the left-most element of the structure\n matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003eifindMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifindMOf",
          "package": "lens",
          "signature": "IndexedGetting i (Endo (m (Maybe a))) s a -\u003e (i -\u003e a -\u003e m Bool) -\u003e s -\u003e m (Maybe a)",
          "source": "src/Control-Lens-Fold.html#ifindMOf",
          "type": "function"
        },
        "index": {
          "description": "The ifindMOf function takes an IndexedFold or IndexedTraversal monadic predicate that is also supplied the index structure and returns in the monad the left-most element of the structure matching the predicate or Nothing if there is no such element When you don need access to the index then findMOf is more flexible in what it accepts findMOf ifindMOf const ifindMOf Monad IndexedGetter Bool Maybe ifindMOf Monad IndexedFold Bool Maybe ifindMOf Monad IndexedLens Bool Maybe ifindMOf Monad IndexedTraversal Bool Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifindMOf",
          "normalized": "IndexedGetting a(Endo(b(Maybe c)))d c-\u003e(a-\u003ec-\u003eb Bool)-\u003ed-\u003eb(Maybe c)",
          "package": "lens",
          "partial": "MOf",
          "signature": "IndexedGetting i(Endo(m(Maybe a)))s a-\u003e(i-\u003ea-\u003em Bool)-\u003es-\u003em(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifindMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e function takes an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e, a predicate that is also\n supplied the index, a structure and returns the left-most element of the structure\n matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efindOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eifindOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifindOf",
          "package": "lens",
          "signature": "IndexedGetting i (Endo (Maybe a)) s a -\u003e (i -\u003e a -\u003e Bool) -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#ifindOf",
          "type": "function"
        },
        "index": {
          "description": "The ifindOf function takes an IndexedFold or IndexedTraversal predicate that is also supplied the index structure and returns the left-most element of the structure matching the predicate or Nothing if there is no such element When you don need access to the index then findOf is more flexible in what it accepts findOf ifindOf const ifindOf IndexedGetter Bool Maybe ifindOf IndexedFold Bool Maybe ifindOf IndexedLens Bool Maybe ifindOf IndexedTraversal Bool Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifindOf",
          "normalized": "IndexedGetting a(Endo(Maybe b))c b-\u003e(a-\u003eb-\u003eBool)-\u003ec-\u003eMaybe b",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i(Endo(Maybe a))s a-\u003e(i-\u003ea-\u003eBool)-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifindOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e by mapping indices and values to an arbitrary \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e with access\n to the \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e m) -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e m) -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e m) -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e m) -\u003e s -\u003e m\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldMapOf",
          "package": "lens",
          "signature": "IndexedGetting i m s a -\u003e (i -\u003e a -\u003e m) -\u003e s -\u003e m",
          "source": "src/Control-Lens-Fold.html#ifoldMapOf",
          "type": "function"
        },
        "index": {
          "description": "Fold an IndexedFold or IndexedTraversal by mapping indices and values to an arbitrary Monoid with access to the When you don need access to the index then foldMapOf is more flexible in what it accepts foldMapOf ifoldMapOf const ifoldMapOf IndexedGetter ifoldMapOf Monoid IndexedFold ifoldMapOf IndexedLens ifoldMapOf Monoid IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldMapOf",
          "normalized": "IndexedGetting a b c d-\u003e(a-\u003ed-\u003eb)-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Map Of",
          "signature": "IndexedGetting i m s a-\u003e(i-\u003ea-\u003em)-\u003es-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldMapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Fold",
          "name": "ifolding",
          "package": "lens",
          "signature": "(s -\u003e f (i, a)) -\u003e Over p g s t a b",
          "source": "src/Control-Lens-Fold.html#ifolding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifolding",
          "normalized": "(a-\u003eb(c,d))-\u003eOver e f a g d h",
          "package": "lens",
          "signature": "(s-\u003ef(i,a))-\u003eOver p g s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifolding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold over the elements of a structure with an index, associating to the left.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldlMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003eifoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003eifoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003eifoldlMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldlMOf",
          "package": "lens",
          "signature": "IndexedGetting i (Endo (r -\u003e m r)) s a -\u003e (i -\u003e r -\u003e a -\u003e m r) -\u003e r -\u003e s -\u003e m r",
          "source": "src/Control-Lens-Fold.html#ifoldlMOf",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over the elements of structure with an index associating to the left When you don need access to the index then foldlMOf is more flexible in what it accepts foldlMOf ifoldlMOf const ifoldlMOf Monad IndexedGetter ifoldlMOf Monad IndexedFold ifoldlMOf Monad IndexedLens ifoldlMOf Monad IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldlMOf",
          "normalized": "IndexedGetting a(Endo(b-\u003ec b))d e-\u003e(a-\u003eb-\u003ee-\u003ec b)-\u003eb-\u003ed-\u003ec b",
          "package": "lens",
          "partial": "MOf",
          "signature": "IndexedGetting i(Endo(r-\u003em r))s a-\u003e(i-\u003er-\u003ea-\u003em r)-\u003er-\u003es-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldlMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of the parts of a structure that are viewed through an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with\n access to the \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldlOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldlOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldlOf",
          "package": "lens",
          "signature": "IndexedGetting i (Dual (Endo r)) s a -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#ifoldlOf",
          "type": "function"
        },
        "index": {
          "description": "Left-associative fold of the parts of structure that are viewed through an IndexedFold or IndexedTraversal with access to the When you don need access to the index then foldlOf is more flexible in what it accepts foldlOf ifoldlOf const ifoldlOf IndexedGetter ifoldlOf IndexedFold ifoldlOf IndexedLens ifoldlOf IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldlOf",
          "normalized": "IndexedGetting a(Dual(Endo b))c d-\u003e(a-\u003eb-\u003ed-\u003eb)-\u003eb-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i(Dual(Endo r))s a-\u003e(i-\u003er-\u003ea-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldlOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold over the elements of a structure with an index, associating to the left, but \u003cem\u003estrictly\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldlOf'\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a         -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a        -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldlOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a   -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldlOf'",
          "package": "lens",
          "signature": "IndexedGetting i (Endo (r -\u003e r)) s a -\u003e (i -\u003e r -\u003e a -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#ifoldlOf%27",
          "type": "function"
        },
        "index": {
          "description": "Fold over the elements of structure with an index associating to the left but strictly When you don need access to the index then foldlOf is more flexible in what it accepts foldlOf ifoldlOf const ifoldlOf IndexedGetter ifoldlOf IndexedFold ifoldlOf IndexedLens ifoldlOf IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldlOf'",
          "normalized": "IndexedGetting a(Endo(b-\u003eb))c d-\u003e(a-\u003eb-\u003ed-\u003eb)-\u003eb-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Of'",
          "signature": "IndexedGetting i(Endo(r-\u003er))s a-\u003e(i-\u003er-\u003ea-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldlOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold right over the elements of a structure with an index.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldrMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003eifoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003eifoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n \u003ccode\u003e\u003ca\u003eifoldrMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldrMOf",
          "package": "lens",
          "signature": "IndexedGetting i (Dual (Endo (r -\u003e m r))) s a -\u003e (i -\u003e a -\u003e r -\u003e m r) -\u003e r -\u003e s -\u003e m r",
          "source": "src/Control-Lens-Fold.html#ifoldrMOf",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold right over the elements of structure with an index When you don need access to the index then foldrMOf is more flexible in what it accepts foldrMOf ifoldrMOf const ifoldrMOf Monad IndexedGetter ifoldrMOf Monad IndexedFold ifoldrMOf Monad IndexedLens ifoldrMOf Monad IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldrMOf",
          "normalized": "IndexedGetting a(Dual(Endo(b-\u003ec b)))d e-\u003e(a-\u003ee-\u003eb-\u003ec b)-\u003eb-\u003ed-\u003ec b",
          "package": "lens",
          "partial": "MOf",
          "signature": "IndexedGetting i(Dual(Endo(r-\u003em r)))s a-\u003e(i-\u003ea-\u003er-\u003em r)-\u003er-\u003es-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldrMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of parts of a structure that are viewed through an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with\n access to the \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldrOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldrOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldrOf",
          "package": "lens",
          "signature": "IndexedGetting i (Endo r) s a -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#ifoldrOf",
          "type": "function"
        },
        "index": {
          "description": "Right-associative fold of parts of structure that are viewed through an IndexedFold or IndexedTraversal with access to the When you don need access to the index then foldrOf is more flexible in what it accepts foldrOf ifoldrOf const ifoldrOf IndexedGetter ifoldrOf IndexedFold ifoldrOf IndexedLens ifoldrOf IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldrOf",
          "normalized": "IndexedGetting a(Endo b)c d-\u003e(a-\u003ed-\u003eb-\u003eb)-\u003eb-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i(Endo r)s a-\u003e(i-\u003ea-\u003er-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldrOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eStrictly\u003c/em\u003e fold right over the elements of a structure with an index.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrOf'\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldrOf'\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eifoldrOf'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ifoldrOf'",
          "package": "lens",
          "signature": "IndexedGetting i (Dual (Endo (r -\u003e r))) s a -\u003e (i -\u003e a -\u003e r -\u003e r) -\u003e r -\u003e s -\u003e r",
          "source": "src/Control-Lens-Fold.html#ifoldrOf%27",
          "type": "function"
        },
        "index": {
          "description": "Strictly fold right over the elements of structure with an index When you don need access to the index then foldrOf is more flexible in what it accepts foldrOf ifoldrOf const ifoldrOf IndexedGetter ifoldrOf IndexedFold ifoldrOf IndexedLens ifoldrOf IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ifoldrOf'",
          "normalized": "IndexedGetting a(Dual(Endo(b-\u003eb)))c d-\u003e(a-\u003ed-\u003eb-\u003eb)-\u003eb-\u003ec-\u003eb",
          "package": "lens",
          "partial": "Of'",
          "signature": "IndexedGetting i(Dual(Endo(r-\u003er)))s a-\u003e(i-\u003ea-\u003er-\u003er)-\u003er-\u003es-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ifoldrOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun monadic actions for each target of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index,\n discarding the results (with the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforMOf_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eimapMOf_\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e l a &#8801; \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e l a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e s -\u003e (i -\u003e a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eiforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e s -\u003e (i -\u003e a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eiforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e s -\u003e (i -\u003e a -\u003e m r) -\u003e m ()\n \u003ccode\u003e\u003ca\u003eiforMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e s -\u003e (i -\u003e a -\u003e m r) -\u003e m ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "iforMOf_",
          "package": "lens",
          "signature": "IndexedGetting i (Sequenced r m) s a -\u003e s -\u003e (i -\u003e a -\u003e m r) -\u003e m ()",
          "source": "src/Control-Lens-Fold.html#iforMOf_",
          "type": "function"
        },
        "index": {
          "description": "Run monadic actions for each target of an IndexedFold or IndexedTraversal with access to the index discarding the results with the arguments flipped iforMOf flip imapMOf When you don need access to the index then forMOf is more flexible in what it accepts forMOf iforMOf const iforMOf Monad IndexedGetter iforMOf Monad IndexedFold iforMOf Monad IndexedLens iforMOf Monad IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "iforMOf_",
          "normalized": "IndexedGetting a(Sequenced b c)d e-\u003ed-\u003e(a-\u003ee-\u003ec b)-\u003ec()",
          "package": "lens",
          "partial": "MOf",
          "signature": "IndexedGetting i(Sequenced r m)s a-\u003es-\u003e(i-\u003ea-\u003em r)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:iforMOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the targets of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index, discarding the results\n (with the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitraverseOf_\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforOf_\u003c/a\u003e\u003c/code\u003e l a &#8801; \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e l a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e s -\u003e (i -\u003e a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e s -\u003e (i -\u003e a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e s -\u003e (i -\u003e a -\u003e f r) -\u003e f ()\n \u003ccode\u003e\u003ca\u003eiforOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e s -\u003e (i -\u003e a -\u003e f r) -\u003e f ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "iforOf_",
          "package": "lens",
          "signature": "IndexedGetting i (Traversed r f) s a -\u003e s -\u003e (i -\u003e a -\u003e f r) -\u003e f ()",
          "source": "src/Control-Lens-Fold.html#iforOf_",
          "type": "function"
        },
        "index": {
          "description": "Traverse the targets of an IndexedFold or IndexedTraversal with access to the index discarding the results with the arguments flipped iforOf flip itraverseOf When you don need access to the index then forOf is more flexible in what it accepts forOf iforOf const iforOf Functor IndexedGetter iforOf Applicative IndexedFold iforOf Functor IndexedLens iforOf Applicative IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "iforOf_",
          "normalized": "IndexedGetting a(Traversed b c)d e-\u003ed-\u003e(a-\u003ee-\u003ec b)-\u003ec()",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i(Traversed r f)s a-\u003es-\u003e(i-\u003ea-\u003ef r)-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:iforOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun monadic actions for each target of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index,\n discarding the results.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eimapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003eimapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003eimapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003eimapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e m r) -\u003e s -\u003e m ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "imapMOf_",
          "package": "lens",
          "signature": "IndexedGetting i (Sequenced r m) s a -\u003e (i -\u003e a -\u003e m r) -\u003e s -\u003e m ()",
          "source": "src/Control-Lens-Fold.html#imapMOf_",
          "type": "function"
        },
        "index": {
          "description": "Run monadic actions for each target of an IndexedFold or IndexedTraversal with access to the index discarding the results When you don need access to the index then mapMOf is more flexible in what it accepts mapMOf imapMOf const imapMOf Monad IndexedGetter imapMOf Monad IndexedFold imapMOf Monad IndexedLens imapMOf Monad IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "imapMOf_",
          "normalized": "IndexedGetting a(Sequenced b c)d e-\u003e(a-\u003ee-\u003ec b)-\u003ed-\u003ec()",
          "package": "lens",
          "partial": "MOf",
          "signature": "IndexedGetting i(Sequenced r m)s a-\u003e(i-\u003ea-\u003em r)-\u003es-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:imapMOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not none of the elements viewed through an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n satisfy a predicate, with access to the \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003einoneOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003einoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003einoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003einoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003einoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "inoneOf",
          "package": "lens",
          "signature": "IndexedGetting i Any s a -\u003e (i -\u003e a -\u003e Bool) -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#inoneOf",
          "type": "function"
        },
        "index": {
          "description": "Return whether or not none of the elements viewed through an IndexedFold or IndexedTraversal satisfy predicate with access to the When you don need access to the index then noneOf is more flexible in what it accepts noneOf inoneOf const inoneOf IndexedGetter Bool Bool inoneOf IndexedFold Bool Bool inoneOf IndexedLens Bool Bool inoneOf IndexedTraversal Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "inoneOf",
          "normalized": "IndexedGetting a Any b c-\u003e(a-\u003ec-\u003eBool)-\u003eb-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i Any s a-\u003e(i-\u003ea-\u003eBool)-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:inoneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis converts an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e that returns the first index\n and element, if they exist, as a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a             -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a               -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i) s a -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i) s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ipre",
          "package": "lens",
          "signature": "IndexedGetting i (First (i, a)) s a -\u003e IndexPreservingGetter s (Maybe (i, a))",
          "source": "src/Control-Lens-Fold.html#ipre",
          "type": "function"
        },
        "index": {
          "description": "This converts an IndexedFold to an IndexPreservingGetter that returns the first index and element if they exist as Maybe ipre IndexedGetter IndexPreservingGetter Maybe ipre IndexedFold IndexPreservingGetter Maybe ipre Simple IndexedTraversal IndexPreservingGetter Maybe ipre Simple IndexedLens IndexPreservingGetter Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ipre",
          "normalized": "IndexedGetting a(First(a,b))c b-\u003eIndexPreservingGetter c(Maybe(a,b))",
          "package": "lens",
          "signature": "IndexedGetting i(First(i,a))s a-\u003eIndexPreservingGetter s(Maybe(i,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ipre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the first index and value targeted by an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index\n and result from an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e) into the current state.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreuse\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ipreuse",
          "package": "lens",
          "signature": "IndexedGetting i (First (i, a)) s a -\u003e m (Maybe (i, a))",
          "source": "src/Control-Lens-Fold.html#ipreuse",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the first index and value targeted by an IndexedFold or IndexedTraversal or Just the index and result from an IndexedGetter or IndexedLens into the current state ipreuse use ipre ipreuse MonadState IndexedGetter Maybe ipreuse MonadState IndexedFold Maybe ipreuse MonadState IndexedLens Maybe ipreuse MonadState IndexedTraversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ipreuse",
          "normalized": "IndexedGetting a(First(a,b))c b-\u003ed(Maybe(a,b))",
          "package": "lens",
          "signature": "IndexedGetting i(First(i,a))s a-\u003em(Maybe(i,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ipreuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve a function of the first index and value targeted by an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e (or a function of \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the index and result from an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e) into the current state.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreuses\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003eipreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003eipreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003eipreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ipreuses",
          "package": "lens",
          "signature": "IndexedGetting i (First r) s a -\u003e (i -\u003e a -\u003e r) -\u003e m (Maybe r)",
          "source": "src/Control-Lens-Fold.html#ipreuses",
          "type": "function"
        },
        "index": {
          "description": "Retrieve function of the first index and value targeted by an IndexedFold or IndexedTraversal or function of Just the index and result from an IndexedGetter or IndexedLens into the current state ipreuses uses ipre ipreuses MonadState IndexedGetter Maybe ipreuses MonadState IndexedFold Maybe ipreuses MonadState IndexedLens Maybe ipreuses MonadState IndexedTraversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ipreuses",
          "normalized": "IndexedGetting a(First b)c d-\u003e(a-\u003ed-\u003eb)-\u003ee(Maybe b)",
          "package": "lens",
          "signature": "IndexedGetting i(First r)s a-\u003e(i-\u003ea-\u003er)-\u003em(Maybe r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ipreuses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the first index and value targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result\n from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e). See also (\u003ccode\u003e\u003ca\u003e^@?\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis is usually applied in the \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(-\u003e) s\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a)\n\u003c/pre\u003e\u003cp\u003eHowever, it may be useful to think of its full generality when working with\n a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n \u003ccode\u003e\u003ca\u003eipreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (i, a))\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ipreview",
          "package": "lens",
          "signature": "IndexedGetting i (First (i, a)) s a -\u003e m (Maybe (i, a))",
          "source": "src/Control-Lens-Fold.html#ipreview",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the first index and value targeted by Fold or Traversal or Just the result from Getter or Lens See also ipreview view ipre This is usually applied in the Reader Monad ipreview IndexedGetter Maybe ipreview IndexedFold Maybe ipreview IndexedLens Maybe ipreview IndexedTraversal Maybe However it may be useful to think of its full generality when working with Monad transformer stack ipreview MonadReader IndexedGetter Maybe ipreview MonadReader IndexedFold Maybe ipreview MonadReader IndexedLens Maybe ipreview MonadReader IndexedTraversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ipreview",
          "normalized": "IndexedGetting a(First(a,b))c b-\u003ed(Maybe(a,b))",
          "package": "lens",
          "signature": "IndexedGetting i(First(i,a))s a-\u003em(Maybe(i,a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ipreview"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve a function of the first index and value targeted by an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result from an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e).\n See also (\u003ccode\u003e\u003ca\u003e^@?\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eipre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis is usually applied in the \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(-\u003e) s\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e r) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e r) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e r) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e r) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eHowever, it may be useful to think of its full generality when working with\n a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003eipreviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "ipreviews",
          "package": "lens",
          "signature": "IndexedGetting i (First r) s a -\u003e (i -\u003e a -\u003e r) -\u003e m (Maybe r)",
          "source": "src/Control-Lens-Fold.html#ipreviews",
          "type": "function"
        },
        "index": {
          "description": "Retrieve function of the first index and value targeted by an IndexedFold or IndexedTraversal or Just the result from an IndexedGetter or IndexedLens See also ipreviews views ipre This is usually applied in the Reader Monad ipreviews IndexedGetter Maybe ipreviews IndexedFold Maybe ipreviews IndexedLens Maybe ipreviews IndexedTraversal Maybe However it may be useful to think of its full generality when working with Monad transformer stack ipreviews MonadReader IndexedGetter Maybe ipreviews MonadReader IndexedFold Maybe ipreviews MonadReader IndexedLens Maybe ipreviews MonadReader IndexedTraversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "ipreviews",
          "normalized": "IndexedGetting a(First b)c d-\u003e(a-\u003ed-\u003eb)-\u003ee(Maybe b)",
          "package": "lens",
          "signature": "IndexedGetting i(First r)s a-\u003e(i-\u003ea-\u003er)-\u003em(Maybe r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:ipreviews"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e by taking elements from another\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e while a predicate holds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitakingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eitakingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a    -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eitakingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a         -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eitakingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eitakingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n \u003ccode\u003e\u003ca\u003eitakingWhile\u003c/a\u003e\u003c/code\u003e :: (i -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "itakingWhile",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e Optical (Indexed i) q (Const (Endo (f s))) s s a a -\u003e Optical p q f s s a a",
          "source": "src/Control-Lens-Fold.html#itakingWhile",
          "type": "function"
        },
        "index": {
          "description": "Obtain an IndexedFold by taking elements from another IndexedFold IndexedLens IndexedGetter or IndexedTraversal while predicate holds itakingWhile Bool IndexedFold IndexedFold itakingWhile Bool IndexedTraversal IndexedFold itakingWhile Bool IndexedLens IndexedFold itakingWhile Bool IndexedGetter IndexedFold itakingWhile Bool IndexedMonadicFold IndexedMonadicFold itakingWhile Bool IndexedAction IndexedMonadicFold",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "itakingWhile",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eOptical(Indexed a)c(Const(Endo(d e)))e e b b-\u003eOptical f c d e e b b",
          "package": "lens",
          "partial": "While",
          "signature": "(i-\u003ea-\u003eBool)-\u003eOptical(Indexed i)q(Const(Endo(f s)))s s a a-\u003eOptical p q f s s a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:itakingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ex \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eiterated\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e returns an infinite \u003ccode\u003e\u003ca\u003eFold1\u003c/a\u003e\u003c/code\u003e of repeated applications of \u003ccode\u003ef\u003c/code\u003e to \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eiterated\u003c/a\u003e\u003c/code\u003e f) a &#8801; \u003ccode\u003e\u003ca\u003eiterate\u003c/a\u003e\u003c/code\u003e f a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "iterated",
          "package": "lens",
          "signature": "(a -\u003e a) -\u003e Fold1 a a",
          "source": "src/Control-Lens-Fold.html#iterated",
          "type": "function"
        },
        "index": {
          "description": "iterated returns an infinite Fold1 of repeated applications of to toListOf iterated iterate",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "iterated",
          "normalized": "(a-\u003ea)-\u003eFold a a",
          "package": "lens",
          "signature": "(a-\u003ea)-\u003eFold a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:iterated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the key-value pairs from a structure.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the indices in the result, then \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitoListOf\u003c/a\u003e\u003c/code\u003e l\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitoListOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e s -\u003e [(i,a)]\n \u003ccode\u003e\u003ca\u003eitoListOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e s -\u003e [(i,a)]\n \u003ccode\u003e\u003ca\u003eitoListOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e s -\u003e [(i,a)]\n \u003ccode\u003e\u003ca\u003eitoListOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e s -\u003e [(i,a)]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "itoListOf",
          "package": "lens",
          "signature": "IndexedGetting i (Endo [(i, a)]) s a -\u003e s -\u003e [(i, a)]",
          "source": "src/Control-Lens-Fold.html#itoListOf",
          "type": "function"
        },
        "index": {
          "description": "Extract the key-value pairs from structure When you don need access to the indices in the result then toListOf is more flexible in what it accepts toListOf map fst itoListOf itoListOf IndexedGetter itoListOf IndexedFold itoListOf IndexedLens itoListOf IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "itoListOf",
          "normalized": "IndexedGetting a(Endo[(a,b)])c b-\u003ec-\u003e[(a,b)]",
          "package": "lens",
          "partial": "List Of",
          "signature": "IndexedGetting i(Endo[(i,a)])s a-\u003es-\u003e[(i,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:itoListOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the targets of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the \u003ccode\u003ei\u003c/code\u003e, discarding the results.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a     -\u003e (i -\u003e a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003eitraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a       -\u003e (i -\u003e a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003eitraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e (i -\u003e a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003eitraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i -\u003e a -\u003e f r) -\u003e s -\u003e f ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "itraverseOf_",
          "package": "lens",
          "signature": "IndexedGetting i (Traversed r f) s a -\u003e (i -\u003e a -\u003e f r) -\u003e s -\u003e f ()",
          "source": "src/Control-Lens-Fold.html#itraverseOf_",
          "type": "function"
        },
        "index": {
          "description": "Traverse the targets of an IndexedFold or IndexedTraversal with access to the discarding the results When you don need access to the index then traverseOf is more flexible in what it accepts traverseOf itraverseOf const itraverseOf Functor IndexedGetter itraverseOf Applicative IndexedFold itraverseOf Functor IndexedLens itraverseOf Applicative IndexedTraversal",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "itraverseOf_",
          "normalized": "IndexedGetting a(Traversed b c)d e-\u003e(a-\u003ee-\u003ec b)-\u003ed-\u003ec()",
          "package": "lens",
          "partial": "Of",
          "signature": "IndexedGetting i(Traversed r f)s a-\u003e(i-\u003ea-\u003ef r)-\u003es-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:itraverseOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the \u003ccode\u003e\u003ca\u003eLast\u003c/a\u003e\u003c/code\u003e entry of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or retrieve \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result\n from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe answer is computed in a manner that leaks space less than \u003ccode\u003e\u003ccode\u003eala\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLast\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n and gives you back access to the outermost \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e constructor more quickly, but may have worse\n constant factors.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elastOf traverse [1..10]\n\u003c/code\u003e\u003c/strong\u003eJust 10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elastOf both (1,2)\n\u003c/code\u003e\u003c/strong\u003eJust 2\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elastOf ignored ()\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "lastOf",
          "package": "lens",
          "signature": "Getting (Rightmost a) s a -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#lastOf",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the Last entry of Fold or Traversal or retrieve Just the result from Getter or Lens The answer is computed in manner that leaks space less than ala Last foldMapOf and gives you back access to the outermost Just constructor more quickly but may have worse constant factors lastOf traverse Just lastOf both Just lastOf ignored Nothing lastOf Getter Maybe lastOf Fold Maybe lastOf Lens Maybe lastOf Iso Maybe lastOf Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "lastOf",
          "normalized": "Getting(Rightmost a)b a-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Rightmost a)s a-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:lastOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the number of targets there are for a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e in a given container.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e This can be rather inefficient for large containers and just like \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e,\n this will not terminate for infinite folds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elengthOf _1 (\"hello\",())\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elengthOf traverse [1..10]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elengthOf (traverse.traverse) [[1,2],[3,4],[5,6]]\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e f, \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e g) =\u003e f (g a) -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "lengthOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo Int)) s a -\u003e s -\u003e Int",
          "source": "src/Control-Lens-Fold.html#lengthOf",
          "type": "function"
        },
        "index": {
          "description": "Calculate the number of targets there are for Fold in given container Note This can be rather inefficient for large containers and just like length this will not terminate for infinite folds length lengthOf folded lengthOf hello lengthOf traverse lengthOf traverse.traverse lengthOf folded folded Foldable Foldable Int lengthOf Getter Int lengthOf Fold Int lengthOf Lens Int lengthOf Iso Int lengthOf Traversal Int",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "lengthOf",
          "normalized": "Getting(Endo(Endo Int))a b-\u003ea-\u003eInt",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(Endo Int))s a-\u003es-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:lengthOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e over the individual \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elined\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elined\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elined\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003elined\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNote: This function type-checks as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e but it doesn't satisfy the laws. It's only valid to use it\n when you don't insert any newline characters while traversing, and if your original \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e contains only\n isolated newline characters.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "lined",
          "package": "lens",
          "signature": "IndexedLensLike' Int f String String",
          "source": "src/Control-Lens-Fold.html#lined",
          "type": "function"
        },
        "index": {
          "description": "Fold over the individual lines of String lined Fold String String lined Traversal String String lined IndexedFold Int String String lined IndexedTraversal Int String String Note This function type-checks as Traversal but it doesn satisfy the laws It only valid to use it when you don insert any newline characters while traversing and if your original String contains only isolated newline characters",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "lined",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:lined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each target of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e on a structure to a monadic action, evaluate these actions from left to right, and ignore the results.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapMOf_ both putStrLn (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e m r) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e m r) -\u003e s -\u003e m ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "mapMOf_",
          "package": "lens",
          "signature": "Accessing p (Sequenced r m) s a -\u003e p a (m r) -\u003e s -\u003e m ()",
          "source": "src/Control-Lens-Fold.html#mapMOf_",
          "type": "function"
        },
        "index": {
          "description": "Map each target of Fold on structure to monadic action evaluate these actions from left to right and ignore the results mapMOf both putStrLn hello world hello world mapM mapMOf folded mapMOf Monad Getter mapMOf Monad Fold mapMOf Monad Lens mapMOf Monad Iso mapMOf Monad Traversal mapMOf Monad Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "mapMOf_",
          "normalized": "Accessing a(Sequenced b c)d e-\u003ea e(c b)-\u003ed-\u003ec()",
          "package": "lens",
          "partial": "MOf",
          "signature": "Accessing p(Sequenced r m)s a-\u003ep a(m r)-\u003es-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:mapMOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the maximum element (if any) targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e,\n or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e according to a user supplied \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emaximumByOf traverse (compare `on` length) [\"mustard\",\"relish\",\"ham\"]\n\u003c/code\u003e\u003c/strong\u003eJust \"mustard\"\n\u003c/pre\u003e\u003cp\u003eIn the interest of efficiency, This operation has semantics more strict than strictly necessary.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emaximumBy\u003c/a\u003e\u003c/code\u003e cmp &#8801; \u003ccode\u003e\u003ca\u003efromMaybe\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e \"empty\") \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emaximumByOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e cmp\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emaximumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "maximumByOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo (Maybe a))) s a -\u003e (a -\u003e a -\u003e Ordering) -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#maximumByOf",
          "type": "function"
        },
        "index": {
          "description": "Obtain the maximum element if any targeted by Fold Traversal Lens Iso or Getter according to user supplied Ordering maximumByOf traverse compare on length mustard relish ham Just mustard In the interest of efficiency This operation has semantics more strict than strictly necessary maximumBy cmp fromMaybe error empty maximumByOf folded cmp maximumByOf Getter Ordering Maybe maximumByOf Fold Ordering Maybe maximumByOf Iso Ordering Maybe maximumByOf Lens Ordering Maybe maximumByOf Traversal Ordering Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "maximumByOf",
          "normalized": "Getting(Endo(Endo(Maybe a)))b a-\u003e(a-\u003ea-\u003eOrdering)-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "By Of",
          "signature": "Getting(Endo(Endo(Maybe a)))s a-\u003e(a-\u003ea-\u003eOrdering)-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:maximumByOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the maximum element (if any) targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e safely.\n\u003c/p\u003e\u003cp\u003eNote: \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e on a valid \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e will always return \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emaximumOf traverse [1..10]\n\u003c/code\u003e\u003c/strong\u003eJust 10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emaximumOf traverse []\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emaximumOf (folded.filtered even) [1,4,3,6,7,9,2]\n\u003c/code\u003e\u003c/strong\u003eJust 6\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emaximum\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efromMaybe\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e \"empty\") \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eIn the interest of efficiency, This operation has semantics more strict than strictly necessary.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003egetMax\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eMax\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e has lazier semantics but could leak memory.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "maximumOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo (Maybe a))) s a -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#maximumOf",
          "type": "function"
        },
        "index": {
          "description": "Obtain the maximum element if any targeted by Fold or Traversal safely Note maximumOf on valid Iso Lens or Getter will always return Just value maximumOf traverse Just maximumOf traverse Nothing maximumOf folded.filtered even Just maximum fromMaybe error empty maximumOf folded In the interest of efficiency This operation has semantics more strict than strictly necessary rmap getMax foldMapOf Max has lazier semantics but could leak memory maximumOf Ord Getter Maybe maximumOf Ord Fold Maybe maximumOf Ord Iso Maybe maximumOf Ord Lens Maybe maximumOf Ord Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "maximumOf",
          "normalized": "Getting(Endo(Endo(Maybe a)))b a-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(Endo(Maybe a)))s a-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:maximumOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the minimum element (if any) targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e according to a user supplied \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIn the interest of efficiency, This operation has semantics more strict than strictly necessary.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eminimumByOf traverse (compare `on` length) [\"mustard\",\"relish\",\"ham\"]\n\u003c/code\u003e\u003c/strong\u003eJust \"ham\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eminimumBy\u003c/a\u003e\u003c/code\u003e cmp &#8801; \u003ccode\u003e\u003ca\u003efromMaybe\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e \"empty\") \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eminimumByOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e cmp\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eminimumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumByOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a -\u003e \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "minimumByOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo (Maybe a))) s a -\u003e (a -\u003e a -\u003e Ordering) -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#minimumByOf",
          "type": "function"
        },
        "index": {
          "description": "Obtain the minimum element if any targeted by Fold Traversal Lens Iso or Getter according to user supplied Ordering In the interest of efficiency This operation has semantics more strict than strictly necessary minimumByOf traverse compare on length mustard relish ham Just ham minimumBy cmp fromMaybe error empty minimumByOf folded cmp minimumByOf Getter Ordering Maybe minimumByOf Fold Ordering Maybe minimumByOf Iso Ordering Maybe minimumByOf Lens Ordering Maybe minimumByOf Traversal Ordering Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "minimumByOf",
          "normalized": "Getting(Endo(Endo(Maybe a)))b a-\u003e(a-\u003ea-\u003eOrdering)-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "By Of",
          "signature": "Getting(Endo(Endo(Maybe a)))s a-\u003e(a-\u003ea-\u003eOrdering)-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:minimumByOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the minimum element (if any) targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e safely.\n\u003c/p\u003e\u003cp\u003eNote: \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e on a valid \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e will always return \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eminimumOf traverse [1..10]\n\u003c/code\u003e\u003c/strong\u003eJust 1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eminimumOf traverse []\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eminimumOf (folded.filtered even) [1,4,3,6,7,9,2]\n\u003c/code\u003e\u003c/strong\u003eJust 2\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eminimum\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efromMaybe\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e \"empty\") \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eIn the interest of efficiency, This operation has semantics more strict than strictly necessary.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003egetMin\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eMin\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e has lazier semantics but could leak memory.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "minimumOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo (Maybe a))) s a -\u003e s -\u003e Maybe a",
          "source": "src/Control-Lens-Fold.html#minimumOf",
          "type": "function"
        },
        "index": {
          "description": "Obtain the minimum element if any targeted by Fold or Traversal safely Note minimumOf on valid Iso Lens or Getter will always return Just value minimumOf traverse Just minimumOf traverse Nothing minimumOf folded.filtered even Just minimum fromMaybe error empty minimumOf folded In the interest of efficiency This operation has semantics more strict than strictly necessary rmap getMin foldMapOf Min has lazier semantics but could leak memory minimumOf Ord Getter Maybe minimumOf Ord Fold Maybe minimumOf Ord Iso Maybe minimumOf Ord Lens Maybe minimumOf Ord Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "minimumOf",
          "normalized": "Getting(Endo(Endo(Maybe a)))b a-\u003eb-\u003eMaybe a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(Endo(Maybe a)))s a-\u003es-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:minimumOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe sum of a collection of actions, generalizing \u003ccode\u003e\u003ca\u003econcatOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emsumOf both (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e\"helloworld\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emsumOf each (Nothing, Just \"hello\", Nothing)\n\u003c/code\u003e\u003c/strong\u003eJust \"hello\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emsum\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s (m a)     -\u003e s -\u003e m a\n \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s (m a)       -\u003e s -\u003e m a\n \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s (m a)      -\u003e s -\u003e m a\n \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s (m a)       -\u003e s -\u003e m a\n \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s (m a) -\u003e s -\u003e m a\n \u003ccode\u003e\u003ca\u003emsumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadPlus\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s (m a)     -\u003e s -\u003e m a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "msumOf",
          "package": "lens",
          "signature": "Getting (Endo (m a)) s (m a) -\u003e s -\u003e m a",
          "source": "src/Control-Lens-Fold.html#msumOf",
          "type": "function"
        },
        "index": {
          "description": "The sum of collection of actions generalizing concatOf msumOf both hello world helloworld msumOf each Nothing Just hello Nothing Just hello msum msumOf folded msumOf MonadPlus Getter msumOf MonadPlus Fold msumOf MonadPlus Lens msumOf MonadPlus Iso msumOf MonadPlus Traversal msumOf MonadPlus Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "msumOf",
          "normalized": "Getting(Endo(a b))c(a b)-\u003ec-\u003ea b",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(m a))s(m a)-\u003es-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:msumOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e only if no targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e satisfy a predicate.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enoneOf each (is _Nothing) (Just 3, Just 4, Just 5)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enoneOf (folded.folded) (\u003c10) [[13,99,20],[3,71,42]]\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003einoneOf\u003c/a\u003e\u003c/code\u003e l = \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enoneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "noneOf",
          "package": "lens",
          "signature": "Accessing p Any s a -\u003e p a Bool -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#noneOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True only if no targets of Fold satisfy predicate noneOf each is Nothing Just Just Just True noneOf folded.folded False inoneOf noneOf Indexed noneOf Getter Bool Bool noneOf Fold Bool Bool noneOf Lens Bool Bool noneOf Iso Bool Bool noneOf Traversal Bool Bool noneOf Prism Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "noneOf",
          "normalized": "Accessing a Any b c-\u003ea c Bool-\u003eb-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p Any s a-\u003ep a Bool-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:noneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes the element not occur anywhere within a given \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e of the structure?\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enotElemOf each 'd' ('a','b','c')\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enotElemOf each 'a' ('a','b','c')\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enotElem\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotElemOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "notElemOf",
          "package": "lens",
          "signature": "Getting All s a -\u003e a -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#notElemOf",
          "type": "function"
        },
        "index": {
          "description": "Does the element not occur anywhere within given Fold of the structure notElemOf each True notElemOf each False notElem notElemOf folded notElemOf Eq Getter Bool notElemOf Eq Fold Bool notElemOf Eq Iso Bool notElemOf Eq Lens Bool notElemOf Eq Traversal Bool notElemOf Eq Prism Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "notElemOf",
          "normalized": "Getting All a b-\u003eb-\u003ea-\u003eBool",
          "package": "lens",
          "partial": "Elem Of",
          "signature": "Getting All s a-\u003ea-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:notElemOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if this \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e has any targets in the given container.\n\u003c/p\u003e\u003cp\u003eA more \"conversational\" alias for this combinator is \u003ccode\u003e\u003ca\u003ehas\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e on a valid \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e should always return \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enull\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis may be rather inefficient compared to the \u003ccode\u003e\u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003enull\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e check of many containers.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enotNullOf _1 (1,2)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enotNullOf traverse [1..10]\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enotNullOf folded []\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enotNullOf (element 20) [1..10]\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e_1\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e f, \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e g) =\u003e f (g a, b) -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enotNullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "notNullOf",
          "package": "lens",
          "signature": "Getting Any s a -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#notNullOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True if this Fold or Traversal has any targets in the given container more conversational alias for this combinator is has Note notNullOf on valid Iso Lens or Getter should always return True null notNullOf folded This may be rather inefficient compared to the not null check of many containers notNullOf True notNullOf traverse True notNullOf folded False notNullOf element False notNullOf folded folded Foldable Foldable Bool notNullOf Getter Bool notNullOf Fold Bool notNullOf Iso Bool notNullOf Lens Bool notNullOf Traversal Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "notNullOf",
          "normalized": "Getting Any a b-\u003ea-\u003eBool",
          "package": "lens",
          "partial": "Null Of",
          "signature": "Getting Any s a-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:notNullOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if this \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e has no targets in the given container.\n\u003c/p\u003e\u003cp\u003eNote: \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e on a valid \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e should always return \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enull\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis may be rather inefficient compared to the \u003ccode\u003e\u003ca\u003enull\u003c/a\u003e\u003c/code\u003e check of many containers.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enullOf _1 (1,2)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enullOf ignored ()\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enullOf traverse []\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enullOf (element 20) [1..10]\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e_1\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e f, \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e g) =\u003e f (g a, b) -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003enullOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "nullOf",
          "package": "lens",
          "signature": "Getting All s a -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#nullOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True if this Fold or Traversal has no targets in the given container Note nullOf on valid Iso Lens or Getter should always return False null nullOf folded This may be rather inefficient compared to the null check of many containers nullOf False nullOf ignored True nullOf traverse True nullOf element True nullOf folded folded Foldable Foldable Bool nullOf Getter Bool nullOf Fold Bool nullOf Iso Bool nullOf Lens Bool nullOf Traversal Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "nullOf",
          "normalized": "Getting All a b-\u003ea-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting All s a-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:nullOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if any target of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eorOf both (True,False)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eorOf both (False,False)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eor\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eorOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "orOf",
          "package": "lens",
          "signature": "Getting Any s Bool -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Fold.html#orOf",
          "type": "function"
        },
        "index": {
          "description": "Returns True if any target of Fold is True orOf both True False True orOf both False False False or orOf folded orOf Getter Bool Bool orOf Fold Bool Bool orOf Lens Bool Bool orOf Iso Bool Bool orOf Traversal Bool Bool orOf Prism Bool Bool",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "orOf",
          "normalized": "Getting Any a Bool-\u003ea-\u003eBool",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting Any s Bool-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:orOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis converts a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e that returns the first element, if it\n exists, as a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a           -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a             -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s a     -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "pre",
          "package": "lens",
          "signature": "Getting (First a) s a -\u003e IndexPreservingGetter s (Maybe a)",
          "source": "src/Control-Lens-Fold.html#pre",
          "type": "function"
        },
        "index": {
          "description": "This converts Fold to IndexPreservingGetter that returns the first element if it exists as Maybe pre Getter IndexPreservingGetter Maybe pre Fold IndexPreservingGetter Maybe pre Simple Traversal IndexPreservingGetter Maybe pre Simple Lens IndexPreservingGetter Maybe pre Simple Iso IndexPreservingGetter Maybe pre Simple Prism IndexPreservingGetter Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "pre",
          "normalized": "Getting(First a)b a-\u003eIndexPreservingGetter b(Maybe a)",
          "package": "lens",
          "signature": "Getting(First a)s a-\u003eIndexPreservingGetter s(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:pre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the first value targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result\n from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e) into the current state.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreuse\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "preuse",
          "package": "lens",
          "signature": "Getting (First a) s a -\u003e m (Maybe a)",
          "source": "src/Control-Lens-Fold.html#preuse",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the first value targeted by Fold or Traversal or Just the result from Getter or Lens into the current state preuse use pre preuse MonadState Getter Maybe preuse MonadState Fold Maybe preuse MonadState Lens Maybe preuse MonadState Iso Maybe preuse MonadState Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "preuse",
          "normalized": "Getting(First a)b a-\u003ec(Maybe a)",
          "package": "lens",
          "signature": "Getting(First a)s a-\u003em(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:preuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve a function of the first value targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e) into the current state.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreuses\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003epreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003epreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003epreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n \u003ccode\u003e\u003ca\u003epreuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r) -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e r)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "preuses",
          "package": "lens",
          "signature": "Getting (First r) s a -\u003e (a -\u003e r) -\u003e m (Maybe r)",
          "source": "src/Control-Lens-Fold.html#preuses",
          "type": "function"
        },
        "index": {
          "description": "Retrieve function of the first value targeted by Fold or Traversal or Just the result from Getter or Lens into the current state preuses uses pre preuses MonadState Getter Maybe preuses MonadState Fold Maybe preuses MonadState Lens Maybe preuses MonadState Iso Maybe preuses MonadState Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "preuses",
          "normalized": "Getting(First a)b c-\u003e(c-\u003ea)-\u003ed(Maybe a)",
          "package": "lens",
          "signature": "Getting(First r)s a-\u003e(a-\u003er)-\u003em(Maybe r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:preuses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the first value targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result\n from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e). See also (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elistToMaybe\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis is usually applied in the \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(-\u003e) s\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epre\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e\u003cp\u003eHowever, it may be useful to think of its full generality when working with\n a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e m (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "preview",
          "package": "lens",
          "signature": "Getting (First a) s a -\u003e m (Maybe a)",
          "source": "src/Control-Lens-Fold.html#preview",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the first value targeted by Fold or Traversal or Just the result from Getter or Lens See also listToMaybe toList preview folded This is usually applied in the Reader Monad preview view pre preview Getter Maybe preview Fold Maybe preview Lens Maybe preview Iso Maybe preview Traversal Maybe However it may be useful to think of its full generality when working with Monad transformer stack preview MonadReader Getter Maybe preview MonadReader Fold Maybe preview MonadReader Lens Maybe preview MonadReader Iso Maybe preview MonadReader Traversal Maybe",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "preview",
          "normalized": "Getting(First a)b a-\u003ec(Maybe a)",
          "package": "lens",
          "signature": "Getting(First a)s a-\u003em(Maybe a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:preview"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve a function of the first value targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the result from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThis is usually applied in the \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e(-\u003e) s\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "previews",
          "package": "lens",
          "signature": "Getting (First r) s a -\u003e (a -\u003e r) -\u003e m (Maybe r)",
          "source": "src/Control-Lens-Fold.html#previews",
          "type": "function"
        },
        "index": {
          "description": "Retrieve function of the first value targeted by Fold or Traversal or Just the result from Getter or Lens This is usually applied in the Reader Monad",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "previews",
          "normalized": "Getting(First a)b c-\u003e(c-\u003ea)-\u003ed(Maybe a)",
          "package": "lens",
          "signature": "Getting(First r)s a-\u003e(a-\u003er)-\u003em(Maybe r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:previews"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the \u003ccode\u003e\u003ca\u003eProduct\u003c/a\u003e\u003c/code\u003e of every number targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eproductOf both (4,5)\n\u003c/code\u003e\u003c/strong\u003e20\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eproductOf folded [1,2,3,4,5]\n\u003c/code\u003e\u003c/strong\u003e120\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eproduct\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eproductOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "productOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo a)) s a -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#productOf",
          "type": "function"
        },
        "index": {
          "description": "Calculate the Product of every number targeted by Fold productOf both productOf folded product productOf folded",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "productOf",
          "normalized": "Getting(Endo(Endo a))b a-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(Endo a))s a-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:productOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForm a \u003ccode\u003e\u003ca\u003eFold1\u003c/a\u003e\u003c/code\u003e by repeating the input forever.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erepeat\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003erepeated\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etimingOut $ 5^..taking 20 repeated\n\u003c/code\u003e\u003c/strong\u003e[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "repeated",
          "package": "lens",
          "signature": "Fold1 a a",
          "source": "src/Control-Lens-Fold.html#repeated",
          "type": "function"
        },
        "index": {
          "description": "Form Fold1 by repeating the input forever repeat toListOf repeated timingOut taking repeated",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "repeated",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:repeated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that replicates its input \u003ccode\u003en\u003c/code\u003e times.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e n &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereplicated\u003c/a\u003e\u003c/code\u003e n)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^..replicated 20\n\u003c/code\u003e\u003c/strong\u003e[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "replicated",
          "package": "lens",
          "signature": "Int -\u003e Fold a a",
          "source": "src/Control-Lens-Fold.html#replicated",
          "type": "function"
        },
        "index": {
          "description": "Fold that replicates its input times replicate toListOf replicated replicated",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "replicated",
          "normalized": "Int-\u003eFold a a",
          "package": "lens",
          "signature": "Int-\u003eFold a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:replicated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in observed by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e on a structure from left to right, ignoring the results.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequenceA_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esequenceAOf_ both (putStrLn \"hello\",putStrLn \"world\")\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s (f a)     -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s (f a)       -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s (f a)      -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s (f a)       -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s (f a) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003esequenceAOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s (f a)     -\u003e s -\u003e f ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "sequenceAOf_",
          "package": "lens",
          "signature": "Getting (Traversed a f) s (f a) -\u003e s -\u003e f ()",
          "source": "src/Control-Lens-Fold.html#sequenceAOf_",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each action in observed by Fold on structure from left to right ignoring the results sequenceA sequenceAOf folded sequenceAOf both putStrLn hello putStrLn world hello world sequenceAOf Functor Getter sequenceAOf Applicative Fold sequenceAOf Functor Lens sequenceAOf Functor Iso sequenceAOf Applicative Traversal sequenceAOf Applicative Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "sequenceAOf_",
          "normalized": "Getting(Traversed a b)c(b a)-\u003ec-\u003eb()",
          "package": "lens",
          "partial": "AOf",
          "signature": "Getting(Traversed a f)s(f a)-\u003es-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:sequenceAOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each monadic action referenced by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e on the structure from left to right, and ignore the results.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esequenceOf_ both (putStrLn \"hello\",putStrLn \"world\")\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequence_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s (m a)     -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s (m a)       -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s (m a)      -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s (m a)       -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s (m a) -\u003e s -\u003e m ()\n \u003ccode\u003e\u003ca\u003esequenceOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s (m a)     -\u003e s -\u003e m ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "sequenceOf_",
          "package": "lens",
          "signature": "Getting (Sequenced a m) s (m a) -\u003e s -\u003e m ()",
          "source": "src/Control-Lens-Fold.html#sequenceOf_",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each monadic action referenced by Fold on the structure from left to right and ignore the results sequenceOf both putStrLn hello putStrLn world hello world sequence sequenceOf folded sequenceOf Monad Getter sequenceOf Monad Fold sequenceOf Monad Lens sequenceOf Monad Iso sequenceOf Monad Traversal sequenceOf Monad Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "sequenceOf_",
          "normalized": "Getting(Sequenced a b)c(b a)-\u003ec-\u003eb()",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Sequenced a m)s(m a)-\u003es-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:sequenceOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e of every number targeted by a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esumOf both (5,6)\n\u003c/code\u003e\u003c/strong\u003e11\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esumOf folded [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esumOf (folded.both) [(1,2),(3,4)]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Data.Lens\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esumOf biplate [(1::Int,[]),(2,[(3::Int,4::Int)])] :: Int\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis operation may be more strict than you would expect. If you\n want a lazier version use \u003ccode\u003e\u003ccode\u003eala\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e_1\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e (a, b) -\u003e a\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_1\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e f, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e f (a, b) -\u003e a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003esumOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "sumOf",
          "package": "lens",
          "signature": "Getting (Endo (Endo a)) s a -\u003e s -\u003e a",
          "source": "src/Control-Lens-Fold.html#sumOf",
          "type": "function"
        },
        "index": {
          "description": "Calculate the Sum of every number targeted by Fold sumOf both sumOf folded sumOf folded.both import Data.Data.Lens sumOf biplate Int Int Int Int sum sumOf folded This operation may be more strict than you would expect If you want lazier version use ala Sum foldMapOf sumOf Num sumOf folded Foldable Num sumOf Num Getter sumOf Num Fold sumOf Num Lens sumOf Num Iso sumOf Num Traversal sumOf Num Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "sumOf",
          "normalized": "Getting(Endo(Endo a))b a-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo(Endo a))s a-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:sumOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by taking elements from another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e while a predicate holds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etakeWhile\u003c/a\u003e\u003c/code\u003e p &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e p \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etimingOut $ toListOf (takingWhile (\u003c=3) folded) [1..]\n\u003c/code\u003e\u003c/strong\u003e[1,2,3]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a                   -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -- * See note below\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a                        -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -- * See note below\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -- * See note below\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -- * See note below\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a                     -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a                -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a -- * See note below\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a               -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a -- * See note below\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a                -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a              -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a            -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a       -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e When applied to a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etakingWhile\u003c/a\u003e\u003c/code\u003e yields something that can be used as if it were a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, but\n which is not a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e per the laws, unless you are careful to ensure that you do not invalidate the predicate when\n writing back through it.\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "takingWhile",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e Over p (TakingWhile p f a a) s t a a -\u003e Over p f s t a a",
          "source": "src/Control-Lens-Fold.html#takingWhile",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by taking elements from another Fold Lens Iso Getter or Traversal while predicate holds takeWhile toListOf takingWhile folded timingOut toListOf takingWhile folded takingWhile Bool Fold Fold takingWhile Bool Getter Fold takingWhile Bool Traversal Fold See note below takingWhile Bool Lens Fold See note below takingWhile Bool Prism Fold See note below takingWhile Bool Iso Fold See note below takingWhile Bool Action MonadicFold takingWhile Bool MonadicFold MonadicFold takingWhile Bool IndexedTraversal IndexedFold See note below takingWhile Bool IndexedLens IndexedFold See note below takingWhile Bool IndexedFold IndexedFold takingWhile Bool IndexedGetter IndexedFold takingWhile Bool IndexedAction IndexedMonadicFold takingWhile Bool IndexedMonadicFold IndexedMonadicFold Note When applied to Traversal takingWhile yields something that can be used as if it were Traversal but which is not Traversal per the laws unless you are careful to ensure that you do not invalidate the predicate when writing back through it",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "takingWhile",
          "normalized": "(a-\u003eBool)-\u003eOver b(TakingWhile b c a a)d e a a-\u003eOver b c d e a a",
          "package": "lens",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eOver p(TakingWhile p f a a)s t a a-\u003eOver p f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:takingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract a list of the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e. See also (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n (\u003ccode\u003e\u003ca\u003e^..\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "toListOf",
          "package": "lens",
          "signature": "Getting (Endo [a]) s a -\u003e s -\u003e [a]",
          "source": "src/Control-Lens-Fold.html#toListOf",
          "type": "function"
        },
        "index": {
          "description": "Extract list of the targets of Fold See also toList toListOf folded flip toListOf",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "toListOf",
          "normalized": "Getting(Endo[a])b a-\u003eb-\u003e[a]",
          "package": "lens",
          "partial": "List Of",
          "signature": "Getting(Endo[a])s a-\u003es-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:toListOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse over all of the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e), computing an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e)-based answer,\n but unlike \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e do not construct a new structure. \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e generalizes\n \u003ccode\u003e\u003ca\u003etraverse_\u003c/a\u003e\u003c/code\u003e to work over any \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen passed a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e can work over any \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, but when passed a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e requires\n an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverseOf_ both putStrLn (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003ehello\nworld\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverse_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e_2\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (c -\u003e f r) -\u003e (d, c) -\u003e f ()\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Left\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f b) -\u003e \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a c -\u003e f ()\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitraverseOf_\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThe rather specific signature of \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e allows it to be used as if the signature was any of:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e f r) -\u003e s -\u003e f ()\n \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e f r) -\u003e s -\u003e f ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "traverseOf_",
          "package": "lens",
          "signature": "Accessing p (Traversed r f) s a -\u003e p a (f r) -\u003e s -\u003e f ()",
          "source": "src/Control-Lens-Fold.html#traverseOf_",
          "type": "function"
        },
        "index": {
          "description": "Traverse over all of the targets of Fold or Getter computing an Applicative or Functor based answer but unlike traverseOf do not construct new structure traverseOf generalizes traverse to work over any Fold When passed Getter traverseOf can work over any Functor but when passed Fold traverseOf requires an Applicative traverseOf both putStrLn hello world hello world traverse traverseOf folded traverseOf Functor traverseOf Left Applicative Either itraverseOf traverseOf Indexed The rather specific signature of traverseOf allows it to be used as if the signature was any of traverseOf Functor Getter traverseOf Applicative Fold traverseOf Functor Lens traverseOf Functor Iso traverseOf Applicative Traversal traverseOf Applicative Prism",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "traverseOf_",
          "normalized": "Accessing a(Traversed b c)d e-\u003ea e(c b)-\u003ed-\u003ec()",
          "package": "lens",
          "partial": "Of",
          "signature": "Accessing p(Traversed r f)s a-\u003ep a(f r)-\u003es-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:traverseOf_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that unfolds its values from a seed.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunfolded\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e10^..unfolded (\\b -\u003e if b == 0 then Nothing else Just (b, b-1))\n\u003c/code\u003e\u003c/strong\u003e[10,9,8,7,6,5,4,3,2,1]\n\u003c/pre\u003e",
          "module": "Control.Lens.Fold",
          "name": "unfolded",
          "package": "lens",
          "signature": "(b -\u003e Maybe (a, b)) -\u003e Fold b a",
          "source": "src/Control-Lens-Fold.html#unfolded",
          "type": "function"
        },
        "index": {
          "description": "Build Fold that unfolds its values from seed unfoldr toListOf unfolded unfolded if then Nothing else Just b-1",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "unfolded",
          "normalized": "(a-\u003eMaybe(b,a))-\u003eFold a b",
          "package": "lens",
          "signature": "(b-\u003eMaybe(a,b))-\u003eFold b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:unfolded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e over the individual \u003ccode\u003e\u003ca\u003ewords\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eworded\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eworded\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eworded\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eworded\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNote: This function type-checks as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e but it doesn't satisfy the laws. It's only valid to use it\n when you don't insert any whitespace characters while traversing, and if your original \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e contains only\n isolated space characters (and no other characters that count as space, such as non-breaking spaces).\n\u003c/p\u003e",
          "module": "Control.Lens.Fold",
          "name": "worded",
          "package": "lens",
          "signature": "IndexedLensLike' Int f String String",
          "source": "src/Control-Lens-Fold.html#worded",
          "type": "function"
        },
        "index": {
          "description": "Fold over the individual words of String worded Fold String String worded Traversal String String worded IndexedFold Int String String worded IndexedTraversal Int String String Note This function type-checks as Traversal but it doesn satisfy the laws It only valid to use it when you don insert any whitespace characters while traversing and if your original String contains only isolated space characters and no other characters that count as space such as non-breaking spaces",
          "hierarchy": "Control Lens Fold",
          "module": "Control.Lens.Fold",
          "name": "worded",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Fold.html#v:worded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e is just any function \u003ccode\u003e(s -\u003e a)\u003c/code\u003e, which we've flipped\n into continuation passing style, \u003ccode\u003e(a -\u003e r) -\u003e s -\u003e r\u003c/code\u003e and decorated\n with \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e to obtain:\n\u003c/p\u003e\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e r s a = (a -\u003e \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e r a) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e r s\u003c/pre\u003e\u003cp\u003eIf we restrict access to knowledge about the type \u003ccode\u003er\u003c/code\u003e, we could get:\n\u003c/p\u003e\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a = forall r. \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e r s a\u003c/pre\u003e\u003cp\u003eBut we actually hide the use of \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e behind a class \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e to\n report error messages from type class resolution rather than at unification\n time, where they are much uglier.\n\u003c/p\u003e\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a = forall f. \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f a) -\u003e s -\u003e f s\u003c/pre\u003e\u003cp\u003eEverything you can do with a function, you can do with a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, but\n note that because of the continuation passing style (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) composes them\n in the opposite order.\n\u003c/p\u003e\u003cp\u003eSince it is only a function, every \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e obviously only retrieves a\n single value for a given input.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Getter",
          "name": "Getter",
          "package": "lens",
          "source": "src/Control-Lens-Getter.html",
          "type": "module"
        },
        "index": {
          "description": "Getter is just any function which we ve flipped into continuation passing style and decorated with Const to obtain type Getting Const Const If we restrict access to knowledge about the type we could get type Getter forall Getting But we actually hide the use of Const behind class Gettable to report error messages from type class resolution rather than at unification time where they are much uglier type Getter forall Gettable Everything you can do with function you can do with Getter but note that because of the continuation passing style composes them in the opposite order Since it is only function every Getter obviously only retrieves single value for given input",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Getter",
          "package": "lens",
          "partial": "Getter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient alias used when consuming (indexed) getters and (indexed) folds\n in a highly general fashion.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "Accessing",
          "package": "lens",
          "source": "src/Control-Lens-Getter.html#Accessing",
          "type": "type"
        },
        "index": {
          "description": "This is convenient alias used when consuming indexed getters and indexed folds in highly general fashion",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Accessing",
          "package": "lens",
          "partial": "Accessing",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Accessing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Getter",
          "name": "Const",
          "package": "lens",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Const",
          "package": "lens",
          "partial": "Const",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny instance should be subject to the following laws:\n\u003c/p\u003e\u003cpre\u003e contramap id = id\n contramap f . contramap g = contramap (g . f)\n\u003c/pre\u003e\u003cp\u003eNote, that the second law follows from the free theorem of the type of\n \u003ccode\u003e\u003ca\u003econtramap\u003c/a\u003e\u003c/code\u003e and the first law, so you need only check that the former\n condition holds.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "Contravariant",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "description": "Any instance should be subject to the following laws contramap id id contramap contramap contramap Note that the second law follows from the free theorem of the type of contramap and the first law so you need only check that the former condition holds",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Contravariant",
          "package": "lens",
          "partial": "Contravariant",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Contravariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is provided mostly for backwards compatibility with lens 3.8,\n but it can also shorten type signatures.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "Gettable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Getter.html#Gettable",
          "type": "class"
        },
        "index": {
          "description": "This class is provided mostly for backwards compatibility with lens but it can also shorten type signatures",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Gettable",
          "package": "lens",
          "partial": "Gettable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Gettable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e describes how to retrieve a single value in a way that can be\n composed with other \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e constructions.\n\u003c/p\u003e\u003cp\u003eUnlike a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e is read-only. Since a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e\n cannot be used to write back there are no \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws that can be applied to\n it. In fact, it is isomorphic to an arbitrary function from \u003ccode\u003e(s -\u003e a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMoreover, a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e can be used directly as a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e,\n since it just ignores the \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "Getter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Getter",
          "type": "type"
        },
        "index": {
          "description": "Getter describes how to retrieve single value in way that can be composed with other LensLike constructions Unlike Lens Getter is read-only Since Getter cannot be used to write back there are no Lens laws that can be applied to it In fact it is isomorphic to an arbitrary function from Moreover Getter can be used directly as Fold since it just ignores the Applicative",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Getter",
          "package": "lens",
          "partial": "Getter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Getter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this in a type signature it indicates that you can\n pass the function a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, or one of\n the indexed variants, and it will just \"do the right thing\".\n\u003c/p\u003e\u003cp\u003eMost \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e combinators are able to be used with both a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e in limited situations, to do so, they need to be\n monomorphic in what we are going to extract with \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e. To be compatible\n with \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e we also restricted choices of the irrelevant \u003ccode\u003et\u003c/code\u003e and\n \u003ccode\u003eb\u003c/code\u003e parameters.\n\u003c/p\u003e\u003cp\u003eIf a function accepts a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e r s a\u003c/code\u003e, then when \u003ccode\u003er\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e, then\n you can pass a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e), otherwise you can only pass this a\n \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "Getting",
          "package": "lens",
          "source": "src/Control-Lens-Getter.html#Getting",
          "type": "type"
        },
        "index": {
          "description": "When you see this in type signature it indicates that you can pass the function Lens Getter Traversal Fold Prism Iso or one of the indexed variants and it will just do the right thing Most Getter combinators are able to be used with both Getter or Fold in limited situations to do so they need to be monomorphic in what we are going to extract with Const To be compatible with Lens Traversal and Iso we also restricted choices of the irrelevant and parameters If function accepts Getting then when is Monoid then you can pass Fold or Traversal otherwise you can only pass this Getter or Lens",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Getting",
          "package": "lens",
          "partial": "Getting",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:Getting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e and can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "IndexedGetter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedGetter",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedGetter is valid IndexedFold and can be used for Getting like Getter",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "IndexedGetter",
          "package": "lens",
          "partial": "Indexed Getter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:IndexedGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to consume an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "IndexedGetting",
          "package": "lens",
          "source": "src/Control-Lens-Getter.html#IndexedGetting",
          "type": "type"
        },
        "index": {
          "description": "Used to consume an IndexedFold",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "IndexedGetting",
          "package": "lens",
          "partial": "Indexed Getting",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#t:IndexedGetting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView the value pointed to by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is the same operation as \u003ccode\u003e\u003ca\u003eiview\u003c/a\u003e\u003c/code\u003e with the arguments flipped.\n\u003c/p\u003e\u003cp\u003eThe fixity and semantics are such that subsequent field accesses can be\n performed with (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^@.\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a -\u003e (i, a)\n (\u003ccode\u003e\u003ca\u003e^@.\u003c/a\u003e\u003c/code\u003e) :: s -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a  -\u003e (i, a)\n\u003c/pre\u003e\u003cp\u003eThe result probably doesn't have much meaning when applied to an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Getter\",\"Control.Lens.Operators\"]",
          "name": "(^@.)",
          "package": "lens",
          "signature": "s -\u003e IndexedGetting i (i, a) s a -\u003e (i, a)",
          "source": "src/Control-Lens-Getter.html#%5E%40.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:-94--64-.\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--64-.\"]"
        },
        "index": {
          "description": "View the value pointed to by Getter or Lens This is the same operation as iview with the arguments flipped The fixity and semantics are such that subsequent field accesses can be performed with IndexedGetter IndexedLens The result probably doesn have much meaning when applied to an IndexedFold",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "(^@.) ^@.",
          "normalized": "a-\u003eIndexedGetting b(b,c)a c-\u003e(b,c)",
          "package": "lens",
          "signature": "s-\u003eIndexedGetting i(i,a)s a-\u003e(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:-94--64-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView the value pointed to by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or the\n result of folding over all the results of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that points at a monoidal values.\n\u003c/p\u003e\u003cp\u003eThis is the same operation as \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e with the arguments flipped.\n\u003c/p\u003e\u003cp\u003eThe fixity and semantics are such that subsequent field accesses can be\n performed with (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b)^._2\n\u003c/code\u003e\u003c/strong\u003eb\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\")^._2\n\u003c/code\u003e\u003c/strong\u003e\"world\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Complex\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e((0, 1 :+ 2), 3)^._1._2.to magnitude\n\u003c/code\u003e\u003c/strong\u003e2.23606797749979\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) ::             s -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e a\n (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e s -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s m       -\u003e m\n (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) ::             s -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a\n (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) ::             s -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a\n (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e s -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s m -\u003e m\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Getter\",\"Control.Lens.Operators\"]",
          "name": "(^.)",
          "package": "lens",
          "signature": "s -\u003e Getting a s a -\u003e a",
          "source": "src/Control-Lens-Getter.html#%5E.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:-94-.\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94-.\"]"
        },
        "index": {
          "description": "View the value pointed to by Getter or Lens or the result of folding over all the results of Fold or Traversal that points at monoidal values This is the same operation as view with the arguments flipped The fixity and semantics are such that subsequent field accesses can be performed with hello world world import Data.Complex to magnitude Getter Monoid Fold Iso Lens Monoid Traversal",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "(^.) ^.",
          "normalized": "a-\u003eGetting b a b-\u003eb",
          "package": "lens",
          "signature": "s-\u003eGetting a s a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:-94-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Getter",
          "name": "Const",
          "package": "lens",
          "signature": "Const",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "Const",
          "package": "lens",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis Generalizes \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e so we can apply simple \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e\n transformations to it and so we can get nicer error messages.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e you can \u003ccode\u003e\u003ca\u003ecoerce\u003c/a\u003e\u003c/code\u003e ignores its argument, which it carries solely as a\n phantom type parameter.\n\u003c/p\u003e\u003cp\u003eBy the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e laws, an instance of \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e will necessarily satisfy:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003ecoerce\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003econtramap\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e",
          "module": "[\"Control.Lens.Getter\",\"Control.Lens.Internal.Getter\"]",
          "name": "coerce",
          "package": "lens",
          "signature": "f a -\u003e f b",
          "source": "src/Control-Lens-Internal-Getter.html#coerce",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:coerce\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#v:coerce\"]"
        },
        "index": {
          "description": "This Generalizes Const so we can apply simple Applicative transformations to it and so we can get nicer error messages Functor you can coerce ignores its argument which it carries solely as phantom type parameter By the Functor and Contravariant laws an instance of Gettable will necessarily satisfy id fmap coerce contramap",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "coerce",
          "normalized": "a b-\u003ea c",
          "package": "lens",
          "signature": "f a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:coerce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCoerce a \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e to a \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e. This is useful\n when using a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that is not simple as a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "coerced",
          "package": "lens",
          "signature": "LensLike f s t a b -\u003e LensLike' f s a",
          "source": "src/Control-Lens-Getter.html#coerced",
          "type": "function"
        },
        "index": {
          "description": "Coerce Gettable LensLike to Simple LensLike This is useful when using Traversal that is not simple as Getter or Fold",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "coerced",
          "normalized": "LensLike a b c d e-\u003eLensLike' a b d",
          "package": "lens",
          "signature": "LensLike f s t a b-\u003eLensLike' f s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:coerced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Getter",
          "name": "contramap",
          "package": "lens",
          "signature": "(a -\u003e b) -\u003e f b -\u003e f a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "contramap",
          "normalized": "(a-\u003eb)-\u003ec b-\u003ec a",
          "package": "lens",
          "signature": "(a-\u003eb)-\u003ef b-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:contramap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Getter",
          "name": "getConst",
          "package": "lens",
          "signature": "a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "getConst",
          "package": "lens",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:getConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalized form of \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e that only extracts the portion of\n the log that is focused on by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e. If given a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n then a monoidal summary of the parts of the log that are visited will be\n returned.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eilistening\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i w u     -\u003e m a -\u003e m (a, (i, u))\n \u003ccode\u003e\u003ca\u003eilistening\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i w u      -\u003e m a -\u003e m (a, (i, u))\n \u003ccode\u003e\u003ca\u003eilistening\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e u) =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i w u       -\u003e m a -\u003e m (a, (i, u))\n \u003ccode\u003e\u003ca\u003eilistening\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e u) =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i w u -\u003e m a -\u003e m (a, (i, u))\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "ilistening",
          "package": "lens",
          "signature": "IndexedGetting i (i, u) w u -\u003e m a -\u003e m (a, (i, u))",
          "source": "src/Control-Lens-Getter.html#ilistening",
          "type": "function"
        },
        "index": {
          "description": "This is generalized form of listen that only extracts the portion of the log that is focused on by Getter If given Fold or Traversal then monoidal summary of the parts of the log that are visited will be returned ilistening MonadWriter IndexedGetter ilistening MonadWriter IndexedLens ilistening MonadWriter Monoid IndexedFold ilistening MonadWriter Monoid IndexedTraversal",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "ilistening",
          "normalized": "IndexedGetting a(a,b)c b-\u003ed e-\u003ed(e,(a,b))",
          "package": "lens",
          "signature": "IndexedGetting i(i,u)w u-\u003em a-\u003em(a,(i,u))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:ilistening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalized form of \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e that only extracts the portion of\n the log that is focused on by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e. If given a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n then a monoidal summary of the parts of the log that are visited will be\n returned.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eilistenings\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e w u     -\u003e (i -\u003e u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003eilistenings\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e w u      -\u003e (i -\u003e u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003eilistenings\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e v) =\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e w u       -\u003e (i -\u003e u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003eilistenings\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e v) =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e w u -\u003e (i -\u003e u -\u003e v) -\u003e m a -\u003e m (a, v)\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "ilistenings",
          "package": "lens",
          "signature": "IndexedGetting i v w u -\u003e (i -\u003e u -\u003e v) -\u003e m a -\u003e m (a, v)",
          "source": "src/Control-Lens-Getter.html#ilistenings",
          "type": "function"
        },
        "index": {
          "description": "This is generalized form of listen that only extracts the portion of the log that is focused on by Getter If given Fold or Traversal then monoidal summary of the parts of the log that are visited will be returned ilistenings MonadWriter IndexedGetter ilistenings MonadWriter IndexedLens ilistenings MonadWriter Monoid IndexedFold ilistenings MonadWriter Monoid IndexedTraversal",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "ilistenings",
          "normalized": "IndexedGetting a b c d-\u003e(a-\u003ed-\u003eb)-\u003ee f-\u003ee(f,b)",
          "package": "lens",
          "signature": "IndexedGetting i v w u-\u003e(i-\u003eu-\u003ev)-\u003em a-\u003em(a,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:ilistenings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Getter",
          "name": "ito",
          "package": "lens",
          "signature": "(s -\u003e (i, a)) -\u003e IndexedGetter i s a",
          "source": "src/Control-Lens-Getter.html#ito",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "ito",
          "normalized": "(a-\u003e(b,c))-\u003eIndexedGetter b a c",
          "package": "lens",
          "signature": "(s-\u003e(i,a))-\u003eIndexedGetter i s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:ito"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the index and value of an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e into the current state as a pair.\n\u003c/p\u003e\u003cp\u003eWhen applied to an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e the result will most likely be a nonsensical monoidal summary of\n the indices tupled with a monoidal summary of the values and probably not whatever it is you wanted.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "iuse",
          "package": "lens",
          "signature": "IndexedGetting i (i, a) s a -\u003e m (i, a)",
          "source": "src/Control-Lens-Getter.html#iuse",
          "type": "function"
        },
        "index": {
          "description": "Use the index and value of an IndexedGetter into the current state as pair When applied to an IndexedFold the result will most likely be nonsensical monoidal summary of the indices tupled with monoidal summary of the values and probably not whatever it is you wanted",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "iuse",
          "normalized": "IndexedGetting a(a,b)c b-\u003ed(a,b)",
          "package": "lens",
          "signature": "IndexedGetting i(i,a)s a-\u003em(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:iuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a function of the index and value of an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e into the current state.\n\u003c/p\u003e\u003cp\u003eWhen applied to an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e the result will be a monoidal summary instead of a single answer.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "iuses",
          "package": "lens",
          "signature": "IndexedGetting i r s a -\u003e (i -\u003e a -\u003e r) -\u003e m r",
          "source": "src/Control-Lens-Getter.html#iuses",
          "type": "function"
        },
        "index": {
          "description": "Use function of the index and value of an IndexedGetter into the current state When applied to an IndexedFold the result will be monoidal summary instead of single answer",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "iuses",
          "normalized": "IndexedGetting a b c d-\u003e(a-\u003ed-\u003eb)-\u003ee b",
          "package": "lens",
          "signature": "IndexedGetting i r s a-\u003e(i-\u003ea-\u003er)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:iuses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView the index and value of an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e into the current environment as a pair.\n\u003c/p\u003e\u003cp\u003eWhen applied to an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e the result will most likely be a nonsensical monoidal summary of\n the indices tupled with a monoidal summary of the values and probably not whatever it is you wanted.\n\u003c/p\u003e",
          "module": "Control.Lens.Getter",
          "name": "iview",
          "package": "lens",
          "signature": "IndexedGetting i (i, a) s a -\u003e m (i, a)",
          "source": "src/Control-Lens-Getter.html#iview",
          "type": "function"
        },
        "index": {
          "description": "View the index and value of an IndexedGetter into the current environment as pair When applied to an IndexedFold the result will most likely be nonsensical monoidal summary of the indices tupled with monoidal summary of the values and probably not whatever it is you wanted",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "iview",
          "normalized": "IndexedGetting a(a,b)c b-\u003ed(a,b)",
          "package": "lens",
          "signature": "IndexedGetting i(i,a)s a-\u003em(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:iview"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView a function of the index and value of an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e into the current environment.\n\u003c/p\u003e\u003cp\u003eWhen applied to an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e the result will be a monoidal summary instead of a single answer.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiviews\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldMapOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "iviews",
          "package": "lens",
          "signature": "IndexedGetting i r s a -\u003e (i -\u003e a -\u003e r) -\u003e m r",
          "source": "src/Control-Lens-Getter.html#iviews",
          "type": "function"
        },
        "index": {
          "description": "View function of the index and value of an IndexedGetter into the current environment When applied to an IndexedFold the result will be monoidal summary instead of single answer iviews ifoldMapOf",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "iviews",
          "normalized": "IndexedGetting a b c d-\u003e(a-\u003ed-\u003eb)-\u003ee b",
          "package": "lens",
          "signature": "IndexedGetting i r s a-\u003e(i-\u003ea-\u003er)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:iviews"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalized form of \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e that only extracts the portion of\n the log that is focused on by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e. If given a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n then a monoidal summary of the parts of the log that are visited will be\n returned.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elistening\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e w u     -\u003e m a -\u003e m (a, u)\n \u003ccode\u003e\u003ca\u003elistening\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e w u      -\u003e m a -\u003e m (a, u)\n \u003ccode\u003e\u003ca\u003elistening\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e w u       -\u003e m a -\u003e m (a, u)\n \u003ccode\u003e\u003ca\u003elistening\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e u) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e w u       -\u003e m a -\u003e m (a, u)\n \u003ccode\u003e\u003ca\u003elistening\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e u) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e w u -\u003e m a -\u003e m (a, u)\n \u003ccode\u003e\u003ca\u003elistening\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e u) =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e w u     -\u003e m a -\u003e m (a, u)\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "listening",
          "package": "lens",
          "signature": "Getting u w u -\u003e m a -\u003e m (a, u)",
          "source": "src/Control-Lens-Getter.html#listening",
          "type": "function"
        },
        "index": {
          "description": "This is generalized form of listen that only extracts the portion of the log that is focused on by Getter If given Fold or Traversal then monoidal summary of the parts of the log that are visited will be returned listening MonadWriter Getter listening MonadWriter Lens listening MonadWriter Iso listening MonadWriter Monoid Fold listening MonadWriter Monoid Traversal listening MonadWriter Monoid Prism",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "listening",
          "normalized": "Getting a b a-\u003ec d-\u003ec(d,a)",
          "package": "lens",
          "signature": "Getting u w u-\u003em a-\u003em(a,u)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:listening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalized form of \u003ccode\u003e\u003ca\u003elisten\u003c/a\u003e\u003c/code\u003e that only extracts the portion of\n the log that is focused on by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e. If given a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n then a monoidal summary of the parts of the log that are visited will be\n returned.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elistenings\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e w u     -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003elistenings\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e w u      -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003elistenings\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e w u       -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003elistenings\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e v) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e w u       -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003elistenings\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e v) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e w u -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)\n \u003ccode\u003e\u003ca\u003elistenings\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e w m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e v) =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e w u     -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "listenings",
          "package": "lens",
          "signature": "Getting v w u -\u003e (u -\u003e v) -\u003e m a -\u003e m (a, v)",
          "source": "src/Control-Lens-Getter.html#listenings",
          "type": "function"
        },
        "index": {
          "description": "This is generalized form of listen that only extracts the portion of the log that is focused on by Getter If given Fold or Traversal then monoidal summary of the parts of the log that are visited will be returned listenings MonadWriter Getter listenings MonadWriter Lens listenings MonadWriter Iso listenings MonadWriter Monoid Fold listenings MonadWriter Monoid Traversal listenings MonadWriter Monoid Prism",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "listenings",
          "normalized": "Getting a b c-\u003e(c-\u003ea)-\u003ed e-\u003ed(e,a)",
          "package": "lens",
          "signature": "Getting v w u-\u003e(u-\u003ev)-\u003em a-\u003em(a,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:listenings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e from an arbitrary Haskell function.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e g &#8801; \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e (g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f)\n\u003c/pre\u003e\u003cpre\u003e\n a \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e f &#8801; f a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea ^.to f\n\u003c/code\u003e\u003c/strong\u003ef a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\")^.to snd\n\u003c/code\u003e\u003c/strong\u003e\"world\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.to succ\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(0, -5)^._2.to abs\n\u003c/code\u003e\u003c/strong\u003e5\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "to",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e IndexPreservingGetter s a",
          "source": "src/Control-Lens-Getter.html#to",
          "type": "function"
        },
        "index": {
          "description": "Build Getter from an arbitrary Haskell function to to to to to hello world to snd world to succ to abs",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "to",
          "normalized": "(a-\u003eb)-\u003eIndexPreservingGetter a b",
          "package": "lens",
          "signature": "(s-\u003ea)-\u003eIndexPreservingGetter s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:to"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, or\n \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e in the current state, or use a summary of a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that points\n to a monoidal value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (use _1) (a,b)\n\u003c/code\u003e\u003c/strong\u003ea\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (use _1) (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e m a\n \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s r       -\u003e m r\n \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e m a\n \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e m a\n \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "use",
          "package": "lens",
          "signature": "Getting a s a -\u003e m a",
          "source": "src/Control-Lens-Getter.html#use",
          "type": "function"
        },
        "index": {
          "description": "Use the target of Lens Iso or Getter in the current state or use summary of Fold or Traversal that points to monoidal value evalState use evalState use hello world hello use MonadState Getter use MonadState Monoid Fold use MonadState Iso use MonadState Lens use MonadState Monoid Traversal",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "use",
          "normalized": "Getting a b a-\u003ec a",
          "package": "lens",
          "signature": "Getting a s a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:use"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e in the current state, or use a summary of a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that\n points to a monoidal value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (uses _1 length) (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e5\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r) -\u003e m r\n \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e m r\n \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r) -\u003e m r\n \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e m r\n \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r) -\u003e m r\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e r s t a b -\u003e (a -\u003e r) -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "uses",
          "package": "lens",
          "signature": "Optical p (-\u003e) (Const r) s s a a -\u003e p a r -\u003e m r",
          "source": "src/Control-Lens-Getter.html#uses",
          "type": "function"
        },
        "index": {
          "description": "Use the target of Lens Iso or Getter in the current state or use summary of Fold or Traversal that points to monoidal value evalState uses length hello world uses MonadState Getter uses MonadState Monoid Fold uses MonadState Lens uses MonadState Iso uses MonadState Monoid Traversal uses MonadState Getting",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "uses",
          "normalized": "Optical a(-\u003e)(Const b)c c d d-\u003ea d b-\u003ee b",
          "package": "lens",
          "signature": "Optical p(-\u003e)(Const r)s s a a-\u003ep a r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:uses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView the value pointed to by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or the result of folding over all the results of a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that points\n at a monoidal value.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eview (to f) a\n\u003c/code\u003e\u003c/strong\u003ef a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eview _2 (1,\"hello\")\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eview (to succ) 5\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eview (_2._1) (\"hello\",(\"world\",\"!!!\"))\n\u003c/code\u003e\u003c/strong\u003e\"world\"\n\u003c/pre\u003e\u003cp\u003eAs \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e is commonly used to access the target of a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or obtain a monoidal summary of the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e,\n It may be useful to think of it as having one of these more restricted signatures:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s m       -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s m -\u003e s -\u003e m\n\u003c/pre\u003e\u003cp\u003eIn a more general setting, such as when working with a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack you can use:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e m a\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "view",
          "package": "lens",
          "signature": "Getting a s a -\u003e m a",
          "source": "src/Control-Lens-Getter.html#view",
          "type": "function"
        },
        "index": {
          "description": "View the value pointed to by Getter Iso or Lens or the result of folding over all the results of Fold or Traversal that points at monoidal value view to id view to view hello hello view to succ view hello world world As view is commonly used to access the target of Getter or obtain monoidal summary of the targets of Fold It may be useful to think of it as having one of these more restricted signatures view Getter view Monoid Fold view Iso view Lens view Monoid Traversal In more general setting such as when working with Monad transformer stack you can use view MonadReader Getter view MonadReader Monoid Fold view MonadReader Iso view MonadReader Lens view MonadReader Monoid Traversal",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "view",
          "normalized": "Getting a b a-\u003ec a",
          "package": "lens",
          "signature": "Getting a s a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:view"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView a function of the value pointed to by a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or the result of\n folding over the result of mapping the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e l f &#8801; \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e (l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e f)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eviews (to f) g a\n\u003c/code\u003e\u003c/strong\u003eg (f a)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eviews _2 length (1,\"hello\")\n\u003c/code\u003e\u003c/strong\u003e5\n\u003c/pre\u003e\u003cp\u003eAs \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e is commonly used to access the target of a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or obtain a monoidal summary of the targets of a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e,\n It may be useful to think of it as having one of these more restricted signatures:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e m) -\u003e s -\u003e m\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e ::             \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e m) -\u003e s -\u003e m\n\u003c/pre\u003e\u003cp\u003eIn a more general setting, such as when working with a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack you can use:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e m a\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e m a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e r s a -\u003e (a -\u003e r) -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Getter",
          "name": "views",
          "package": "lens",
          "signature": "Optical p (-\u003e) (Const r) s s a a -\u003e p a r -\u003e m r",
          "source": "src/Control-Lens-Getter.html#views",
          "type": "function"
        },
        "index": {
          "description": "View function of the value pointed to by Getter or Lens or the result of folding over the result of mapping the targets of Fold or Traversal views view to views to views length hello As views is commonly used to access the target of Getter or obtain monoidal summary of the targets of Fold It may be useful to think of it as having one of these more restricted signatures views Getter views Monoid Fold views Iso views Lens views Monoid Traversal In more general setting such as when working with Monad transformer stack you can use view MonadReader Getter view MonadReader Monoid Fold view MonadReader Iso view MonadReader Lens view MonadReader Monoid Traversal views MonadReader Getting",
          "hierarchy": "Control Lens Getter",
          "module": "Control.Lens.Getter",
          "name": "views",
          "normalized": "Optical a(-\u003e)(Const b)c c d d-\u003ea d b-\u003ee b",
          "package": "lens",
          "signature": "Optical p(-\u003e)(Const r)s s a a-\u003ep a r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Getter.html#v:views"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e(The classes in here need to be defined together for \u003ccode\u003eDefaultSignatures\u003c/code\u003e to work.)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Indexed",
          "name": "Indexed",
          "package": "lens",
          "source": "src/Control-Lens-Indexed.html",
          "type": "module"
        },
        "index": {
          "description": "The classes in here need to be defined together for DefaultSignatures to work",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "Indexed",
          "package": "lens",
          "partial": "Indexed",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e that is both \u003ccode\u003e\u003ca\u003eCorepresentable\u003c/a\u003e\u003c/code\u003e by \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRepresentable\u003c/a\u003e\u003c/code\u003e by \u003ccode\u003eg\u003c/code\u003e such\n that \u003ccode\u003ef\u003c/code\u003e is left adjoint to \u003ccode\u003eg\u003c/code\u003e. From this you can derive a lot of structure due\n to the preservation of limits and colimits.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "Conjoined",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Conjoined",
          "type": "class"
        },
        "index": {
          "description": "This is Profunctor that is both Corepresentable by and Representable by such that is left adjoint to From this you can derive lot of structure due to the preservation of limits and colimits",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "Conjoined",
          "package": "lens",
          "partial": "Conjoined",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#t:Conjoined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA container that supports folding with an additional index.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "FoldableWithIndex",
          "package": "lens",
          "source": "src/Control-Lens-Indexed.html#FoldableWithIndex",
          "type": "class"
        },
        "index": {
          "description": "container that supports folding with an additional index",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "FoldableWithIndex",
          "package": "lens",
          "partial": "Foldable With Index",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#t:FoldableWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e with an additional index.\n\u003c/p\u003e\u003cp\u003eInstances must satisfy a modified form of the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e laws:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eimap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eimap\u003c/a\u003e\u003c/code\u003e g &#8801; \u003ccode\u003e\u003ca\u003eimap\u003c/a\u003e\u003c/code\u003e (\\i -\u003e f i \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g i)\n \u003ccode\u003e\u003ca\u003eimap\u003c/a\u003e\u003c/code\u003e (\\_ a -\u003e a) &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "FunctorWithIndex",
          "package": "lens",
          "source": "src/Control-Lens-Indexed.html#FunctorWithIndex",
          "type": "class"
        },
        "index": {
          "description": "Functor with an additional index Instances must satisfy modified form of the Functor laws imap imap imap imap id",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "FunctorWithIndex",
          "package": "lens",
          "partial": "Functor With Index",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#t:FunctorWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class permits overloading of function application for things that\n also admit a notion of a key or index.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "Indexable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexable",
          "type": "class"
        },
        "index": {
          "description": "This class permits overloading of function application for things that also admit notion of key or index",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "Indexable",
          "package": "lens",
          "partial": "Indexable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#t:Indexable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with access to a index. This constructor may be useful when you need to store\n an \u003ccode\u003e\u003ca\u003eIndexable\u003c/a\u003e\u003c/code\u003e in a container to avoid \u003ccode\u003eImpredicativeTypes\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003eindex :: Indexed i a b -\u003e i -\u003e a -\u003e b\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "Indexed",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexed",
          "type": "newtype"
        },
        "index": {
          "description": "function with access to index This constructor may be useful when you need to store an Indexable in container to avoid ImpredicativeTypes index Indexed",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "Indexed",
          "package": "lens",
          "partial": "Indexed",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#t:Indexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e with an additional index.\n\u003c/p\u003e\u003cp\u003eAn instance must satisfy a (modified) form of the \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e laws:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitraverse\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eitraverse\u003c/a\u003e\u003c/code\u003e f) \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitraverse\u003c/a\u003e\u003c/code\u003e g &#8801; \u003ccode\u003e\u003ca\u003egetCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitraverse\u003c/a\u003e\u003c/code\u003e (\\i -\u003e \u003ccode\u003e\u003ca\u003eCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e (f i) \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "TraversableWithIndex",
          "package": "lens",
          "source": "src/Control-Lens-Indexed.html#TraversableWithIndex",
          "type": "class"
        },
        "index": {
          "description": "Traversable with an additional index An instance must satisfy modified form of the Traversable laws itraverse const Identity Identity fmap itraverse itraverse getCompose itraverse Compose fmap",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "TraversableWithIndex",
          "package": "lens",
          "partial": "Traversable With Index",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#t:TraversableWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose an \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e function with a non-indexed function.\n\u003c/p\u003e\u003cp\u003eMnemonically, the \u003ccode\u003e\u003c\u003c/code\u003e points to the indexing we want to preserve.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Operators\"]",
          "name": "(\u003c.)",
          "package": "lens",
          "signature": "(Indexed i s t -\u003e r) -\u003e ((a -\u003e b) -\u003e s -\u003e t) -\u003e p a b -\u003e r",
          "source": "src/Control-Lens-Indexed.html#%3C.",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:-60-.\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60-.\"]"
        },
        "index": {
          "description": "Compose an Indexed function with non-indexed function Mnemonically the points to the indexing we want to preserve",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "(\u003c.) \u003c.",
          "normalized": "(Indexed a b c-\u003ed)-\u003e((e-\u003ef)-\u003eb-\u003ec)-\u003eg e f-\u003ed",
          "package": "lens",
          "signature": "(Indexed i s t-\u003er)-\u003e((a-\u003eb)-\u003es-\u003et)-\u003ep a b-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:-60-."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e functions.\n\u003c/p\u003e\u003cp\u003eMnemonically, the \u003ccode\u003e\u003c\u003c/code\u003e and \u003ccode\u003e\u003e\u003c/code\u003e points to the fact that we want to preserve the indices.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Operators\"]",
          "name": "(\u003c.\u003e)",
          "package": "lens",
          "signature": "(Indexed i s t -\u003e r) -\u003e (Indexed j a b -\u003e s -\u003e t) -\u003e p a b -\u003e r",
          "source": "src/Control-Lens-Indexed.html#%3C.%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:-60-.-62-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60-.-62-\"]"
        },
        "index": {
          "description": "Composition of Indexed functions Mnemonically the and points to the fact that we want to preserve the indices",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "(\u003c.\u003e) \u003c.\u003e",
          "normalized": "(Indexed a b c-\u003ed)-\u003e(Indexed e f g-\u003eb-\u003ec)-\u003eh f g-\u003ed",
          "package": "lens",
          "signature": "(Indexed i s t-\u003er)-\u003e(Indexed j a b-\u003es-\u003et)-\u003ep a b-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:-60-.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose a non-indexed function with an \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e\u003cp\u003eMnemonically, the \u003ccode\u003e\u003e\u003c/code\u003e points to the indexing we want to preserve.\n\u003c/p\u003e\u003cp\u003eThis is the same as \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003ef \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g\u003c/code\u003e (and \u003ccode\u003ef \u003ccode\u003e\u003ca\u003e.\u003e\u003c/a\u003e\u003c/code\u003e g\u003c/code\u003e) gives you the index of \u003ccode\u003eg\u003c/code\u003e unless \u003ccode\u003eg\u003c/code\u003e is index-preserving, like a\n \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e, in which case it'll pass through the index of \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Operators\"]",
          "name": "(.\u003e)",
          "package": "lens",
          "signature": "(st -\u003e r) -\u003e (kab -\u003e st) -\u003e kab -\u003e r",
          "source": "src/Control-Lens-Indexed.html#.%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:.-62-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:.-62-\"]"
        },
        "index": {
          "description": "Compose non-indexed function with an Indexed function Mnemonically the points to the indexing we want to preserve This is the same as and gives you the index of unless is index-preserving like Prism Iso or Equality in which case it ll pass through the index of",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "(.\u003e) .\u003e",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ea)-\u003ec-\u003eb",
          "package": "lens",
          "signature": "(st-\u003er)-\u003e(kab-\u003est)-\u003ekab-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:.-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Internal.Indexed\"]",
          "name": "Indexed",
          "package": "lens",
          "signature": "Indexed",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:Indexed\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:Indexed\"]"
        },
        "index": {
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "Indexed",
          "package": "lens",
          "partial": "Indexed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:Indexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen composed with an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e this yields an\n (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e) \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e of the indices.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "asIndex",
          "package": "lens",
          "signature": "Optical' p (Indexed i) f s i",
          "source": "src/Control-Lens-Indexed.html#asIndex",
          "type": "function"
        },
        "index": {
          "description": "When composed with an IndexedFold or IndexedTraversal this yields an Indexed Fold of the indices",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "asIndex",
          "package": "lens",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:asIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis permits us to make a decision at an outermost point about whether or not we use an index.\n\u003c/p\u003e\u003cp\u003eIdeally any use of this function should be done in such a way so that you compute the same answer,\n but this cannot be enforced at the type level.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "conjoined",
          "package": "lens",
          "signature": "q (a -\u003e b) r) -\u003e q (p a b) r -\u003e q (p a b) r",
          "source": "src/Control-Lens-Internal-Indexed.html#conjoined",
          "type": "method"
        },
        "index": {
          "description": "This permits us to make decision at an outermost point about whether or not we use an index Ideally any use of this function should be done in such way so that you compute the same answer but this cannot be enforced at the type level",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "conjoined",
          "normalized": "a(b-\u003ec)d)-\u003ea(e b c)d-\u003ea(e b c)d",
          "package": "lens",
          "signature": "q(a-\u003eb)r)-\u003eq(p a b)r-\u003eq(p a b)r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:conjoined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e is strong enough to let us distribute every \u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e over every Haskell \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e. This is effectively a\n generalization of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "distrib",
          "package": "lens",
          "signature": "p a b -\u003e p (f a) (f b)",
          "source": "src/Control-Lens-Internal-Indexed.html#distrib",
          "type": "method"
        },
        "index": {
          "description": "Conjoined is strong enough to let us distribute every Conjoined Profunctor over every Haskell Functor This is effectively generalization of fmap",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "distrib",
          "normalized": "a b c-\u003ea(d b)(d c)",
          "package": "lens",
          "signature": "p a b-\u003ep(f a)(f b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:distrib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not all elements in a container satisfy a predicate, with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eiall\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "iall",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e f a -\u003e Bool",
          "source": "src/Control-Lens-Indexed.html#iall",
          "type": "function"
        },
        "index": {
          "description": "Return whether or not all elements in container satisfy predicate with access to the index When you don need access to the index then all is more flexible in what it accepts all iall const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "iall",
          "normalized": "(a-\u003eb-\u003eBool)-\u003ec b-\u003eBool",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eBool)-\u003ef a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:iall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not any element in a container satisfies a predicate, with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eiany\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "iany",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e f a -\u003e Bool",
          "source": "src/Control-Lens-Indexed.html#iany",
          "type": "function"
        },
        "index": {
          "description": "Return whether or not any element in container satisfies predicate with access to the index When you don need access to the index then any is more flexible in what it accepts any iany const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "iany",
          "normalized": "(a-\u003eb-\u003eBool)-\u003ec b-\u003eBool",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eBool)-\u003ef a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:iany"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition of \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e functions with a user supplied function for combining indices.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "icompose",
          "package": "lens",
          "signature": "(i -\u003e j -\u003e p) -\u003e (Indexed i s t -\u003e r) -\u003e (Indexed j a b -\u003e s -\u003e t) -\u003e c a b -\u003e r",
          "source": "src/Control-Lens-Indexed.html#icompose",
          "type": "function"
        },
        "index": {
          "description": "Composition of Indexed functions with user supplied function for combining indices",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "icompose",
          "normalized": "(a-\u003eb-\u003ec)-\u003e(Indexed a d e-\u003ef)-\u003e(Indexed b g h-\u003ed-\u003ee)-\u003ei g h-\u003ef",
          "package": "lens",
          "signature": "(i-\u003ej-\u003ep)-\u003e(Indexed i s t-\u003er)-\u003e(Indexed j a b-\u003es-\u003et)-\u003ec a b-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:icompose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConcatenate the results of a function of the elements of an indexed container with access to the index.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econcatMap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eiconcatMap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiconcatMap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldMap\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "iconcatMap",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e [b]) -\u003e f a -\u003e [b]",
          "source": "src/Control-Lens-Indexed.html#iconcatMap",
          "type": "function"
        },
        "index": {
          "description": "Concatenate the results of function of the elements of an indexed container with access to the index When you don need access to the index then concatMap is more flexible in what it accepts concatMap iconcatMap const iconcatMap ifoldMap",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "iconcatMap",
          "normalized": "(a-\u003eb-\u003e[c])-\u003ed b-\u003e[c]",
          "package": "lens",
          "partial": "Map",
          "signature": "(i-\u003ea-\u003e[b])-\u003ef a-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:iconcatMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearches a container with a predicate that is also supplied the index, returning the left-most element of the structure\n matching the predicate, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if there is no such element.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efind\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifind\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifind",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e f a -\u003e Maybe (i, a)",
          "source": "src/Control-Lens-Indexed.html#ifind",
          "type": "function"
        },
        "index": {
          "description": "Searches container with predicate that is also supplied the index returning the left-most element of the structure matching the predicate or Nothing if there is no such element When you don need access to the index then find is more flexible in what it accepts find ifind const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifind",
          "normalized": "(a-\u003eb-\u003eBool)-\u003ec b-\u003eMaybe(a,b)",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eBool)-\u003ef a-\u003eMaybe(i,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a container by mapping value to an arbitrary \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldMap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldMap",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e m) -\u003e f a -\u003e m",
          "source": "src/Control-Lens-Indexed.html#ifoldMap",
          "type": "method"
        },
        "index": {
          "description": "Fold container by mapping value to an arbitrary Monoid with access to the index When you don need access to the index then foldMap is more flexible in what it accepts foldMap ifoldMap const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldMap",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed b-\u003ec",
          "package": "lens",
          "partial": "Map",
          "signature": "(i-\u003ea-\u003em)-\u003ef a-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Indexed",
          "name": "ifoldMapBy",
          "package": "lens",
          "signature": "(r -\u003e r -\u003e r) -\u003e r -\u003e (i -\u003e a -\u003e r) -\u003e t a -\u003e r",
          "source": "src/Control-Lens-Indexed.html#ifoldMapBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldMapBy",
          "normalized": "(a-\u003ea-\u003ea)-\u003ea-\u003e(b-\u003ec-\u003ea)-\u003ed c-\u003ea",
          "package": "lens",
          "partial": "Map By",
          "signature": "(r-\u003er-\u003er)-\u003er-\u003e(i-\u003ea-\u003er)-\u003et a-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldMapBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Indexed",
          "name": "ifoldMapByOf",
          "package": "lens",
          "signature": "(forall s.  IndexedGetting i (M r s) t a) -\u003e (r -\u003e r -\u003e r) -\u003e r -\u003e (i -\u003e a -\u003e r) -\u003e t -\u003e r",
          "source": "src/Control-Lens-Indexed.html#ifoldMapByOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldMapByOf",
          "normalized": "(a b IndexedGetting c(M d e)f g)-\u003e(d-\u003ed-\u003ed)-\u003ed-\u003e(c-\u003eg-\u003ed)-\u003ef-\u003ed",
          "package": "lens",
          "partial": "Map By Of",
          "signature": "(forall s. IndexedGetting i(M r s)t a)-\u003e(r-\u003er-\u003er)-\u003er-\u003e(i-\u003ea-\u003er)-\u003et-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldMapByOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eFoldableWithIndex\u003c/a\u003e\u003c/code\u003e container.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifolded",
          "package": "lens",
          "signature": "IndexedFold i (f a) a",
          "source": "src/Control-Lens-Indexed.html#ifolded",
          "type": "method"
        },
        "index": {
          "description": "The IndexedFold of FoldableWithIndex container",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifolded",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifolded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeft-associative fold of an indexed container with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldl\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldl",
          "package": "lens",
          "signature": "(i -\u003e b -\u003e a -\u003e b) -\u003e b -\u003e f a -\u003e b",
          "source": "src/Control-Lens-Indexed.html#ifoldl",
          "type": "method"
        },
        "index": {
          "description": "Left-associative fold of an indexed container with access to the index When you don need access to the index then foldl is more flexible in what it accepts foldl ifoldl const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldl",
          "normalized": "(a-\u003eb-\u003ec-\u003eb)-\u003eb-\u003ed c-\u003eb",
          "package": "lens",
          "signature": "(i-\u003eb-\u003ea-\u003eb)-\u003eb-\u003ef a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold over the elements of a structure with an index, associating to the left, but \u003cem\u003estrictly\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlOf'\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eifoldlOf'\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldl'",
          "package": "lens",
          "signature": "(i -\u003e b -\u003e a -\u003e b) -\u003e b -\u003e f a -\u003e b",
          "source": "src/Control-Lens-Indexed.html#ifoldl%27",
          "type": "method"
        },
        "index": {
          "description": "Fold over the elements of structure with an index associating to the left but strictly When you don need access to the index then foldlOf is more flexible in what it accepts foldlOf ifoldlOf const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldl'",
          "normalized": "(a-\u003eb-\u003ec-\u003eb)-\u003eb-\u003ed c-\u003eb",
          "package": "lens",
          "signature": "(i-\u003eb-\u003ea-\u003eb)-\u003eb-\u003ef a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold over the elements of a structure with an index, associating to the left.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldlM\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldlM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldlM\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldlM",
          "package": "lens",
          "signature": "(i -\u003e b -\u003e a -\u003e m b) -\u003e b -\u003e f a -\u003e m b",
          "source": "src/Control-Lens-Indexed.html#ifoldlM",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold over the elements of structure with an index associating to the left When you don need access to the index then foldlM is more flexible in what it accepts foldlM ifoldlM const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldlM",
          "normalized": "(a-\u003eb-\u003ec-\u003ed b)-\u003eb-\u003ee c-\u003ed b",
          "package": "lens",
          "signature": "(i-\u003eb-\u003ea-\u003em b)-\u003eb-\u003ef a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldlM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-associative fold of an indexed container with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldr\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldr",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e f a -\u003e b",
          "source": "src/Control-Lens-Indexed.html#ifoldr",
          "type": "method"
        },
        "index": {
          "description": "Right-associative fold of an indexed container with access to the index When you don need access to the index then foldr is more flexible in what it accepts foldr ifoldr const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldr",
          "normalized": "(a-\u003eb-\u003ec-\u003ec)-\u003ec-\u003ed b-\u003ec",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ef a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eStrictly\u003c/em\u003e fold right over the elements of a structure with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldr'\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldr'\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldr'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldr'",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e f a -\u003e b",
          "source": "src/Control-Lens-Indexed.html#ifoldr%27",
          "type": "method"
        },
        "index": {
          "description": "Strictly fold right over the elements of structure with access to the index When you don need access to the index then foldr is more flexible in what it accepts foldr ifoldr const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldr'",
          "normalized": "(a-\u003eb-\u003ec-\u003ec)-\u003ec-\u003ed b-\u003ec",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eb-\u003eb)-\u003eb-\u003ef a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic fold right over the elements of a structure with an index.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efoldrM\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efoldrM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eifoldrM\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifoldrM",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e b -\u003e m b) -\u003e b -\u003e f a -\u003e m b",
          "source": "src/Control-Lens-Indexed.html#ifoldrM",
          "type": "function"
        },
        "index": {
          "description": "Monadic fold right over the elements of structure with an index When you don need access to the index then foldrM is more flexible in what it accepts foldrM ifoldrM const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifoldrM",
          "normalized": "(a-\u003eb-\u003ec-\u003ed c)-\u003ec-\u003ee b-\u003ed c",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eb-\u003em b)-\u003eb-\u003ef a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifoldrM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse with an index (and the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efor\u003c/a\u003e\u003c/code\u003e a &#8801; \u003ccode\u003e\u003ca\u003eifor\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eifor\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifor",
          "package": "lens",
          "signature": "t a -\u003e (i -\u003e a -\u003e f b) -\u003e f (t b)",
          "source": "src/Control-Lens-Indexed.html#ifor",
          "type": "function"
        },
        "index": {
          "description": "Traverse with an index and the arguments flipped for ifor const ifor flip itraverse",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifor",
          "normalized": "a b-\u003e(c-\u003eb-\u003ed e)-\u003ed(a e)",
          "package": "lens",
          "signature": "t a-\u003e(i-\u003ea-\u003ef b)-\u003ef(t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action,\n evaluate these actions from left to right, and collect the results, with access\n its position (and the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e a &#8801; \u003ccode\u003e\u003ca\u003eiforM\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiforM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eimapM\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "iforM",
          "package": "lens",
          "signature": "t a -\u003e (i -\u003e a -\u003e m b) -\u003e m (t b)",
          "source": "src/Control-Lens-Indexed.html#iforM",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and collect the results with access its position and the arguments flipped forM iforM const iforM flip imapM",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "iforM",
          "normalized": "a b-\u003e(c-\u003eb-\u003ed e)-\u003ed(a e)",
          "package": "lens",
          "signature": "t a-\u003e(i-\u003ea-\u003em b)-\u003em(t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:iforM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun monadic actions for each target of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index,\n discarding the results (with the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforM_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eimapM_\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforMOf_\u003c/a\u003e\u003c/code\u003e l a &#8801; \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e l a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "iforM_",
          "package": "lens",
          "signature": "t a -\u003e (i -\u003e a -\u003e m b) -\u003e m ()",
          "source": "src/Control-Lens-Indexed.html#iforM_",
          "type": "function"
        },
        "index": {
          "description": "Run monadic actions for each target of an IndexedFold or IndexedTraversal with access to the index discarding the results with the arguments flipped iforM flip imapM When you don need access to the index then forMOf is more flexible in what it accepts forMOf iforMOf const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "iforM_",
          "normalized": "a b-\u003e(c-\u003eb-\u003ed e)-\u003ed()",
          "package": "lens",
          "signature": "t a-\u003e(i-\u003ea-\u003em b)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:iforM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse elements with access to the index \u003ccode\u003ei\u003c/code\u003e, discarding the results (with the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifor_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitraverse_\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003efor_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efor_\u003c/a\u003e\u003c/code\u003e a &#8801; \u003ccode\u003e\u003ca\u003eifor_\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "ifor_",
          "package": "lens",
          "signature": "t a -\u003e (i -\u003e a -\u003e f b) -\u003e f ()",
          "source": "src/Control-Lens-Indexed.html#ifor_",
          "type": "function"
        },
        "index": {
          "description": "Traverse elements with access to the index discarding the results with the arguments flipped ifor flip itraverse When you don need access to the index then for is more flexible in what it accepts for ifor const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "ifor_",
          "normalized": "a b-\u003e(c-\u003eb-\u003ed e)-\u003ed()",
          "package": "lens",
          "signature": "t a-\u003e(i-\u003ea-\u003ef b)-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:ifor_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap with access to the index.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "imap",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e b) -\u003e f a -\u003e f b",
          "source": "src/Control-Lens-Indexed.html#imap",
          "type": "method"
        },
        "index": {
          "description": "Map with access to the index",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "imap",
          "normalized": "(a-\u003eb-\u003ec)-\u003ed b-\u003ed c",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:imap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralizes \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e to add access to the index.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eimapAccumLOf\u003c/a\u003e\u003c/code\u003e accumulates state from left to right.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eimapAccumL\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "imapAccumL",
          "package": "lens",
          "signature": "(i -\u003e s -\u003e a -\u003e (s, b)) -\u003e s -\u003e t a -\u003e (s, t b)",
          "source": "src/Control-Lens-Indexed.html#imapAccumL",
          "type": "function"
        },
        "index": {
          "description": "Generalizes mapAccumL to add access to the index imapAccumLOf accumulates state from left to right mapAccumLOf imapAccumL const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "imapAccumL",
          "normalized": "(a-\u003eb-\u003ec-\u003e(b,d))-\u003eb-\u003ee c-\u003e(b,e d)",
          "package": "lens",
          "partial": "Accum",
          "signature": "(i-\u003es-\u003ea-\u003e(s,b))-\u003es-\u003et a-\u003e(s,t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:imapAccumL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralizes \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e to add access to the index.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eimapAccumROf\u003c/a\u003e\u003c/code\u003e accumulates state from right to left.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eimapAccumR\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "imapAccumR",
          "package": "lens",
          "signature": "(i -\u003e s -\u003e a -\u003e (s, b)) -\u003e s -\u003e t a -\u003e (s, t b)",
          "source": "src/Control-Lens-Indexed.html#imapAccumR",
          "type": "function"
        },
        "index": {
          "description": "Generalizes mapAccumR to add access to the index imapAccumROf accumulates state from right to left mapAccumR imapAccumR const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "imapAccumR",
          "normalized": "(a-\u003eb-\u003ec-\u003e(b,d))-\u003eb-\u003ee c-\u003e(b,e d)",
          "package": "lens",
          "partial": "Accum",
          "signature": "(i-\u003es-\u003ea-\u003e(s,b))-\u003es-\u003et a-\u003e(s,t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:imapAccumR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to a monadic action,\n evaluate these actions from left to right, and collect the results, with access\n the index.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e is more liberal in what it can accept.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eimapM\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "imapM",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e m b) -\u003e t a -\u003e m (t b)",
          "source": "src/Control-Lens-Indexed.html#imapM",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure to monadic action evaluate these actions from left to right and collect the results with access the index When you don need access to the index mapM is more liberal in what it can accept mapM imapM const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "imapM",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ee b-\u003ec(e d)",
          "package": "lens",
          "signature": "(i-\u003ea-\u003em b)-\u003et a-\u003em(t b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:imapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun monadic actions for each target of an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index,\n discarding the results.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003emapMOf_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eimapM\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "imapM_",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e m b) -\u003e t a -\u003e m ()",
          "source": "src/Control-Lens-Indexed.html#imapM_",
          "type": "function"
        },
        "index": {
          "description": "Run monadic actions for each target of an IndexedFold or IndexedTraversal with access to the index discarding the results When you don need access to the index then mapMOf is more flexible in what it accepts mapM imapM const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "imapM_",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ee b-\u003ec()",
          "package": "lens",
          "signature": "(i-\u003ea-\u003em b)-\u003et a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:imapM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003e\u003ca\u003eFunctorWithIndex\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf you don't need access to the index, then \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "imapped",
          "package": "lens",
          "signature": "IndexedSetter i (f a) (f b) a b",
          "source": "src/Control-Lens-Indexed.html#imapped",
          "type": "method"
        },
        "index": {
          "description": "The IndexedSetter for FunctorWithIndex If you don need access to the index then mapped is more flexible in what it accepts",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "imapped",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:imapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis allows you to filter an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e based on an index.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"the\",\"world\",\"!!!\"]^?traversed.index 2\n\u003c/code\u003e\u003c/strong\u003eJust \"world\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "index",
          "package": "lens",
          "signature": "i -\u003e Optical' p (Indexed i) f a a",
          "source": "src/Control-Lens-Indexed.html#index",
          "type": "function"
        },
        "index": {
          "description": "This allows you to filter an IndexedFold IndexedGetter IndexedTraversal or IndexedLens based on an index hello the world traversed.index Just world",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "index",
          "normalized": "a-\u003eOptical' b(Indexed a)c d d",
          "package": "lens",
          "signature": "i-\u003eOptical' p(Indexed i)f a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a function from an \u003ccode\u003e\u003ca\u003eindexed\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "indexed",
          "package": "lens",
          "signature": "p a b -\u003e i -\u003e a -\u003e b",
          "source": "src/Control-Lens-Internal-Indexed.html#indexed",
          "type": "method"
        },
        "index": {
          "description": "Build function from an indexed function",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "indexed",
          "normalized": "a b c-\u003ed-\u003eb-\u003ec",
          "package": "lens",
          "signature": "p a b-\u003ei-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:indexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e or\n a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e into an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, etc.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s t a b     -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e  s t a b\n \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexable\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexing\u003c/a\u003e\u003c/code\u003e f) s t a b -\u003e \u003ccode\u003e\u003ca\u003eOptical\u003c/a\u003e\u003c/code\u003e p (-\u003e) f s t a b\u003c/pre\u003e",
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Internal.Indexed\"]",
          "name": "indexing",
          "package": "lens",
          "signature": "((a -\u003e Indexing f b) -\u003e s -\u003e Indexing f t) -\u003e p a (f b) -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Internal-Indexed.html#indexing",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:indexing\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:indexing\"]"
        },
        "index": {
          "description": "Transform Traversal into an IndexedTraversal or Fold into an IndexedFold etc indexing Traversal IndexedTraversal Int indexing Prism IndexedTraversal Int indexing Lens IndexedLens Int indexing Iso IndexedLens Int indexing Fold IndexedFold Int indexing Getter IndexedGetter Int indexing Indexable Int LensLike Indexing Optical",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "indexing",
          "normalized": "((a-\u003eIndexing b c)-\u003ed-\u003eIndexing b e)-\u003ef a(b c)-\u003ed-\u003eb e",
          "package": "lens",
          "signature": "((a-\u003eIndexing f b)-\u003es-\u003eIndexing f t)-\u003ep a(f b)-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:indexing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e or\n a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e into an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, etc.\n\u003c/p\u003e\u003cp\u003eThis combinator is like \u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e except that it handles large traversals and folds gracefully.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s t a b     -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eindexing64\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexable\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexing64\u003c/a\u003e\u003c/code\u003e f) s t a b -\u003e \u003ccode\u003e\u003ca\u003eOver\u003c/a\u003e\u003c/code\u003e p f s t a b\u003c/pre\u003e",
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Internal.Indexed\"]",
          "name": "indexing64",
          "package": "lens",
          "signature": "((a -\u003e Indexing64 f b) -\u003e s -\u003e Indexing64 f t) -\u003e p a (f b) -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Internal-Indexed.html#indexing64",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:indexing64\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:indexing64\"]"
        },
        "index": {
          "description": "Transform Traversal into an IndexedTraversal or Fold into an IndexedFold etc This combinator is like indexing except that it handles large traversals and folds gracefully indexing64 Traversal IndexedTraversal Int64 indexing64 Prism IndexedTraversal Int64 indexing64 Lens IndexedLens Int64 indexing64 Iso IndexedLens Int64 indexing64 Fold IndexedFold Int64 indexing64 Getter IndexedGetter Int64 indexing64 Indexable Int64 LensLike Indexing64 Over",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "indexing64",
          "normalized": "((a-\u003eIndexing b c)-\u003ed-\u003eIndexing b e)-\u003ef a(b c)-\u003ed-\u003eb e",
          "package": "lens",
          "signature": "((a-\u003eIndexing f b)-\u003es-\u003eIndexing f t)-\u003ep a(f b)-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:indexing64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis allows you to filter an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e based on a predicate\n on the indices.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"the\",\"world\",\"!!!\"]^..traversed.indices even\n\u003c/code\u003e\u003c/strong\u003e[\"hello\",\"world\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (traversed.indices (\u003e0)) Prelude.reverse $ [\"He\",\"was\",\"stressed\",\"o_O\"]\n\u003c/code\u003e\u003c/strong\u003e[\"He\",\"saw\",\"desserts\",\"O_o\"]\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "indices",
          "package": "lens",
          "signature": "(i -\u003e Bool) -\u003e Optical' p (Indexed i) f a a",
          "source": "src/Control-Lens-Indexed.html#indices",
          "type": "function"
        },
        "index": {
          "description": "This allows you to filter an IndexedFold IndexedGetter IndexedTraversal or IndexedLens based on predicate on the indices hello the world traversed.indices even hello world over traversed.indices Prelude.reverse He was stressed He saw desserts",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "indices",
          "normalized": "(a-\u003eBool)-\u003eOptical' b(Indexed a)c d d",
          "package": "lens",
          "signature": "(i-\u003eBool)-\u003eOptical' p(Indexed i)f a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:indices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn whether or not none of the elements in a container satisfy a predicate, with access to the index \u003ccode\u003ei\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003enone\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enone\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003einone\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003einone\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eiany\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "inone",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e Bool) -\u003e f a -\u003e Bool",
          "source": "src/Control-Lens-Indexed.html#inone",
          "type": "function"
        },
        "index": {
          "description": "Return whether or not none of the elements in container satisfy predicate with access to the index When you don need access to the index then none is more flexible in what it accepts none inone const inone not iany",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "inone",
          "normalized": "(a-\u003eb-\u003eBool)-\u003ec b-\u003eBool",
          "package": "lens",
          "signature": "(i-\u003ea-\u003eBool)-\u003ef a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:inone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the key-value pairs from a structure.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the indices in the result, then \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitoList\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "itoList",
          "package": "lens",
          "signature": "f a -\u003e [(i, a)]",
          "source": "src/Control-Lens-Indexed.html#itoList",
          "type": "function"
        },
        "index": {
          "description": "Extract the key-value pairs from structure When you don need access to the indices in the result then toList is more flexible in what it accepts toList map fst itoList",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "itoList",
          "normalized": "a b-\u003e[(c,b)]",
          "package": "lens",
          "partial": "List",
          "signature": "f a-\u003e[(i,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:itoList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse an indexed container.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "itraverse",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e f b) -\u003e t a -\u003e f (t b)",
          "source": "src/Control-Lens-Indexed.html#itraverse",
          "type": "method"
        },
        "index": {
          "description": "Traverse an indexed container",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "itraverse",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ee b-\u003ec(e d)",
          "package": "lens",
          "signature": "(i-\u003ea-\u003ef b)-\u003et a-\u003ef(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:itraverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse elements with access to the index \u003ccode\u003ei\u003c/code\u003e, discarding the results.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index then \u003ccode\u003e\u003ca\u003etraverse_\u003c/a\u003e\u003c/code\u003e is more flexible in what it accepts.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverse_\u003c/a\u003e\u003c/code\u003e l = \u003ccode\u003e\u003ca\u003eitraverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "itraverse_",
          "package": "lens",
          "signature": "(i -\u003e a -\u003e f b) -\u003e t a -\u003e f ()",
          "source": "src/Control-Lens-Indexed.html#itraverse_",
          "type": "function"
        },
        "index": {
          "description": "Traverse elements with access to the index discarding the results When you don need access to the index then traverse is more flexible in what it accepts traverse itraverse const",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "itraverse_",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ee b-\u003ec()",
          "package": "lens",
          "signature": "(i-\u003ea-\u003ef b)-\u003et a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:itraverse_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eTraversableWithIndex\u003c/a\u003e\u003c/code\u003e container.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "itraversed",
          "package": "lens",
          "signature": "IndexedTraversal i (t a) (t b) a b",
          "source": "src/Control-Lens-Indexed.html#itraversed",
          "type": "method"
        },
        "index": {
          "description": "The IndexedTraversal of TraversableWithIndex container",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "itraversed",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:itraversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDetermines whether no elements of the structure satisfy the predicate.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enone\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eany\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e",
          "module": "Control.Lens.Indexed",
          "name": "none",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e f a -\u003e Bool",
          "source": "src/Control-Lens-Indexed.html#none",
          "type": "function"
        },
        "index": {
          "description": "Determines whether no elements of the structure satisfy the predicate none not any",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "none",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eBool",
          "package": "lens",
          "signature": "(a-\u003eBool)-\u003ef a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:none"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemap the index.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "reindexed",
          "package": "lens",
          "signature": "(i -\u003e j) -\u003e (Indexed i a b -\u003e r) -\u003e p a b -\u003e r",
          "source": "src/Control-Lens-Indexed.html#reindexed",
          "type": "function"
        },
        "index": {
          "description": "Remap the index",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "reindexed",
          "normalized": "(a-\u003eb)-\u003e(Indexed a c d-\u003ee)-\u003ef c d-\u003ee",
          "package": "lens",
          "signature": "(i-\u003ej)-\u003e(Indexed i a b-\u003er)-\u003ep a b-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:reindexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Indexed\",\"Control.Lens.Internal.Indexed\"]",
          "name": "runIndexed",
          "package": "lens",
          "signature": "i -\u003e a -\u003e b",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:runIndexed\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:runIndexed\"]"
        },
        "index": {
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "runIndexed",
          "normalized": "a-\u003eb-\u003ec",
          "package": "lens",
          "partial": "Indexed",
          "signature": "i-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:runIndexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold a container with indices returning both the indices and the values.\n\u003c/p\u003e\u003cp\u003eThe result is only valid to compose in a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, if you don't edit the\n index as edits to the index have no effect.\n\u003c/p\u003e",
          "module": "Control.Lens.Indexed",
          "name": "withIndex",
          "package": "lens",
          "signature": "Optical p (Indexed i) f s t (i, s) (j, t)",
          "source": "src/Control-Lens-Indexed.html#withIndex",
          "type": "function"
        },
        "index": {
          "description": "Fold container with indices returning both the indices and the values The result is only valid to compose in Traversal if you don edit the index as edits to the index have no effect",
          "hierarchy": "Control Lens Indexed",
          "module": "Control.Lens.Indexed",
          "name": "withIndex",
          "normalized": "Optical a(Indexed b)c d e(b,d)(f,e)",
          "package": "lens",
          "partial": "Index",
          "signature": "Optical p(Indexed i)f s t(i,s)(j,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Indexed.html#v:withIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Action",
          "name": "Action",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Action.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "Action",
          "package": "lens",
          "partial": "Action",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap a monadic effect with a phantom type argument.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Action",
          "name": "Effect",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Action.html#Effect",
          "type": "newtype"
        },
        "index": {
          "description": "Wrap monadic effect with phantom type argument",
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "Effect",
          "package": "lens",
          "partial": "Effect",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#t:Effect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eEffective\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e ignores its argument and is isomorphic to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e wrapped around a value.\n\u003c/p\u003e\u003cp\u003eThat said, the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e is possibly rather unrelated to any \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e structure.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Action",
          "name": "Effective",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Action.html#Effective",
          "type": "class"
        },
        "index": {
          "description": "An Effective Functor ignores its argument and is isomorphic to Monad wrapped around value That said the Monad is possibly rather unrelated to any Applicative structure",
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "Effective",
          "package": "lens",
          "partial": "Effective",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#t:Effective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Action",
          "name": "Effect",
          "package": "lens",
          "signature": "Effect",
          "source": "src/Control-Lens-Internal-Action.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "Effect",
          "package": "lens",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#v:Effect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Action",
          "name": "effective",
          "package": "lens",
          "signature": "m r -\u003e f a",
          "source": "src/Control-Lens-Internal-Action.html#effective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "effective",
          "normalized": "a b-\u003ec d",
          "package": "lens",
          "signature": "m r-\u003ef a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#v:effective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Action",
          "name": "getEffect",
          "package": "lens",
          "signature": "m r",
          "source": "src/Control-Lens-Internal-Action.html#Effect",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "getEffect",
          "package": "lens",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#v:getEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Action",
          "name": "ineffective",
          "package": "lens",
          "signature": "f a -\u003e m r",
          "source": "src/Control-Lens-Internal-Action.html#ineffective",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Action",
          "module": "Control.Lens.Internal.Action",
          "name": "ineffective",
          "normalized": "a b-\u003ec d",
          "package": "lens",
          "signature": "f a-\u003em r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Action.html#v:ineffective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar",
          "package": "lens",
          "partial": "Bazaar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used to characterize a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ea.k.a. indexed Cartesian store comonad, indexed Kleene store comonad, or an indexed \u003ccode\u003eFunList\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://twanvl.nl/blog/haskell/non-regular1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e is like a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that has already been applied to some structure.\n\u003c/p\u003e\u003cp\u003eWhere a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds an \u003ccode\u003ea\u003c/code\u003e and a function from \u003ccode\u003eb\u003c/code\u003e to\n \u003ccode\u003et\u003c/code\u003e, a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds \u003ccode\u003eN\u003c/code\u003e \u003ccode\u003ea\u003c/code\u003es and a function from \u003ccode\u003eN\u003c/code\u003e\n \u003ccode\u003eb\u003c/code\u003es to \u003ccode\u003et\u003c/code\u003e, (where \u003ccode\u003eN\u003c/code\u003e might be infinite).\n\u003c/p\u003e\u003cp\u003eMnemonically, a \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e holds many stores and you can easily add more.\n\u003c/p\u003e\u003cp\u003eThis is a final encoding of \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar",
          "type": "newtype"
        },
        "index": {
          "description": "This is used to characterize Traversal a.k.a indexed Cartesian store comonad indexed Kleene store comonad or an indexed FunList http twanvl.nl blog haskell non-regular1 Bazaar is like Traversal that has already been applied to some structure Where Context holds an and function from to Bazaar holds and function from to where might be infinite Mnemonically Bazaar holds many stores and you can easily add more This is final encoding of Bazaar",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar",
          "package": "lens",
          "partial": "Bazaar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:Bazaar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis alias is helpful when it comes to reducing repetition in type signatures.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eBazaar'\u003c/a\u003e\u003c/code\u003e p a t = \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e p a a t\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar%27",
          "type": "type"
        },
        "index": {
          "description": "This alias is helpful when it comes to reducing repetition in type signatures type Bazaar Bazaar",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar'",
          "package": "lens",
          "partial": "Bazaar'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:Bazaar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used to characterize a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ea.k.a. indexed Cartesian store comonad, indexed Kleene store comonad, or an indexed \u003ccode\u003eFunList\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://twanvl.nl/blog/haskell/non-regular1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e is like a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that has already been applied to some structure.\n\u003c/p\u003e\u003cp\u003eWhere a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds an \u003ccode\u003ea\u003c/code\u003e and a function from \u003ccode\u003eb\u003c/code\u003e to\n \u003ccode\u003et\u003c/code\u003e, a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds \u003ccode\u003eN\u003c/code\u003e \u003ccode\u003ea\u003c/code\u003es and a function from \u003ccode\u003eN\u003c/code\u003e\n \u003ccode\u003eb\u003c/code\u003es to \u003ccode\u003et\u003c/code\u003e, (where \u003ccode\u003eN\u003c/code\u003e might be infinite).\n\u003c/p\u003e\u003cp\u003eMnemonically, a \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e holds many stores and you can easily add more.\n\u003c/p\u003e\u003cp\u003eThis is a final encoding of \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar1",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar1",
          "type": "newtype"
        },
        "index": {
          "description": "This is used to characterize Traversal a.k.a indexed Cartesian store comonad indexed Kleene store comonad or an indexed FunList http twanvl.nl blog haskell non-regular1 Bazaar1 is like Traversal that has already been applied to some structure Where Context holds an and function from to Bazaar1 holds and function from to where might be infinite Mnemonically Bazaar1 holds many stores and you can easily add more This is final encoding of Bazaar1",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar1",
          "package": "lens",
          "partial": "Bazaar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:Bazaar1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis alias is helpful when it comes to reducing repetition in type signatures.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eBazaar1'\u003c/a\u003e\u003c/code\u003e p a t = \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e p a a t\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar1'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar1%27",
          "type": "type"
        },
        "index": {
          "description": "This alias is helpful when it comes to reducing repetition in type signatures type Bazaar1 Bazaar1",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar1'",
          "package": "lens",
          "partial": "Bazaar",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:Bazaar1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eBazaarT\u003c/a\u003e\u003c/code\u003e is like \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e, except that it provides a questionable \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e instance\n To protect this instance it relies on the soundness of another \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e type, and usage conventions.\n\u003c/p\u003e\u003cp\u003eFor example. This lets us write a suitably polymorphic and lazy \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e, but there\n must be a better way!\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT",
          "type": "newtype"
        },
        "index": {
          "description": "BazaarT is like Bazaar except that it provides questionable Contravariant instance To protect this instance it relies on the soundness of another Contravariant type and usage conventions For example This lets us write suitably polymorphic and lazy taking but there must be better way",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT",
          "package": "lens",
          "partial": "Bazaar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:BazaarT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis alias is helpful when it comes to reducing repetition in type signatures.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eBazaarT'\u003c/a\u003e\u003c/code\u003e p g a t = \u003ccode\u003e\u003ca\u003eBazaarT\u003c/a\u003e\u003c/code\u003e p g a a t\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT%27",
          "type": "type"
        },
        "index": {
          "description": "This alias is helpful when it comes to reducing repetition in type signatures type BazaarT BazaarT",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT'",
          "package": "lens",
          "partial": "Bazaar T'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:BazaarT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eBazaarT1\u003c/a\u003e\u003c/code\u003e is like \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e, except that it provides a questionable \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e instance\n To protect this instance it relies on the soundness of another \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e type, and usage conventions.\n\u003c/p\u003e\u003cp\u003eFor example. This lets us write a suitably polymorphic and lazy \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e, but there\n must be a better way!\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT1",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT1",
          "type": "newtype"
        },
        "index": {
          "description": "BazaarT1 is like Bazaar1 except that it provides questionable Contravariant instance To protect this instance it relies on the soundness of another Contravariant type and usage conventions For example This lets us write suitably polymorphic and lazy taking but there must be better way",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT1",
          "package": "lens",
          "partial": "Bazaar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:BazaarT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis alias is helpful when it comes to reducing repetition in type signatures.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eBazaarT1'\u003c/a\u003e\u003c/code\u003e p g a t = \u003ccode\u003e\u003ca\u003eBazaarT1\u003c/a\u003e\u003c/code\u003e p g a a t\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT1'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT1%27",
          "type": "type"
        },
        "index": {
          "description": "This alias is helpful when it comes to reducing repetition in type signatures type BazaarT1 BazaarT1",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT1'",
          "package": "lens",
          "partial": "Bazaar",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:BazaarT1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is used to run the various \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e variants used in this\n library.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bizarre",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bizarre",
          "type": "class"
        },
        "index": {
          "description": "This class is used to run the various Bazaar variants used in this library",
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bizarre",
          "package": "lens",
          "partial": "Bizarre",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:Bizarre"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bizarre1",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bizarre1",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bizarre1",
          "package": "lens",
          "partial": "Bizarre",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#t:Bizarre1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Internal.Bazaar\",\"Control.Lens.Traversal\"]",
          "name": "Bazaar",
          "package": "lens",
          "signature": "Bazaar",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:Bazaar\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:Bazaar\"]"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar",
          "package": "lens",
          "partial": "Bazaar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:Bazaar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Internal.Bazaar\",\"Control.Lens.Traversal\"]",
          "name": "Bazaar1",
          "package": "lens",
          "signature": "Bazaar1",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:Bazaar1\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:Bazaar1\"]"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "Bazaar1",
          "package": "lens",
          "partial": "Bazaar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:Bazaar1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT",
          "package": "lens",
          "signature": "BazaarT",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT",
          "package": "lens",
          "partial": "Bazaar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:BazaarT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT1",
          "package": "lens",
          "signature": "BazaarT1",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "BazaarT1",
          "package": "lens",
          "partial": "Bazaar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:BazaarT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "bazaar",
          "package": "lens",
          "signature": "p a (f b) -\u003e w a b t -\u003e f t",
          "source": "src/Control-Lens-Internal-Bazaar.html#bazaar",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "bazaar",
          "normalized": "a b(c d)-\u003ee b d f-\u003ec f",
          "package": "lens",
          "signature": "p a(f b)-\u003ew a b t-\u003ef t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:bazaar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "bazaar1",
          "package": "lens",
          "signature": "p a (f b) -\u003e w a b t -\u003e f t",
          "source": "src/Control-Lens-Internal-Bazaar.html#bazaar1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "bazaar1",
          "normalized": "a b(c d)-\u003ee b d f-\u003ec f",
          "package": "lens",
          "signature": "p a(f b)-\u003ew a b t-\u003ef t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:bazaar1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Internal.Bazaar\",\"Control.Lens.Traversal\"]",
          "name": "runBazaar",
          "package": "lens",
          "signature": "p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:runBazaar\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:runBazaar\"]"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "runBazaar",
          "normalized": "a b(c d)-\u003ec e",
          "package": "lens",
          "partial": "Bazaar",
          "signature": "p a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:runBazaar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Internal.Bazaar\",\"Control.Lens.Traversal\"]",
          "name": "runBazaar1",
          "package": "lens",
          "signature": "p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar1",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:runBazaar1\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:runBazaar1\"]"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "runBazaar1",
          "normalized": "a b(c d)-\u003ec e",
          "package": "lens",
          "partial": "Bazaar",
          "signature": "p a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:runBazaar1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "runBazaarT",
          "package": "lens",
          "signature": "p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "runBazaarT",
          "normalized": "a b(c d)-\u003ec e",
          "package": "lens",
          "partial": "Bazaar",
          "signature": "p a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:runBazaarT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Bazaar",
          "name": "runBazaarT1",
          "package": "lens",
          "signature": "p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Internal-Bazaar.html#BazaarT1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Bazaar",
          "module": "Control.Lens.Internal.Bazaar",
          "name": "runBazaarT1",
          "normalized": "a b(c d)-\u003ec e",
          "package": "lens",
          "partial": "Bazaar",
          "signature": "p a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Bazaar.html#v:runBazaarT1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module spends a lot of time fiddling around with \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e internals\n to work around \u003ca\u003ehttp://hackage.haskell.org/trac/ghc/ticket/7556\u003c/a\u003e on older\n Haskell Platforms and to improve constant and asymptotic factors in our performance.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "ByteString",
          "package": "lens",
          "source": "src/Control-Lens-Internal-ByteString.html",
          "type": "module"
        },
        "index": {
          "description": "This module spends lot of time fiddling around with ByteString internals to work around http hackage.haskell.org trac ghc ticket on older Haskell Platforms and to improve constant and asymptotic factors in our performance",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "ByteString",
          "package": "lens",
          "partial": "Byte String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e of the individual bytes in a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedLazy",
          "package": "lens",
          "signature": "IndexedTraversal' Int64 ByteString Word8",
          "source": "src/Control-Lens-Internal-ByteString.html#traversedLazy",
          "type": "function"
        },
        "index": {
          "description": "An IndexedTraversal of the individual bytes in lazy ByteString",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedLazy",
          "package": "lens",
          "partial": "Lazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:traversedLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e of the individual bytes in a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e pretending the bytes are chars.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedLazy8",
          "package": "lens",
          "signature": "IndexedTraversal' Int64 ByteString Char",
          "source": "src/Control-Lens-Internal-ByteString.html#traversedLazy8",
          "type": "function"
        },
        "index": {
          "description": "An IndexedTraversal of the individual bytes in lazy ByteString pretending the bytes are chars",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedLazy8",
          "package": "lens",
          "partial": "Lazy",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:traversedLazy8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e from left to right in a biased fashion.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrict",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int ByteString Word8",
          "source": "src/Control-Lens-Internal-ByteString.html#traversedStrict",
          "type": "function"
        },
        "index": {
          "description": "Traverse strict ByteString from left to right in biased fashion",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrict",
          "normalized": "Int-\u003eIndexedTraversal' Int ByteString Word",
          "package": "lens",
          "partial": "Strict",
          "signature": "Int-\u003eIndexedTraversal' Int ByteString Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:traversedStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e from left to right in a biased fashion\n pretending the bytes are characters.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrict8",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int ByteString Char",
          "source": "src/Control-Lens-Internal-ByteString.html#traversedStrict8",
          "type": "function"
        },
        "index": {
          "description": "Traverse strict ByteString from left to right in biased fashion pretending the bytes are characters",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrict8",
          "normalized": "Int-\u003eIndexedTraversal' Int ByteString Char",
          "package": "lens",
          "partial": "Strict",
          "signature": "Int-\u003eIndexedTraversal' Int ByteString Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:traversedStrict8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e in a relatively balanced fashion, as a balanced tree with biased runs of\n elements at the leaves.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrictTree",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int ByteString Word8",
          "source": "src/Control-Lens-Internal-ByteString.html#traversedStrictTree",
          "type": "function"
        },
        "index": {
          "description": "Traverse strict ByteString in relatively balanced fashion as balanced tree with biased runs of elements at the leaves",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrictTree",
          "normalized": "Int-\u003eIndexedTraversal' Int ByteString Word",
          "package": "lens",
          "partial": "Strict Tree",
          "signature": "Int-\u003eIndexedTraversal' Int ByteString Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:traversedStrictTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse a strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e in a relatively balanced fashion, as a balanced tree with biased runs of\n elements at the leaves, pretending the bytes are chars.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrictTree8",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int ByteString Char",
          "source": "src/Control-Lens-Internal-ByteString.html#traversedStrictTree8",
          "type": "function"
        },
        "index": {
          "description": "Traverse strict ByteString in relatively balanced fashion as balanced tree with biased runs of elements at the leaves pretending the bytes are chars",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "traversedStrictTree8",
          "normalized": "Int-\u003eIndexedTraversal' Int ByteString Char",
          "package": "lens",
          "partial": "Strict Tree",
          "signature": "Int-\u003eIndexedTraversal' Int ByteString Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:traversedStrictTree8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack a lazy \u003ccode\u003eBytestring\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackLazy",
          "package": "lens",
          "signature": "ByteString -\u003e [Word8]",
          "source": "src/Control-Lens-Internal-ByteString.html#unpackLazy",
          "type": "function"
        },
        "index": {
          "description": "Unpack lazy Bytestring",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackLazy",
          "normalized": "ByteString-\u003e[Word]",
          "package": "lens",
          "partial": "Lazy",
          "signature": "ByteString-\u003e[Word]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:unpackLazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack a lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e pretending the bytes are chars.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackLazy8",
          "package": "lens",
          "signature": "ByteString -\u003e String",
          "source": "src/Control-Lens-Internal-ByteString.html#unpackLazy8",
          "type": "function"
        },
        "index": {
          "description": "Unpack lazy ByteString pretending the bytes are chars",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackLazy8",
          "normalized": "ByteString-\u003eString",
          "package": "lens",
          "partial": "Lazy",
          "signature": "ByteString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:unpackLazy8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack a strict \u003ccode\u003e\u003ca\u003eBytestring\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackStrict",
          "package": "lens",
          "signature": "ByteString -\u003e [Word8]",
          "source": "src/Control-Lens-Internal-ByteString.html#unpackStrict",
          "type": "function"
        },
        "index": {
          "description": "Unpack strict Bytestring",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackStrict",
          "normalized": "ByteString-\u003e[Word]",
          "package": "lens",
          "partial": "Strict",
          "signature": "ByteString-\u003e[Word]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:unpackStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnpack a strict \u003ccode\u003e\u003ca\u003eBytestring\u003c/a\u003e\u003c/code\u003e, pretending the bytes are chars.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackStrict8",
          "package": "lens",
          "signature": "ByteString -\u003e String",
          "source": "src/Control-Lens-Internal-ByteString.html#unpackStrict8",
          "type": "function"
        },
        "index": {
          "description": "Unpack strict Bytestring pretending the bytes are chars",
          "hierarchy": "Control Lens Internal ByteString",
          "module": "Control.Lens.Internal.ByteString",
          "name": "unpackStrict8",
          "normalized": "ByteString-\u003eString",
          "package": "lens",
          "partial": "Strict",
          "signature": "ByteString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-ByteString.html#v:unpackStrict8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "Context",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Context",
          "package": "lens",
          "partial": "Context",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe indexed store can be used to characterize a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n and is used by \u003ccode\u003e\u003ca\u003eclone\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e is isomorphic to\n \u003ccode\u003enewtype \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t = \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e { runContext :: forall f. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f b) -\u003e f t }\u003c/code\u003e,\n and to \u003ccode\u003eexists s. (s, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e is like a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that has already been applied to a some structure.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "Context",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Context",
          "type": "data"
        },
        "index": {
          "description": "The indexed store can be used to characterize Lens and is used by clone Context is isomorphic to newtype Context Context runContext forall Functor and to exists Lens Context is like Lens that has already been applied to some structure",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Context",
          "package": "lens",
          "partial": "Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eContext'\u003c/a\u003e\u003c/code\u003e a s = \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a a s\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "Context'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Context%27",
          "type": "type"
        },
        "index": {
          "description": "type Context Context",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Context'",
          "package": "lens",
          "partial": "Context'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:Context-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a Bob Atkey -style 2-argument indexed comonad.\n\u003c/p\u003e\u003cp\u003eIt exists as a superclass for \u003ccode\u003e\u003ca\u003eIndexedComonad\u003c/a\u003e\u003c/code\u003e and expresses the functoriality\n of an \u003ccode\u003e\u003ca\u003eIndexedComonad\u003c/a\u003e\u003c/code\u003e in its third argument.\n\u003c/p\u003e\u003cp\u003eThe notion of indexed monads is covered in more depth in Bob Atkey's\n \u003ca\u003eParameterized Notions of Computation\u003c/a\u003e \u003ca\u003ehttp://bentnib.org/paramnotions-jfp.pdf\u003c/a\u003e\n and that construction is dualized here.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "IndexedComonad",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#IndexedComonad",
          "type": "class"
        },
        "index": {
          "description": "This is Bob Atkey style argument indexed comonad It exists as superclass for IndexedComonad and expresses the functoriality of an IndexedComonad in its third argument The notion of indexed monads is covered in more depth in Bob Atkey Parameterized Notions of Computation http bentnib.org paramnotions-jfp.pdf and that construction is dualized here",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "IndexedComonad",
          "package": "lens",
          "partial": "Indexed Comonad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:IndexedComonad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an indexed analogue to \u003ccode\u003e\u003ca\u003eComonadStore\u003c/a\u003e\u003c/code\u003e for when you are working with an\n \u003ccode\u003e\u003ca\u003eIndexedComonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "IndexedComonadStore",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#IndexedComonadStore",
          "type": "class"
        },
        "index": {
          "description": "This is an indexed analogue to ComonadStore for when you are working with an IndexedComonad",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "IndexedComonadStore",
          "package": "lens",
          "partial": "Indexed Comonad Store",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:IndexedComonadStore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a Bob Atkey -style 2-argument indexed functor.\n\u003c/p\u003e\u003cp\u003eIt exists as a superclass for \u003ccode\u003e\u003ca\u003eIndexedComonad\u003c/a\u003e\u003c/code\u003e and expresses the functoriality\n of an \u003ccode\u003e\u003ca\u003eIndexedComonad\u003c/a\u003e\u003c/code\u003e in its third argument.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "IndexedFunctor",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#IndexedFunctor",
          "type": "class"
        },
        "index": {
          "description": "This is Bob Atkey style argument indexed functor It exists as superclass for IndexedComonad and expresses the functoriality of an IndexedComonad in its third argument",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "IndexedFunctor",
          "package": "lens",
          "partial": "Indexed Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:IndexedFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalized form of \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e that can be repeatedly cloned with less\n impact on its performance, and which permits the use of an arbitrary \u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "Pretext",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Pretext",
          "type": "newtype"
        },
        "index": {
          "description": "This is generalized form of Context that can be repeatedly cloned with less impact on its performance and which permits the use of an arbitrary Conjoined Profunctor",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Pretext",
          "package": "lens",
          "partial": "Pretext",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:Pretext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003etype \u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e p a s = \u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e p a a s\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "Pretext'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Pretext%27",
          "type": "type"
        },
        "index": {
          "description": "type Pretext Pretext",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Pretext'",
          "package": "lens",
          "partial": "Pretext'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:Pretext-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalized form of \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e that can be repeatedly cloned with less\n impact on its performance, and which permits the use of an arbitrary \u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe extra phantom \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e is used to let us lie and claim a \u003ccode\u003eGettable\u003c/code\u003e instance under\n limited circumstances. This is used internally to permit a number of combinators to\n gracefully degrade when applied to a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "PretextT",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#PretextT",
          "type": "newtype"
        },
        "index": {
          "description": "This is generalized form of Context that can be repeatedly cloned with less impact on its performance and which permits the use of an arbitrary Conjoined Profunctor The extra phantom Functor is used to let us lie and claim Gettable instance under limited circumstances This is used internally to permit number of combinators to gracefully degrade when applied to Fold Getter or Action",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "PretextT",
          "package": "lens",
          "partial": "Pretext",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:PretextT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003etype \u003ccode\u003e\u003ca\u003ePretextT'\u003c/a\u003e\u003c/code\u003e p g a s = \u003ccode\u003e\u003ca\u003ePretextT\u003c/a\u003e\u003c/code\u003e p g a a s\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "PretextT'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#PretextT%27",
          "type": "type"
        },
        "index": {
          "description": "type PretextT PretextT",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "PretextT'",
          "package": "lens",
          "partial": "Pretext T'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:PretextT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used internally to construct a \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e\n from a singleton value.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "Sellable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Sellable",
          "type": "class"
        },
        "index": {
          "description": "This is used internally to construct Bazaar Context or Pretext from singleton value",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Sellable",
          "package": "lens",
          "partial": "Sellable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#t:Sellable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Internal.Context\",\"Control.Lens.Lens\"]",
          "name": "Context",
          "package": "lens",
          "signature": "Context (b -\u003e t) a",
          "source": "src/Control-Lens-Internal-Context.html#Context",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:Context\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:Context\"]"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Context",
          "normalized": "Context(a-\u003eb)c",
          "package": "lens",
          "partial": "Context",
          "signature": "Context(b-\u003et)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "Pretext",
          "package": "lens",
          "signature": "Pretext",
          "source": "src/Control-Lens-Internal-Context.html#Pretext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "Pretext",
          "package": "lens",
          "partial": "Pretext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:Pretext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "PretextT",
          "package": "lens",
          "signature": "PretextT",
          "source": "src/Control-Lens-Internal-Context.html#PretextT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "PretextT",
          "package": "lens",
          "partial": "Pretext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:PretextT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can always forget the rest of the structure of \u003ccode\u003ew\u003c/code\u003e and obtain a simpler\n indexed comonad store model called \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "context",
          "package": "lens",
          "signature": "w a b t -\u003e Context a b t",
          "source": "src/Control-Lens-Internal-Context.html#context",
          "type": "method"
        },
        "index": {
          "description": "We can always forget the rest of the structure of and obtain simpler indexed comonad store model called Context",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "context",
          "normalized": "a b c d-\u003eContext b c d",
          "package": "lens",
          "signature": "w a b t-\u003eContext a b t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eduplicate an indexed comonadic value splitting the index.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "iduplicate",
          "package": "lens",
          "signature": "w a c t -\u003e w a b (w b c t)",
          "source": "src/Control-Lens-Internal-Context.html#iduplicate",
          "type": "method"
        },
        "index": {
          "description": "duplicate an indexed comonadic value splitting the index",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "iduplicate",
          "normalized": "a b c d-\u003ea b e(a e c d)",
          "package": "lens",
          "signature": "w a c t-\u003ew a b(w b c t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:iduplicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the generalization of \u003ccode\u003e\u003ca\u003eexperiment\u003c/a\u003e\u003c/code\u003e to an indexed comonad store.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "iexperiment",
          "package": "lens",
          "signature": "(b -\u003e f c) -\u003e w b c t -\u003e f t",
          "source": "src/Control-Lens-Internal-Context.html#iexperiment",
          "type": "method"
        },
        "index": {
          "description": "This is the generalization of experiment to an indexed comonad store",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "iexperiment",
          "normalized": "(a-\u003eb c)-\u003ed a c e-\u003eb e",
          "package": "lens",
          "signature": "(b-\u003ef c)-\u003ew b c t-\u003ef t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:iexperiment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextend a indexed comonadic computation splitting the index.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "iextend",
          "package": "lens",
          "signature": "(w b c t -\u003e r) -\u003e w a c t -\u003e w a b r",
          "source": "src/Control-Lens-Internal-Context.html#iextend",
          "type": "method"
        },
        "index": {
          "description": "extend indexed comonadic computation splitting the index",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "iextend",
          "normalized": "(a b c d-\u003ee)-\u003ea f c d-\u003ea f b e",
          "package": "lens",
          "signature": "(w b c t-\u003er)-\u003ew a c t-\u003ew a b r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:iextend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextract from an indexed comonadic value when the indices match.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "iextract",
          "package": "lens",
          "signature": "w a a t -\u003e t",
          "source": "src/Control-Lens-Internal-Context.html#iextract",
          "type": "method"
        },
        "index": {
          "description": "extract from an indexed comonadic value when the indices match",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "iextract",
          "normalized": "a b b c-\u003ec",
          "package": "lens",
          "signature": "w a a t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:iextract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "ifmap",
          "package": "lens",
          "signature": "(s -\u003e t) -\u003e w a b s -\u003e w a b t",
          "source": "src/Control-Lens-Internal-Context.html#ifmap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "ifmap",
          "normalized": "(a-\u003eb)-\u003ec d e a-\u003ec d e b",
          "package": "lens",
          "signature": "(s-\u003et)-\u003ew a b s-\u003ew a b t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:ifmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the generalization of \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e to an indexed comonad store.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "ipeek",
          "package": "lens",
          "signature": "c -\u003e w a c t -\u003e t",
          "source": "src/Control-Lens-Internal-Context.html#ipeek",
          "type": "method"
        },
        "index": {
          "description": "This is the generalization of peek to an indexed comonad store",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "ipeek",
          "normalized": "a-\u003eb c a d-\u003ed",
          "package": "lens",
          "signature": "c-\u003ew a c t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:ipeek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the generalization of \u003ccode\u003e\u003ca\u003epeeks\u003c/a\u003e\u003c/code\u003e to an indexed comonad store.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "ipeeks",
          "package": "lens",
          "signature": "(a -\u003e c) -\u003e w a c t -\u003e t",
          "source": "src/Control-Lens-Internal-Context.html#ipeeks",
          "type": "method"
        },
        "index": {
          "description": "This is the generalization of peeks to an indexed comonad store",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "ipeeks",
          "normalized": "(a-\u003eb)-\u003ec a b d-\u003ed",
          "package": "lens",
          "signature": "(a-\u003ec)-\u003ew a c t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:ipeeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the generalization of \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e to an indexed comonad store.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "ipos",
          "package": "lens",
          "signature": "w a c t -\u003e a",
          "source": "src/Control-Lens-Internal-Context.html#ipos",
          "type": "method"
        },
        "index": {
          "description": "This is the generalization of pos to an indexed comonad store",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "ipos",
          "normalized": "a b c d-\u003eb",
          "package": "lens",
          "signature": "w a c t-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:ipos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the generalization of \u003ccode\u003e\u003ca\u003eseek\u003c/a\u003e\u003c/code\u003e to an indexed comonad store.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "iseek",
          "package": "lens",
          "signature": "b -\u003e w a c t -\u003e w b c t",
          "source": "src/Control-Lens-Internal-Context.html#iseek",
          "type": "method"
        },
        "index": {
          "description": "This is the generalization of seek to an indexed comonad store",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "iseek",
          "normalized": "a-\u003eb c d e-\u003eb a d e",
          "package": "lens",
          "signature": "b-\u003ew a c t-\u003ew b c t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:iseek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the generalization of \u003ccode\u003e\u003ca\u003eseeks\u003c/a\u003e\u003c/code\u003e to an indexed comonad store.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Context",
          "name": "iseeks",
          "package": "lens",
          "signature": "(a -\u003e b) -\u003e w a c t -\u003e w b c t",
          "source": "src/Control-Lens-Internal-Context.html#iseeks",
          "type": "method"
        },
        "index": {
          "description": "This is the generalization of seeks to an indexed comonad store",
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "iseeks",
          "normalized": "(a-\u003eb)-\u003ec a d e-\u003ec b d e",
          "package": "lens",
          "signature": "(a-\u003eb)-\u003ew a c t-\u003ew b c t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:iseeks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "runPretext",
          "package": "lens",
          "signature": "p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Internal-Context.html#Pretext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "runPretext",
          "normalized": "a b(c d)-\u003ec e",
          "package": "lens",
          "partial": "Pretext",
          "signature": "p a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:runPretext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "runPretextT",
          "package": "lens",
          "signature": "p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Internal-Context.html#PretextT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "runPretextT",
          "normalized": "a b(c d)-\u003ec e",
          "package": "lens",
          "partial": "Pretext",
          "signature": "p a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:runPretextT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Context",
          "name": "sell",
          "package": "lens",
          "signature": "p a (w a b b)",
          "source": "src/Control-Lens-Internal-Context.html#sell",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Context",
          "module": "Control.Lens.Internal.Context",
          "name": "sell",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Context.html#v:sell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module is designed to be imported qualified.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.Deque",
          "name": "Deque",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Deque.html",
          "type": "module"
        },
        "index": {
          "description": "This module is designed to be imported qualified",
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "Deque",
          "package": "lens",
          "partial": "Deque",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Banker's deque based on Chris Okasaki's \"Purely Functional Data Structures\"\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Deque",
          "name": "Deque",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Deque.html#Deque",
          "type": "data"
        },
        "index": {
          "description": "Banker deque based on Chris Okasaki Purely Functional Data Structures",
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "Deque",
          "package": "lens",
          "partial": "Deque",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#t:Deque"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Deque",
          "name": "BD",
          "package": "lens",
          "signature": "BD !Int [a] !Int [a]",
          "source": "src/Control-Lens-Internal-Deque.html#Deque",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "BD",
          "normalized": "BD Int[a]Int[a]",
          "package": "lens",
          "partial": "BD",
          "signature": "BD Int[a]Int[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#v:BD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e amortized. Construct a \u003ccode\u003e\u003ca\u003eDeque\u003c/a\u003e\u003c/code\u003e from a list of values.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [1,2]\n\u003c/code\u003e\u003c/strong\u003eBD 1 [1] 1 [2]\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Deque",
          "name": "fromList",
          "package": "lens",
          "signature": "[a] -\u003e Deque a",
          "source": "src/Control-Lens-Internal-Deque.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "amortized Construct Deque from list of values fromList BD",
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "fromList",
          "normalized": "[a]-\u003eDeque a",
          "package": "lens",
          "partial": "List",
          "signature": "[a]-\u003eDeque a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Determine of a \u003ccode\u003e\u003ca\u003eDeque\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enull empty\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003enull (singleton 1)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Deque",
          "name": "null",
          "package": "lens",
          "signature": "Deque a -\u003e Bool",
          "source": "src/Control-Lens-Internal-Deque.html#null",
          "type": "function"
        },
        "index": {
          "description": "Determine of Deque is empty null empty True null singleton False",
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "null",
          "normalized": "Deque a-\u003eBool",
          "package": "lens",
          "signature": "Deque a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Generate a singleton \u003ccode\u003e\u003ca\u003eDeque\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esingleton 1\n\u003c/code\u003e\u003c/strong\u003eBD 1 [1] 0 []\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Deque",
          "name": "singleton",
          "package": "lens",
          "signature": "a -\u003e Deque a",
          "source": "src/Control-Lens-Internal-Deque.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "Generate singleton Deque singleton BD",
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "singleton",
          "normalized": "a-\u003eDeque a",
          "package": "lens",
          "signature": "a-\u003eDeque a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Calculate the size of a \u003ccode\u003e\u003ca\u003eDeque\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esize (fromList [1,4,6])\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Deque",
          "name": "size",
          "package": "lens",
          "signature": "Deque a -\u003e Int",
          "source": "src/Control-Lens-Internal-Deque.html#size",
          "type": "function"
        },
        "index": {
          "description": "Calculate the size of Deque size fromList",
          "hierarchy": "Control Lens Internal Deque",
          "module": "Control.Lens.Internal.Deque",
          "name": "size",
          "normalized": "Deque a-\u003eInt",
          "package": "lens",
          "signature": "Deque a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Deque.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module uses dirty tricks to generate a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e from an arbitrary\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.Exception",
          "name": "Exception",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Exception.html",
          "type": "module"
        },
        "index": {
          "description": "This module uses dirty tricks to generate Handler from an arbitrary Fold",
          "hierarchy": "Control Lens Internal Exception",
          "module": "Control.Lens.Internal.Exception",
          "name": "Exception",
          "package": "lens",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoth \u003ccode\u003eexceptions\u003c/code\u003e and \u003ca\u003eControl.Exception\u003c/a\u003e provide a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e\u003cp\u003eThis lets us write combinators to build handlers that are agnostic about the choice of\n which of these they use.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Exception",
          "name": "Handleable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Exception.html#Handleable",
          "type": "class"
        },
        "index": {
          "description": "Both exceptions and Control.Exception provide Handler type This lets us write combinators to build handlers that are agnostic about the choice of which of these they use",
          "hierarchy": "Control Lens Internal Exception",
          "module": "Control.Lens.Internal.Exception",
          "name": "Handleable",
          "package": "lens",
          "partial": "Handleable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Exception.html#t:Handleable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere was an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e caused by abusing the internals of a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Exception",
          "name": "HandlingException",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Exception.html#HandlingException",
          "type": "data"
        },
        "index": {
          "description": "There was an Exception caused by abusing the internals of Handler",
          "hierarchy": "Control Lens Internal Exception",
          "module": "Control.Lens.Internal.Exception",
          "name": "HandlingException",
          "package": "lens",
          "partial": "Handling Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Exception.html#t:HandlingException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Exception",
          "name": "HandlingException",
          "package": "lens",
          "signature": "HandlingException",
          "source": "src/Control-Lens-Internal-Exception.html#HandlingException",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Exception",
          "module": "Control.Lens.Internal.Exception",
          "name": "HandlingException",
          "package": "lens",
          "partial": "Handling Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Exception.html#v:HandlingException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis builds a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e for just the targets of a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e ... [ \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_AssertionFailed\u003c/a\u003e\u003c/code\u003e (s -\u003e \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \"Assertion Failed\\n\" \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e s)\n             , \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_ErrorCall\u003c/a\u003e\u003c/code\u003e (s -\u003e \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \"Error\\n\" \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e s)\n             ]\n\u003c/pre\u003e\u003cp\u003eThis works ith both the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Exception\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Catch\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Error.Lens\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Exception",
          "name": "handler",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e (a -\u003e m r) -\u003e h r",
          "source": "src/Control-Lens-Internal-Exception.html#handler",
          "type": "method"
        },
        "index": {
          "description": "This builds Handler for just the targets of given Prism or any Getter really catches handler AssertionFailed print Assertion Failed handler ErrorCall print Error This works ith both the Handler type provided by Control.Exception handler Getter SomeException IO Handler handler Fold SomeException IO Handler handler Prism SomeException IO Handler handler Lens SomeException IO Handler handler Traversal SomeException IO Handler and with the Handler type provided by Control.Monad.Catch handler Getter SomeException Handler handler Fold SomeException Handler handler Prism SomeException Handler handler Lens SomeException Handler handler Traversal SomeException Handler and with the Handler type provided by Control.Monad.Error.Lens handler Getter Handler handler Fold Handler handler Prism Handler handler Lens Handler handler Traversal Handler",
          "hierarchy": "Control Lens Internal Exception",
          "module": "Control.Lens.Internal.Exception",
          "name": "handler",
          "normalized": "Getting(First a)b a-\u003e(a-\u003ec d)-\u003ee d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003e(a-\u003em r)-\u003eh r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Exception.html#v:handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis builds a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e for just the targets of a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n that ignores its input and just recovers with the stated monadic action.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e ... [ \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_NonTermination\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e \"looped\")\n             , \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_StackOverflow\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e \"overflow\")\n             ]\n\u003c/pre\u003e\u003cp\u003eThis works with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Exception\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Catch\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Error.Lens\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Exception",
          "name": "handler_",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e h r",
          "source": "src/Control-Lens-Internal-Exception.html#handler_",
          "type": "method"
        },
        "index": {
          "description": "This builds Handler for just the targets of given Prism or any Getter really that ignores its input and just recovers with the stated monadic action catches handler NonTermination return looped handler StackOverflow return overflow This works with the Handler type provided by Control.Exception handler Getter SomeException IO Handler handler Fold SomeException IO Handler handler Prism SomeException IO Handler handler Lens SomeException IO Handler handler Traversal SomeException IO Handler and with the Handler type provided by Control.Monad.Catch handler Getter SomeException Handler handler Fold SomeException Handler handler Prism SomeException Handler handler Lens SomeException Handler handler Traversal SomeException Handler and with the Handler type provided by Control.Monad.Error.Lens handler Getter Handler handler Fold Handler handler Prism Handler handler Lens Handler handler Traversal Handler",
          "hierarchy": "Control Lens Internal Exception",
          "module": "Control.Lens.Internal.Exception",
          "name": "handler_",
          "normalized": "Getting(First a)b a-\u003ec d-\u003ee d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003eh r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Exception.html#v:handler_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "Fold",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Fold",
          "package": "lens",
          "partial": "Fold",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Folding",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Folding",
          "type": "newtype"
        },
        "index": {
          "description": "Monoid for Contravariant Applicative",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Folding",
          "package": "lens",
          "partial": "Folding",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Folding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Leftmost",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Leftmost",
          "type": "data"
        },
        "index": {
          "description": "Used for preview",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Leftmost",
          "package": "lens",
          "partial": "Leftmost",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Leftmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "M",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#M",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "M",
          "package": "lens",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for \u003ccode\u003e\u003ca\u003emaximumOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Max",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Max",
          "type": "data"
        },
        "index": {
          "description": "Used for maximumOf",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Max",
          "package": "lens",
          "partial": "Max",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for \u003ccode\u003e\u003ca\u003eminimumOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Min",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Min",
          "type": "data"
        },
        "index": {
          "description": "Used for minimumOf",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Min",
          "package": "lens",
          "partial": "Min",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "ReifiedMonoid",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#ReifiedMonoid",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "ReifiedMonoid",
          "package": "lens",
          "partial": "Reified Monoid",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:ReifiedMonoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed for \u003ccode\u003e\u003ca\u003elastOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Rightmost",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Rightmost",
          "type": "data"
        },
        "index": {
          "description": "Used for lastOf",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Rightmost",
          "package": "lens",
          "partial": "Rightmost",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Rightmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed internally by \u003ccode\u003e\u003ca\u003emapM_\u003c/a\u003e\u003c/code\u003e and the like.\n\u003c/p\u003e\u003cp\u003eThe argument \u003ccode\u003ea\u003c/code\u003e of the result should not be used!\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Sequenced",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Sequenced",
          "type": "newtype"
        },
        "index": {
          "description": "Used internally by mapM and the like The argument of the result should not be used",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Sequenced",
          "package": "lens",
          "partial": "Sequenced",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Sequenced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed internally by \u003ccode\u003e\u003ca\u003etraverseOf_\u003c/a\u003e\u003c/code\u003e and the like.\n\u003c/p\u003e\u003cp\u003eThe argument \u003ccode\u003ea\u003c/code\u003e of the result should not be used!\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "Traversed",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Fold.html#Traversed",
          "type": "newtype"
        },
        "index": {
          "description": "Used internally by traverseOf and the like The argument of the result should not be used",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Traversed",
          "package": "lens",
          "partial": "Traversed",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#t:Traversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "Folding",
          "package": "lens",
          "signature": "Folding",
          "source": "src/Control-Lens-Internal-Fold.html#Folding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Folding",
          "package": "lens",
          "partial": "Folding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:Folding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "LLeaf",
          "package": "lens",
          "signature": "LLeaf a",
          "source": "src/Control-Lens-Internal-Fold.html#Leftmost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "LLeaf",
          "package": "lens",
          "partial": "LLeaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:LLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "LPure",
          "package": "lens",
          "signature": "LPure",
          "source": "src/Control-Lens-Internal-Fold.html#Leftmost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "LPure",
          "package": "lens",
          "partial": "LPure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:LPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "LStep",
          "package": "lens",
          "signature": "LStep (Leftmost a)",
          "source": "src/Control-Lens-Internal-Fold.html#Leftmost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "LStep",
          "package": "lens",
          "partial": "LStep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:LStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "M",
          "package": "lens",
          "signature": "M a",
          "source": "src/Control-Lens-Internal-Fold.html#M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "M",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "Max",
          "package": "lens",
          "signature": "Max a",
          "source": "src/Control-Lens-Internal-Fold.html#Max",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Max",
          "package": "lens",
          "partial": "Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:Max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "Min",
          "package": "lens",
          "signature": "Min a",
          "source": "src/Control-Lens-Internal-Fold.html#Min",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Min",
          "package": "lens",
          "partial": "Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:Min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "NoMax",
          "package": "lens",
          "signature": "NoMax",
          "source": "src/Control-Lens-Internal-Fold.html#Max",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "NoMax",
          "package": "lens",
          "partial": "No Max",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:NoMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "NoMin",
          "package": "lens",
          "signature": "NoMin",
          "source": "src/Control-Lens-Internal-Fold.html#Min",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "NoMin",
          "package": "lens",
          "partial": "No Min",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:NoMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "RLeaf",
          "package": "lens",
          "signature": "RLeaf a",
          "source": "src/Control-Lens-Internal-Fold.html#Rightmost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "RLeaf",
          "package": "lens",
          "partial": "RLeaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:RLeaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "RPure",
          "package": "lens",
          "signature": "RPure",
          "source": "src/Control-Lens-Internal-Fold.html#Rightmost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "RPure",
          "package": "lens",
          "partial": "RPure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:RPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "RStep",
          "package": "lens",
          "signature": "RStep (Rightmost a)",
          "source": "src/Control-Lens-Internal-Fold.html#Rightmost",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "RStep",
          "package": "lens",
          "partial": "RStep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:RStep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "ReifiedMonoid",
          "package": "lens",
          "signature": "ReifiedMonoid",
          "source": "src/Control-Lens-Internal-Fold.html#ReifiedMonoid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "ReifiedMonoid",
          "package": "lens",
          "partial": "Reified Monoid",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:ReifiedMonoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "Sequenced",
          "package": "lens",
          "signature": "Sequenced",
          "source": "src/Control-Lens-Internal-Fold.html#Sequenced",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Sequenced",
          "package": "lens",
          "partial": "Sequenced",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:Sequenced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "Traversed",
          "package": "lens",
          "signature": "Traversed",
          "source": "src/Control-Lens-Internal-Fold.html#Traversed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "Traversed",
          "package": "lens",
          "partial": "Traversed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:Traversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "getFolding",
          "package": "lens",
          "signature": "f a",
          "source": "src/Control-Lens-Internal-Fold.html#Folding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getFolding",
          "package": "lens",
          "partial": "Folding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getFolding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the \u003ccode\u003e\u003ca\u003eLeftmost\u003c/a\u003e\u003c/code\u003e element. This will fairly eagerly determine that it can return \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e\n the moment it sees any element at all.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "getLeftmost",
          "package": "lens",
          "signature": "Leftmost a -\u003e Maybe a",
          "source": "src/Control-Lens-Internal-Fold.html#getLeftmost",
          "type": "function"
        },
        "index": {
          "description": "Extract the Leftmost element This will fairly eagerly determine that it can return Just the moment it sees any element at all",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getLeftmost",
          "normalized": "Leftmost a-\u003eMaybe a",
          "package": "lens",
          "partial": "Leftmost",
          "signature": "Leftmost a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getLeftmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the maximum.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "getMax",
          "package": "lens",
          "signature": "Max a -\u003e Maybe a",
          "source": "src/Control-Lens-Internal-Fold.html#getMax",
          "type": "function"
        },
        "index": {
          "description": "Obtain the maximum",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getMax",
          "normalized": "Max a-\u003eMaybe a",
          "package": "lens",
          "partial": "Max",
          "signature": "Max a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the minimum.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "getMin",
          "package": "lens",
          "signature": "Min a -\u003e Maybe a",
          "source": "src/Control-Lens-Internal-Fold.html#getMin",
          "type": "function"
        },
        "index": {
          "description": "Obtain the minimum",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getMin",
          "normalized": "Min a-\u003eMaybe a",
          "package": "lens",
          "partial": "Min",
          "signature": "Min a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the \u003ccode\u003e\u003ca\u003eRightmost\u003c/a\u003e\u003c/code\u003e element. This will fairly eagerly determine that it can return \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e\n the moment it sees any element at all.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Fold",
          "name": "getRightmost",
          "package": "lens",
          "signature": "Rightmost a -\u003e Maybe a",
          "source": "src/Control-Lens-Internal-Fold.html#getRightmost",
          "type": "function"
        },
        "index": {
          "description": "Extract the Rightmost element This will fairly eagerly determine that it can return Just the moment it sees any element at all",
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getRightmost",
          "normalized": "Rightmost a-\u003eMaybe a",
          "package": "lens",
          "partial": "Rightmost",
          "signature": "Rightmost a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getRightmost"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "getSequenced",
          "package": "lens",
          "signature": "m a",
          "source": "src/Control-Lens-Internal-Fold.html#Sequenced",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getSequenced",
          "package": "lens",
          "partial": "Sequenced",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getSequenced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "getTraversed",
          "package": "lens",
          "signature": "f a",
          "source": "src/Control-Lens-Internal-Fold.html#Traversed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "getTraversed",
          "package": "lens",
          "partial": "Traversed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:getTraversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "reifiedMappend",
          "package": "lens",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Control-Lens-Internal-Fold.html#ReifiedMonoid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "reifiedMappend",
          "normalized": "a-\u003ea-\u003ea",
          "package": "lens",
          "partial": "Mappend",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:reifiedMappend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "reifiedMempty",
          "package": "lens",
          "signature": "a",
          "source": "src/Control-Lens-Internal-Fold.html#ReifiedMonoid",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "reifiedMempty",
          "package": "lens",
          "partial": "Mempty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:reifiedMempty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Fold",
          "name": "reifyFold",
          "package": "lens",
          "signature": "t -\u003e M a s) -\u003e t -\u003e a",
          "source": "src/Control-Lens-Internal-Fold.html#reifyFold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Fold",
          "module": "Control.Lens.Internal.Fold",
          "name": "reifyFold",
          "normalized": "a-\u003eM b c)-\u003ea-\u003eb",
          "package": "lens",
          "partial": "Fold",
          "signature": "t-\u003eM a s)-\u003et-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Fold.html#v:reifyFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "Getter",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Getter.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "Getter",
          "package": "lens",
          "partial": "Getter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideLeft",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Getter.html#AlongsideLeft",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideLeft",
          "package": "lens",
          "partial": "Alongside Left",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#t:AlongsideLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideRight",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Getter.html#AlongsideRight",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideRight",
          "package": "lens",
          "partial": "Alongside Right",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#t:AlongsideRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is provided mostly for backwards compatibility with lens 3.8,\n but it can also shorten type signatures.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Getter",
          "name": "Gettable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Getter.html#Gettable",
          "type": "class"
        },
        "index": {
          "description": "This class is provided mostly for backwards compatibility with lens but it can also shorten type signatures",
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "Gettable",
          "package": "lens",
          "partial": "Gettable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#t:Gettable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideLeft",
          "package": "lens",
          "signature": "AlongsideLeft",
          "source": "src/Control-Lens-Internal-Getter.html#AlongsideLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideLeft",
          "package": "lens",
          "partial": "Alongside Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#v:AlongsideLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideRight",
          "package": "lens",
          "signature": "AlongsideRight",
          "source": "src/Control-Lens-Internal-Getter.html#AlongsideRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "AlongsideRight",
          "package": "lens",
          "partial": "Alongside Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#v:AlongsideRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "getAlongsideLeft",
          "package": "lens",
          "signature": "f (a, b)",
          "source": "src/Control-Lens-Internal-Getter.html#AlongsideLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "getAlongsideLeft",
          "normalized": "a(b,c)",
          "package": "lens",
          "partial": "Alongside Left",
          "signature": "f(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#v:getAlongsideLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Getter",
          "name": "getAlongsideRight",
          "package": "lens",
          "signature": "f (a, b)",
          "source": "src/Control-Lens-Internal-Getter.html#AlongsideRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "getAlongsideRight",
          "normalized": "a(b,c)",
          "package": "lens",
          "partial": "Alongside Right",
          "signature": "f(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#v:getAlongsideRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003emempty\u003c/code\u003e equivalent for a \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Getter",
          "name": "noEffect",
          "package": "lens",
          "signature": "f a",
          "source": "src/Control-Lens-Internal-Getter.html#noEffect",
          "type": "function"
        },
        "index": {
          "description": "The mempty equivalent for Gettable Applicative Functor",
          "hierarchy": "Control Lens Internal Getter",
          "module": "Control.Lens.Internal.Getter",
          "name": "noEffect",
          "package": "lens",
          "partial": "Effect",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Getter.html#v:noEffect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eInternal implementation details for \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e lens-likes\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexed",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html",
          "type": "module"
        },
        "index": {
          "description": "Internal implementation details for Indexed lens-likes",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexed",
          "package": "lens",
          "partial": "Indexed",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e that is both \u003ccode\u003e\u003ca\u003eCorepresentable\u003c/a\u003e\u003c/code\u003e by \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRepresentable\u003c/a\u003e\u003c/code\u003e by \u003ccode\u003eg\u003c/code\u003e such\n that \u003ccode\u003ef\u003c/code\u003e is left adjoint to \u003ccode\u003eg\u003c/code\u003e. From this you can derive a lot of structure due\n to the preservation of limits and colimits.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Conjoined",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Conjoined",
          "type": "class"
        },
        "index": {
          "description": "This is Profunctor that is both Corepresentable by and Representable by such that is left adjoint to From this you can derive lot of structure due to the preservation of limits and colimits",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Conjoined",
          "package": "lens",
          "partial": "Conjoined",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#t:Conjoined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class permits overloading of function application for things that\n also admit a notion of a key or index.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexable",
          "type": "class"
        },
        "index": {
          "description": "This class permits overloading of function application for things that also admit notion of key or index",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexable",
          "package": "lens",
          "partial": "Indexable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#t:Indexable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with access to a index. This constructor may be useful when you need to store\n an \u003ccode\u003e\u003ca\u003eIndexable\u003c/a\u003e\u003c/code\u003e in a container to avoid \u003ccode\u003eImpredicativeTypes\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003eindex :: Indexed i a b -\u003e i -\u003e a -\u003e b\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexed",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexed",
          "type": "newtype"
        },
        "index": {
          "description": "function with access to index This constructor may be useful when you need to store an Indexable in container to avoid ImpredicativeTypes index Indexed",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexed",
          "package": "lens",
          "partial": "Indexed",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#t:Indexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e composition of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, used\n by \u003ccode\u003e\u003ca\u003eindexed\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexing",
          "type": "newtype"
        },
        "index": {
          "description": "Applicative composition of State Int with Functor used by indexed",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing",
          "package": "lens",
          "partial": "Indexing",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#t:Indexing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e composition of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt64\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, used\n by \u003ccode\u003e\u003ca\u003eindexed64\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing64",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexing64",
          "type": "newtype"
        },
        "index": {
          "description": "Applicative composition of State Int64 with Functor used by indexed64",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing64",
          "package": "lens",
          "partial": "Indexing",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#t:Indexing64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing",
          "package": "lens",
          "signature": "Indexing",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing",
          "package": "lens",
          "partial": "Indexing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:Indexing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing64",
          "package": "lens",
          "signature": "Indexing64",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexing64",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "Indexing64",
          "package": "lens",
          "partial": "Indexing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:Indexing64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis permits us to make a decision at an outermost point about whether or not we use an index.\n\u003c/p\u003e\u003cp\u003eIdeally any use of this function should be done in such a way so that you compute the same answer,\n but this cannot be enforced at the type level.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "conjoined",
          "package": "lens",
          "signature": "q (a -\u003e b) r) -\u003e q (p a b) r -\u003e q (p a b) r",
          "source": "src/Control-Lens-Internal-Indexed.html#conjoined",
          "type": "method"
        },
        "index": {
          "description": "This permits us to make decision at an outermost point about whether or not we use an index Ideally any use of this function should be done in such way so that you compute the same answer but this cannot be enforced at the type level",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "conjoined",
          "normalized": "a(b-\u003ec)d)-\u003ea(e b c)d-\u003ea(e b c)d",
          "package": "lens",
          "signature": "q(a-\u003eb)r)-\u003eq(p a b)r-\u003eq(p a b)r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:conjoined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e is strong enough to let us distribute every \u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e over every Haskell \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e. This is effectively a\n generalization of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "distrib",
          "package": "lens",
          "signature": "p a b -\u003e p (f a) (f b)",
          "source": "src/Control-Lens-Internal-Indexed.html#distrib",
          "type": "method"
        },
        "index": {
          "description": "Conjoined is strong enough to let us distribute every Conjoined Profunctor over every Haskell Functor This is effectively generalization of fmap",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "distrib",
          "normalized": "a b c-\u003ea(d b)(d c)",
          "package": "lens",
          "signature": "p a b-\u003ep(f a)(f b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:distrib"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a function from an \u003ccode\u003e\u003ca\u003eindexed\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Indexed",
          "name": "indexed",
          "package": "lens",
          "signature": "p a b -\u003e i -\u003e a -\u003e b",
          "source": "src/Control-Lens-Internal-Indexed.html#indexed",
          "type": "method"
        },
        "index": {
          "description": "Build function from an indexed function",
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "indexed",
          "normalized": "a b c-\u003ed-\u003eb-\u003ec",
          "package": "lens",
          "signature": "p a b-\u003ei-\u003ea-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:indexed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Indexed",
          "name": "runIndexing",
          "package": "lens",
          "signature": "Int -\u003e (Int, f a)",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "runIndexing",
          "normalized": "Int-\u003e(Int,a b)",
          "package": "lens",
          "partial": "Indexing",
          "signature": "Int-\u003e(Int,f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:runIndexing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Indexed",
          "name": "runIndexing64",
          "package": "lens",
          "signature": "Int64 -\u003e (Int64, f a)",
          "source": "src/Control-Lens-Internal-Indexed.html#Indexing64",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Indexed",
          "module": "Control.Lens.Internal.Indexed",
          "name": "runIndexing64",
          "normalized": "Int-\u003e(Int,a b)",
          "package": "lens",
          "partial": "Indexing",
          "signature": "Int-\u003e(Int,f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Indexed.html#v:runIndexing64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module includes orphan instances for \u003ccode\u003e(,)\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e that\n should be supplied by base.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.Instances",
          "name": "Instances",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Instances.html",
          "type": "module"
        },
        "index": {
          "description": "This module includes orphan instances for Either and Const that should be supplied by base",
          "hierarchy": "Control Lens Internal Instances",
          "module": "Control.Lens.Internal.Instances",
          "name": "Instances",
          "package": "lens",
          "partial": "Instances",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Instances.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Iso",
          "name": "Iso",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Iso.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Iso",
          "module": "Control.Lens.Internal.Iso",
          "name": "Iso",
          "package": "lens",
          "partial": "Iso",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Iso.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used internally by the \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e code to provide\n efficient access to the two functions that make up an isomorphism.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Iso",
          "name": "Exchange",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Iso.html#Exchange",
          "type": "data"
        },
        "index": {
          "description": "This is used internally by the Iso code to provide efficient access to the two functions that make up an isomorphism",
          "hierarchy": "Control Lens Internal Iso",
          "module": "Control.Lens.Internal.Iso",
          "name": "Exchange",
          "package": "lens",
          "partial": "Exchange",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Iso.html#t:Exchange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides a generalized notion of list reversal extended to other containers.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Iso",
          "name": "Reversing",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Iso.html#Reversing",
          "type": "class"
        },
        "index": {
          "description": "This class provides generalized notion of list reversal extended to other containers",
          "hierarchy": "Control Lens Internal Iso",
          "module": "Control.Lens.Internal.Iso",
          "name": "Reversing",
          "package": "lens",
          "partial": "Reversing",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Iso.html#t:Reversing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Iso",
          "name": "Exchange",
          "package": "lens",
          "signature": "Exchange (s -\u003e a) (b -\u003e t)",
          "source": "src/Control-Lens-Internal-Iso.html#Exchange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Iso",
          "module": "Control.Lens.Internal.Iso",
          "name": "Exchange",
          "normalized": "Exchange(a-\u003eb)(c-\u003ed)",
          "package": "lens",
          "partial": "Exchange",
          "signature": "Exchange(s-\u003ea)(b-\u003et)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Iso.html#v:Exchange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Iso",
          "name": "reversing",
          "package": "lens",
          "signature": "t -\u003e t",
          "source": "src/Control-Lens-Internal-Iso.html#reversing",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Iso",
          "module": "Control.Lens.Internal.Iso",
          "name": "reversing",
          "normalized": "a-\u003ea",
          "package": "lens",
          "signature": "t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Iso.html#v:reversing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides implementation details of the combinators in\n \u003ca\u003eControl.Lens.Level\u003c/a\u003e, which provides for the breadth-first \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of\n an arbitrary \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.Level",
          "name": "Level",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Level.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides implementation details of the combinators in Control.Lens.Level which provides for the breadth-first Traversal of an arbitrary Traversal",
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Level",
          "package": "lens",
          "partial": "Level",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an illegal \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e used to construct a single \u003ccode\u003e\u003ca\u003eLevel\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Level",
          "name": "Deepening",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Level.html#Deepening",
          "type": "newtype"
        },
        "index": {
          "description": "This is an illegal Monoid used to construct single Level",
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Deepening",
          "package": "lens",
          "partial": "Deepening",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#t:Deepening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an illegal \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e used to replace the contents of a list of consecutive \u003ccode\u003e\u003ca\u003eLevel\u003c/a\u003e\u003c/code\u003e values\n representing each layer of a structure into the original shape that they were derived from.\n\u003c/p\u003e\u003cp\u003eAttempting to \u003ccode\u003eFlow\u003c/code\u003e something back into a shape other than the one it was taken from will fail.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Level",
          "name": "Flows",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Level.html#Flows",
          "type": "newtype"
        },
        "index": {
          "description": "This is an illegal Applicative used to replace the contents of list of consecutive Level values representing each layer of structure into the original shape that they were derived from Attempting to Flow something back into shape other than the one it was taken from will fail",
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Flows",
          "package": "lens",
          "partial": "Flows",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#t:Flows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type represents a path-compressed copy of one level of a source\n data structure. We can safely use path-compression because we know the depth\n of the tree.\n\u003c/p\u003e\u003cp\u003ePath compression is performed by viewing a \u003ccode\u003e\u003ca\u003eLevel\u003c/a\u003e\u003c/code\u003e as a PATRICIA trie of the\n paths into the structure to leaves at a given depth, similar in many ways\n to a \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e, but unlike a regular PATRICIA trie we do not need\n to store the mask bits merely the depth of the fork.\n\u003c/p\u003e\u003cp\u003eOne invariant of this structure is that underneath a \u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e node you will not\n find any \u003ccode\u003e\u003ca\u003eZero\u003c/a\u003e\u003c/code\u003e nodes, so \u003ccode\u003e\u003ca\u003eZero\u003c/a\u003e\u003c/code\u003e can only occur at the root.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Level",
          "name": "Level",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Level.html#Level",
          "type": "data"
        },
        "index": {
          "description": "This data type represents path-compressed copy of one level of source data structure We can safely use path-compression because we know the depth of the tree Path compression is performed by viewing Level as PATRICIA trie of the paths into the structure to leaves at given depth similar in many ways to IntMap but unlike regular PATRICIA trie we do not need to store the mask bits merely the depth of the fork One invariant of this structure is that underneath Two node you will not find any Zero nodes so Zero can only occur at the root",
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Level",
          "package": "lens",
          "partial": "Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#t:Level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "Deepening",
          "package": "lens",
          "signature": "Deepening",
          "source": "src/Control-Lens-Internal-Level.html#Deepening",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Deepening",
          "package": "lens",
          "partial": "Deepening",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:Deepening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "Flows",
          "package": "lens",
          "signature": "Flows",
          "source": "src/Control-Lens-Internal-Level.html#Flows",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Flows",
          "package": "lens",
          "partial": "Flows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:Flows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "One",
          "package": "lens",
          "signature": "One i a",
          "source": "src/Control-Lens-Internal-Level.html#Level",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "One",
          "package": "lens",
          "partial": "One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:One"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "Two",
          "package": "lens",
          "signature": "Two !Word !(Level i a) !(Level i a)",
          "source": "src/Control-Lens-Internal-Level.html#Level",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Two",
          "package": "lens",
          "partial": "Two",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:Two"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "Zero",
          "package": "lens",
          "signature": "Zero",
          "source": "src/Control-Lens-Internal-Level.html#Level",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "Zero",
          "package": "lens",
          "partial": "Zero",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:Zero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate the leaf of a given \u003ccode\u003e\u003ca\u003eDeepening\u003c/a\u003e\u003c/code\u003e based on whether or not we're at the correct depth.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Level",
          "name": "deepening",
          "package": "lens",
          "signature": "i -\u003e a -\u003e Deepening i a",
          "source": "src/Control-Lens-Internal-Level.html#deepening",
          "type": "function"
        },
        "index": {
          "description": "Generate the leaf of given Deepening based on whether or not we re at the correct depth",
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "deepening",
          "normalized": "a-\u003eb-\u003eDeepening a b",
          "package": "lens",
          "signature": "i-\u003ea-\u003eDeepening i a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:deepening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "runDeepening",
          "package": "lens",
          "signature": "forall r.  Int -\u003e (Level i a -\u003e Bool -\u003e r) -\u003e r",
          "source": "src/Control-Lens-Internal-Level.html#Deepening",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "runDeepening",
          "normalized": "a b Int-\u003e(Level c d-\u003eBool-\u003ee)-\u003ee",
          "package": "lens",
          "partial": "Deepening",
          "signature": "forall r. Int-\u003e(Level i a-\u003eBool-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:runDeepening"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Level",
          "name": "runFlows",
          "package": "lens",
          "signature": "[Level i b] -\u003e a",
          "source": "src/Control-Lens-Internal-Level.html#Flows",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Level",
          "module": "Control.Lens.Internal.Level",
          "name": "runFlows",
          "normalized": "[Level a b]-\u003ec",
          "package": "lens",
          "partial": "Flows",
          "signature": "[Level i b]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Level.html#v:runFlows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "Magma",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Magma.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Magma",
          "package": "lens",
          "partial": "Magma",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used to generate an indexed magma from an unindexed source\n\u003c/p\u003e\u003cp\u003eBy constructing it this way we avoid infinite reassociations in sums where possible.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "Mafic",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Magma.html#Mafic",
          "type": "data"
        },
        "index": {
          "description": "This is used to generate an indexed magma from an unindexed source By constructing it this way we avoid infinite reassociations in sums where possible",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Mafic",
          "package": "lens",
          "partial": "Mafic",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#t:Mafic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis provides a way to peek at the internal structure of a\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "Magma",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Magma.html#Magma",
          "type": "data"
        },
        "index": {
          "description": "This provides way to peek at the internal structure of Traversal or IndexedTraversal",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Magma",
          "package": "lens",
          "partial": "Magma",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#t:Magma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a a non-reassociating initially encoded version of \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "Molten",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Magma.html#Molten",
          "type": "newtype"
        },
        "index": {
          "description": "This is non-reassociating initially encoded version of Bazaar",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Molten",
          "package": "lens",
          "partial": "Molten",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#t:Molten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used to generate an indexed magma from an unindexed source\n\u003c/p\u003e\u003cp\u003eBy constructing it this way we avoid infinite reassociations where possible.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "TakingWhile",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Magma.html#TakingWhile",
          "type": "data"
        },
        "index": {
          "description": "This is used to generate an indexed magma from an unindexed source By constructing it this way we avoid infinite reassociations where possible",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "TakingWhile",
          "package": "lens",
          "partial": "Taking While",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#t:TakingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "Mafic",
          "package": "lens",
          "signature": "Mafic Int (Int -\u003e Magma Int t b a)",
          "source": "src/Control-Lens-Internal-Magma.html#Mafic",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Mafic",
          "normalized": "Mafic Int(Int-\u003eMagma Int a b c)",
          "package": "lens",
          "partial": "Mafic",
          "signature": "Mafic Int(Int-\u003eMagma Int t b a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:Mafic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "Magma",
          "package": "lens",
          "signature": "i -\u003e a -\u003e Magma i b b a",
          "source": "src/Control-Lens-Internal-Magma.html#Magma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Magma",
          "normalized": "a-\u003eb-\u003eMagma a c c b",
          "package": "lens",
          "partial": "Magma",
          "signature": "i-\u003ea-\u003eMagma i b b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:Magma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "MagmaAp",
          "package": "lens",
          "signature": "Magma i (x -\u003e y) b a -\u003e Magma i x b a -\u003e Magma i y b a",
          "source": "src/Control-Lens-Internal-Magma.html#Magma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "MagmaAp",
          "normalized": "Magma a(b-\u003ec)d e-\u003eMagma a b d e-\u003eMagma a c d e",
          "package": "lens",
          "partial": "Magma Ap",
          "signature": "Magma i(x-\u003ey)b a-\u003eMagma i x b a-\u003eMagma i y b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:MagmaAp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "MagmaFmap",
          "package": "lens",
          "signature": "(x -\u003e y) -\u003e Magma i x b a -\u003e Magma i y b a",
          "source": "src/Control-Lens-Internal-Magma.html#Magma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "MagmaFmap",
          "normalized": "(a-\u003eb)-\u003eMagma c a d e-\u003eMagma c b d e",
          "package": "lens",
          "partial": "Magma Fmap",
          "signature": "(x-\u003ey)-\u003eMagma i x b a-\u003eMagma i y b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:MagmaFmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "MagmaPure",
          "package": "lens",
          "signature": "x -\u003e Magma i x b a",
          "source": "src/Control-Lens-Internal-Magma.html#Magma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "MagmaPure",
          "normalized": "a-\u003eMagma b a c d",
          "package": "lens",
          "partial": "Magma Pure",
          "signature": "x-\u003eMagma i x b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:MagmaPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "Molten",
          "package": "lens",
          "signature": "Molten",
          "source": "src/Control-Lens-Internal-Magma.html#Molten",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "Molten",
          "package": "lens",
          "partial": "Molten",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:Molten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "TakingWhile",
          "package": "lens",
          "signature": "TakingWhile Bool t (Bool -\u003e Magma () t b (Corep p a))",
          "source": "src/Control-Lens-Internal-Magma.html#TakingWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "TakingWhile",
          "normalized": "TakingWhile Bool a(Bool-\u003eMagma()a b(Corep c d))",
          "package": "lens",
          "partial": "Taking While",
          "signature": "TakingWhile Bool t(Bool-\u003eMagma()t b(Corep p a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:TakingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eMagma\u003c/a\u003e\u003c/code\u003e using from a prefix sum.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "runMafic",
          "package": "lens",
          "signature": "Mafic a b t -\u003e Magma Int t b a",
          "source": "src/Control-Lens-Internal-Magma.html#runMafic",
          "type": "function"
        },
        "index": {
          "description": "Generate Magma using from prefix sum",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "runMafic",
          "normalized": "Mafic a b c-\u003eMagma Int c b a",
          "package": "lens",
          "partial": "Mafic",
          "signature": "Mafic a b t-\u003eMagma Int t b a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:runMafic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a \u003ccode\u003e\u003ca\u003eMagma\u003c/a\u003e\u003c/code\u003e where all the individual leaves have been converted to the\n expected type\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "runMagma",
          "package": "lens",
          "signature": "Magma i t a a -\u003e t",
          "source": "src/Control-Lens-Internal-Magma.html#runMagma",
          "type": "function"
        },
        "index": {
          "description": "Run Magma where all the individual leaves have been converted to the expected type",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "runMagma",
          "normalized": "Magma a b c c-\u003eb",
          "package": "lens",
          "partial": "Magma",
          "signature": "Magma i t a a-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:runMagma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Magma",
          "name": "runMolten",
          "package": "lens",
          "signature": "Magma i t b a",
          "source": "src/Control-Lens-Internal-Magma.html#Molten",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "runMolten",
          "package": "lens",
          "partial": "Molten",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:runMolten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eMagma\u003c/a\u003e\u003c/code\u003e with leaves only while the predicate holds from left to right.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Magma",
          "name": "runTakingWhile",
          "package": "lens",
          "signature": "TakingWhile p f a b t -\u003e Magma () t b (Corep p a)",
          "source": "src/Control-Lens-Internal-Magma.html#runTakingWhile",
          "type": "function"
        },
        "index": {
          "description": "Generate Magma with leaves only while the predicate holds from left to right",
          "hierarchy": "Control Lens Internal Magma",
          "module": "Control.Lens.Internal.Magma",
          "name": "runTakingWhile",
          "normalized": "TakingWhile a b c d e-\u003eMagma()e d(Corep a c)",
          "package": "lens",
          "partial": "Taking While",
          "signature": "TakingWhile p f a b t-\u003eMagma()t b(Corep p a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Magma.html#v:runTakingWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Prism",
          "name": "Prism",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Prism.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Prism",
          "module": "Control.Lens.Internal.Prism",
          "name": "Prism",
          "package": "lens",
          "partial": "Prism",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Prism.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used internally by the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e code to\n provide efficient access to the two parts of a \u003ccode\u003ePrism\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Prism",
          "name": "Market",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Prism.html#Market",
          "type": "data"
        },
        "index": {
          "description": "This type is used internally by the Prism code to provide efficient access to the two parts of Prism",
          "hierarchy": "Control Lens Internal Prism",
          "module": "Control.Lens.Internal.Prism",
          "name": "Market",
          "package": "lens",
          "partial": "Market",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Prism.html#t:Market"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eMarket'\u003c/a\u003e\u003c/code\u003e a s t = \u003ccode\u003e\u003ca\u003eMarket\u003c/a\u003e\u003c/code\u003e a a s t\u003c/pre\u003e",
          "module": "Control.Lens.Internal.Prism",
          "name": "Market'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Prism.html#Market%27",
          "type": "type"
        },
        "index": {
          "description": "type Market Market",
          "hierarchy": "Control Lens Internal Prism",
          "module": "Control.Lens.Internal.Prism",
          "name": "Market'",
          "package": "lens",
          "partial": "Market'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Prism.html#t:Market-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Prism",
          "name": "Market",
          "package": "lens",
          "signature": "Market (b -\u003e t) (s -\u003e Either t a)",
          "source": "src/Control-Lens-Internal-Prism.html#Market",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Prism",
          "module": "Control.Lens.Internal.Prism",
          "name": "Market",
          "normalized": "Market(a-\u003eb)(c-\u003eEither b d)",
          "package": "lens",
          "partial": "Market",
          "signature": "Market(b-\u003et)(s-\u003eEither t a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Prism.html#v:Market"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eReifies arbitrary terms at the type level. Based on the Functional\n Pearl: Implicit Configurations paper by Oleg Kiselyov and\n Chung-chieh Shan.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe approach from the paper was modified to work with Data.Proxy\n and streamline the API by Edward Kmett and Elliott Hird.\n\u003c/p\u003e\u003cp\u003eUsage comes down to two combinators, \u003ccode\u003e\u003ca\u003ereify\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereflect\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereify 6 (\\p -\u003e reflect p + reflect p)\n\u003c/code\u003e\u003c/strong\u003e12\n\u003c/pre\u003e\u003cp\u003eThe argument passed along by reify is just a \u003ccode\u003edata \u003ccode\u003e\u003ca\u003eProxy\u003c/a\u003e\u003c/code\u003e t =\n Proxy\u003c/code\u003e, so all of the information needed to reconstruct your value\n has been moved to the type level.  This enables it to be used when\n constructing instances (see \u003ccode\u003eexamples/Monoid.hs\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eThis version is based on the \"slow\" path from the \u003ccode\u003ereflection\u003c/code\u003e package,\n but modified to work with the same \u003ccode\u003e\u003ca\u003eReifies\u003c/a\u003e\u003c/code\u003e class as is provided by the \"fast\"\n path, and to make sure the parameter is \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is necessary to work around the changes to \u003ccode\u003eData.Typeable\u003c/code\u003e in GHC HEAD.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal.Reflection",
          "name": "Reflection",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Reflection.html",
          "type": "module"
        },
        "index": {
          "description": "Reifies arbitrary terms at the type level Based on the Functional Pearl Implicit Configurations paper by Oleg Kiselyov and Chung-chieh Shan http www.cs.rutgers.edu ccshan prepose prepose.pdf The approach from the paper was modified to work with Data.Proxy and streamline the API by Edward Kmett and Elliott Hird Usage comes down to two combinators reify and reflect reify reflect reflect The argument passed along by reify is just data Proxy Proxy so all of the information needed to reconstruct your value has been moved to the type level This enables it to be used when constructing instances see examples Monoid.hs This version is based on the slow path from the reflection package but modified to work with the same Reifies class as is provided by the fast path and to make sure the parameter is Typeable This is necessary to work around the changes to Data.Typeable in GHC HEAD",
          "hierarchy": "Control Lens Internal Reflection",
          "module": "Control.Lens.Internal.Reflection",
          "name": "Reflection",
          "package": "lens",
          "partial": "Reflection",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Reflection.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Reflection",
          "name": "Reifies",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Lens Internal Reflection",
          "module": "Control.Lens.Internal.Reflection",
          "name": "Reifies",
          "package": "lens",
          "partial": "Reifies",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Reflection.html#t:Reifies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecover a value inside a \u003ccode\u003e\u003ca\u003ereify\u003c/a\u003e\u003c/code\u003e context, given a proxy for its\n reified type.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Reflection",
          "name": "reflect",
          "package": "lens",
          "signature": "proxy s -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Recover value inside reify context given proxy for its reified type",
          "hierarchy": "Control Lens Internal Reflection",
          "module": "Control.Lens.Internal.Reflection",
          "name": "reflect",
          "normalized": "a b-\u003ec",
          "package": "lens",
          "signature": "proxy s-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Reflection.html#v:reflect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify a value at the type level in a \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e-compatible fashion, to be recovered with \u003ccode\u003e\u003ca\u003ereflect\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Reflection",
          "name": "reifyTypeable",
          "package": "lens",
          "signature": "Proxy s -\u003e r) -\u003e r",
          "source": "src/Control-Lens-Internal-Reflection.html#reifyTypeable",
          "type": "function"
        },
        "index": {
          "description": "Reify value at the type level in Typeable compatible fashion to be recovered with reflect",
          "hierarchy": "Control Lens Internal Reflection",
          "module": "Control.Lens.Internal.Reflection",
          "name": "reifyTypeable",
          "normalized": "Proxy a-\u003eb)-\u003eb",
          "package": "lens",
          "partial": "Typeable",
          "signature": "Proxy s-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Reflection.html#v:reifyTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Review",
          "name": "Review",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Review.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Review",
          "module": "Control.Lens.Internal.Review",
          "name": "Review",
          "package": "lens",
          "partial": "Review",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Review.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is provided mostly for backwards compatibility with lens 3.8,\n but it can also shorten type signatures.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Review",
          "name": "Reviewable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Review.html#Reviewable",
          "type": "class"
        },
        "index": {
          "description": "This class is provided mostly for backwards compatibility with lens but it can also shorten type signatures",
          "hierarchy": "Control Lens Internal Review",
          "module": "Control.Lens.Internal.Review",
          "name": "Reviewable",
          "package": "lens",
          "partial": "Reviewable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Review.html#t:Reviewable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a profunctor used internally to implement \u003ca\u003eReview\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eIt plays a role similar to that of \u003ccode\u003e\u003ca\u003eAccessor\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003eConst\u003c/code\u003e do for \u003ca\u003eControl.Lens.Getter\u003c/a\u003e\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Internal.Review\",\"Control.Lens.Review\"]",
          "name": "retagged",
          "package": "lens",
          "signature": "p a b -\u003e p s b",
          "source": "src/Control-Lens-Internal-Review.html#retagged",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Review.html#v:retagged\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:retagged\"]"
        },
        "index": {
          "description": "This is profunctor used internally to implement Review It plays role similar to that of Accessor or Const do for Control.Lens.Getter",
          "hierarchy": "Control Lens Internal Review",
          "module": "Control.Lens.Internal.Review",
          "name": "retagged",
          "normalized": "a b c-\u003ea d c",
          "package": "lens",
          "signature": "p a b-\u003ep s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Review.html#v:retagged"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Setter",
          "name": "Setter",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Setter.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Setter",
          "module": "Control.Lens.Internal.Setter",
          "name": "Setter",
          "package": "lens",
          "partial": "Setter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Setter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnything \u003ccode\u003e\u003ca\u003eSettable\u003c/a\u003e\u003c/code\u003e must be isomorphic to the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Setter",
          "name": "Settable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Setter.html#Settable",
          "type": "class"
        },
        "index": {
          "description": "Anything Settable must be isomorphic to the Identity Functor",
          "hierarchy": "Control Lens Internal Setter",
          "module": "Control.Lens.Internal.Setter",
          "name": "Settable",
          "package": "lens",
          "partial": "Settable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Setter.html#t:Settable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Setter",
          "name": "taintedDot",
          "package": "lens",
          "signature": "p a b -\u003e p a (f b)",
          "source": "src/Control-Lens-Internal-Setter.html#taintedDot",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Setter",
          "module": "Control.Lens.Internal.Setter",
          "name": "taintedDot",
          "normalized": "a b c-\u003ea b(d c)",
          "package": "lens",
          "partial": "Dot",
          "signature": "p a b-\u003ep a(f b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Setter.html#v:taintedDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Setter",
          "name": "untainted",
          "package": "lens",
          "signature": "f a -\u003e a",
          "source": "src/Control-Lens-Internal-Setter.html#untainted",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Setter",
          "module": "Control.Lens.Internal.Setter",
          "name": "untainted",
          "normalized": "a b-\u003eb",
          "package": "lens",
          "signature": "f a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Setter.html#v:untainted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Setter",
          "name": "untaintedDot",
          "package": "lens",
          "signature": "p a (f b) -\u003e p a b",
          "source": "src/Control-Lens-Internal-Setter.html#untaintedDot",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Internal Setter",
          "module": "Control.Lens.Internal.Setter",
          "name": "untaintedDot",
          "normalized": "a b(c d)-\u003ea b d",
          "package": "lens",
          "partial": "Dot",
          "signature": "p a(f b)-\u003ep a b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Setter.html#v:untaintedDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.TH",
          "name": "TH",
          "package": "lens",
          "source": "src/Control-Lens-Internal-TH.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "TH",
          "package": "lens",
          "partial": "TH",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.TH",
          "name": "appsE1",
          "package": "lens",
          "signature": "ExpQ -\u003e [ExpQ] -\u003e ExpQ",
          "source": "src/Control-Lens-Internal-TH.html#appsE1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "appsE1",
          "normalized": "ExpQ-\u003e[ExpQ]-\u003eExpQ",
          "package": "lens",
          "signature": "ExpQ-\u003e[ExpQ]-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#v:appsE1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.TH",
          "name": "appsT",
          "package": "lens",
          "signature": "TypeQ -\u003e [TypeQ] -\u003e TypeQ",
          "source": "src/Control-Lens-Internal-TH.html#appsT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "appsT",
          "normalized": "TypeQ-\u003e[TypeQ]-\u003eTypeQ",
          "package": "lens",
          "signature": "TypeQ-\u003e[TypeQ]-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#v:appsT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.TH",
          "name": "toTupleE",
          "package": "lens",
          "signature": "[ExpQ] -\u003e ExpQ",
          "source": "src/Control-Lens-Internal-TH.html#toTupleE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "toTupleE",
          "normalized": "[ExpQ]-\u003eExpQ",
          "package": "lens",
          "partial": "Tuple",
          "signature": "[ExpQ]-\u003eExpQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#v:toTupleE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.TH",
          "name": "toTupleP",
          "package": "lens",
          "signature": "[PatQ] -\u003e PatQ",
          "source": "src/Control-Lens-Internal-TH.html#toTupleP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "toTupleP",
          "normalized": "[PatQ]-\u003ePatQ",
          "package": "lens",
          "partial": "Tuple",
          "signature": "[PatQ]-\u003ePatQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#v:toTupleP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.TH",
          "name": "toTupleT",
          "package": "lens",
          "signature": "[TypeQ] -\u003e TypeQ",
          "source": "src/Control-Lens-Internal-TH.html#toTupleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "toTupleT",
          "normalized": "[TypeQ]-\u003eTypeQ",
          "package": "lens",
          "partial": "Tuple",
          "signature": "[TypeQ]-\u003eTypeQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#v:toTupleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompatibility shim for recent changes to template haskell's \u003ccode\u003e\u003ca\u003etySynInstD\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.TH",
          "name": "tySynInstD'",
          "package": "lens",
          "signature": "Name -\u003e [TypeQ] -\u003e TypeQ -\u003e DecQ",
          "source": "src/Control-Lens-Internal-TH.html#tySynInstD%27",
          "type": "function"
        },
        "index": {
          "description": "Compatibility shim for recent changes to template haskell tySynInstD",
          "hierarchy": "Control Lens Internal TH",
          "module": "Control.Lens.Internal.TH",
          "name": "tySynInstD'",
          "normalized": "Name-\u003e[TypeQ]-\u003eTypeQ-\u003eDecQ",
          "package": "lens",
          "partial": "Syn Inst D'",
          "signature": "Name-\u003e[TypeQ]-\u003eTypeQ-\u003eDecQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-TH.html#v:tySynInstD-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "Zoom",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Zoom",
          "package": "lens",
          "partial": "Zoom",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap a monadic effect with a phantom type argument. Used when magnifying \u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "EffectRWS",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#EffectRWS",
          "type": "newtype"
        },
        "index": {
          "description": "Wrap monadic effect with phantom type argument Used when magnifying RWST",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "EffectRWS",
          "package": "lens",
          "partial": "Effect RWS",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:EffectRWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e out of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e for error handling.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Err",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#Err",
          "type": "newtype"
        },
        "index": {
          "description": "Make Monoid out of Either for error handling",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Err",
          "package": "lens",
          "partial": "Err",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003e\u003ca\u003eStateT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Focusing",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#Focusing",
          "type": "newtype"
        },
        "index": {
          "description": "Used by Zoom to zoom into StateT",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Focusing",
          "package": "lens",
          "partial": "Focusing",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:Focusing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003e\u003ca\u003eErrorT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingErr",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingErr",
          "type": "newtype"
        },
        "index": {
          "description": "Used by Zoom to zoom into ErrorT",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingErr",
          "package": "lens",
          "partial": "Focusing Err",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:FocusingErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003e\u003ca\u003eErrorT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingMay",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingMay",
          "type": "newtype"
        },
        "index": {
          "description": "Used by Zoom to zoom into ErrorT",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingMay",
          "package": "lens",
          "partial": "Focusing May",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:FocusingMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003e\u003ca\u003eMaybeT\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eListT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingOn",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingOn",
          "type": "newtype"
        },
        "index": {
          "description": "Used by Zoom to zoom into MaybeT or ListT",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingOn",
          "package": "lens",
          "partial": "Focusing On",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:FocusingOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003e\u003ca\u003eWriterT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingPlus",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingPlus",
          "type": "newtype"
        },
        "index": {
          "description": "Used by Zoom to zoom into WriterT",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingPlus",
          "package": "lens",
          "partial": "Focusing Plus",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:FocusingPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingWith",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingWith",
          "type": "newtype"
        },
        "index": {
          "description": "Used by Zoom to zoom into RWST",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingWith",
          "package": "lens",
          "partial": "Focusing With",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:FocusingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type family is used by \u003ccode\u003e\u003ca\u003eMagnify\u003c/a\u003e\u003c/code\u003e to describe the common effect type.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Magnified",
          "package": "lens",
          "signature": "Magnified",
          "type": "function"
        },
        "index": {
          "description": "This type family is used by Magnify to describe the common effect type",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Magnified",
          "package": "lens",
          "partial": "Magnified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:Magnified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e out of \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e for error handling.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "May",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Zoom.html#May",
          "type": "newtype"
        },
        "index": {
          "description": "Make Monoid out of Maybe for error handling",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "May",
          "package": "lens",
          "partial": "May",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:May"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type family is used by \u003ccode\u003e\u003ca\u003eZoom\u003c/a\u003e\u003c/code\u003e to describe the common effect type.\n\u003c/p\u003e",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Zoomed",
          "package": "lens",
          "signature": "Zoomed",
          "type": "function"
        },
        "index": {
          "description": "This type family is used by Zoom to describe the common effect type",
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Zoomed",
          "package": "lens",
          "partial": "Zoomed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#t:Zoomed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "EffectRWS",
          "package": "lens",
          "signature": "EffectRWS",
          "source": "src/Control-Lens-Internal-Zoom.html#EffectRWS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "EffectRWS",
          "package": "lens",
          "partial": "Effect RWS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:EffectRWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "Err",
          "package": "lens",
          "signature": "Err",
          "source": "src/Control-Lens-Internal-Zoom.html#Err",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Err",
          "package": "lens",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "Focusing",
          "package": "lens",
          "signature": "Focusing",
          "source": "src/Control-Lens-Internal-Zoom.html#Focusing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "Focusing",
          "package": "lens",
          "partial": "Focusing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:Focusing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingErr",
          "package": "lens",
          "signature": "FocusingErr",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingErr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingErr",
          "package": "lens",
          "partial": "Focusing Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:FocusingErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingMay",
          "package": "lens",
          "signature": "FocusingMay",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingMay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingMay",
          "package": "lens",
          "partial": "Focusing May",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:FocusingMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingOn",
          "package": "lens",
          "signature": "FocusingOn",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingOn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingOn",
          "package": "lens",
          "partial": "Focusing On",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:FocusingOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingPlus",
          "package": "lens",
          "signature": "FocusingPlus",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingPlus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingPlus",
          "package": "lens",
          "partial": "Focusing Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:FocusingPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingWith",
          "package": "lens",
          "signature": "FocusingWith",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "FocusingWith",
          "package": "lens",
          "partial": "Focusing With",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:FocusingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "May",
          "package": "lens",
          "signature": "May",
          "source": "src/Control-Lens-Internal-Zoom.html#May",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "May",
          "package": "lens",
          "partial": "May",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:May"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "getEffectRWS",
          "package": "lens",
          "signature": "st -\u003e m (s, st, w)",
          "source": "src/Control-Lens-Internal-Zoom.html#EffectRWS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "getEffectRWS",
          "normalized": "a-\u003eb(c,a,d)",
          "package": "lens",
          "partial": "Effect RWS",
          "signature": "st-\u003em(s,st,w)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:getEffectRWS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "getErr",
          "package": "lens",
          "signature": "Either e a",
          "source": "src/Control-Lens-Internal-Zoom.html#Err",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "getErr",
          "package": "lens",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:getErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "getMay",
          "package": "lens",
          "signature": "Maybe a",
          "source": "src/Control-Lens-Internal-Zoom.html#May",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "getMay",
          "package": "lens",
          "partial": "May",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:getMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusing",
          "package": "lens",
          "signature": "m (s, a)",
          "source": "src/Control-Lens-Internal-Zoom.html#Focusing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusing",
          "normalized": "a(b,c)",
          "package": "lens",
          "signature": "m(s,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:unfocusing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingErr",
          "package": "lens",
          "signature": "k (Err e s) a",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingErr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingErr",
          "package": "lens",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:unfocusingErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingMay",
          "package": "lens",
          "signature": "k (May s) a",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingMay",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingMay",
          "package": "lens",
          "partial": "May",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:unfocusingMay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingOn",
          "package": "lens",
          "signature": "k (f s) a",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingOn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingOn",
          "package": "lens",
          "partial": "On",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:unfocusingOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingPlus",
          "package": "lens",
          "signature": "k (s, w) a",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingPlus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingPlus",
          "normalized": "a(b,c)d",
          "package": "lens",
          "partial": "Plus",
          "signature": "k(s,w)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:unfocusingPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingWith",
          "package": "lens",
          "signature": "m (s, a, w)",
          "source": "src/Control-Lens-Internal-Zoom.html#FocusingWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Internal Zoom",
          "module": "Control.Lens.Internal.Zoom",
          "name": "unfocusingWith",
          "normalized": "a(b,c,d)",
          "package": "lens",
          "partial": "With",
          "signature": "m(s,a,w)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Zoom.html#v:unfocusingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThese are some of the explicit \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instances that leak into the\n type signatures of \u003ccode\u003eControl.Lens\u003c/code\u003e. You shouldn't need to import this\n module directly for most use-cases.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Internal",
          "name": "Internal",
          "package": "lens",
          "source": "src/Control-Lens-Internal.html",
          "type": "module"
        },
        "index": {
          "description": "These are some of the explicit Functor instances that leak into the type signatures of Control.Lens You shouldn need to import this module directly for most use-cases",
          "hierarchy": "Control Lens Internal",
          "module": "Control.Lens.Internal",
          "name": "Internal",
          "package": "lens",
          "partial": "Internal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Iso",
          "name": "Iso",
          "package": "lens",
          "source": "src/Control-Lens-Iso.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Iso",
          "package": "lens",
          "partial": "Iso",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "AnIso",
          "package": "lens",
          "source": "src/Control-Lens-Iso.html#AnIso",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects an Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "AnIso",
          "package": "lens",
          "partial": "An Iso",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:AnIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAnIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "AnIso'",
          "package": "lens",
          "source": "src/Control-Lens-Iso.html#AnIso%27",
          "type": "type"
        },
        "index": {
          "description": "Simple AnIso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "AnIso'",
          "package": "lens",
          "partial": "An Iso'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:AnIso-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIsomorphism families can be composed with another \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) and \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Composition with an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is index- and measure- preserving.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "Iso",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Iso",
          "type": "type"
        },
        "index": {
          "description": "Isomorphism families can be composed with another Lens using and id Note Composition with an Iso is index and measure preserving",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Iso",
          "package": "lens",
          "partial": "Iso",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "Iso'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Iso%27",
          "type": "type"
        },
        "index": {
          "description": "type Iso Simple Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Iso'",
          "package": "lens",
          "partial": "Iso'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Iso-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis provides a way to peek at the internal structure of a\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "Magma",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Magma.html#Magma",
          "type": "data"
        },
        "index": {
          "description": "This provides way to peek at the internal structure of Traversal or IndexedTraversal",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Magma",
          "package": "lens",
          "partial": "Magma",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Magma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFormally, the class \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e represents a profunctor\n from \u003ccode\u003eHask\u003c/code\u003e -\u003e \u003ccode\u003eHask\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIntuitively it is a bifunctor where the first argument is contravariant\n and the second argument is covariant.\n\u003c/p\u003e\u003cp\u003eYou can define a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e by either defining \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e or by defining both\n \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf you supply \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e, you should ensure that:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you supply \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e, ensure:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eIf you supply both, you should also ensure:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e f g &#8801; \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003cp\u003eThese ensure by parametricity:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g) (h \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e i) &#8801; \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e g h \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e f i\n \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g) &#8801; \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e f\n \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g) &#8801; \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e g\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "Profunctor",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "description": "Formally the class Profunctor represents profunctor from Hask Hask Intuitively it is bifunctor where the first argument is contravariant and the second argument is covariant You can define Profunctor by either defining dimap or by defining both lmap and rmap If you supply dimap you should ensure that dimap id id id If you supply lmap and rmap ensure lmap id id rmap id id If you supply both you should also ensure dimap lmap rmap These ensure by parametricity dimap dimap dimap lmap lmap lmap rmap rmap rmap",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Profunctor",
          "package": "lens",
          "partial": "Profunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Profunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides a generalized notion of list reversal extended to other containers.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "Reversing",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Iso.html#Reversing",
          "type": "class"
        },
        "index": {
          "description": "This class provides generalized notion of list reversal extended to other containers",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Reversing",
          "package": "lens",
          "partial": "Reversing",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Reversing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAd hoc conversion between \"strict\" and \"lazy\" versions of a structure,\n such as \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "Strict",
          "package": "lens",
          "source": "src/Control-Lens-Iso.html#Strict",
          "type": "class"
        },
        "index": {
          "description": "Ad hoc conversion between strict and lazy versions of structure such as Text or ByteString",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Strict",
          "package": "lens",
          "partial": "Strict",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Strict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class provides for symmetric bifunctors.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "Swapped",
          "package": "lens",
          "source": "src/Control-Lens-Iso.html#Swapped",
          "type": "class"
        },
        "index": {
          "description": "This class provides for symmetric bifunctors",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "Swapped",
          "package": "lens",
          "partial": "Swapped",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:Swapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eanon\u003c/a\u003e\u003c/code\u003e a p\u003c/code\u003e generalizes \u003ccode\u003e\u003ccode\u003e\u003ca\u003enon\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e to take any value and a predicate.\n\u003c/p\u003e\u003cp\u003eThis function assumes that \u003ccode\u003ep a\u003c/code\u003e holds \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and generates an isomorphism between \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (a | \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e (p a))\u003c/code\u003e and \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.empty & at \"hello\" . anon Map.empty Map.null . at \"world\" ?~ \"!!!\"\n\u003c/code\u003e\u003c/strong\u003efromList [(\"hello\",fromList [(\"world\",\"!!!\")])]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [(\"hello\",fromList [(\"world\",\"!!!\")])] & at \"hello\" . anon Map.empty Map.null . at \"world\" .~ Nothing\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "anon",
          "package": "lens",
          "signature": "a -\u003e (a -\u003e Bool) -\u003e Iso' (Maybe a) a",
          "source": "src/Control-Lens-Iso.html#anon",
          "type": "function"
        },
        "index": {
          "description": "anon generalizes non to take any value and predicate This function assumes that holds True and generates an isomorphism between Maybe not and Map.empty at hello anon Map.empty Map.null at world fromList hello fromList world fromList hello fromList world at hello anon Map.empty Map.null at world Nothing fromList",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "anon",
          "normalized": "a-\u003e(a-\u003eBool)-\u003eIso'(Maybe a)a",
          "package": "lens",
          "signature": "a-\u003e(a-\u003eBool)-\u003eIso'(Maybe a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:anon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBased on \u003ccode\u003e\u003ca\u003eala\u003c/a\u003e\u003c/code\u003e from Conor McBride's work on Epigram.\n\u003c/p\u003e\u003cp\u003eThis version is generalized to accept any \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, not just a \u003ccode\u003enewtype\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eau (_Unwrapping Sum) foldMap [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "au",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e ((s -\u003e a) -\u003e e -\u003e b) -\u003e e -\u003e t",
          "source": "src/Control-Lens-Iso.html#au",
          "type": "function"
        },
        "index": {
          "description": "Based on ala from Conor McBride work on Epigram This version is generalized to accept any Iso not just newtype au Unwrapping Sum foldMap",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "au",
          "normalized": "AnIso a b c d-\u003e((a-\u003ec)-\u003ee-\u003ed)-\u003ee-\u003eb",
          "package": "lens",
          "signature": "AnIso s t a b-\u003e((s-\u003ea)-\u003ee-\u003eb)-\u003ee-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:au"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBased on \u003ccode\u003eala'\u003c/code\u003e from Conor McBride's work on Epigram.\n\u003c/p\u003e\u003cp\u003eThis version is generalized to accept any \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, not just a \u003ccode\u003enewtype\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor a version you pass the name of the \u003ccode\u003enewtype\u003c/code\u003e constructor to, see \u003ccode\u003e\u003ca\u003ealaf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMnemonically, the German \u003cem\u003eauf\u003c/em\u003e plays a similar role to \u003cem\u003e&#224; la\u003c/em\u003e, and the combinator\n is \u003ccode\u003e\u003ca\u003eau\u003c/a\u003e\u003c/code\u003e with an extra function argument.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eauf (_Unwrapping Sum) (foldMapOf both) Prelude.length (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "auf",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e (p r a -\u003e e -\u003e b) -\u003e p r s -\u003e e -\u003e t",
          "source": "src/Control-Lens-Iso.html#auf",
          "type": "function"
        },
        "index": {
          "description": "Based on ala from Conor McBride work on Epigram This version is generalized to accept any Iso not just newtype For version you pass the name of the newtype constructor to see alaf Mnemonically the German auf plays similar role to la and the combinator is au with an extra function argument auf Unwrapping Sum foldMapOf both Prelude.length hello world",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "auf",
          "normalized": "AnIso a b c d-\u003e(e f c-\u003eg-\u003ed)-\u003ee f a-\u003eg-\u003eb",
          "package": "lens",
          "signature": "AnIso s t a b-\u003e(p r a-\u003ee-\u003eb)-\u003ep r s-\u003ee-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:auf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from \u003ccode\u003e\u003ca\u003eAnIso\u003c/a\u003e\u003c/code\u003e back to any \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is useful when you need to store an isomorphism as a data type inside a container\n and later reconstitute it as an overloaded function.\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003ecloneLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ecloneTraversal\u003c/a\u003e\u003c/code\u003e for more information on why you might want to do this.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "cloneIso",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e Iso s t a b",
          "source": "src/Control-Lens-Iso.html#cloneIso",
          "type": "function"
        },
        "index": {
          "description": "Convert from AnIso back to any Iso This is useful when you need to store an isomorphism as data type inside container and later reconstitute it as an overloaded function See cloneLens or cloneTraversal for more information on why you might want to do this",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "cloneIso",
          "normalized": "AnIso a b c d-\u003eIso a b c d",
          "package": "lens",
          "partial": "Iso",
          "signature": "AnIso s t a b-\u003eIso s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:cloneIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e functor.\n\u003c/p\u003e\u003cpre\u003e\n contramapping :: \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e (f a) (f b) (f s) (f t)\n contramapping :: \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e (f a) (f s)\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "contramapping",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e Iso (f a) (f b) (f s) (f t)",
          "source": "src/Control-Lens-Iso.html#contramapping",
          "type": "function"
        },
        "index": {
          "description": "Lift an Iso into Contravariant functor contramapping Contravariant Iso Iso contramapping Contravariant Iso Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "contramapping",
          "normalized": "AnIso a b c d-\u003eIso(e c)(e d)(e a)(e b)",
          "package": "lens",
          "signature": "AnIso s t a b-\u003eIso(f a)(f b)(f s)(f t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:contramapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe canonical isomorphism for currying and uncurrying a function.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecurried\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecurry\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euncurry\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(fst^.curried) 3 4\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eview curried fst 3 4\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "curried",
          "package": "lens",
          "signature": "Iso ((a, b) -\u003e c) ((d, e) -\u003e f) (a -\u003e b -\u003e c) (d -\u003e e -\u003e f)",
          "source": "src/Control-Lens-Iso.html#curried",
          "type": "function"
        },
        "index": {
          "description": "The canonical isomorphism for currying and uncurrying function curried iso curry uncurry fst curried view curried fst",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "curried",
          "normalized": "Iso((a,b)-\u003ec)((d,e)-\u003ef)(a-\u003eb-\u003ec)(d-\u003ee-\u003ef)",
          "package": "lens",
          "signature": "Iso((a,b)-\u003ec)((d,e)-\u003ef)(a-\u003eb-\u003ec)(d-\u003ee-\u003ef)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:curried"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap over both arguments at the same time.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e f g &#8801; \u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "dimap",
          "package": "lens",
          "signature": "(a -\u003e b) -\u003e (c -\u003e d) -\u003e p b c -\u003e p a d",
          "type": "method"
        },
        "index": {
          "description": "Map over both arguments at the same time dimap lmap rmap",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "dimap",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ee b c-\u003ee a d",
          "package": "lens",
          "signature": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ep b c-\u003ep a d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:dimap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift two \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003es into both arguments of a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e simultaneously.\n\u003c/p\u003e\u003cpre\u003e\n dimapping :: \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s' t' a' b' -\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e (p a s') (p b t') (p s a') (p t b')\n dimapping :: \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s' a' -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e (p a s') (p s a')\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "dimapping",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e AnIso s' t' a' b' -\u003e Iso (p a s') (p b t') (p s a') (p t b')",
          "source": "src/Control-Lens-Iso.html#dimapping",
          "type": "function"
        },
        "index": {
          "description": "Lift two Iso into both arguments of Profunctor simultaneously dimapping Profunctor Iso Iso Iso dimapping Profunctor Iso Iso Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "dimapping",
          "normalized": "AnIso a b c d-\u003eAnIso e f g h-\u003eIso(i c e)(i d f)(i a g)(i b h)",
          "package": "lens",
          "signature": "AnIso s t a b-\u003eAnIso s' t' a' b'-\u003eIso(p a s')(p b t')(p s a')(p t b')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:dimapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to convert to or from an instance of \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLT^.from enum\n\u003c/code\u003e\u003c/strong\u003e0\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e97^.enum :: Char\n\u003c/code\u003e\u003c/strong\u003e'a'\n\u003c/pre\u003e\u003cp\u003eNote: this is only an isomorphism from the numeric range actually used\n and it is a bit of a pleasant fiction, since there are questionable\n \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e instances for \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eFloat\u003c/a\u003e\u003c/code\u003e that exist solely for\n \u003ccode\u003e[1.0 .. 4.0]\u003c/code\u003e sugar and the instances for those and \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e don't\n cover all values in their range.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "enum",
          "package": "lens",
          "signature": "Iso' Int a",
          "source": "src/Control-Lens-Iso.html#enum",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to convert to or from an instance of Enum LT from enum enum Char Note this is only an isomorphism from the numeric range actually used and it is bit of pleasant fiction since there are questionable Enum instances for Double and Float that exist solely for sugar and the instances for those and Integer don cover all values in their range",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "enum",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe isomorphism for flipping a function.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e((,)^.flipped) 1 2\n\u003c/code\u003e\u003c/strong\u003e(2,1)\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "flipped",
          "package": "lens",
          "signature": "Iso (a -\u003e b -\u003e c) (a' -\u003e b' -\u003e c') (b -\u003e a -\u003e c) (b' -\u003e a' -\u003e c')",
          "source": "src/Control-Lens-Iso.html#flipped",
          "type": "function"
        },
        "index": {
          "description": "The isomorphism for flipping function flipped",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "flipped",
          "normalized": "Iso(a-\u003eb-\u003ec)(d-\u003ee-\u003ef)(b-\u003ea-\u003ec)(e-\u003ed-\u003ef)",
          "package": "lens",
          "signature": "Iso(a-\u003eb-\u003ec)(a'-\u003eb'-\u003ec')(b-\u003ea-\u003ec)(b'-\u003ea'-\u003ec')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:flipped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInvert an isomorphism.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e l) &#8801; l\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "from",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e Iso b a t s",
          "source": "src/Control-Lens-Iso.html#from",
          "type": "function"
        },
        "index": {
          "description": "Invert an isomorphism from from",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "from",
          "normalized": "AnIso a b c d-\u003eIso d c b a",
          "package": "lens",
          "signature": "AnIso s t a b-\u003eIso b a t s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:from"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to inspect an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e to see how it associates\n the structure and it can also be used to bake the \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eMagma\u003c/a\u003e\u003c/code\u003e so\n that you can traverse over it multiple times with access to the original indices.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "imagma",
          "package": "lens",
          "signature": "Over (Indexed i) (Molten i a b) s t a b -\u003e Iso s t' (Magma i t b a) (Magma j t' c c)",
          "source": "src/Control-Lens-Iso.html#imagma",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to inspect an IndexedTraversal to see how it associates the structure and it can also be used to bake the IndexedTraversal into Magma so that you can traverse over it multiple times with access to the original indices",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "imagma",
          "normalized": "Over(Indexed a)(Molten a b c)d e b c-\u003eIso d f(Magma a e c b)(Magma g f h h)",
          "package": "lens",
          "signature": "Over(Indexed i)(Molten i a b)s t a b-\u003eIso s t'(Magma i t b a)(Magma j t' c c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:imagma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a function that is its own inverse, this gives you an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e using it in both directions.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003einvoluted\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"live\" ^. involuted reverse\n\u003c/code\u003e\u003c/strong\u003e\"evil\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"live\" & involuted reverse %~ ('d':)\n\u003c/code\u003e\u003c/strong\u003e\"lived\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "involuted",
          "package": "lens",
          "signature": "(a -\u003e a) -\u003e Iso' a a",
          "source": "src/Control-Lens-Iso.html#involuted",
          "type": "function"
        },
        "index": {
          "description": "Given function that is its own inverse this gives you an Iso using it in both directions involuted join iso live involuted reverse evil live involuted reverse lived",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "involuted",
          "normalized": "(a-\u003ea)-\u003eIso' a a",
          "package": "lens",
          "signature": "(a-\u003ea)-\u003eIso' a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:involuted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a simple isomorphism from a pair of inverse functions.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e f g) &#8801; f\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e f g)) &#8801; g\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e f g) h &#8801; g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e h \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e f g)) h &#8801; f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e h \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "iso",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e (b -\u003e t) -\u003e Iso s t a b",
          "source": "src/Control-Lens-Iso.html#iso",
          "type": "function"
        },
        "index": {
          "description": "Build simple isomorphism from pair of inverse functions view iso view from iso over iso over from iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "iso",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003eIso a d b c",
          "package": "lens",
          "signature": "(s-\u003ea)-\u003e(b-\u003et)-\u003eIso s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e between the strict variant of a structure and its lazy\n counterpart.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elazy\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003estrict\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eSee \u003ca\u003ehttp://hackage.haskell.org/package/strict-base-types\u003c/a\u003e for an example\n use.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "lazy",
          "package": "lens",
          "signature": "Iso' strict lazy",
          "source": "src/Control-Lens-Iso.html#lazy",
          "type": "function"
        },
        "index": {
          "description": "An Iso between the strict variant of structure and its lazy counterpart lazy from strict See http hackage.haskell.org package strict-base-types for an example use",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "lazy",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:lazy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap the first argument contravariantly.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003elmap\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "lmap",
          "package": "lens",
          "signature": "(a -\u003e b) -\u003e p b c -\u003e p a c",
          "type": "method"
        },
        "index": {
          "description": "Map the first argument contravariantly lmap dimap id",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "lmap",
          "normalized": "(a-\u003eb)-\u003ec b d-\u003ec a d",
          "package": "lens",
          "signature": "(a-\u003eb)-\u003ep b c-\u003ep a c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:lmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e contravariantly into the left argument of a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n lmapping :: \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e (p a x) (p b y) (p s x) (p t y)\n lmapping :: \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e (p a x) (p s x)\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "lmapping",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e Iso (p a x) (p b y) (p s x) (p t y)",
          "source": "src/Control-Lens-Iso.html#lmapping",
          "type": "function"
        },
        "index": {
          "description": "Lift an Iso contravariantly into the left argument of Profunctor lmapping Profunctor Iso Iso lmapping Profunctor Iso Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "lmapping",
          "normalized": "AnIso a b c d-\u003eIso(e c f)(e d g)(e a f)(e b g)",
          "package": "lens",
          "signature": "AnIso s t a b-\u003eIso(p a x)(p b y)(p s x)(p t y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:lmapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to inspect a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to see how it associates\n the structure and it can also be used to bake the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eMagma\u003c/a\u003e\u003c/code\u003e so\n that you can traverse over it multiple times.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "magma",
          "package": "lens",
          "signature": "LensLike (Mafic a b) s t a b -\u003e Iso s u (Magma Int t b a) (Magma j u c c)",
          "source": "src/Control-Lens-Iso.html#magma",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to inspect Traversal to see how it associates the structure and it can also be used to bake the Traversal into Magma so that you can traverse over it multiple times",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "magma",
          "normalized": "LensLike(Mafic a b)c d a b-\u003eIso c e(Magma Int d b a)(Magma f e g g)",
          "package": "lens",
          "signature": "LensLike(Mafic a b)s t a b-\u003eIso s u(Magma Int t b a)(Magma j u c c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:magma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis can be used to lift any \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e into an arbitrary \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "mapping",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e Iso (f s) (f t) (f a) (f b)",
          "source": "src/Control-Lens-Iso.html#mapping",
          "type": "function"
        },
        "index": {
          "description": "This can be used to lift any Iso into an arbitrary Functor",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "mapping",
          "normalized": "AnIso a b c d-\u003eIso(e a)(e b)(e c)(e d)",
          "package": "lens",
          "signature": "AnIso s t a b-\u003eIso(f s)(f t)(f a)(f b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:mapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf \u003ccode\u003ev\u003c/code\u003e is an element of a type \u003ccode\u003ea\u003c/code\u003e, and \u003ccode\u003ea'\u003c/code\u003e is \u003ccode\u003ea\u003c/code\u003e sans the element \u003ccode\u003ev\u003c/code\u003e, then \u003ccode\u003e\u003ccode\u003e\u003ca\u003enon\u003c/a\u003e\u003c/code\u003e v\u003c/code\u003e is an isomorphism from\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a'\u003c/code\u003e to \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003enon\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003enon'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eonly\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eKeep in mind this is only a real isomorphism if you treat the domain as being \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (a sans v)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is practically quite useful when you want to have a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e where all the entries should have non-zero values.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.fromList [(\"hello\",1)] & at \"hello\" . non 0 +~ 2\n\u003c/code\u003e\u003c/strong\u003efromList [(\"hello\",3)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.fromList [(\"hello\",1)] & at \"hello\" . non 0 -~ 1\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.fromList [(\"hello\",1)] ^. at \"hello\" . non 0\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.fromList [] ^. at \"hello\" . non 0\n\u003c/code\u003e\u003c/strong\u003e0\n\u003c/pre\u003e\u003cp\u003eThis combinator is also particularly useful when working with nested maps.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e When you want to create the nested \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e when it is missing:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.empty & at \"hello\" . non Map.empty . at \"world\" ?~ \"!!!\"\n\u003c/code\u003e\u003c/strong\u003efromList [(\"hello\",fromList [(\"world\",\"!!!\")])]\n\u003c/pre\u003e\u003cp\u003eand when have deleting the last entry from the nested \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e mean that we\n should delete its entry from the surrounding one:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [(\"hello\",fromList [(\"world\",\"!!!\")])] & at \"hello\" . non Map.empty . at \"world\" .~ Nothing\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "non",
          "package": "lens",
          "signature": "a -\u003e Iso' (Maybe a) a",
          "source": "src/Control-Lens-Iso.html#non",
          "type": "function"
        },
        "index": {
          "description": "If is an element of type and is sans the element then non is an isomorphism from Maybe to non non only Keep in mind this is only real isomorphism if you treat the domain as being Maybe sans This is practically quite useful when you want to have Map where all the entries should have non-zero values Map.fromList hello at hello non fromList hello Map.fromList hello at hello non fromList Map.fromList hello at hello non Map.fromList at hello non This combinator is also particularly useful when working with nested maps e.g When you want to create the nested Map when it is missing Map.empty at hello non Map.empty at world fromList hello fromList world and when have deleting the last entry from the nested Map mean that we should delete its entry from the surrounding one fromList hello fromList world at hello non Map.empty at world Nothing fromList",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "non",
          "normalized": "a-\u003eIso'(Maybe a)a",
          "package": "lens",
          "signature": "a-\u003eIso'(Maybe a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:non"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003enon'\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e generalizes \u003ccode\u003e\u003ccode\u003e\u003ca\u003enon\u003c/a\u003e\u003c/code\u003e (p # ())\u003c/code\u003e to take any unit \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis function generates an isomorphism between \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e (a | \u003ccode\u003e\u003ca\u003eisn't\u003c/a\u003e\u003c/code\u003e p a)\u003c/code\u003e and \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.singleton \"hello\" Map.empty & at \"hello\" . non' _Empty . at \"world\" ?~ \"!!!\"\n\u003c/code\u003e\u003c/strong\u003efromList [(\"hello\",fromList [(\"world\",\"!!!\")])]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [(\"hello\",fromList [(\"world\",\"!!!\")])] & at \"hello\" . non' _Empty . at \"world\" .~ Nothing\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "non'",
          "package": "lens",
          "signature": "APrism' a () -\u003e Iso' (Maybe a) a",
          "source": "src/Control-Lens-Iso.html#non%27",
          "type": "function"
        },
        "index": {
          "description": "non generalizes non to take any unit Prism This function generates an isomorphism between Maybe isn and Map.singleton hello Map.empty at hello non Empty at world fromList hello fromList world fromList hello fromList world at hello non Empty at world Nothing fromList",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "non'",
          "normalized": "APrism' a()-\u003eIso'(Maybe a)a",
          "package": "lens",
          "signature": "APrism' a()-\u003eIso'(Maybe a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:non-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e between a list, \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e fragment, etc. and its reversal.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"live\" ^. reversed\n\u003c/code\u003e\u003c/strong\u003e\"evil\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"live\" & reversed %~ ('d':)\n\u003c/code\u003e\u003c/strong\u003e\"lived\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "reversed",
          "package": "lens",
          "signature": "Iso' a a",
          "source": "src/Control-Lens-Iso.html#reversed",
          "type": "function"
        },
        "index": {
          "description": "An Iso between list ByteString Text fragment etc and its reversal live reversed evil live reversed lived",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "reversed",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:reversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Iso",
          "name": "reversing",
          "package": "lens",
          "signature": "t -\u003e t",
          "source": "src/Control-Lens-Internal-Iso.html#reversing",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "reversing",
          "normalized": "a-\u003ea",
          "package": "lens",
          "signature": "t-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:reversing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap the second argument covariantly.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003ermap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003edimap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "rmap",
          "package": "lens",
          "signature": "(b -\u003e c) -\u003e p a b -\u003e p a c",
          "type": "method"
        },
        "index": {
          "description": "Map the second argument covariantly rmap dimap id",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "rmap",
          "normalized": "(a-\u003eb)-\u003ec d a-\u003ec d b",
          "package": "lens",
          "signature": "(b-\u003ec)-\u003ep a b-\u003ep a c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:rmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e covariantly into the right argument of a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n rmapping :: \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e (p x s) (p y t) (p x a) (p y b)\n rmapping :: \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e (p x s) (p x a)\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "rmapping",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e Iso (p x s) (p y t) (p x a) (p y b)",
          "source": "src/Control-Lens-Iso.html#rmapping",
          "type": "function"
        },
        "index": {
          "description": "Lift an Iso covariantly into the right argument of Profunctor rmapping Profunctor Iso Iso rmapping Profunctor Iso Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "rmapping",
          "normalized": "AnIso a b c d-\u003eIso(e f a)(e g b)(e f c)(e g d)",
          "package": "lens",
          "signature": "AnIso s t a b-\u003eIso(p x s)(p y t)(p x a)(p y b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:rmapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposition with this isomorphism is occasionally useful when your \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e has a constraint on an unused\n argument to force that argument to agree with the\n type of a used argument and avoid \u003ccode\u003eScopedTypeVariables\u003c/code\u003e or other ugliness.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "simple",
          "package": "lens",
          "signature": "Iso' a a",
          "source": "src/Control-Lens-Iso.html#simple",
          "type": "function"
        },
        "index": {
          "description": "Composition with this isomorphism is occasionally useful when your Lens Traversal or Iso has constraint on an unused argument to force that argument to agree with the type of used argument and avoid ScopedTypeVariables or other ugliness",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "simple",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Iso",
          "name": "strict",
          "package": "lens",
          "signature": "Iso' lazy strict",
          "source": "src/Control-Lens-Iso.html#strict",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "strict",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:strict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003efirst\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003esecond\u003c/code\u003e f\n \u003ccode\u003esecond\u003c/code\u003e g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efirst\u003c/code\u003e g\n \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e f g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eswapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e g f\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2)^.swapped\n\u003c/code\u003e\u003c/strong\u003e(2,1)\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "swapped",
          "package": "lens",
          "signature": "Iso (p a b) (p c d) (p b a) (p d c)",
          "source": "src/Control-Lens-Iso.html#swapped",
          "type": "method"
        },
        "index": {
          "description": "swapped swapped id first swapped swapped second second swapped swapped first bimap swapped swapped bimap swapped",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "swapped",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:swapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe canonical isomorphism for uncurrying and currying a function.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003euncurried\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euncurry\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecurry\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003euncurried\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecurried\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e((+)^.uncurried) (1,2)\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "uncurried",
          "package": "lens",
          "signature": "Iso (a -\u003e b -\u003e c) (d -\u003e e -\u003e f) ((a, b) -\u003e c) ((d, e) -\u003e f)",
          "source": "src/Control-Lens-Iso.html#uncurried",
          "type": "function"
        },
        "index": {
          "description": "The canonical isomorphism for uncurrying and currying function uncurried iso uncurry curry uncurried from curried uncurried",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "uncurried",
          "normalized": "Iso(a-\u003eb-\u003ec)(d-\u003ee-\u003ef)((a,b)-\u003ec)((d,e)-\u003ef)",
          "package": "lens",
          "signature": "Iso(a-\u003eb-\u003ec)(d-\u003ee-\u003ef)((a,b)-\u003ec)((d,e)-\u003ef)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:uncurried"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe opposite of working \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e is working \u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e an isomorphism.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (t -\u003e s) -\u003e b -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Iso",
          "name": "under",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e (t -\u003e s) -\u003e b -\u003e a",
          "source": "src/Control-Lens-Iso.html#under",
          "type": "function"
        },
        "index": {
          "description": "The opposite of working over Setter is working under an isomorphism under over from under Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "under",
          "normalized": "AnIso a b c d-\u003e(b-\u003ea)-\u003ed-\u003ec",
          "package": "lens",
          "signature": "AnIso s t a b-\u003e(t-\u003es)-\u003eb-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:under"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the two functions, one from \u003ccode\u003es -\u003e a\u003c/code\u003e and\n one from \u003ccode\u003eb -\u003e t\u003c/code\u003e that characterize an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Iso",
          "name": "withIso",
          "package": "lens",
          "signature": "AnIso s t a b -\u003e ((s -\u003e a) -\u003e (b -\u003e t) -\u003e r) -\u003e r",
          "source": "src/Control-Lens-Iso.html#withIso",
          "type": "function"
        },
        "index": {
          "description": "Extract the two functions one from and one from that characterize an Iso",
          "hierarchy": "Control Lens Iso",
          "module": "Control.Lens.Iso",
          "name": "withIso",
          "normalized": "AnIso a b c d-\u003e((a-\u003ec)-\u003e(d-\u003eb)-\u003ee)-\u003ee",
          "package": "lens",
          "partial": "Iso",
          "signature": "AnIso s t a b-\u003e((s-\u003ea)-\u003e(b-\u003et)-\u003er)-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:withIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b\u003c/code\u003e is a purely functional reference.\n\u003c/p\u003e\u003cp\u003eWhile a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e could be used for\n \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a valid \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e,\n it wasn't a valid \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e as \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e wasn't a superclass of\n \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, however is the superclass of both.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b = forall f. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that doesn't use the \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that only uses\n the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e part of the \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e it is supplied.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a valid\n \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, since \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e is a superclass of \u003ccode\u003e\u003ca\u003eGettable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSince every \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a\n valid \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e it follows that it must view exactly one element in the\n structure.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws follow from this property and the desire for it to act like\n a \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e when used as a\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIn the examples below, \u003ccode\u003egetter\u003c/code\u003e and \u003ccode\u003esetter\u003c/code\u003e are supplied as example getters\n and setters, and are not actual functions supplied by this package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Lens is purely functional reference While Traversal could be used for Getting like valid Fold it wasn valid Getter as Applicative wasn superclass of Gettable Functor however is the superclass of both type Lens forall Functor Every Lens is valid Setter Every Lens can be used for Getting like Fold that doesn use the Applicative or Gettable Every Lens is valid Traversal that only uses the Functor part of the Applicative it is supplied Every Lens can be used for Getting like valid Getter since Functor is superclass of Gettable Since every Lens can be used for Getting like valid Getter it follows that it must view exactly one element in the structure The Lens laws follow from this property and the desire for it to act like Traversable when used as Traversal In the examples below getter and setter are supplied as example getters and setters and are not actual functions supplied by this package",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis type can also be used when you need to store a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e in a container,\n since it is rank-1. You can turn them back into a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003ecloneLens\u003c/a\u003e\u003c/code\u003e,\n or use it directly with combinators like \u003ccode\u003e\u003ca\u003estoring\u003c/a\u003e\u003c/code\u003e and (\u003ccode\u003e\u003ca\u003e^#\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "ALens",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html#ALens",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects Lens This type can also be used when you need to store Lens in container since it is rank-1 You can turn them back into Lens with cloneLens or use it directly with combinators like storing and",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "ALens",
          "package": "lens",
          "partial": "ALens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:ALens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eALens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "ALens'",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html#ALens%27",
          "type": "type"
        },
        "index": {
          "description": "type ALens Simple ALens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "ALens'",
          "package": "lens",
          "partial": "ALens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:ALens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "AnIndexedLens",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html#AnIndexedLens",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects an IndexedLens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "AnIndexedLens",
          "package": "lens",
          "partial": "An Indexed Lens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:AnIndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eAnIndexedLens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eAnIndexedLens\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "AnIndexedLens'",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html#AnIndexedLens%27",
          "type": "type"
        },
        "index": {
          "description": "type AnIndexedLens Simple AnIndexedLens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "AnIndexedLens'",
          "package": "lens",
          "partial": "An Indexed Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:AnIndexedLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe indexed store can be used to characterize a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n and is used by \u003ccode\u003e\u003ca\u003eclone\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e is isomorphic to\n \u003ccode\u003enewtype \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t = \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e { runContext :: forall f. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f b) -\u003e f t }\u003c/code\u003e,\n and to \u003ccode\u003eexists s. (s, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e is like a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that has already been applied to a some structure.\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "Context",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Context",
          "type": "data"
        },
        "index": {
          "description": "The indexed store can be used to characterize Lens and is used by clone Context is isomorphic to newtype Context Context runContext forall Functor and to exists Lens Context is like Lens that has already been applied to some structure",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "Context",
          "package": "lens",
          "partial": "Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003etype \u003ccode\u003e\u003ca\u003eContext'\u003c/a\u003e\u003c/code\u003e a s = \u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a a s\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "Context'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Context.html#Context%27",
          "type": "type"
        },
        "index": {
          "description": "type Context Context",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "Context'",
          "package": "lens",
          "partial": "Context'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:Context-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and a valid \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "IndexedLens",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedLens",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedLens is valid Lens and valid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "IndexedLens",
          "package": "lens",
          "partial": "Indexed Lens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:IndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "IndexedLens'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedLens%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedLens Simple IndexedLens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "IndexedLens'",
          "package": "lens",
          "partial": "Indexed Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:IndexedLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is actually a lens family as described in\n \u003ca\u003ehttp://comonad.com/reader/2012/mirrored-lenses/\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eWith great power comes great responsibility and a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is subject to the\n three common sense \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws:\n\u003c/p\u003e\u003cp\u003e1) You get back what you put in:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s)  &#8801; v\n\u003c/pre\u003e\u003cp\u003e2) Putting back what you got doesn't change anything:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l s) s  &#8801; s\n\u003c/pre\u003e\u003cp\u003e3) Setting twice is the same as setting once:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v' (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v' s\n\u003c/pre\u003e\u003cp\u003eThese laws are strong enough that the 4 type parameters of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e cannot\n vary fully independently. For more on how they interact, read the \"Why is\n it a Lens Family?\" section of\n \u003ca\u003ehttp://comonad.com/reader/2012/mirrored-lenses/\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThere are some emergent properties of these laws:\n\u003c/p\u003e\u003cp\u003e1) \u003ccode\u003e\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l s\u003c/code\u003e must be injective for every \u003ccode\u003es\u003c/code\u003e This is a consequence of law #1\n\u003c/p\u003e\u003cp\u003e2) \u003ccode\u003e\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l\u003c/code\u003e must be surjective, because of law #2, which indicates that it is possible to obtain any \u003ccode\u003ev\u003c/code\u003e from some \u003ccode\u003es\u003c/code\u003e such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e s v = s\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e3) Given just the first two laws you can prove a weaker form of law #3 where the values \u003ccode\u003ev\u003c/code\u003e that you are setting match:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s\n\u003c/pre\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used directly as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can also use a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e as if it were a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSince every \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, the\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws are required of any \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e you create:\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e (l f) \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l g &#8801; \u003ccode\u003e\u003ca\u003egetCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b = forall f. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Lens",
          "type": "type"
        },
        "index": {
          "description": "Lens is actually lens family as described in http comonad.com reader mirrored-lenses With great power comes great responsibility and Lens is subject to the three common sense Lens laws You get back what you put in view set Putting back what you got doesn change anything set view Setting twice is the same as setting once set set set These laws are strong enough that the type parameters of Lens cannot vary fully independently For more on how they interact read the Why is it Lens Family section of http comonad.com reader mirrored-lenses There are some emergent properties of these laws set must be injective for every This is consequence of law set must be surjective because of law which indicates that it is possible to obtain any from some such that set Given just the first two laws you can prove weaker form of law where the values that you are setting match set set set Every Lens can be used directly as Setter or Traversal You can also use Lens for Getting as if it were Fold or Getter Since every Lens is valid Traversal the Traversal laws are required of any Lens you create pure pure fmap getCompose Compose fmap type Lens forall Functor LensLike",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:Lens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "Lens'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Lens%27",
          "type": "type"
        },
        "index": {
          "description": "type Lens Simple Lens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "Lens'",
          "package": "lens",
          "partial": "Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:Lens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"there\") & _2 #~ \"world\"\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",\"world\")\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(#~)",
          "package": "lens",
          "signature": "ALens s t a b -\u003e b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Lens.html#%23~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-35--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35--126-\"]"
        },
        "index": {
          "description": "version of that works on ALens hello there world hello world",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(#~) #~",
          "normalized": "ALens a b c d-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ALens s t a b-\u003eb-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") & _2 #%~ length\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",5)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(#%~)",
          "package": "lens",
          "signature": "ALens s t a b -\u003e (a -\u003e b) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Lens.html#%23%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-35--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35--37--126-\"]"
        },
        "index": {
          "description": "version of that works on ALens hello world length hello",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(#%~) #%~",
          "normalized": "ALens a b c d-\u003e(c-\u003ed)-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ALens s t a b-\u003e(a-\u003eb)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") & _2 #%%~ \\x -\u003e (length x, x ++ \"!\")\n\u003c/code\u003e\u003c/strong\u003e(5,(\"hello\",\"world!\"))\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(#%%~)",
          "package": "lens",
          "signature": "ALens s t a b -\u003e (a -\u003e f b) -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Lens.html#%23%25%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-35--37--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35--37--37--126-\"]"
        },
        "index": {
          "description": "version of that works on ALens hello world length hello world",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(#%%~) #%%~",
          "normalized": "ALens a b c d-\u003e(c-\u003ee d)-\u003ea-\u003ee b",
          "package": "lens",
          "signature": "ALens s t a b-\u003e(a-\u003ef b)-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e%%=\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(#%%=)",
          "package": "lens",
          "signature": "ALens s s a b -\u003e (a -\u003e (r, b)) -\u003e m r",
          "source": "src/Control-Lens-Lens.html#%23%25%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-35--37--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35--37--37--61-\"]"
        },
        "index": {
          "description": "version of that works on ALens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(#%%=) #%%=",
          "normalized": "ALens a a b c-\u003e(b-\u003e(d,c))-\u003ee d",
          "package": "lens",
          "signature": "ALens s s a b-\u003e(a-\u003e(r,b))-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(#%=)",
          "package": "lens",
          "signature": "ALens s s a b -\u003e (a -\u003e b) -\u003e m ()",
          "source": "src/Control-Lens-Lens.html#%23%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-35--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35--37--61-\"]"
        },
        "index": {
          "description": "version of that works on ALens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(#%=) #%=",
          "normalized": "ALens a a b c-\u003e(b-\u003ec)-\u003ed()",
          "package": "lens",
          "signature": "ALens s s a b-\u003e(a-\u003eb)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(#=)",
          "package": "lens",
          "signature": "ALens s s a b -\u003e b -\u003e m ()",
          "source": "src/Control-Lens-Lens.html#%23%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-35--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35--61-\"]"
        },
        "index": {
          "description": "version of that works on ALens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(#=) #=",
          "normalized": "ALens a a b c-\u003ec-\u003ed()",
          "package": "lens",
          "signature": "ALens s s a b-\u003eb-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-35--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e(\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) can be used in one of two scenarios:\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, it can edit the target of the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e in a\n structure, extracting a functorial result.\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, it can edit the\n targets of the traversals, extracting an applicative summary of its\n actions.\n\u003c/p\u003e\u003cp\u003eFor all that the definition of this combinator is just:\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eIt may be beneficial to think about it as if it had these even more\n restricted types, however:\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e     \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e     \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, it can edit the\n targets of the traversals, extracting a supplemental monoidal summary\n of its actions, by choosing \u003ccode\u003ef = ((,) m)\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e (r, b)) -\u003e s -\u003e (r, t)\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e (r, b)) -\u003e s -\u003e (r, t)\n (\u003ccode\u003e\u003ca\u003e%%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e (m, b)) -\u003e s -\u003e (m, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(%%~)",
          "package": "lens",
          "signature": "Optical p q f s t a b -\u003e p a (f b) -\u003e q s (f t)",
          "source": "src/Control-Lens-Lens.html#%25%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--37--126-\"]"
        },
        "index": {
          "description": "can be used in one of two scenarios When applied to Lens it can edit the target of the Lens in structure extracting functorial result When applied to Traversal it can edit the targets of the traversals extracting an applicative summary of its actions For all that the definition of this combinator is just id It may be beneficial to think about it as if it had these even more restricted types however Functor Iso Functor Lens Applicative Traversal When applied to Traversal it can edit the targets of the traversals extracting supplemental monoidal summary of its actions by choosing Iso Lens Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(%%~) %%~",
          "normalized": "Optical a b c d e f g-\u003ea f(c g)-\u003eb d(c e)",
          "package": "lens",
          "signature": "Optical p q f s t a b-\u003ep a(f b)-\u003eq s(f t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e in the current state returning some extra\n information of type \u003ccode\u003er\u003c/code\u003e or modify all targets of a\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in the current state, extracting extra\n information of type \u003ccode\u003er\u003c/code\u003e and return a monoidal summary of the changes.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erunState (_1 %%= \\x -\u003e (f x, g x)) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,(g a,b))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%=\u003c/a\u003e\u003c/code\u003e) &#8801; (\u003ccode\u003e\u003ca\u003estate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cp\u003eIt may be useful to think of (\u003ccode\u003e\u003ca\u003e%%=\u003c/a\u003e\u003c/code\u003e), instead, as having either of the\n following more restricted type signatures:\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s s a b       -\u003e (a -\u003e (r, b)) -\u003e m r\n (\u003ccode\u003e\u003ca\u003e%%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s s a b      -\u003e (a -\u003e (r, b)) -\u003e m r\n (\u003ccode\u003e\u003ca\u003e%%=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r) =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s s a b -\u003e (a -\u003e (r, b)) -\u003e m r\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(%%=)",
          "package": "lens",
          "signature": "Over p ((,) r) s s a b -\u003e p a (r, b) -\u003e m r",
          "source": "src/Control-Lens-Lens.html#%25%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--37--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens in the current state returning some extra information of type or modify all targets of Traversal in the current state extracting extra information of type and return monoidal summary of the changes runState state It may be useful to think of instead as having either of the following more restricted type signatures MonadState Iso MonadState Lens MonadState Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(%%=) %%=",
          "normalized": "Over a((,)b)c c d e-\u003ea d(b,e)-\u003ef b",
          "package": "lens",
          "signature": "Over p((,)r)s s a b-\u003ep a(r,b)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the target of an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e returning a supplementary result, or\n adjust all of the targets of an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e and return a monoidal summary\n of the supplementary results and the answer.\n\u003c/p\u003e\u003cpre\u003e(\u003ccode\u003e\u003ca\u003e%%@~\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003ewithIndex\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t\n (\u003ccode\u003e\u003ca\u003e%%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e\u003cp\u003eIn particular, it is often useful to think of this function as having one of these even more\n restricted type signatures:\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%@~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e (r, b)) -\u003e s -\u003e (r, t)\n (\u003ccode\u003e\u003ca\u003e%%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e (r, b)) -\u003e s -\u003e (r, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(%%@~)",
          "package": "lens",
          "signature": "IndexedLensLike i f s t a b -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Lens.html#%25%25%40~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--64--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--37--64--126-\"]"
        },
        "index": {
          "description": "Adjust the target of an IndexedLens returning supplementary result or adjust all of the targets of an IndexedTraversal and return monoidal summary of the supplementary results and the answer withIndex Functor IndexedLens Applicative IndexedTraversal In particular it is often useful to think of this function as having one of these even more restricted type signatures IndexedLens Monoid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(%%@~) %%@~",
          "normalized": "IndexedLensLike a b c d e f-\u003e(a-\u003ee-\u003eb f)-\u003ec-\u003eb d",
          "package": "lens",
          "signature": "IndexedLensLike i f s t a b-\u003e(i-\u003ea-\u003ef b)-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--64--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the target of an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e returning a supplementary result, or\n adjust all of the targets of an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e within the current state, and\n return a monoidal summary of the supplementary results.\n\u003c/p\u003e\u003cpre\u003el \u003ccode\u003e\u003ca\u003e%%@=\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003estate\u003c/a\u003e\u003c/code\u003e (l \u003ccode\u003e\u003ca\u003e%%@~\u003c/a\u003e\u003c/code\u003e f)\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%%@=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m                 =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s s a b      -\u003e (i -\u003e a -\u003e (r, b)) -\u003e s -\u003e m r\n (\u003ccode\u003e\u003ca\u003e%%@=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r) =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s s a b -\u003e (i -\u003e a -\u003e (r, b)) -\u003e s -\u003e m r\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(%%@=)",
          "package": "lens",
          "signature": "IndexedLensLike i ((,) r) s s a b -\u003e (i -\u003e a -\u003e (r, b)) -\u003e m r",
          "source": "src/Control-Lens-Lens.html#%25%25%40%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--64--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--37--64--61-\"]"
        },
        "index": {
          "description": "Adjust the target of an IndexedLens returning supplementary result or adjust all of the targets of an IndexedTraversal within the current state and return monoidal summary of the supplementary results state MonadState IndexedLens MonadState Monoid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(%%@=) %%@=",
          "normalized": "IndexedLensLike a((,)b)c c d e-\u003e(a-\u003ed-\u003e(b,e))-\u003ef b",
          "package": "lens",
          "signature": "IndexedLensLike i((,)r)s s a b-\u003e(i-\u003ea-\u003e(r,b))-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-37--37--64--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePasses the result of the left side to the function on the right side (forward pipe operator).\n\u003c/p\u003e\u003cp\u003eThis is the flipped version of (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e), which is more common in languages like F# as (\u003ccode\u003e|\u003e\u003c/code\u003e) where it is needed\n for inference. Here it is supplied for notational convenience and given a precedence that allows it\n to be nested inside uses of (\u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea & f\n\u003c/code\u003e\u003c/strong\u003ef a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\" & length & succ\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cp\u003eThis combinator is commonly used when applying multiple \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e operations in sequence.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") & _1.element 0 .~ 'j' & _1.element 4 .~ 'y'\n\u003c/code\u003e\u003c/strong\u003e(\"jelly\",\"world\")\n\u003c/pre\u003e\u003cp\u003eThis reads somewhat similar to:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip execState (\"hello\",\"world\") $ do _1.element 0 .= 'j'; _1.element 4 .= 'y'\n\u003c/code\u003e\u003c/strong\u003e(\"jelly\",\"world\")\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(&)",
          "package": "lens",
          "signature": "a -\u003e (a -\u003e b) -\u003e b",
          "source": "src/Control-Lens-Lens.html#%26",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-38-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-38-\"]"
        },
        "index": {
          "description": "Passes the result of the left side to the function on the right side forward pipe operator This is the flipped version of which is more common in languages like as where it is needed for inference Here it is supplied for notational convenience and given precedence that allows it to be nested inside uses of hello length succ This combinator is commonly used when applying multiple Lens operations in sequence hello world element element jelly world This reads somewhat similar to flip execState hello world do element element jelly world",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(&) &",
          "normalized": "a-\u003e(a-\u003eb)-\u003eb",
          "package": "lens",
          "signature": "a-\u003e(a-\u003eb)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogically \u003ccode\u003e\u003ca\u003e||\u003c/a\u003e\u003c/code\u003e a Boolean valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e||~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c||~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e (\u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, s)\n (\u003ccode\u003e\u003ca\u003e\u003c||~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e  -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e (\u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c||~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) Bool) s t Bool Bool -\u003e Bool -\u003e q s (Bool, t)",
          "source": "src/Control-Lens-Lens.html#%3C%7C%7C~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--124--124--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--124--124--126-\"]"
        },
        "index": {
          "description": "Logically Boolean valued Lens and return the result When you do not need the result of the operation is more flexible Lens Bool Bool Bool Iso Bool Bool Bool",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c||~) \u003c||~",
          "normalized": "Optical(-\u003e)a((,)Bool)b c Bool Bool-\u003eBool-\u003ea b(Bool,c)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)Bool)s t Bool Bool-\u003eBool-\u003eq s(Bool,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--124--124--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogically \u003ccode\u003e\u003ca\u003e||\u003c/a\u003e\u003c/code\u003e a Boolean valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state and return\n the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e||=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c||=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c||=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e  -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c||=)",
          "package": "lens",
          "signature": "LensLike' ((,) Bool) s Bool -\u003e Bool -\u003e m Bool",
          "source": "src/Control-Lens-Lens.html#%3C%7C%7C%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--124--124--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--124--124--61-\"]"
        },
        "index": {
          "description": "Logically Boolean valued Lens into your Monad state and return the result When you do not need the result of the operation is more flexible MonadState Lens Bool Bool Bool MonadState Iso Bool Bool Bool",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c||=) \u003c||=",
          "normalized": "LensLike'((,)Bool)a Bool-\u003eBool-\u003eb Bool",
          "package": "lens",
          "signature": "LensLike'((,)Bool)s Bool-\u003eBool-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--124--124--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e\u003c.~\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"there\") & _2 \u003c#~ \"world\"\n\u003c/code\u003e\u003c/strong\u003e(\"world\",(\"hello\",\"world\"))\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(\u003c#~)",
          "package": "lens",
          "signature": "ALens s t a b -\u003e b -\u003e s -\u003e (b, t)",
          "source": "src/Control-Lens-Lens.html#%3C%23~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-60--35--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--35--126-\"]"
        },
        "index": {
          "description": "version of that works on ALens hello there world world hello world",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c#~) \u003c#~",
          "normalized": "ALens a b c d-\u003ed-\u003ea-\u003e(d,b)",
          "package": "lens",
          "signature": "ALens s t a b-\u003eb-\u003es-\u003e(b,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e\u003c%~\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") & _2 \u003c#%~ length\n\u003c/code\u003e\u003c/strong\u003e(5,(\"hello\",5))\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(\u003c#%~)",
          "package": "lens",
          "signature": "ALens s t a b -\u003e (a -\u003e b) -\u003e s -\u003e (b, t)",
          "source": "src/Control-Lens-Lens.html#%3C%23%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-60--35--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--35--37--126-\"]"
        },
        "index": {
          "description": "version of that works on ALens hello world length hello",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c#%~) \u003c#%~",
          "normalized": "ALens a b c d-\u003e(c-\u003ed)-\u003ea-\u003e(d,b)",
          "package": "lens",
          "signature": "ALens s t a b-\u003e(a-\u003eb)-\u003es-\u003e(b,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e\u003c%=\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(\u003c#%=)",
          "package": "lens",
          "signature": "ALens s s a b -\u003e (a -\u003e b) -\u003e m b",
          "source": "src/Control-Lens-Lens.html#%3C%23%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-60--35--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--35--37--61-\"]"
        },
        "index": {
          "description": "version of that works on ALens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c#%=) \u003c#%=",
          "normalized": "ALens a a b c-\u003e(b-\u003ec)-\u003ed c",
          "package": "lens",
          "signature": "ALens s s a b-\u003e(a-\u003eb)-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e\u003c.=\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(\u003c#=)",
          "package": "lens",
          "signature": "ALens s s a b -\u003e b -\u003e m b",
          "source": "src/Control-Lens-Lens.html#%3C%23%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-60--35--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--35--61-\"]"
        },
        "index": {
          "description": "version of that works on ALens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c#=) \u003c#=",
          "normalized": "ALens a a b c-\u003ec-\u003ed c",
          "package": "lens",
          "signature": "ALens s s a b-\u003eb-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--35--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the addition, (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c%~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e b) -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c%~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e b) -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e b =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e b) -\u003e s -\u003e (b, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c%~)",
          "package": "lens",
          "signature": "Optical p q ((,) b) s t a b -\u003e p a b -\u003e q s (b, t)",
          "source": "src/Control-Lens-Lens.html#%3C%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--37--126-\"]"
        },
        "index": {
          "description": "Modify the target of Lens and return the result When you do not need the result of the addition is more flexible Lens Iso Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c%~) \u003c%~",
          "normalized": "Optical a b((,)c)d e f c-\u003ea f c-\u003eb d(c,e)",
          "package": "lens",
          "signature": "Optical p q((,)b)s t a b-\u003ep a b-\u003eq s(b,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state by a user supplied\n function and return the result.\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, it this will return a monoidal summary of all of the intermediate\n results.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a) -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a) -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c%=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a) -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c%=)",
          "package": "lens",
          "signature": "Over p ((,) b) s s a b -\u003e p a b -\u003e m b",
          "source": "src/Control-Lens-Lens.html#%3C%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--37--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens into your Monad state by user supplied function and return the result When applied to Traversal it this will return monoidal summary of all of the intermediate results When you do not need the result of the operation is more flexible MonadState Lens MonadState Iso MonadState Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c%=) \u003c%=",
          "normalized": "Over a((,)b)c c d b-\u003ea d b-\u003ee b",
          "package": "lens",
          "signature": "Over p((,)b)s s a b-\u003ep a b-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the target of an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e returning the intermediate result, or\n adjust all of the targets of an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e and return a monoidal summary\n along with the answer.\n\u003c/p\u003e\u003cpre\u003el \u003ccode\u003e\u003ca\u003e\u003c%~\u003c/a\u003e\u003c/code\u003e f &#8801; l \u003ccode\u003e\u003ca\u003e\u003c%@~\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003cp\u003eWhen you do not need access to the index then (\u003ccode\u003e\u003ca\u003e\u003c%~\u003c/a\u003e\u003c/code\u003e) is more liberal in what it can accept.\n\u003c/p\u003e\u003cp\u003eIf you do not need the intermediate result, you can use (\u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e) or even (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c%@~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e b =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e (b, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c%@~)",
          "package": "lens",
          "signature": "Optical (Indexed i) q ((,) b) s t a b -\u003e (i -\u003e a -\u003e b) -\u003e q s (b, t)",
          "source": "src/Control-Lens-Lens.html#%3C%25%40~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--64--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--37--64--126-\"]"
        },
        "index": {
          "description": "Adjust the target of an IndexedLens returning the intermediate result or adjust all of the targets of an IndexedTraversal and return monoidal summary along with the answer const When you do not need access to the index then is more liberal in what it can accept If you do not need the intermediate result you can use or even IndexedLens Monoid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c%@~) \u003c%@~",
          "normalized": "Optical(Indexed a)b((,)c)d e f c-\u003e(a-\u003ef-\u003ec)-\u003eb d(c,e)",
          "package": "lens",
          "signature": "Optical(Indexed i)q((,)b)s t a b-\u003e(i-\u003ea-\u003eb)-\u003eq s(b,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--64--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the target of an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e returning the intermediate result, or\n adjust all of the targets of an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e within the current state, and\n return a monoidal summary of the intermediate results.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c%@=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m                 =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s s a b      -\u003e (i -\u003e a -\u003e b) -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c%@=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e b) =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s s a b -\u003e (i -\u003e a -\u003e b) -\u003e m b\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c%@=)",
          "package": "lens",
          "signature": "IndexedLensLike i ((,) b) s s a b -\u003e (i -\u003e a -\u003e b) -\u003e m b",
          "source": "src/Control-Lens-Lens.html#%3C%25%40%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--64--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--37--64--61-\"]"
        },
        "index": {
          "description": "Adjust the target of an IndexedLens returning the intermediate result or adjust all of the targets of an IndexedTraversal within the current state and return monoidal summary of the intermediate results MonadState IndexedLens MonadState Monoid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c%@=) \u003c%@=",
          "normalized": "IndexedLensLike a((,)b)c c d b-\u003e(a-\u003ed-\u003eb)-\u003ee b",
          "package": "lens",
          "signature": "IndexedLensLike i((,)b)s s a b-\u003e(i-\u003ea-\u003eb)-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--37--64--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogically \u003ccode\u003e\u003ca\u003e&&\u003c/a\u003e\u003c/code\u003e a Boolean valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e&&~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c&&~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e (\u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, s)\n (\u003ccode\u003e\u003ca\u003e\u003c&&~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e  -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e (\u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c&&~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) Bool) s t Bool Bool -\u003e Bool -\u003e q s (Bool, t)",
          "source": "src/Control-Lens-Lens.html#%3C%26%26~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--38--38--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--38--38--126-\"]"
        },
        "index": {
          "description": "Logically Boolean valued Lens and return the result When you do not need the result of the operation is more flexible Lens Bool Bool Bool Iso Bool Bool Bool",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c&&~) \u003c&&~",
          "normalized": "Optical(-\u003e)a((,)Bool)b c Bool Bool-\u003eBool-\u003ea b(Bool,c)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)Bool)s t Bool Bool-\u003eBool-\u003eq s(Bool,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--38--38--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogically \u003ccode\u003e\u003ca\u003e&&\u003c/a\u003e\u003c/code\u003e a Boolean valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state and return\n the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e&&=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c&&=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c&&=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e  -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c&&=)",
          "package": "lens",
          "signature": "LensLike' ((,) Bool) s Bool -\u003e Bool -\u003e m Bool",
          "source": "src/Control-Lens-Lens.html#%3C%26%26%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--38--38--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--38--38--61-\"]"
        },
        "index": {
          "description": "Logically Boolean valued Lens into your Monad state and return the result When you do not need the result of the operation is more flexible MonadState Lens Bool Bool Bool MonadState Iso Bool Bool Bool",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c&&=) \u003c&&=",
          "normalized": "LensLike'((,)Bool)a Bool-\u003eBool-\u003eb Bool",
          "package": "lens",
          "signature": "LensLike'((,)Bool)s Bool-\u003eBool-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--38--38--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix flipped \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c&\u003e\u003c/a\u003e\u003c/code\u003e) = \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c&\u003e)",
          "package": "lens",
          "signature": "f a -\u003e (a -\u003e b) -\u003e f b",
          "source": "src/Control-Lens-Lens.html#%3C%26%3E",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--38--62-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--38--62-\"]"
        },
        "index": {
          "description": "Infix flipped fmap flip fmap",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c&\u003e) \u003c&\u003e",
          "normalized": "a b-\u003e(b-\u003ec)-\u003ea c",
          "package": "lens",
          "signature": "f a-\u003e(a-\u003eb)-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--38--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the multiplication, (\u003ccode\u003e\u003ca\u003e*~\u003c/a\u003e\u003c/code\u003e) is more\n flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c*~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c*~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e  s a -\u003e a -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c*~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e a -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%2A~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--42--126-\"]"
        },
        "index": {
          "description": "Multiply the target of numerically valued Lens and return the result When you do not need the result of the multiplication is more flexible Num Lens Num Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c*~) \u003c*~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003eb-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ea-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target of a floating-point valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to an arbitrary power\n and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e**~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c**~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c**~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a  -\u003e a -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c**~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e a -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%2A%2A~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--42--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--42--42--126-\"]"
        },
        "index": {
          "description": "Raise the target of floating-point valued Lens to an arbitrary power and return the result When you do not need the result of the operation is more flexible Floating Lens Floating Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c**~) \u003c**~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003eb-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ea-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--42--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target of a floating-point valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s\n state to an arbitrary power and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e**=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c**=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c**=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c**=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%2A%2A%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--42--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--42--42--61-\"]"
        },
        "index": {
          "description": "Raise the target of floating-point valued Lens into your Monad state to an arbitrary power and return the result When you do not need the result of the operation is more flexible MonadState Floating Lens MonadState Floating Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c**=) \u003c**=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s\n state and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the multiplication, (\u003ccode\u003e\u003ca\u003e*=\u003c/a\u003e\u003c/code\u003e) is more\n flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c*=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c*=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c*=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%2A%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--42--61-\"]"
        },
        "index": {
          "description": "Multiply the target of numerically valued Lens into your Monad state and return the result When you do not need the result of the multiplication is more flexible MonadState Num Lens MonadState Num Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c*=) \u003c*=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the addition, (\u003ccode\u003e\u003ca\u003e+~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c+~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c+~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a  -\u003e a -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c+~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e a -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%2B~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--43--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--43--126-\"]"
        },
        "index": {
          "description": "Increment the target of numerically valued Lens and return the result When you do not need the result of the addition is more flexible Num Lens Num Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c+~) \u003c+~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003eb-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ea-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--43--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd to the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state\n and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the addition, (\u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e) is more\n flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c+=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c+=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c+=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%2B%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--43--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--43--61-\"]"
        },
        "index": {
          "description": "Add to the target of numerically valued Lens into your Monad state and return the result When you do not need the result of the addition is more flexible MonadState Num Lens MonadState Num Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c+=) \u003c+=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--43--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrement the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the subtraction, (\u003ccode\u003e\u003ca\u003e-~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c-~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c-~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a  -\u003e a -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c-~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e a -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C-~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--45--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--45--126-\"]"
        },
        "index": {
          "description": "Decrement the target of numerically valued Lens and return the result When you do not need the result of the subtraction is more flexible Num Lens Num Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c-~) \u003c-~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003eb-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ea-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--45--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubtract from the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s\n state and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the subtraction, (\u003ccode\u003e\u003ca\u003e-=\u003c/a\u003e\u003c/code\u003e) is more\n flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c-=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c-=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c-=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C-%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--45--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--45--61-\"]"
        },
        "index": {
          "description": "Subtract from the target of numerically valued Lens into your Monad state and return the result When you do not need the result of the subtraction is more flexible MonadState Num Lens MonadState Num Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c-=) \u003c-=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--45--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide the target of a fractionally valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the division, (\u003ccode\u003e\u003ca\u003e//~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c//~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c//~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e  s a -\u003e a -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c//~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e a -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%2F%2F~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--47--47--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--47--47--126-\"]"
        },
        "index": {
          "description": "Divide the target of fractionally valued Lens and return the result When you do not need the result of the division is more flexible Fractional Lens Fractional Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c//~) \u003c//~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003eb-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ea-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--47--47--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide the target of a fractionally valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state\n and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the division, (\u003ccode\u003e\u003ca\u003e//=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c//=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c//=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c//=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%2F%2F%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--47--47--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--47--47--61-\"]"
        },
        "index": {
          "description": "Divide the target of fractionally valued Lens into your Monad state and return the result When you do not need the result of the division is more flexible MonadState Fractional Lens MonadState Fractional Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c//=) \u003c//=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--47--47--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c||~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) Bool) s Bool -\u003e Bool -\u003e q s (Bool, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%7C%7C~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--124--124--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--124--124--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c||~) \u003c\u003c||~",
          "normalized": "Optical'(-\u003e)a((,)Bool)b Bool-\u003eBool-\u003ea b(Bool,b)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)Bool)s Bool-\u003eBool-\u003eq s(Bool,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--124--124--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c||=)",
          "package": "lens",
          "signature": "LensLike' ((,) Bool) s Bool -\u003e Bool -\u003e m Bool",
          "source": "src/Control-Lens-Lens.html#%3C%3C%7C%7C%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--124--124--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--124--124--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c||=) \u003c\u003c||=",
          "normalized": "LensLike'((,)Bool)a Bool-\u003eBool-\u003eb Bool",
          "package": "lens",
          "signature": "LensLike'((,)Bool)s Bool-\u003eBool-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--124--124--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a monadic action, and set the target of \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to its result.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s s a b   -\u003e m b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s s a b  -\u003e m b -\u003e m b\n\u003c/pre\u003e\u003cp\u003eNB: This is limited to taking an actual \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e than admitting a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e because\n there are potential loss of state issues otherwise.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c~)",
          "package": "lens",
          "signature": "ALens s s a b -\u003e m b -\u003e m b",
          "source": "src/Control-Lens-Lens.html#%3C%3C~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--126-\"]"
        },
        "index": {
          "description": "Run monadic action and set the target of Lens to its result MonadState Iso MonadState Lens NB This is limited to taking an actual Lens than admitting Traversal because there are potential loss of state issues otherwise",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c~) \u003c\u003c~",
          "normalized": "ALens a a b c-\u003ed c-\u003ed c",
          "package": "lens",
          "signature": "ALens s s a b-\u003em b-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, but return the old value.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the addition, (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e b) -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e b) -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e b) -\u003e s -\u003e (a, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c%~)",
          "package": "lens",
          "signature": "Optical p q ((,) a) s t a b -\u003e p a b -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--37--126-\"]"
        },
        "index": {
          "description": "Modify the target of Lens but return the old value When you do not need the result of the addition is more flexible Lens Iso Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c%~) \u003c\u003c%~",
          "normalized": "Optical a b((,)c)d e c f-\u003ea c f-\u003eb d(c,e)",
          "package": "lens",
          "signature": "Optical p q((,)a)s t a b-\u003ep a b-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state by a user supplied\n function and return the \u003cem\u003eold\u003c/em\u003e value that was replaced.\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, it this will return a monoidal summary of all of the old values\n present.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a) -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a) -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e b) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a) -\u003e m a\n\u003c/pre\u003e\u003cpre\u003e(\u003ccode\u003e\u003ca\u003e\u003c\u003c%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e ((,)a) s s a b -\u003e (a -\u003e b) -\u003e m a\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c%=)",
          "package": "lens",
          "signature": "Over p ((,) a) s s a b -\u003e p a b -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--37--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens into your Monad state by user supplied function and return the old value that was replaced When applied to Traversal it this will return monoidal summary of all of the old values present When you do not need the result of the operation is more flexible MonadState Lens MonadState Iso MonadState Monoid Traversal MonadState LensLike",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c%=) \u003c\u003c%=",
          "normalized": "Over a((,)b)c c b d-\u003ea b d-\u003ee b",
          "package": "lens",
          "signature": "Over p((,)a)s s a b-\u003ep a b-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the target of an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e returning the old value, or\n adjust all of the targets of an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e and return a monoidal summary\n of the old values along with the answer.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%@~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e (a, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c%@~)",
          "package": "lens",
          "signature": "Optical (Indexed i) q ((,) a) s t a b -\u003e (i -\u003e a -\u003e b) -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%25%40~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--64--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--37--64--126-\"]"
        },
        "index": {
          "description": "Adjust the target of an IndexedLens returning the old value or adjust all of the targets of an IndexedTraversal and return monoidal summary of the old values along with the answer IndexedLens Monoid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c%@~) \u003c\u003c%@~",
          "normalized": "Optical(Indexed a)b((,)c)d e c f-\u003e(a-\u003ec-\u003ef)-\u003eb d(c,e)",
          "package": "lens",
          "signature": "Optical(Indexed i)q((,)a)s t a b-\u003e(i-\u003ea-\u003eb)-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--64--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust the target of an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e returning the old value, or\n adjust all of the targets of an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e within the current state, and\n return a monoidal summary of the old values.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%@=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m                 =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s s a b      -\u003e (i -\u003e a -\u003e b) -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c%@=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e b) =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s s a b -\u003e (i -\u003e a -\u003e b) -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c%@=)",
          "package": "lens",
          "signature": "IndexedLensLike i ((,) a) s s a b -\u003e (i -\u003e a -\u003e b) -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%25%40%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--64--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--37--64--61-\"]"
        },
        "index": {
          "description": "Adjust the target of an IndexedLens returning the old value or adjust all of the targets of an IndexedTraversal within the current state and return monoidal summary of the old values MonadState IndexedLens MonadState Monoid IndexedTraversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c%@=) \u003c\u003c%@=",
          "normalized": "IndexedLensLike a((,)b)c c b d-\u003e(a-\u003eb-\u003ed)-\u003ee b",
          "package": "lens",
          "signature": "IndexedLensLike i((,)a)s s a b-\u003e(i-\u003ea-\u003eb)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--37--64--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c&&~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) Bool) s Bool -\u003e Bool -\u003e q s (Bool, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%26%26~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--38--38--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--38--38--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c&&~) \u003c\u003c&&~",
          "normalized": "Optical'(-\u003e)a((,)Bool)b Bool-\u003eBool-\u003ea b(Bool,b)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)Bool)s Bool-\u003eBool-\u003eq s(Bool,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--38--38--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c&&=)",
          "package": "lens",
          "signature": "LensLike' ((,) Bool) s Bool -\u003e Bool -\u003e m Bool",
          "source": "src/Control-Lens-Lens.html#%3C%3C%26%26%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--38--38--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--38--38--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c&&=) \u003c\u003c&&=",
          "normalized": "LensLike'((,)Bool)a Bool-\u003eBool-\u003eb Bool",
          "package": "lens",
          "signature": "LensLike'((,)Bool)s Bool-\u003eBool-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--38--38--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c*~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2A~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--42--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c*~) \u003c\u003c*~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c**~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2A%2A~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--42--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--42--42--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c**~) \u003c\u003c**~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--42--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c**=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2A%2A%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--42--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--42--42--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c**=) \u003c\u003c**=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c*=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2A%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--42--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c*=) \u003c\u003c*=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c+~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2B~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--43--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--43--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c+~) \u003c\u003c+~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--43--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c+=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2B%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--43--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--43--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c+=) \u003c\u003c+=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--43--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c-~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C-~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--45--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--45--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c-~) \u003c\u003c-~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--45--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c-=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C-%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--45--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--45--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c-=) \u003c\u003c-=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--45--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c//~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2F%2F~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--47--47--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--47--47--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c//~) \u003c\u003c//~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--47--47--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c//=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%2F%2F%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--47--47--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--47--47--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c//=) \u003c\u003c//=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--47--47--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c\u003c\u003e~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) r) s r -\u003e r -\u003e q s (r, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%3C%3E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--60--62--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--60--62--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c\u003c\u003e~) \u003c\u003c\u003c\u003e~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)r)s r-\u003er-\u003eq s(r,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--60--62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c\u003c\u003e=)",
          "package": "lens",
          "signature": "LensLike' ((,) r) s r -\u003e r -\u003e m r",
          "source": "src/Control-Lens-Lens.html#%3C%3C%3C%3E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--60--62--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--60--62--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c\u003c\u003e=) \u003c\u003c\u003c\u003e=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)r)s r-\u003er-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--60--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e a monoidal value onto the end of the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and\n return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e\u003c\u003e~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c\u003e~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) m) s t m m -\u003e m -\u003e q s (m, t)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%3E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--62--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--62--126-\"]"
        },
        "index": {
          "description": "mappend monoidal value onto the end of the target of Lens and return the result When you do not need the result of the operation is more flexible",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c\u003e~) \u003c\u003c\u003e~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003eb-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)m)s t m m-\u003em-\u003eq s(m,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003e a monoidal value onto the end of the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into\n your 'Monad'\\'s state and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e\u003c\u003e=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c\u003e=)",
          "package": "lens",
          "signature": "LensLike' ((,) r) s r -\u003e r -\u003e m r",
          "source": "src/Control-Lens-Lens.html#%3C%3C%3E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--62--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--62--61-\"]"
        },
        "index": {
          "description": "mappend monoidal value onto the end of the target of Lens into your Monad state and return the result When you do not need the result of the operation is more flexible",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c\u003e=) \u003c\u003c\u003e=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)r)s r-\u003er-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c^~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e e -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%5E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--94--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c^~) \u003c\u003c^~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003ed-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ee-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c^=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e e -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%5E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--94--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c^=) \u003c\u003c^=",
          "normalized": "LensLike'((,)a)b a-\u003ec-\u003ed a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ee-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c^^~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e e -\u003e q s (a, s)",
          "source": "src/Control-Lens-Lens.html#%3C%3C%5E%5E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--94--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--94--94--126-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c^^~) \u003c\u003c^^~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003ed-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ee-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--94--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c^^=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e e -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C%5E%5E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--94--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60--94--94--61-\"]"
        },
        "index": {
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c^^=) \u003c\u003c^^=",
          "normalized": "LensLike'((,)a)b a-\u003ec-\u003ed a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ee-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60--94--94--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, but return the old value.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the old value, (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c.~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e b -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c.~\u003c/a\u003e\u003c/code\u003e) ::             \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e b -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e b -\u003e s -\u003e (a, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c.~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a b -\u003e b -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%3C.~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60-.-126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60-.-126-\"]"
        },
        "index": {
          "description": "Modify the target of Lens but return the old value When you do not need the old value is more flexible Lens Iso Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c.~) \u003c\u003c.~",
          "normalized": "Optical(-\u003e)a((,)b)c d b e-\u003ee-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a b-\u003eb-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state by a user supplied\n function and return the \u003cem\u003eold\u003c/em\u003e value that was replaced.\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, it this will return a monoidal summary of all of the old values\n present.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m             =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c\u003c.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e t) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c\u003c.=)",
          "package": "lens",
          "signature": "LensLike ((,) a) s s a b -\u003e b -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%3C.%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60-.-61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--60-.-61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens into your Monad state by user supplied function and return the old value that was replaced When applied to Traversal it this will return monoidal summary of all of the old values present When you do not need the result of the operation is more flexible MonadState Lens MonadState Iso MonadState Monoid Traversal",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c\u003c.=) \u003c\u003c.=",
          "normalized": "LensLike((,)a)b b a c-\u003ec-\u003ed a",
          "package": "lens",
          "signature": "LensLike((,)a)s s a b-\u003eb-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--60-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to a non-negative\n \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e power and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e^~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c^~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e e -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%5E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--94--126-\"]"
        },
        "index": {
          "description": "Raise the target of numerically valued Lens to non-negative Integral power and return the result When you do not need the result of the operation is more flexible Num Integral Lens Num Integral Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c^~) \u003c^~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003ee-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ee-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state\n to a non-negative \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e power and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e^=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c^=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c^=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c^=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e e -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%5E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--94--61-\"]"
        },
        "index": {
          "description": "Raise the target of numerically valued Lens into your Monad state to non-negative Integral power and return the result When you do not need the result of the operation is more flexible MonadState Num Integral Lens MonadState Num Integral Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c^=) \u003c^=",
          "normalized": "LensLike'((,)a)b a-\u003ec-\u003ed a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ee-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target of a fractionally valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e power\n and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e^^~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c^^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e s -\u003e (a, s)\n (\u003ccode\u003e\u003ca\u003e\u003c^^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e s -\u003e (a, s)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c^^~)",
          "package": "lens",
          "signature": "Optical (-\u003e) q ((,) a) s t a a -\u003e e -\u003e q s (a, t)",
          "source": "src/Control-Lens-Lens.html#%3C%5E%5E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--94--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--94--94--126-\"]"
        },
        "index": {
          "description": "Raise the target of fractionally valued Lens to an Integral power and return the result When you do not need the result of the operation is more flexible Fractional Integral Lens Fractional Integral Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c^^~) \u003c^^~",
          "normalized": "Optical(-\u003e)a((,)b)c d b b-\u003ee-\u003ea c(b,d)",
          "package": "lens",
          "signature": "Optical(-\u003e)q((,)a)s t a a-\u003ee-\u003eq s(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--94--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target of a fractionally valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into your 'Monad'\\'s state\n to an \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e power and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e^^=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c^^=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e b, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c^^=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e b, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a  -\u003e e -\u003e m a\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(\u003c^^=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e e -\u003e m a",
          "source": "src/Control-Lens-Lens.html#%3C%5E%5E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--94--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--94--94--61-\"]"
        },
        "index": {
          "description": "Raise the target of fractionally valued Lens into your Monad state to an Integral power and return the result When you do not need the result of the operation is more flexible MonadState Fractional Integral Lens MonadState Fractional Integral Iso",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(\u003c^^=) \u003c^^=",
          "normalized": "LensLike'((,)a)b a-\u003ec-\u003ed a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ee-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-60--94--94--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is convenient to \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e argument order of composite functions.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _2 ?? (\"hello\",\"world\") $ length\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",5)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover ?? length ?? (\"hello\",\"world\") $ _2\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",5)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Operators\"]",
          "name": "(??)",
          "package": "lens",
          "signature": "f (a -\u003e b) -\u003e a -\u003e f b",
          "source": "src/Control-Lens-Lens.html#%3F%3F",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-63--63-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-63--63-\"]"
        },
        "index": {
          "description": "This is convenient to flip argument order of composite functions over hello world length hello over length hello world hello",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(??) ??",
          "normalized": "a(b-\u003ec)-\u003eb-\u003ea c",
          "package": "lens",
          "signature": "f(a-\u003eb)-\u003ea-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-63--63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\")^#_2\n\u003c/code\u003e\u003c/strong\u003e\"world\"\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\",\"Control.Lens.Operators\"]",
          "name": "(^#)",
          "package": "lens",
          "signature": "s -\u003e ALens s t a b -\u003e a",
          "source": "src/Control-Lens-Lens.html#%5E%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-94--35-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:-94--35-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--35-\"]"
        },
        "index": {
          "description": "version of that works on ALens hello world world",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "(^#) ^#",
          "normalized": "a-\u003eALens a b c d-\u003ec",
          "package": "lens",
          "signature": "s-\u003eALens s t a b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:-94--35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ealongside\u003c/a\u003e\u003c/code\u003e makes a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e from two other lenses or a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e from two other getters\n by executing them on their respective halves of a product.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(Left a, Right b)^.alongside chosen chosen\n\u003c/code\u003e\u003c/strong\u003e(a,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(Left a, Right b) & alongside chosen chosen .~ (c,d)\n\u003c/code\u003e\u003c/strong\u003e(Left c,Right d)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ealongside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e   s t a b -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e   s' t' a' b' -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e   (s,s') (t,t') (a,a') (b,b')\n \u003ccode\u003e\u003ca\u003ealongside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s' t' a' b' -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e (s,s') (t,t') (a,a') (b,b')\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "alongside",
          "package": "lens",
          "signature": "LensLike (AlongsideLeft f b') s t a b -\u003e LensLike (AlongsideRight f t) s' t' a' b' -\u003e LensLike f (s, s') (t, t') (a, a') (b, b')",
          "source": "src/Control-Lens-Lens.html#alongside",
          "type": "function"
        },
        "index": {
          "description": "alongside makes Lens from two other lenses or Getter from two other getters by executing them on their respective halves of product Left Right alongside chosen chosen Left Right alongside chosen chosen Left Right alongside Lens Lens Lens alongside Getter Getter Getter",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "alongside",
          "normalized": "LensLike(AlongsideLeft a b)c d e f-\u003eLensLike(AlongsideRight a d)g h i b-\u003eLensLike a(c,g)(d,h)(e,i)(f,b)",
          "package": "lens",
          "signature": "LensLike(AlongsideLeft f b')s t a b-\u003eLensLike(AlongsideRight f t)s' t' a' b'-\u003eLensLike f(s,s')(t,t')(a,a')(b,b')",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:alongside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge two lenses, getters, setters, folds or traversals.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echosen\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s' a     -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e s s') a\n \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s' a       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e s s') a\n \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s' a      -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e s s') a\n \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s' a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e s s') a\n \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s' a    -\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e s s') a\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "choosing",
          "package": "lens",
          "signature": "LensLike f s t a b -\u003e LensLike f s' t' a b -\u003e LensLike f (Either s s') (Either t t') a b",
          "source": "src/Control-Lens-Lens.html#choosing",
          "type": "function"
        },
        "index": {
          "description": "Merge two lenses getters setters folds or traversals chosen choosing id id choosing Getter Getter Getter Either choosing Fold Fold Fold Either choosing Lens Lens Lens Either choosing Traversal Traversal Traversal Either choosing Setter Setter Setter Either",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "choosing",
          "normalized": "LensLike a b c d e-\u003eLensLike a f g d e-\u003eLensLike a(Either b f)(Either c g)d e",
          "package": "lens",
          "signature": "LensLike f s t a b-\u003eLensLike f s' t' a b-\u003eLensLike f(Either s s')(Either t t')a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:choosing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that updates either side of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e, where both sides have the same type.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echosen\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003echoosing\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft a^.chosen\n\u003c/code\u003e\u003c/strong\u003ea\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eRight a^.chosen\n\u003c/code\u003e\u003c/strong\u003ea\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eRight \"hello\"^.chosen\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eRight a & chosen *~ b\n\u003c/code\u003e\u003c/strong\u003eRight (a * b)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echosen\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a a) (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e b b) a b\n \u003ccode\u003e\u003ca\u003echosen\u003c/a\u003e\u003c/code\u003e f (\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e a)  = \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e f a\n \u003ccode\u003e\u003ca\u003echosen\u003c/a\u003e\u003c/code\u003e f (\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e a) = \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e f a\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "chosen",
          "package": "lens",
          "signature": "IndexPreservingLens (Either a a) (Either b b) a b",
          "source": "src/Control-Lens-Lens.html#chosen",
          "type": "function"
        },
        "index": {
          "description": "This is Lens that updates either side of an Either where both sides have the same type chosen choosing id id Left chosen Right chosen Right hello chosen hello Right chosen Right chosen Lens Either Either chosen Left Left chosen Right Right",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "chosen",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:chosen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e as an \u003ccode\u003eIndexedPreservingLens\u003c/code\u003e that just passes through whatever\n index is on any \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e or  \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e it is composed with.\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "cloneIndexPreservingLens",
          "package": "lens",
          "signature": "ALens s t a b -\u003e IndexPreservingLens s t a b",
          "source": "src/Control-Lens-Lens.html#cloneIndexPreservingLens",
          "type": "function"
        },
        "index": {
          "description": "Clone Lens as an IndexedPreservingLens that just passes through whatever index is on any IndexedLens IndexedFold IndexedGetter or IndexedTraversal it is composed with",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "cloneIndexPreservingLens",
          "normalized": "ALens a b c d-\u003eIndexPreservingLens a b c d",
          "package": "lens",
          "partial": "Index Preserving Lens",
          "signature": "ALens s t a b-\u003eIndexPreservingLens s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:cloneIndexPreservingLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e as an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e with the same index.\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "cloneIndexedLens",
          "package": "lens",
          "signature": "AnIndexedLens i s t a b -\u003e IndexedLens i s t a b",
          "source": "src/Control-Lens-Lens.html#cloneIndexedLens",
          "type": "function"
        },
        "index": {
          "description": "Clone an IndexedLens as an IndexedLens with the same index",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "cloneIndexedLens",
          "normalized": "AnIndexedLens a b c d e-\u003eIndexedLens a b c d e",
          "package": "lens",
          "partial": "Indexed Lens",
          "signature": "AnIndexedLens i s t a b-\u003eIndexedLens i s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:cloneIndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCloning a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is one way to make sure you aren't given\n something weaker, such as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e and can be\n used as a way to pass around lenses that have to be monomorphic in \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: This only accepts a proper \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet example l x = set (cloneLens l) (x^.cloneLens l + 1) x in example _2 (\"hello\",1,\"you\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",2,\"you\")\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\"]",
          "name": "cloneLens",
          "package": "lens",
          "signature": "ALens s t a b -\u003e Lens s t a b",
          "source": "src/Control-Lens-Lens.html#cloneLens",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:cloneLens\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:cloneLens\"]"
        },
        "index": {
          "description": "Cloning Lens is one way to make sure you aren given something weaker such as Traversal and can be used as way to pass around lenses that have to be monomorphic in Note This only accepts proper Lens let example set cloneLens cloneLens in example hello you hello you",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "cloneLens",
          "normalized": "ALens a b c d-\u003eLens a b c d",
          "package": "lens",
          "partial": "Lens",
          "signature": "ALens s t a b-\u003eLens s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:cloneLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThere is a field for every type in the \u003ccode\u003e\u003ca\u003eVoid\u003c/a\u003e\u003c/code\u003e. Very zen.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] & mapped.devoid +~ 1\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eNothing & mapped.devoid %~ abs\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edevoid\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eVoid\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "devoid",
          "package": "lens",
          "signature": "Over p f Void Void a b",
          "source": "src/Control-Lens-Lens.html#devoid",
          "type": "function"
        },
        "index": {
          "description": "There is field for every type in the Void Very zen mapped.devoid Nothing mapped.devoid abs Nothing devoid Lens Void",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "devoid",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:devoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e and\n a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "ilens",
          "package": "lens",
          "signature": "(s -\u003e (i, a)) -\u003e (s -\u003e b -\u003e t) -\u003e IndexedLens i s t a b",
          "source": "src/Control-Lens-Lens.html#ilens",
          "type": "function"
        },
        "index": {
          "description": "Build an IndexedLens from Getter and Setter",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "ilens",
          "normalized": "(a-\u003e(b,c))-\u003e(a-\u003ed-\u003ee)-\u003eIndexedLens b a e c d",
          "package": "lens",
          "signature": "(s-\u003e(i,a))-\u003e(s-\u003eb-\u003et)-\u003eIndexedLens i s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:ilens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e so it can run under a function (or other corepresentable profunctor).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003einside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (e -\u003e s) (e -\u003e t) (e -\u003e a) (e -\u003e b)\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "inside",
          "package": "lens",
          "signature": "ALens s t a b -\u003e Lens (p e s) (p e t) (p e a) (p e b)",
          "source": "src/Control-Lens-Lens.html#inside",
          "type": "function"
        },
        "index": {
          "description": "Lift Lens so it can run under function or other corepresentable profunctor inside Lens Lens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "inside",
          "normalized": "ALens a b c d-\u003eLens(e f a)(e f b)(e f c)(e f d)",
          "package": "lens",
          "signature": "ALens s t a b-\u003eLens(p e s)(p e t)(p e a)(p e b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:inside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an index-preserving \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e and a\n \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Lens",
          "name": "iplens",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e (s -\u003e b -\u003e t) -\u003e IndexPreservingLens s t a b",
          "source": "src/Control-Lens-Lens.html#iplens",
          "type": "function"
        },
        "index": {
          "description": "Build an index-preserving Lens from Getter and Setter",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "iplens",
          "normalized": "(a-\u003eb)-\u003e(a-\u003ec-\u003ed)-\u003eIndexPreservingLens a d b c",
          "package": "lens",
          "signature": "(s-\u003ea)-\u003e(s-\u003eb-\u003et)-\u003eIndexPreservingLens s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:iplens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e from a getter and a setter.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elens\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (s -\u003e a) -\u003e (s -\u003e b -\u003e t) -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003es ^. lens getter setter\n\u003c/code\u003e\u003c/strong\u003egetter s\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003es & lens getter setter .~ b\n\u003c/code\u003e\u003c/strong\u003esetter s b\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003es & lens getter setter %~ f\n\u003c/code\u003e\u003c/strong\u003esetter s (f (getter s))\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elens\u003c/a\u003e\u003c/code\u003e :: (s -\u003e a) -\u003e (s -\u003e a -\u003e s) -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "lens",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e (s -\u003e b -\u003e t) -\u003e Lens s t a b",
          "source": "src/Control-Lens-Lens.html#lens",
          "type": "function"
        },
        "index": {
          "description": "Build Lens from getter and setter lens Functor lens getter setter getter lens getter setter setter lens getter setter setter getter lens Lens",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "lens",
          "normalized": "(a-\u003eb)-\u003e(a-\u003ec-\u003ed)-\u003eLens a d b c",
          "package": "lens",
          "signature": "(s-\u003ea)-\u003e(s-\u003eb-\u003et)-\u003eLens s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:lens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e lets you \u003ccode\u003eview\u003c/code\u003e the current \u003ccode\u003epos\u003c/code\u003e of any indexed\n store comonad and \u003ccode\u003eseek\u003c/code\u003e to a new position. This reduces the API\n for working these instances to a single \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eipos\u003c/a\u003e\u003c/code\u003e w &#8801; w \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elocus\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiseek\u003c/a\u003e\u003c/code\u003e s w &#8801; w \u003ccode\u003e\u003ca\u003e&\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elocus\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e s\n \u003ccode\u003e\u003ca\u003eiseeks\u003c/a\u003e\u003c/code\u003e f w &#8801; w \u003ccode\u003e\u003ca\u003e&\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elocus\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elocus\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eContext'\u003c/a\u003e\u003c/code\u003e a s) a\n \u003ccode\u003e\u003ca\u003elocus\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e p a s) a\n \u003ccode\u003e\u003ca\u003elocus\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eConjoined\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ePretextT'\u003c/a\u003e\u003c/code\u003e p g a s) a\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "locus",
          "package": "lens",
          "signature": "Lens (p a c s) (p b c s) a b",
          "source": "src/Control-Lens-Lens.html#locus",
          "type": "function"
        },
        "index": {
          "description": "This Lens lets you view the current pos of any indexed store comonad and seek to new position This reduces the API for working these instances to single Lens ipos locus iseek locus iseeks locus locus Lens Context locus Conjoined Lens Pretext locus Conjoined Lens PretextT",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "locus",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:locus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e for Arrows.\n\u003c/p\u003e\u003cp\u003eUnlike \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eoverA\u003c/a\u003e\u003c/code\u003e can't accept a simple\n \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, but requires a full lens, or close\n enough.\n\u003c/p\u003e\u003cpre\u003e\n overA :: Arrow ar =\u003e Lens s t a b -\u003e ar a b -\u003e ar s t\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "overA",
          "package": "lens",
          "signature": "LensLike (Context a b) s t a b -\u003e ar a b -\u003e ar s t",
          "source": "src/Control-Lens-Lens.html#overA",
          "type": "function"
        },
        "index": {
          "description": "over for Arrows Unlike over overA can accept simple Setter but requires full lens or close enough overA Arrow ar Lens ar ar",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "overA",
          "normalized": "LensLike(Context a b)c d a b-\u003ee a b-\u003ee c d",
          "package": "lens",
          "signature": "LensLike(Context a b)s t a b-\u003ear a b-\u003ear s t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:overA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e that works on \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003estoring _2 \"world\" (\"hello\",\"there\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",\"world\")\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Lens\",\"Control.Lens.Loupe\"]",
          "name": "storing",
          "package": "lens",
          "signature": "ALens s t a b -\u003e b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Lens.html#storing",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:storing\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#v:storing\"]"
        },
        "index": {
          "description": "version of set that works on ALens storing world hello there hello world",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "storing",
          "normalized": "ALens a b c d-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ALens s t a b-\u003eb-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:storing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe can always retrieve a \u003ccode\u003e()\u003c/code\u003e from any type.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.united\n\u003c/code\u003e\u003c/strong\u003e()\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\" & united .~ ()\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Lens",
          "name": "united",
          "package": "lens",
          "signature": "Lens' a ()",
          "source": "src/Control-Lens-Lens.html#united",
          "type": "function"
        },
        "index": {
          "description": "We can always retrieve from any type hello united hello united hello",
          "hierarchy": "Control Lens Lens",
          "module": "Control.Lens.Lens",
          "name": "united",
          "normalized": "Lens' a()",
          "package": "lens",
          "signature": "Lens' a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:united"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides combinators for breadth-first searching within\n arbitrary traversals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Level",
          "name": "Level",
          "package": "lens",
          "source": "src/Control-Lens-Level.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides combinators for breadth-first searching within arbitrary traversals",
          "hierarchy": "Control Lens Level",
          "module": "Control.Lens.Level",
          "name": "Level",
          "package": "lens",
          "partial": "Level",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Level.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis data type represents a path-compressed copy of one level of a source\n data structure. We can safely use path-compression because we know the depth\n of the tree.\n\u003c/p\u003e\u003cp\u003ePath compression is performed by viewing a \u003ccode\u003e\u003ca\u003eLevel\u003c/a\u003e\u003c/code\u003e as a PATRICIA trie of the\n paths into the structure to leaves at a given depth, similar in many ways\n to a \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e, but unlike a regular PATRICIA trie we do not need\n to store the mask bits merely the depth of the fork.\n\u003c/p\u003e\u003cp\u003eOne invariant of this structure is that underneath a \u003ccode\u003e\u003ca\u003eTwo\u003c/a\u003e\u003c/code\u003e node you will not\n find any \u003ccode\u003e\u003ca\u003eZero\u003c/a\u003e\u003c/code\u003e nodes, so \u003ccode\u003e\u003ca\u003eZero\u003c/a\u003e\u003c/code\u003e can only occur at the root.\n\u003c/p\u003e",
          "module": "Control.Lens.Level",
          "name": "Level",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Level.html#Level",
          "type": "data"
        },
        "index": {
          "description": "This data type represents path-compressed copy of one level of source data structure We can safely use path-compression because we know the depth of the tree Path compression is performed by viewing Level as PATRICIA trie of the paths into the structure to leaves at given depth similar in many ways to IntMap but unlike regular PATRICIA trie we do not need to store the mask bits merely the depth of the fork One invariant of this structure is that underneath Two node you will not find any Zero nodes so Zero can only occur at the root",
          "hierarchy": "Control Lens Level",
          "module": "Control.Lens.Level",
          "name": "Level",
          "package": "lens",
          "partial": "Level",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Level.html#t:Level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis provides a breadth-first \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the individual levels of any other \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n via iterative deepening depth-first search. The levels are returned to you in a compressed format.\n\u003c/p\u003e\u003cp\u003eThis is similar to \u003ccode\u003e\u003ca\u003elevels\u003c/a\u003e\u003c/code\u003e, but retains the index of the original \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e, so you can\n access it when traversing the levels later on.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"dog\",\"cat\"]^@..ilevels (traversed\u003c.\u003etraversed).itraversed\n\u003c/code\u003e\u003c/strong\u003e[((0,0),'d'),((0,1),'o'),((1,0),'c'),((0,2),'g'),((1,1),'a'),((1,2),'t')]\n\u003c/pre\u003e\u003cp\u003eThe resulting \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the levels which is indexed by the depth of each \u003ccode\u003e\u003ca\u003eLevel\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"dog\",\"cat\"]^@..ilevels (traversed\u003c.\u003etraversed)\u003c.\u003eitraversed\n\u003c/code\u003e\u003c/strong\u003e[((2,(0,0)),'d'),((3,(0,1)),'o'),((3,(1,0)),'c'),((4,(0,2)),'g'),((4,(1,1)),'a'),((5,(1,2)),'t')]\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e Internally this is implemented by using an illegal \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e, as it extracts information\n in an order that violates the \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e",
          "module": "Control.Lens.Level",
          "name": "ilevels",
          "package": "lens",
          "signature": "AnIndexedTraversal i s t a b -\u003e IndexedTraversal Int s t (Level i a) (Level j b)",
          "source": "src/Control-Lens-Level.html#ilevels",
          "type": "function"
        },
        "index": {
          "description": "This provides breadth-first Traversal of the individual levels of any other Traversal via iterative deepening depth-first search The levels are returned to you in compressed format This is similar to levels but retains the index of the original IndexedTraversal so you can access it when traversing the levels later on dog cat ilevels traversed traversed itraversed The resulting Traversal of the levels which is indexed by the depth of each Level dog cat ilevels traversed traversed itraversed Note Internally this is implemented by using an illegal Applicative as it extracts information in an order that violates the Applicative laws",
          "hierarchy": "Control Lens Level",
          "module": "Control.Lens.Level",
          "name": "ilevels",
          "normalized": "AnIndexedTraversal a b c d e-\u003eIndexedTraversal Int b c(Level a d)(Level f e)",
          "package": "lens",
          "signature": "AnIndexedTraversal i s t a b-\u003eIndexedTraversal Int s t(Level i a)(Level j b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Level.html#v:ilevels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis provides a breadth-first \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the individual \u003ccode\u003e\u003ca\u003elevels\u003c/a\u003e\u003c/code\u003e of any other \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n via iterative deepening depth-first search. The levels are returned to you in a compressed format.\n\u003c/p\u003e\u003cp\u003eThis can permit us to extract the \u003ccode\u003e\u003ca\u003elevels\u003c/a\u003e\u003c/code\u003e directly:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"world\"]^..levels (traverse.traverse)\n\u003c/code\u003e\u003c/strong\u003e[Zero,Zero,One () 'h',Two 0 (One () 'e') (One () 'w'),Two 0 (One () 'l') (One () 'o'),Two 0 (One () 'l') (One () 'r'),Two 0 (One () 'o') (One () 'l'),One () 'd']\n\u003c/pre\u003e\u003cp\u003eBut we can also traverse them in turn:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"world\"]^..levels (traverse.traverse).traverse\n\u003c/code\u003e\u003c/strong\u003e\"hewlolrold\"\n\u003c/pre\u003e\u003cp\u003eWe can use this to traverse to a fixed depth in the tree of (\u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e) used in the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"world\"] & taking 4 (levels (traverse.traverse)).traverse %~ toUpper\n\u003c/code\u003e\u003c/strong\u003e[\"HEllo\",\"World\"]\n\u003c/pre\u003e\u003cp\u003eOr we can use it to traverse the first \u003ccode\u003en\u003c/code\u003e elements in found in that \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e regardless of the depth\n at which they were found.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"hello\",\"world\"] & taking 4 (levels (traverse.traverse).traverse) %~ toUpper\n\u003c/code\u003e\u003c/strong\u003e[\"HELlo\",\"World\"]\n\u003c/pre\u003e\u003cp\u003eThe resulting \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the \u003ccode\u003e\u003ca\u003elevels\u003c/a\u003e\u003c/code\u003e which is indexed by the depth of each \u003ccode\u003e\u003ca\u003eLevel\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[\"dog\",\"cat\"]^@..levels (traverse.traverse) \u003c. traverse\n\u003c/code\u003e\u003c/strong\u003e[(2,'d'),(3,'o'),(3,'c'),(4,'g'),(4,'a'),(5,'t')]\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e Internally this is implemented by using an illegal \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e, as it extracts information\n in an order that violates the \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e",
          "module": "Control.Lens.Level",
          "name": "levels",
          "package": "lens",
          "signature": "ATraversal s t a b -\u003e IndexedTraversal Int s t (Level () a) (Level () b)",
          "source": "src/Control-Lens-Level.html#levels",
          "type": "function"
        },
        "index": {
          "description": "This provides breadth-first Traversal of the individual levels of any other Traversal via iterative deepening depth-first search The levels are returned to you in compressed format This can permit us to extract the levels directly hello world levels traverse.traverse Zero Zero One Two One One Two One One Two One One Two One One One But we can also traverse them in turn hello world levels traverse.traverse traverse hewlolrold We can use this to traverse to fixed depth in the tree of used in the Traversal hello world taking levels traverse.traverse traverse toUpper HEllo World Or we can use it to traverse the first elements in found in that Traversal regardless of the depth at which they were found hello world taking levels traverse.traverse traverse toUpper HELlo World The resulting Traversal of the levels which is indexed by the depth of each Level dog cat levels traverse.traverse traverse Note Internally this is implemented by using an illegal Applicative as it extracts information in an order that violates the Applicative laws",
          "hierarchy": "Control Lens Level",
          "module": "Control.Lens.Level",
          "name": "levels",
          "normalized": "ATraversal a b c d-\u003eIndexedTraversal Int a b(Level()c)(Level()d)",
          "package": "lens",
          "signature": "ATraversal s t a b-\u003eIndexedTraversal Int s t(Level()a)(Level()b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Level.html#v:levels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports a minimalist API for working with lenses in highly\n monomorphic settings.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Loupe",
          "name": "Loupe",
          "package": "lens",
          "source": "src/Control-Lens-Loupe.html",
          "type": "module"
        },
        "index": {
          "description": "This module exports minimalist API for working with lenses in highly monomorphic settings",
          "hierarchy": "Control Lens Loupe",
          "module": "Control.Lens.Loupe",
          "name": "Loupe",
          "package": "lens",
          "partial": "Loupe",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis type can also be used when you need to store a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e in a container,\n since it is rank-1. You can turn them back into a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003ecloneLens\u003c/a\u003e\u003c/code\u003e,\n or use it directly with combinators like \u003ccode\u003e\u003ca\u003estoring\u003c/a\u003e\u003c/code\u003e and (\u003ccode\u003e\u003ca\u003e^#\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Lens.Loupe",
          "name": "ALens",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html#ALens",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects Lens This type can also be used when you need to store Lens in container since it is rank-1 You can turn them back into Lens with cloneLens or use it directly with combinators like storing and",
          "hierarchy": "Control Lens Loupe",
          "module": "Control.Lens.Loupe",
          "name": "ALens",
          "package": "lens",
          "partial": "ALens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#t:ALens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eALens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Loupe",
          "name": "ALens'",
          "package": "lens",
          "source": "src/Control-Lens-Lens.html#ALens%27",
          "type": "type"
        },
        "index": {
          "description": "type ALens Simple ALens",
          "hierarchy": "Control Lens Loupe",
          "module": "Control.Lens.Loupe",
          "name": "ALens'",
          "package": "lens",
          "partial": "ALens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#t:ALens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use ALens\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis is an older alias for a type-restricted form of lens that is able to be passed around\n in containers monomorphically.\n\u003c/p\u003e\u003cp\u003eDeprecated. This has since been renamed to \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e for consistency.\n\u003c/p\u003e",
          "module": "Control.Lens.Loupe",
          "name": "Loupe",
          "package": "lens",
          "source": "src/Control-Lens-Loupe.html#Loupe",
          "type": "type"
        },
        "index": {
          "description": "Deprecated use ALens This is an older alias for type-restricted form of lens that is able to be passed around in containers monomorphically Deprecated This has since been renamed to ALens for consistency",
          "hierarchy": "Control Lens Loupe",
          "module": "Control.Lens.Loupe",
          "name": "Loupe",
          "package": "lens",
          "partial": "Loupe",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#t:Loupe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use ALens'\n\u003c/p\u003e\u003c/div\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eSimpleLoupe\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLoupe\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eDeprecated for two reasons. \u003ccode\u003e\u003ca\u003eLoupe\u003c/a\u003e\u003c/code\u003e is now \u003ccode\u003e\u003ca\u003eALens\u003c/a\u003e\u003c/code\u003e, and we no longer use the verbose \u003ccode\u003eSimpleFoo\u003c/code\u003e naming\n convention, this has since been renamed to \u003ccode\u003e\u003ca\u003eALens'\u003c/a\u003e\u003c/code\u003e for consistency.\n\u003c/p\u003e",
          "module": "Control.Lens.Loupe",
          "name": "SimpleLoupe",
          "package": "lens",
          "source": "src/Control-Lens-Loupe.html#SimpleLoupe",
          "type": "type"
        },
        "index": {
          "description": "Deprecated use ALens type SimpleLoupe Simple Loupe Deprecated for two reasons Loupe is now ALens and we no longer use the verbose SimpleFoo naming convention this has since been renamed to ALens for consistency",
          "hierarchy": "Control Lens Loupe",
          "module": "Control.Lens.Loupe",
          "name": "SimpleLoupe",
          "package": "lens",
          "partial": "Simple Loupe",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Loupe.html#t:SimpleLoupe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exists for users who like to work with qualified imports\n but want access to the operators from Lens.\n\u003c/p\u003e\u003cpre\u003e import qualified Control.Lens as L\n import Control.Lens.Operators\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Control.Lens.Operators",
          "name": "Operators",
          "package": "lens",
          "source": "src/Control-Lens-Operators.html",
          "type": "module"
        },
        "index": {
          "description": "This module exists for users who like to work with qualified imports but want access to the operators from Lens import qualified Control.Lens as import Control.Lens.Operators",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "Operators",
          "package": "lens",
          "partial": "Operators",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogically \u003ccode\u003e\u003ca\u003e||\u003c/a\u003e\u003c/code\u003e the target(s) of a \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e-valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth ||~ True $ (False,True)\n\u003c/code\u003e\u003c/strong\u003e(True,True)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth ||~ False $ (False,True)\n\u003c/code\u003e\u003c/strong\u003e(False,True)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e||~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e    -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e||~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e||~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e      -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e||~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(||~)",
          "package": "lens",
          "signature": "ASetter s t Bool Bool -\u003e Bool -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%7C%7C~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-124--124--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-124--124--126-\"]"
        },
        "index": {
          "description": "Logically the target of Bool valued Lens or Setter both True False True True True both False False True False True Setter Bool Bool Iso Bool Bool Lens Bool Bool Traversal Bool Bool",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(||~) ||~",
          "normalized": "ASetter a b Bool Bool-\u003eBool-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t Bool Bool-\u003eBool-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-124--124--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, 'Iso, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by taking their logical \u003ccode\u003e\u003ca\u003e||\u003c/a\u003e\u003c/code\u003e with a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 ||= True; _2 ||= False; _3 ||= True; _4 ||= False) (True,True,False,False)\n\u003c/code\u003e\u003c/strong\u003e(True,True,True,False)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e||=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e    -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e||=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e||=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e      -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e||=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(||=)",
          "package": "lens",
          "signature": "ASetter' s Bool -\u003e Bool -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%7C%7C%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-124--124--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-124--124--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by taking their logical with value execState do True False True False True True False False True True True False MonadState Setter Bool Bool MonadState Iso Bool Bool MonadState Lens Bool Bool MonadState Traversal Bool Bool",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(||=) ||=",
          "normalized": "ASetter' a Bool-\u003eBool-\u003eb()",
          "package": "lens",
          "signature": "ASetter' s Bool-\u003eBool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-124--124--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn infix alias for \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e f # x &#8801; f x\n l # x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e l\n\u003c/pre\u003e\u003cp\u003eThis is commonly used when using a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e as a smart constructor.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_Left # 4\n\u003c/code\u003e\u003c/strong\u003eLeft 4\n\u003c/pre\u003e\u003cp\u003eBut it can be used for any \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebase 16 # 123\n\u003c/code\u003e\u003c/strong\u003e\"7b\"\n\u003c/pre\u003e\u003cpre\u003e\n (#) :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e      s a -\u003e a -\u003e s\n (#) :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e    s a -\u003e a -\u003e s\n (#) :: \u003ccode\u003e\u003ca\u003eReview'\u003c/a\u003e\u003c/code\u003e   s a -\u003e a -\u003e s\n (#) :: \u003ccode\u003e\u003ca\u003eEquality'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Review\"]",
          "name": "(#)",
          "package": "lens",
          "signature": "AReview s t a b -\u003e b -\u003e t",
          "source": "src/Control-Lens-Review.html#%23",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:-35-\"]"
        },
        "index": {
          "description": "An infix alias for review unto re This is commonly used when using Prism as smart constructor Left Left But it can be used for any Prism base Iso Prism Review Equality",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(#) #",
          "normalized": "AReview a b c d-\u003ed-\u003eb",
          "package": "lens",
          "signature": "AReview s t a b-\u003eb-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModifies the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e with a user supplied function.\n\u003c/p\u003e\u003cp\u003eThis is an infix version of \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n \u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c) & _3 %~ f\n\u003c/code\u003e\u003c/strong\u003e(a,b,f c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both %~ f\n\u003c/code\u003e\u003c/strong\u003e(f a,f b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 %~ length $ (1,\"hello\")\n\u003c/code\u003e\u003c/strong\u003e(1,5)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverse %~ f $ [a,b,c]\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverse %~ even $ [1,2,3]\n\u003c/code\u003e\u003c/strong\u003e[False,True,False]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverse.traverse %~ length $ [[\"hello\",\"world\"],[\"!!!\"]]\n\u003c/code\u003e\u003c/strong\u003e[[5,5],[3]]\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e (a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e b) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(%~)",
          "package": "lens",
          "signature": "Setting p s t a b -\u003e p a b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%25~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-37--126-\"]"
        },
        "index": {
          "description": "Modifies the target of Lens or all of the targets of Setter or Traversal with user supplied function This is an infix version of over fmap mapped fmapDefault traverse both length hello traverse traverse even False True False traverse.traverse length hello world Setter Iso Lens Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(%~) %~",
          "normalized": "Setting a b c d e-\u003ea d e-\u003eb-\u003ec",
          "package": "lens",
          "signature": "Setting p s t a b-\u003ep a b-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap over the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in our monadic state.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 %= f;_2 %= g) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,g b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do both %= f) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,f b)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e a) -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e a) -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a) -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e (a -\u003e a) -\u003e m ()\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eASetter\u003c/a\u003e\u003c/code\u003e s s a b -\u003e (a -\u003e b) -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(%=)",
          "package": "lens",
          "signature": "Setting p s s a b -\u003e p a b -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%25%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-37--61-\"]"
        },
        "index": {
          "description": "Map over the target of Lens or all of the targets of Setter or Traversal in our monadic state execState do execState do both MonadState Iso MonadState Lens MonadState Traversal MonadState Setter MonadState ASetter",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(%=) %=",
          "normalized": "Setting a b b c d-\u003ea c d-\u003ee()",
          "package": "lens",
          "signature": "Setting p s s a b-\u003ep a b-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust every target of an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n with access to the index.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eimapOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eWhen you do not need access to the index then (\u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e) is more liberal in what it can accept.\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f &#8801; l \u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e i s t a b    -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e%@~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(%@~)",
          "package": "lens",
          "signature": "AnIndexedSetter i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%25%40~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--64--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-37--64--126-\"]"
        },
        "index": {
          "description": "Adjust every target of an IndexedSetter IndexedLens or IndexedTraversal with access to the index imapOf When you do not need access to the index then is more liberal in what it can accept const IndexedSetter IndexedLens IndexedTraversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(%@~) %@~",
          "normalized": "AnIndexedSetter a b c d e-\u003e(a-\u003ed-\u003ee)-\u003eb-\u003ec",
          "package": "lens",
          "signature": "AnIndexedSetter i s t a b-\u003e(i-\u003ea-\u003eb)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--64--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjust every target in the current state of an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n with access to the index.\n\u003c/p\u003e\u003cp\u003eWhen you do not need access to the index then (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e) is more liberal in what it can accept.\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e f &#8801; l \u003ccode\u003e\u003ca\u003e%@=\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e%@=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e i s s a b    -\u003e (i -\u003e a -\u003e b) -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e%@=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s s a b      -\u003e (i -\u003e a -\u003e b) -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e%@=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(%@=)",
          "package": "lens",
          "signature": "AnIndexedSetter i s s a b -\u003e (i -\u003e a -\u003e b) -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%25%40%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--64--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-37--64--61-\"]"
        },
        "index": {
          "description": "Adjust every target in the current state of an IndexedSetter IndexedLens or IndexedTraversal with access to the index When you do not need access to the index then is more liberal in what it can accept const MonadState IndexedSetter MonadState IndexedLens MonadState IndexedTraversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(%@=) %@=",
          "normalized": "AnIndexedSetter a b b c d-\u003e(a-\u003ec-\u003ed)-\u003ee()",
          "package": "lens",
          "signature": "AnIndexedSetter i s s a b-\u003e(i-\u003ea-\u003eb)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-37--64--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLogically \u003ccode\u003e\u003ca\u003e&&\u003c/a\u003e\u003c/code\u003e the target(s) of a \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e-valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth &&~ True $ (False, True)\n\u003c/code\u003e\u003c/strong\u003e(False,True)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth &&~ False $ (False, True)\n\u003c/code\u003e\u003c/strong\u003e(False,False)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e&&~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e    -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e&&~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e&&~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e      -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e&&~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(&&~)",
          "package": "lens",
          "signature": "ASetter s t Bool Bool -\u003e Bool -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%26%26~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-38--38--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-38--38--126-\"]"
        },
        "index": {
          "description": "Logically the target of Bool valued Lens or Setter both True False True False True both False False True False False Setter Bool Bool Iso Bool Bool Lens Bool Bool Traversal Bool Bool",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(&&~) &&~",
          "normalized": "ASetter a b Bool Bool-\u003eBool-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t Bool Bool-\u003eBool-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-38--38--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by taking their logical \u003ccode\u003e\u003ca\u003e&&\u003c/a\u003e\u003c/code\u003e with a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 &&= True; _2 &&= False; _3 &&= True; _4 &&= False) (True,True,False,False)\n\u003c/code\u003e\u003c/strong\u003e(True,False,False,False)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e&&=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e    -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e&&=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e       -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e&&=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e      -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e&&=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(&&=)",
          "package": "lens",
          "signature": "ASetter' s Bool -\u003e Bool -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%26%26%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-38--38--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-38--38--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by taking their logical with value execState do True False True False True True False False True False False False MonadState Setter Bool Bool MonadState Iso Bool Bool MonadState Lens Bool Bool MonadState Traversal Bool Bool",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(&&=) &&=",
          "normalized": "ASetter' a Bool-\u003eBool-\u003eb()",
          "package": "lens",
          "signature": "ASetter' s Bool-\u003eBool-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-38--38--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMultiply the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & _1 *~ c\n\u003c/code\u003e\u003c/strong\u003e(a * c,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both *~ c\n\u003c/code\u003e\u003c/strong\u003e(a * c,b * c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2) & _2 *~ 4\n\u003c/code\u003e\u003c/strong\u003e(1,8)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eJust 24 & mapped *~ 2\n\u003c/code\u003e\u003c/strong\u003eJust 48\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e*~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e*~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e*~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e*~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(*~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%2A~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-42--126-\"]"
        },
        "index": {
          "description": "Multiply the target of numerically valued Lens Iso Setter or Traversal both Just mapped Just Num Setter Num Iso Num Lens Num Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(*~) *~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target(s) of a floating-point valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to an arbitrary power.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & _1 **~ c\n\u003c/code\u003e\u003c/strong\u003e(a**c,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both **~ c\n\u003c/code\u003e\u003c/strong\u003e(a**c,b**c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 **~ 10 $ (3,2)\n\u003c/code\u003e\u003c/strong\u003e(3,1024.0)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e**~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e**~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e**~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e**~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(**~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%2A%2A~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--42--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-42--42--126-\"]"
        },
        "index": {
          "description": "Raise the target of floating-point valued Lens Setter or Traversal to an arbitrary power both Floating Setter Floating Iso Floating Lens Floating Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(**~) **~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--42--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to an arbitrary power\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 **= c; _2 **= d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(a**c,b**d)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e**=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e**=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e**=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e**=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFloating\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(**=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%2A%2A%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--42--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-42--42--61-\"]"
        },
        "index": {
          "description": "Raise the target of numerically valued Lens Setter or Traversal to an arbitrary power execState do MonadState Floating Setter MonadState Floating Iso MonadState Floating Lens MonadState Floating Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(**=) **=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by multiplying by value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 *= c; _2 *= d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(a * c,b * d)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e*=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e*=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e*=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e*=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(*=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%2A%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-42--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by multiplying by value execState do MonadState Num Setter MonadState Num Iso MonadState Num Lens MonadState Num Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(*=) *=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-42--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & _1 +~ c\n\u003c/code\u003e\u003c/strong\u003e(a + c,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both +~ c\n\u003c/code\u003e\u003c/strong\u003e(a + c,b + c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2) & _2 +~ 1\n\u003c/code\u003e\u003c/strong\u003e(1,3)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[(a,b),(c,d)] & traverse.both +~ e\n\u003c/code\u003e\u003c/strong\u003e[(a + e,b + e),(c + e,d + e)]\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e+~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e+~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e+~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e+~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(+~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%2B~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-43--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-43--126-\"]"
        },
        "index": {
          "description": "Increment the target of numerically valued Lens Setter or Traversal both traverse.both Num Setter Num Iso Num Lens Num Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(+~) +~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-43--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by adding a value.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003efresh\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e m =\u003e m \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003efresh\u003c/code\u003e = do\n   \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e 1\n   \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 += c; _2 += d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(a + c,b + d)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1.at 1.non 0 += 10) (Map.fromList [(2,100)],\"hello\")\n\u003c/code\u003e\u003c/strong\u003e(fromList [(1,10),(2,100)],\"hello\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e+=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(+=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%2B%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-43--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-43--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by adding value Example fresh MonadState Int Int fresh do id use id execState do execState do at non Map.fromList hello fromList hello MonadState Num Setter MonadState Num Iso MonadState Num Lens MonadState Num Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(+=) +=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-43--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrement the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & _1 -~ c\n\u003c/code\u003e\u003c/strong\u003e(a - c,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both -~ c\n\u003c/code\u003e\u003c/strong\u003e(a - c,b - c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_1 -~ 2 $ (1,2)\n\u003c/code\u003e\u003c/strong\u003e(-1,2)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapped.mapped -~ 1 $ [[4,5],[6,7]]\n\u003c/code\u003e\u003c/strong\u003e[[3,4],[5,6]]\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e-~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e-~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e-~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e-~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(-~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#-~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-45--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-45--126-\"]"
        },
        "index": {
          "description": "Decrement the target of numerically valued Lens Iso Setter or Traversal both mapped.mapped Num Setter Num Iso Num Lens Num Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(-~) -~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-45--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by subtracting a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 -= c; _2 -= d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(a - c,b - d)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e-=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e-=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e-=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e-=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(-=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#-%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-45--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-45--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by subtracting value execState do MonadState Num Setter MonadState Num Iso MonadState Num Lens MonadState Num Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(-=) -=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-45--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivide the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & _1 //~ c\n\u003c/code\u003e\u003c/strong\u003e(a / c,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both //~ c\n\u003c/code\u003e\u003c/strong\u003e(a / c,b / c)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"Hawaii\",10) & _2 //~ 2\n\u003c/code\u003e\u003c/strong\u003e(\"Hawaii\",5.0)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e//~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e//~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e//~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e//~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(//~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%2F%2F~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-47--47--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-47--47--126-\"]"
        },
        "index": {
          "description": "Divide the target of numerically valued Lens Iso Setter or Traversal both Hawaii Hawaii Fractional Setter Fractional Iso Fractional Lens Fractional Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(//~) //~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-47--47--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by dividing by a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 //= c; _2 //= d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(a / c,b / d)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e//=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e//=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e//=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e//=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(//=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%2F%2F%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-47--47--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-47--47--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by dividing by value execState do MonadState Fractional Setter MonadState Fractional Iso MonadState Fractional Lens MonadState Fractional Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(//=) //=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-47--47--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a monadic action, and set all of the targets of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to its result.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s s a b       -\u003e m b -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s s a b      -\u003e m b -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s s a b -\u003e m b -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s s a b    -\u003e m b -\u003e m ()\n\u003c/pre\u003e\u003cp\u003eAs a reasonable mnemonic, this lets you store the result of a monadic action in a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e rather than\n in a local variable.\n\u003c/p\u003e\u003cpre\u003e\n do foo \u003c- bar\n    ...\n\u003c/pre\u003e\u003cp\u003ewill store the result in a variable, while\n\u003c/p\u003e\u003cpre\u003e\n do foo \u003ccode\u003e\u003ca\u003e\u003c~\u003c/a\u003e\u003c/code\u003e bar\n    ...\n\u003c/pre\u003e\u003cp\u003ewill store the result in a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c~)",
          "package": "lens",
          "signature": "ASetter s s a b -\u003e m b -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%3C~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60--126-\"]"
        },
        "index": {
          "description": "Run monadic action and set all of the targets of Lens Setter or Traversal to its result MonadState Iso MonadState Lens MonadState Traversal MonadState Setter As reasonable mnemonic this lets you store the result of monadic action in Lens rather than in local variable do foo bar will store the result in variable while do foo bar will store the result in Lens Setter or Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c~) \u003c~",
          "normalized": "ASetter a a b c-\u003ed c-\u003ed()",
          "package": "lens",
          "signature": "ASetter s s a b-\u003em b-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a monoidally valued by \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003eing another value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(Sum a,b) & _1 \u003c\u003e~ Sum c\n\u003c/code\u003e\u003c/strong\u003e(Sum {getSum = a + c},b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(Sum a,Sum b) & both \u003c\u003e~ Sum c\n\u003c/code\u003e\u003c/strong\u003e(Sum {getSum = a + c},Sum {getSum = b + c})\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth \u003c\u003e~ \"!!!\" $ (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello!!!\",\"world!!!\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a a    -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a a       -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a      -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e a -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c\u003e~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%3C%3E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--62--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60--62--126-\"]"
        },
        "index": {
          "description": "Modify the target of monoidally valued by mappend ing another value Sum Sum Sum getSum Sum Sum both Sum Sum getSum Sum getSum both hello world hello world Monoid Setter Monoid Iso Monoid Lens Monoid Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c\u003e~) \u003c\u003e~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by \u003ccode\u003e\u003ca\u003emappend\u003c/a\u003e\u003c/code\u003eing a value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 \u003c\u003e= Sum c; _2 \u003c\u003e= Product d) (Sum a,Product b)\n\u003c/code\u003e\u003c/strong\u003e(Sum {getSum = a + c},Product {getProduct = b * d})\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (both \u003c\u003e= \"!!!\") (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello!!!\",\"world!!!\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c\u003e=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c\u003e=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%3C%3E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--62--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60--62--61-\"]"
        },
        "index": {
          "description": "Modify the target of Lens Iso Setter or Traversal by mappend ing value execState do Sum Product Sum Product Sum getSum Product getProduct execState both hello world hello world MonadState Monoid Setter MonadState Monoid Iso MonadState Monoid Lens MonadState Monoid Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c\u003e=) \u003c\u003e=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet to \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a value with pass-through.\n\u003c/p\u003e\u003cp\u003eThis is mostly present for consistency, but may be useful for for chaining assignments.\n\u003c/p\u003e\u003cp\u003eIf you do not need a copy of the intermediate result, then using \u003ccode\u003el \u003ccode\u003e\u003ca\u003e?~\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e directly is a good idea.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimport Data.Map as Map\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2.at \"hello\" \u003c?~ \"world\" $ (42,Map.fromList [(\"goodnight\",\"gracie\")])\n\u003c/code\u003e\u003c/strong\u003e(\"world\",(42,fromList [(\"goodnight\",\"gracie\"),(\"hello\",\"world\")]))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)    -\u003e b -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)       -\u003e b -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)      -\u003e b -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b) -\u003e b -\u003e s -\u003e (b, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c?~)",
          "package": "lens",
          "signature": "ASetter s t a (Maybe b) -\u003e b -\u003e s -\u003e (b, t)",
          "source": "src/Control-Lens-Setter.html#%3C%3F~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--63--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60--63--126-\"]"
        },
        "index": {
          "description": "Set to Just value with pass-through This is mostly present for consistency but may be useful for for chaining assignments If you do not need copy of the intermediate result then using directly is good idea import Data.Map as Map at hello world Map.fromList goodnight gracie world fromList goodnight gracie hello world Setter Maybe Iso Maybe Lens Maybe Traversal Maybe",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c?~) \u003c?~",
          "normalized": "ASetter a b c(Maybe d)-\u003ed-\u003ea-\u003e(d,b)",
          "package": "lens",
          "signature": "ASetter s t a(Maybe b)-\u003eb-\u003es-\u003e(b,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--63--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a value with pass-through\n\u003c/p\u003e\u003cp\u003eThis is useful for chaining assignment without round-tripping through your \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e stack.\n\u003c/p\u003e\u003cpre\u003e\n do x \u003c- \u003ccode\u003e\u003ca\u003eat\u003c/a\u003e\u003c/code\u003e \u003ca\u003efoo\u003c/a\u003e \u003ccode\u003e\u003ca\u003e\u003c?=\u003c/a\u003e\u003c/code\u003e ninety_nine_bottles_of_beer_on_the_wall\n\u003c/pre\u003e\u003cp\u003eIf you do not need a copy of the intermediate result, then using \u003ccode\u003el \u003ccode\u003e\u003ca\u003e?=\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e will avoid unused binding warnings.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s s a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)    -\u003e b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s s a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)       -\u003e b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s s a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)      -\u003e b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s s a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b) -\u003e b -\u003e m b\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c?=)",
          "package": "lens",
          "signature": "ASetter s s a (Maybe b) -\u003e b -\u003e m b",
          "source": "src/Control-Lens-Setter.html#%3C%3F%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--63--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60--63--61-\"]"
        },
        "index": {
          "description": "Set Just value with pass-through This is useful for chaining assignment without round-tripping through your Monad stack do at foo ninety nine bottles of beer on the wall If you do not need copy of the intermediate result then using will avoid unused binding warnings MonadState Setter Maybe MonadState Iso Maybe MonadState Lens Maybe MonadState Traversal Maybe",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c?=) \u003c?=",
          "normalized": "ASetter a a b(Maybe c)-\u003ec-\u003ed c",
          "package": "lens",
          "signature": "ASetter s s a(Maybe b)-\u003eb-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60--63--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet with pass-through.\n\u003c/p\u003e\u003cp\u003eThis is mostly present for consistency, but may be useful for for chaining assignments.\n\u003c/p\u003e\u003cp\u003eIf you do not need a copy of the intermediate result, then using \u003ccode\u003el \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e t\u003c/code\u003e directly is a good idea.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & _1 \u003c.~ c\n\u003c/code\u003e\u003c/strong\u003e(c,(c,b))\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"good\",\"morning\",\"vietnam\") & _3 \u003c.~ \"world\"\n\u003c/code\u003e\u003c/strong\u003e(\"world\",(\"good\",\"morning\",\"world\"))\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(42,Map.fromList [(\"goodnight\",\"gracie\")]) & _2.at \"hello\" \u003c.~ Just \"world\"\n\u003c/code\u003e\u003c/strong\u003e(Just \"world\",(42,fromList [(\"goodnight\",\"gracie\"),(\"hello\",\"world\")]))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e b -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e b -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e b -\u003e s -\u003e (b, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e b -\u003e s -\u003e (b, t)\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c.~)",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e b -\u003e s -\u003e (b, t)",
          "source": "src/Control-Lens-Setter.html#%3C.~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60-.-126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60-.-126-\"]"
        },
        "index": {
          "description": "Set with pass-through This is mostly present for consistency but may be useful for for chaining assignments If you do not need copy of the intermediate result then using directly is good idea good morning vietnam world world good morning world Map.fromList goodnight gracie at hello Just world Just world fromList goodnight gracie hello world Setter Iso Lens Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c.~) \u003c.~",
          "normalized": "ASetter a b c d-\u003ed-\u003ea-\u003e(d,b)",
          "package": "lens",
          "signature": "ASetter s t a b-\u003eb-\u003es-\u003e(b,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet with pass-through\n\u003c/p\u003e\u003cp\u003eThis is useful for chaining assignment without round-tripping through your \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e stack.\n\u003c/p\u003e\u003cpre\u003e\n do x \u003c- \u003ccode\u003e\u003ca\u003e_2\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e\u003c.=\u003c/a\u003e\u003c/code\u003e ninety_nine_bottles_of_beer_on_the_wall\n\u003c/pre\u003e\u003cp\u003eIf you do not need a copy of the intermediate result, then using \u003ccode\u003el \u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e d\u003c/code\u003e will avoid unused binding warnings.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s s a b    -\u003e b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s s a b       -\u003e b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s s a b      -\u003e b -\u003e m b\n (\u003ccode\u003e\u003ca\u003e\u003c.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s s a b -\u003e b -\u003e m b\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(\u003c.=)",
          "package": "lens",
          "signature": "ASetter s s a b -\u003e b -\u003e m b",
          "source": "src/Control-Lens-Setter.html#%3C.%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60-.-61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-60-.-61-\"]"
        },
        "index": {
          "description": "Set with pass-through This is useful for chaining assignment without round-tripping through your Monad stack do ninety nine bottles of beer on the wall If you do not need copy of the intermediate result then using will avoid unused binding warnings MonadState Setter MonadState Iso MonadState Lens MonadState Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(\u003c.=) \u003c.=",
          "normalized": "ASetter a a b c-\u003ec-\u003ed c",
          "package": "lens",
          "signature": "ASetter s s a b-\u003eb-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-60-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a value.\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003e?~\u003c/a\u003e\u003c/code\u003e t &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e t)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eNothing & id ?~ a\n\u003c/code\u003e\u003c/strong\u003eJust a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.empty & at 3 ?~ x\n\u003c/code\u003e\u003c/strong\u003efromList [(3,x)]\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)    -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)       -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b)      -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e?~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e b) -\u003e b -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(?~)",
          "package": "lens",
          "signature": "ASetter s t a (Maybe b) -\u003e b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%3F~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-63--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-63--126-\"]"
        },
        "index": {
          "description": "Set the target of Lens Traversal or Setter to Just value set Just Nothing id Just Map.empty at fromList Setter Maybe Iso Maybe Lens Maybe Traversal Maybe",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(?~) ?~",
          "normalized": "ASetter a b c(Maybe d)-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a(Maybe b)-\u003eb-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-63--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in our monadic\n state with \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a new value, irrespective of the old.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do at 1 ?= a; at 2 ?= b) Map.empty\n\u003c/code\u003e\u003c/strong\u003efromList [(1,a),(2,b)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 ?= b; _2 ?= c) (Just a, Nothing)\n\u003c/code\u003e\u003c/strong\u003e(Just b,Just c)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e?=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s (\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a)    -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(?=)",
          "package": "lens",
          "signature": "ASetter s s a (Maybe b) -\u003e b -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%3F%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-63--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-63--61-\"]"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal in our monadic state with Just new value irrespective of the old execState do at at Map.empty fromList execState do Just Nothing Just Just MonadState Iso Maybe MonadState Lens Maybe MonadState Traversal Maybe MonadState Setter Maybe",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(?=) ?=",
          "normalized": "ASetter a a b(Maybe c)-\u003ec-\u003ed()",
          "package": "lens",
          "signature": "ASetter s s a(Maybe b)-\u003eb-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-63--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to a non-negative integral power.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,3) & _2 ^~ 2\n\u003c/code\u003e\u003c/strong\u003e(1,9)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(^~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e e -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%5E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-94--126-\"]"
        },
        "index": {
          "description": "Raise the target of numerically valued Lens Setter or Traversal to non-negative integral power Num Integral Setter Num Integral Iso Num Integral Lens Num Integral Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(^~) ^~",
          "normalized": "ASetter a b c c-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ee-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to a non-negative integral power.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(^=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e e -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%5E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-94--61-\"]"
        },
        "index": {
          "description": "Raise the target of numerically valued Lens Setter or Traversal to non-negative integral power MonadState Num Integral Setter MonadState Num Integral Iso MonadState Num Integral Lens MonadState Num Integral Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(^=) ^=",
          "normalized": "ASetter' a b-\u003ec-\u003ed()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ee-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target(s) of a fractionally valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to an integral power.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2) & _2 ^^~ (-1)\n\u003c/code\u003e\u003c/strong\u003e(1,0.5)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e^^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e^^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e e -\u003e s -\u003e s\n (\u003ccode\u003e\u003ca\u003e^^~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(^^~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e e -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#%5E%5E~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--94--126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-94--94--126-\"]"
        },
        "index": {
          "description": "Raise the target of fractionally valued Lens Setter or Traversal to an integral power Fractional Integral Setter Fractional Integral Iso Fractional Integral Lens Fractional Integral Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(^^~) ^^~",
          "normalized": "ASetter a b c c-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ee-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--94--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRaise the target(s) of a numerically valued \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to an integral power.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e^^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e^^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e^^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e^^=\u003c/a\u003e\u003c/code\u003e) ::  (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e e -\u003e m ()\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(^^=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e e -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#%5E%5E%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--94--61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:-94--94--61-\"]"
        },
        "index": {
          "description": "Raise the target of numerically valued Lens Setter or Traversal to an integral power MonadState Fractional Integral Setter MonadState Fractional Integral Iso MonadState Fractional Integral Lens MonadState Fractional Integral Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(^^=) ^^=",
          "normalized": "ASetter' a b-\u003ec-\u003ed()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ee-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:-94--94--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e with a constant value.\n\u003c/p\u003e\u003cp\u003eThis is an infix version of \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e, provided for consistency with (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e\n f \u003ccode\u003e\u003ca\u003e\u003c$\u003c/a\u003e\u003c/code\u003e a &#8801; \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c,d) & _4 .~ e\n\u003c/code\u003e\u003c/strong\u003e(a,b,c,e)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(42,\"world\") & _1 .~ \"hello\"\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",\"world\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b) & both .~ c\n\u003c/code\u003e\u003c/strong\u003e(c,c)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e b -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e b -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(.~)",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#.~",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:.-126-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:.-126-\"]"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal with constant value This is an infix version of set provided for consistency with mapped world hello hello world both Setter Iso Lens Traversal",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(.~) .~",
          "normalized": "ASetter a b c d-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a b-\u003eb-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in our monadic state with a new value, irrespective of the\n old.\n\u003c/p\u003e\u003cp\u003eThis is an infix version of \u003ccode\u003e\u003ca\u003eassign\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 .= c; _2 .= d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(c,d)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (both .= c) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(c,c)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eIt puts the state in the monad or it gets the hose again.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Setter\"]",
          "name": "(.=)",
          "package": "lens",
          "signature": "ASetter s s a b -\u003e b -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#.%3D",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:.-61-\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:.-61-\"]"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal in our monadic state with new value irrespective of the old This is an infix version of assign execState do execState both MonadState Iso MonadState Lens MonadState Traversal MonadState Setter It puts the state in the monad or it gets the hose again",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(.=) .=",
          "normalized": "ASetter a a b c-\u003ec-\u003ed()",
          "package": "lens",
          "signature": "ASetter s s a b-\u003eb-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompose through a plate\n\u003c/p\u003e",
          "module": "[\"Control.Lens.Operators\",\"Control.Lens.Plated\"]",
          "name": "(...)",
          "package": "lens",
          "signature": "LensLike f s t c c -\u003e Over p f c c a b -\u003e Over p f s t a b",
          "source": "src/Control-Lens-Plated.html#...",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:...\",\"http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:...\"]"
        },
        "index": {
          "description": "Compose through plate",
          "hierarchy": "Control Lens Operators",
          "module": "Control.Lens.Operators",
          "name": "(...) ...",
          "normalized": "LensLike a b c d d-\u003eOver e a d d f g-\u003eOver e a b c f g",
          "package": "lens",
          "signature": "LensLike f s t c c-\u003eOver p f c c a b-\u003eOver p f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Operators.html#v:..."
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe name \"plate\" stems originally from \"boilerplate\", which was the term\n used by the \"Scrap Your Boilerplate\" papers, and later inherited by Neil\n Mitchell's \"Uniplate\".\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://community.haskell.org/~ndm/uniplate/\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThe combinators in here are designed to be compatible with and subsume the\n \u003ccode\u003euniplate\u003c/code\u003e API with the notion of a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e replacing\n a \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eBy implementing these combinators in terms of \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e instead of\n \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e additional type safety is gained, as the user is\n no longer responsible for maintaining invariants such as the number of\n children they received.\n\u003c/p\u003e\u003cp\u003eNote: The \u003ccode\u003eBiplate\u003c/code\u003e is \u003cem\u003edeliberately\u003c/em\u003e excluded from the API here, with the\n intention that you replace them with either explicit traversals, or by using the\n \u003ccode\u003eOn\u003c/code\u003e variants of the combinators below with \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e from\n \u003ccode\u003eData.Data.Lens\u003c/code\u003e. As a design, it forced the user into too many situations where\n they had to choose between correctness and ease of use, and it was brittle in the\n face of competing imports.\n\u003c/p\u003e\u003cp\u003eThe sensible use of these combinators makes some simple assumptions.  Notably, any\n of the \u003ccode\u003eOn\u003c/code\u003e combinators are expecting a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e\n to play the role of the \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e combinator, and so when the\n types of the contents and the container match, they should be the \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIt is often beneficial to use the combinators in this module with the combinators\n from \u003ccode\u003eData.Data.Lens\u003c/code\u003e or \u003ccode\u003eGHC.Generics.Lens\u003c/code\u003e to make it easier to automatically\n derive definitions for \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e, or to derive custom traversals.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Plated",
          "name": "Plated",
          "package": "lens",
          "source": "src/Control-Lens-Plated.html",
          "type": "module"
        },
        "index": {
          "description": "The name plate stems originally from boilerplate which was the term used by the Scrap Your Boilerplate papers and later inherited by Neil Mitchell Uniplate http community.haskell.org ndm uniplate The combinators in here are designed to be compatible with and subsume the uniplate API with the notion of Traversal replacing uniplate or biplate By implementing these combinators in terms of plate instead of uniplate additional type safety is gained as the user is no longer responsible for maintaining invariants such as the number of children they received Note The Biplate is deliberately excluded from the API here with the intention that you replace them with either explicit traversals or by using the On variants of the combinators below with biplate from Data.Data.Lens As design it forced the user into too many situations where they had to choose between correctness and ease of use and it was brittle in the face of competing imports The sensible use of these combinators makes some simple assumptions Notably any of the On combinators are expecting Traversal Setter or Fold to play the role of the biplate combinator and so when the types of the contents and the container match they should be the id Traversal Setter or Fold It is often beneficial to use the combinators in this module with the combinators from Data.Data.Lens or GHC.Generics.Lens to make it easier to automatically derive definitions for plate or to derive custom traversals",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "Plated",
          "package": "lens",
          "partial": "Plated",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e type is one where we know how to extract its immediate self-similar children.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eExample 1\u003c/em\u003e:\n\u003c/p\u003e\u003cpre\u003e\n import Control.Applicative\n import Control.Lens\n import Control.Lens.Plated\n import Data.Data\n import Data.Data.Lens (\u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cpre\u003e\n data Expr\n   = Val \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n   | Neg Expr\n   | Add Expr Expr\n   deriving (\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cpre\u003e\n instance \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e Expr where\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e f (Neg e) = Neg \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e f e\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e f (Add a b) = Add \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e f a \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e f b\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e _ a = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eor\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n instance \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e Expr where\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eExample 2\u003c/em\u003e:\n\u003c/p\u003e\u003cpre\u003e\n import Control.Applicative\n import Control.Lens\n import Control.Lens.Plated\n import Data.Data\n import Data.Data.Lens (\u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cpre\u003e\n data Tree a\n   = Bin (Tree a) (Tree a)\n   | Tip a\n   deriving (\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e)\n\u003c/pre\u003e\u003cpre\u003e\n instance \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e (Tree a) where\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e f (Bin l r) = Bin \u003ccode\u003e\u003ca\u003e\u003c$\u003e\u003c/a\u003e\u003c/code\u003e f l \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e f r\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e _ t = \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e t\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003eor\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n instance \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e (Tree a) where\n   \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNote the big distinction between these two implementations.\n\u003c/p\u003e\u003cp\u003eThe former will only treat children directly in this tree as descendents,\n the latter will treat trees contained in the values under the tips also\n as descendants!\n\u003c/p\u003e\u003cp\u003eWhen in doubt, pick a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e and just use the various \u003ccode\u003e...Of\u003c/code\u003e combinators\n rather than pollute \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e with orphan instances!\n\u003c/p\u003e\u003cp\u003eIf you want to find something unplated and non-recursive with \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e\n use the \u003ccode\u003e...OnOf\u003c/code\u003e variant with \u003ccode\u003e\u003ca\u003eignored\u003c/a\u003e\u003c/code\u003e, though those usecases are much better served\n in most cases by using the existing \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e combinators! e.g.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003euniverseOnOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eignored\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis same ability to explicitly pass the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in question is why there is no\n analogue to uniplate's \u003ccode\u003eBiplate\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMoreover, since we can allow custom traversals, we implement reasonable defaults for\n polymorphic data types, that only \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e into themselves, and \u003cem\u003enot\u003c/em\u003e their\n polymorphic arguments.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "Plated",
          "package": "lens",
          "source": "src/Control-Lens-Plated.html#Plated",
          "type": "class"
        },
        "index": {
          "description": "Plated type is one where we know how to extract its immediate self-similar children Example import Control.Applicative import Control.Lens import Control.Lens.Plated import Data.Data import Data.Data.Lens uniplate data Expr Val Int Neg Expr Add Expr Expr deriving Eq Ord Show Read Data Typeable instance Plated Expr where plate Neg Neg plate Add Add plate pure or instance Plated Expr where plate uniplate Example import Control.Applicative import Control.Lens import Control.Lens.Plated import Data.Data import Data.Data.Lens uniplate data Tree Bin Tree Tree Tip deriving Eq Ord Show Read Data Typeable instance Plated Tree where plate Bin Bin plate pure or instance Data Plated Tree where plate uniplate Note the big distinction between these two implementations The former will only treat children directly in this tree as descendents the latter will treat trees contained in the values under the tips also as descendants When in doubt pick Traversal and just use the various Of combinators rather than pollute Plated with orphan instances If you want to find something unplated and non-recursive with biplate use the OnOf variant with ignored though those usecases are much better served in most cases by using the existing Lens combinators e.g toListOf biplate universeOnOf biplate ignored This same ability to explicitly pass the Traversal in question is why there is no analogue to uniplate Biplate Moreover since we can allow custom traversals we implement reasonable defaults for polymorphic data types that only traverse into themselves and not their polymorphic arguments",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "Plated",
          "package": "lens",
          "partial": "Plated",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#t:Plated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the immediate descendants of a \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e container.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echildren\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "children",
          "package": "lens",
          "signature": "a -\u003e [a]",
          "source": "src/Control-Lens-Plated.html#children",
          "type": "function"
        },
        "index": {
          "description": "Extract the immediate descendants of Plated container children toListOf plate",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "children",
          "normalized": "a-\u003e[a]",
          "package": "lens",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:children"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFold the immediate children of a \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e container.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecomposOpFold\u003c/a\u003e\u003c/code\u003e z c f = \u003ccode\u003e\u003ca\u003efoldrOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e (c \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f) z\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "composOpFold",
          "package": "lens",
          "signature": "b -\u003e (b -\u003e b -\u003e b) -\u003e (a -\u003e b) -\u003e a -\u003e b",
          "source": "src/Control-Lens-Plated.html#composOpFold",
          "type": "function"
        },
        "index": {
          "description": "Fold the immediate children of Plated container composOpFold foldrOf plate",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "composOpFold",
          "normalized": "a-\u003e(a-\u003ea-\u003ea)-\u003e(b-\u003ea)-\u003eb-\u003ea",
          "package": "lens",
          "partial": "Op Fold",
          "signature": "b-\u003e(b-\u003eb-\u003eb)-\u003e(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:composOpFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of all of the editable contexts for every location in the structure, recursively.\n\u003c/p\u003e\u003cpre\u003e\n propUniverse x = \u003ccode\u003e\u003ca\u003euniverse\u003c/a\u003e\u003c/code\u003e x \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003econtexts\u003c/a\u003e\u003c/code\u003e x)\n propId x = \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e x) [\u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e w | w \u003c- \u003ccode\u003e\u003ca\u003econtexts\u003c/a\u003e\u003c/code\u003e x]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econtexts\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003econtextsOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "contexts",
          "package": "lens",
          "signature": "a -\u003e [Context a a a]",
          "source": "src/Control-Lens-Plated.html#contexts",
          "type": "function"
        },
        "index": {
          "description": "Return list of all of the editable contexts for every location in the structure recursively propUniverse universe map pos contexts propId all extract contexts contexts contextsOf plate",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "contexts",
          "normalized": "a-\u003e[Context a a a]",
          "package": "lens",
          "signature": "a-\u003e[Context a a a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:contexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of all of the editable contexts for every location in the structure, recursively, using a user-specified \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to walk each layer.\n\u003c/p\u003e\u003cpre\u003e\n propUniverse l x = \u003ccode\u003e\u003ca\u003euniverseOf\u003c/a\u003e\u003c/code\u003e l x \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003econtextsOf\u003c/a\u003e\u003c/code\u003e l x)\n propId l x = \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e x) [\u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e w | w \u003c- \u003ccode\u003e\u003ca\u003econtextsOf\u003c/a\u003e\u003c/code\u003e l x]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econtextsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e a -\u003e [\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a a a]\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "contextsOf",
          "package": "lens",
          "signature": "ATraversal' a a -\u003e a -\u003e [Context a a a]",
          "source": "src/Control-Lens-Plated.html#contextsOf",
          "type": "function"
        },
        "index": {
          "description": "Return list of all of the editable contexts for every location in the structure recursively using user-specified Traversal to walk each layer propUniverse universeOf map pos contextsOf propId all extract contextsOf contextsOf Traversal Context",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "contextsOf",
          "normalized": "ATraversal' a a-\u003ea-\u003e[Context a a a]",
          "package": "lens",
          "partial": "Of",
          "signature": "ATraversal' a a-\u003ea-\u003e[Context a a a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:contextsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of all of the editable contexts for every location in the structure in an areas indicated by a user supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, recursively using \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econtextsOn\u003c/a\u003e\u003c/code\u003e b &#8801; \u003ccode\u003e\u003ca\u003econtextsOnOf\u003c/a\u003e\u003c/code\u003e b \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econtextsOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a a s]\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "contextsOn",
          "package": "lens",
          "signature": "ATraversal s t a a -\u003e s -\u003e [Context a a t]",
          "source": "src/Control-Lens-Plated.html#contextsOn",
          "type": "function"
        },
        "index": {
          "description": "Return list of all of the editable contexts for every location in the structure in an areas indicated by user supplied Traversal recursively using plate contextsOn contextsOnOf plate contextsOn Plated Traversal Context",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "contextsOn",
          "normalized": "ATraversal a b c c-\u003ea-\u003e[Context c c b]",
          "package": "lens",
          "partial": "On",
          "signature": "ATraversal s t a a-\u003es-\u003e[Context a a t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:contextsOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a list of all of the editable contexts for every location in the structure in an areas indicated by a user supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, recursively using\n another user-supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to walk each layer.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econtextsOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a a s]\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "contextsOnOf",
          "package": "lens",
          "signature": "ATraversal s t a a -\u003e ATraversal' a a -\u003e s -\u003e [Context a a t]",
          "source": "src/Control-Lens-Plated.html#contextsOnOf",
          "type": "function"
        },
        "index": {
          "description": "Return list of all of the editable contexts for every location in the structure in an areas indicated by user supplied Traversal recursively using another user-supplied Traversal to walk each layer contextsOnOf Traversal Traversal Context",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "contextsOnOf",
          "normalized": "ATraversal a b c c-\u003eATraversal' c c-\u003ea-\u003e[Context c c b]",
          "package": "lens",
          "partial": "On Of",
          "signature": "ATraversal s t a a-\u003eATraversal' a a-\u003es-\u003e[Context a a t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:contextsOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe one-level version of \u003ccode\u003e\u003ca\u003econtext\u003c/a\u003e\u003c/code\u003e. This extracts a list of the immediate children as editable contexts.\n\u003c/p\u003e\u003cp\u003eGiven a context you can use \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e to see the values, \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e at what the structure would be like with an edited result, or simply \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e the original structure.\n\u003c/p\u003e\u003cpre\u003e\n propChildren x = \u003ccode\u003e\u003ca\u003echildren\u003c/a\u003e\u003c/code\u003e l x \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eholes\u003c/a\u003e\u003c/code\u003e l x)\n propId x = \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e x) [\u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e w | w \u003c- \u003ccode\u003e\u003ca\u003eholes\u003c/a\u003e\u003c/code\u003e l x]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eholes\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "holes",
          "package": "lens",
          "signature": "a -\u003e [Pretext (-\u003e) a a a]",
          "source": "src/Control-Lens-Plated.html#holes",
          "type": "function"
        },
        "index": {
          "description": "The one-level version of context This extracts list of the immediate children as editable contexts Given context you can use pos to see the values peek at what the structure would be like with an edited result or simply extract the original structure propChildren children map pos holes propId all extract holes holes holesOf plate",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "holes",
          "normalized": "a-\u003e[Pretext(-\u003e)a a a]",
          "package": "lens",
          "signature": "a-\u003e[Pretext(-\u003e)a a a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:holes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alias for \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e, provided for consistency with the other combinators.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eholesOn\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eholesOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a                -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (-\u003e) a a s]\n \u003ccode\u003e\u003ca\u003eholesOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a               -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (-\u003e) a a s]\n \u003ccode\u003e\u003ca\u003eholesOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a          -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (-\u003e) a a s]\n \u003ccode\u003e\u003ca\u003eholesOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i) a a s]\n \u003ccode\u003e\u003ca\u003eholesOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i) a a s]\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "holesOn",
          "package": "lens",
          "signature": "Optical p (-\u003e) (Bazaar p a a) s t a a -\u003e s -\u003e [Pretext p a a t]",
          "source": "src/Control-Lens-Plated.html#holesOn",
          "type": "function"
        },
        "index": {
          "description": "An alias for holesOf provided for consistency with the other combinators holesOn holesOf holesOn Iso Pretext holesOn Lens Pretext holesOn Traversal Pretext holesOn IndexedLens Pretext Indexed holesOn IndexedTraversal Pretext Indexed",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "holesOn",
          "normalized": "Optical a(-\u003e)(Bazaar a b b)c d b b-\u003ec-\u003e[Pretext a b b d]",
          "package": "lens",
          "partial": "On",
          "signature": "Optical p(-\u003e)(Bazaar p a a)s t a a-\u003es-\u003e[Pretext p a a t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:holesOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract one level of \u003ccode\u003e\u003ca\u003eholes\u003c/a\u003e\u003c/code\u003e from a container in a region specified by one \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, using another.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eholesOnOf\u003c/a\u003e\u003c/code\u003e b l &#8801; \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e (b \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eholesOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e a a                -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (-\u003e) a a s]\n \u003ccode\u003e\u003ca\u003eholesOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e a a               -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (-\u003e) a a s]\n \u003ccode\u003e\u003ca\u003eholesOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a          -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (-\u003e) a a s]\n \u003ccode\u003e\u003ca\u003eholesOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i a a      -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i) a a s]\n \u003ccode\u003e\u003ca\u003eholesOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i a a -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i) a a s]\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "holesOnOf",
          "package": "lens",
          "signature": "LensLike (Bazaar p r r) s t a b -\u003e Optical p (-\u003e) (Bazaar p r r) a b r r -\u003e s -\u003e [Pretext p r r t]",
          "source": "src/Control-Lens-Plated.html#holesOnOf",
          "type": "function"
        },
        "index": {
          "description": "Extract one level of holes from container in region specified by one Traversal using another holesOnOf holesOf holesOnOf Iso Iso Pretext holesOnOf Lens Lens Pretext holesOnOf Traversal Traversal Pretext holesOnOf Lens IndexedLens Pretext Indexed holesOnOf Traversal IndexedTraversal Pretext Indexed",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "holesOnOf",
          "normalized": "LensLike(Bazaar a b b)c d e f-\u003eOptical a(-\u003e)(Bazaar a b b)e f b b-\u003ec-\u003e[Pretext a b b d]",
          "package": "lens",
          "partial": "On Of",
          "signature": "LensLike(Bazaar p r r)s t a b-\u003eOptical p(-\u003e)(Bazaar p r r)a b r r-\u003es-\u003e[Pretext p r r t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:holesOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a fold-like computation on each value, technically a paramorphism.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epara\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eparaOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "para",
          "package": "lens",
          "signature": "(a -\u003e [r] -\u003e r) -\u003e a -\u003e r",
          "source": "src/Control-Lens-Plated.html#para",
          "type": "function"
        },
        "index": {
          "description": "Perform fold-like computation on each value technically paramorphism para paraOf plate",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "para",
          "normalized": "(a-\u003e[b]-\u003eb)-\u003ea-\u003eb",
          "package": "lens",
          "signature": "(a-\u003e[r]-\u003er)-\u003ea-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:para"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a fold-like computation on each value, technically a paramorphism.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eparaOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e [r] -\u003e r) -\u003e a -\u003e r\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "paraOf",
          "package": "lens",
          "signature": "Getting (Endo [a]) a a -\u003e (a -\u003e [r] -\u003e r) -\u003e a -\u003e r",
          "source": "src/Control-Lens-Plated.html#paraOf",
          "type": "function"
        },
        "index": {
          "description": "Perform fold-like computation on each value technically paramorphism paraOf Fold",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "paraOf",
          "normalized": "Getting(Endo[a])a a-\u003e(a-\u003e[b]-\u003eb)-\u003ea-\u003eb",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo[a])a a-\u003e(a-\u003e[r]-\u003er)-\u003ea-\u003er",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:paraOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe original \u003ccode\u003euniplate\u003c/code\u003e combinator, implemented in terms of \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eparts\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThe resulting \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is safer to use as it ignores 'over-application' and deals gracefully with under-application,\n but it is only a proper \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e if you don't change the list \u003ccode\u003e\u003ca\u003elength\u003c/a\u003e\u003c/code\u003e!\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "parts",
          "package": "lens",
          "signature": "Lens' a [a]",
          "source": "src/Control-Lens-Plated.html#parts",
          "type": "function"
        },
        "index": {
          "description": "The original uniplate combinator implemented in terms of Plated as Lens parts partsOf plate The resulting Lens is safer to use as it ignores over-application and deals gracefully with under-application but it is only proper Lens if you don change the list length",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "parts",
          "normalized": "Lens' a[a]",
          "package": "lens",
          "signature": "Lens' a[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:parts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the immediate children of this structure.\n\u003c/p\u003e\u003cp\u003eIf you're using GHC 7.2 or newer and your type has a \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e instance,\n \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e will default to \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e and you can choose to not override\n it with your own definition.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "plate",
          "package": "lens",
          "signature": "Traversal' a a",
          "source": "src/Control-Lens-Plated.html#plate",
          "type": "method"
        },
        "index": {
          "description": "Traversal of the immediate children of this structure If you re using GHC or newer and your type has Data instance plate will default to uniplate and you can choose to not override it with your own definition",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "plate",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:plate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a rule everywhere you can. Ensures that the rule cannot\n be applied anywhere in the result:\n\u003c/p\u003e\u003cpre\u003e\n propRewrite r x = \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eisNothing\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e r) (\u003ccode\u003e\u003ca\u003euniverse\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003erewrite\u003c/a\u003e\u003c/code\u003e r x))\n\u003c/pre\u003e\u003cp\u003eUsually \u003ccode\u003e\u003ca\u003etransform\u003c/a\u003e\u003c/code\u003e is more appropriate, but \u003ccode\u003e\u003ca\u003erewrite\u003c/a\u003e\u003c/code\u003e can give better\n compositionality. Given two single transformations \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e, you can\n construct \u003ccode\u003ea -\u003e f a \u003ccode\u003emplus\u003c/code\u003e g a\u003c/code\u003e which performs both rewrites until a fixed point.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewrite",
          "package": "lens",
          "signature": "(a -\u003e Maybe a) -\u003e a -\u003e a",
          "source": "src/Control-Lens-Plated.html#rewrite",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying rule everywhere you can Ensures that the rule cannot be applied anywhere in the result propRewrite all isNothing universe rewrite Usually transform is more appropriate but rewrite can give better compositionality Given two single transformations and you can construct mplus which performs both rewrites until fixed point",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewrite",
          "normalized": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "lens",
          "signature": "(a-\u003eMaybe a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a monadic rule everywhere you can. Ensures that the rule cannot\n be applied anywhere in the result.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteM",
          "package": "lens",
          "signature": "(a -\u003e m (Maybe a)) -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Plated.html#rewriteM",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying monadic rule everywhere you can Ensures that the rule cannot be applied anywhere in the result",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteM",
          "normalized": "(a-\u003eb(Maybe a))-\u003ea-\u003eb a",
          "package": "lens",
          "signature": "(a-\u003em(Maybe a))-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a monadic rule everywhere you recursing with a user-specified \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n Ensures that the rule cannot be applied anywhere in the result.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteMOf",
          "package": "lens",
          "signature": "LensLike' (WrappedMonad m) a a -\u003e (a -\u003e m (Maybe a)) -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Plated.html#rewriteMOf",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying monadic rule everywhere you recursing with user-specified Traversal Ensures that the rule cannot be applied anywhere in the result",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteMOf",
          "normalized": "LensLike'(WrappedMonad a)b b-\u003e(b-\u003ea(Maybe b))-\u003eb-\u003ea b",
          "package": "lens",
          "partial": "MOf",
          "signature": "LensLike'(WrappedMonad m)a a-\u003e(a-\u003em(Maybe a))-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a monadic rule everywhere inside of a structure located by a user-specified \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n Ensures that the rule cannot be applied anywhere in the result.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteMOn",
          "package": "lens",
          "signature": "LensLike (WrappedMonad m) s t a a -\u003e (a -\u003e m (Maybe a)) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Plated.html#rewriteMOn",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying monadic rule everywhere inside of structure located by user-specified Traversal Ensures that the rule cannot be applied anywhere in the result",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteMOn",
          "normalized": "LensLike(WrappedMonad a)b c d d-\u003e(d-\u003ea(Maybe d))-\u003eb-\u003ea c",
          "package": "lens",
          "partial": "MOn",
          "signature": "LensLike(WrappedMonad m)s t a a-\u003e(a-\u003em(Maybe a))-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteMOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a monadic rule everywhere inside of a structure located by a user-specified \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e,\n using a user-specified \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for recursion. Ensures that the rule cannot be applied anywhere in the result.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteMOnOf",
          "package": "lens",
          "signature": "LensLike (WrappedMonad m) s t a a -\u003e LensLike' (WrappedMonad m) a a -\u003e (a -\u003e m (Maybe a)) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Plated.html#rewriteMOnOf",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying monadic rule everywhere inside of structure located by user-specified Traversal using user-specified Traversal for recursion Ensures that the rule cannot be applied anywhere in the result",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteMOnOf",
          "normalized": "LensLike(WrappedMonad a)b c d d-\u003eLensLike'(WrappedMonad a)d d-\u003e(d-\u003ea(Maybe d))-\u003eb-\u003ea c",
          "package": "lens",
          "partial": "MOn Of",
          "signature": "LensLike(WrappedMonad m)s t a a-\u003eLensLike'(WrappedMonad m)a a-\u003e(a-\u003em(Maybe a))-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteMOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite by applying a rule everywhere you can. Ensures that the rule cannot\n be applied anywhere in the result:\n\u003c/p\u003e\u003cpre\u003e\n propRewriteOf l r x = \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eisNothing\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e r) (\u003ccode\u003e\u003ca\u003euniverseOf\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003erewriteOf\u003c/a\u003e\u003c/code\u003e l r x))\n\u003c/pre\u003e\u003cp\u003eUsually \u003ccode\u003e\u003ca\u003etransformOf\u003c/a\u003e\u003c/code\u003e is more appropriate, but \u003ccode\u003e\u003ca\u003erewriteOf\u003c/a\u003e\u003c/code\u003e can give better\n compositionality. Given two single transformations \u003ccode\u003ef\u003c/code\u003e and \u003ccode\u003eg\u003c/code\u003e, you can\n construct \u003ccode\u003ea -\u003e f a \u003ccode\u003emplus\u003c/code\u003e g a\u003c/code\u003e which performs both rewrites until a fixed point.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erewriteOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e a a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e a -\u003e a\n \u003ccode\u003e\u003ca\u003erewriteOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e a a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e a -\u003e a\n \u003ccode\u003e\u003ca\u003erewriteOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e a -\u003e a\n \u003ccode\u003e\u003ca\u003erewriteOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e a a    -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e a -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteOf",
          "package": "lens",
          "signature": "ASetter' a a -\u003e (a -\u003e Maybe a) -\u003e a -\u003e a",
          "source": "src/Control-Lens-Plated.html#rewriteOf",
          "type": "function"
        },
        "index": {
          "description": "Rewrite by applying rule everywhere you can Ensures that the rule cannot be applied anywhere in the result propRewriteOf all isNothing universeOf rewriteOf Usually transformOf is more appropriate but rewriteOf can give better compositionality Given two single transformations and you can construct mplus which performs both rewrites until fixed point rewriteOf Iso Maybe rewriteOf Lens Maybe rewriteOf Traversal Maybe rewriteOf Setter Maybe",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteOf",
          "normalized": "ASetter' a a-\u003e(a-\u003eMaybe a)-\u003ea-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "ASetter' a a-\u003e(a-\u003eMaybe a)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite recursively over part of a larger structure.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erewriteOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003erewriteOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003erewriteOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003erewriteOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eASetter'\u003c/a\u003e\u003c/code\u003e s a   -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteOn",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e (a -\u003e Maybe a) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Plated.html#rewriteOn",
          "type": "function"
        },
        "index": {
          "description": "Rewrite recursively over part of larger structure rewriteOn Plated Iso Maybe rewriteOn Plated Lens Maybe rewriteOn Plated Traversal Maybe rewriteOn Plated ASetter Maybe",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteOn",
          "normalized": "ASetter a b c c-\u003e(c-\u003eMaybe c)-\u003ea-\u003eb",
          "package": "lens",
          "partial": "On",
          "signature": "ASetter s t a a-\u003e(a-\u003eMaybe a)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRewrite recursively over part of a larger structure using a specified \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003erewriteOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e a a       -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003erewriteOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e a a      -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003erewriteOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003erewriteOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e a a    -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "rewriteOnOf",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e ASetter' a a -\u003e (a -\u003e Maybe a) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Plated.html#rewriteOnOf",
          "type": "function"
        },
        "index": {
          "description": "Rewrite recursively over part of larger structure using specified Setter rewriteOnOf Plated Iso Iso Maybe rewriteOnOf Plated Lens Lens Maybe rewriteOnOf Plated Traversal Traversal Maybe rewriteOnOf Plated Setter Setter Maybe",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "rewriteOnOf",
          "normalized": "ASetter a b c c-\u003eASetter' c c-\u003e(c-\u003eMaybe c)-\u003ea-\u003eb",
          "package": "lens",
          "partial": "On Of",
          "signature": "ASetter s t a a-\u003eASetter' a a-\u003e(a-\u003eMaybe a)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:rewriteOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in the tree, in a bottom-up manner.\n\u003c/p\u003e\u003cp\u003eFor example, replacing negative literals with literals:\n\u003c/p\u003e\u003cpre\u003e\n negLits = \u003ccode\u003e\u003ca\u003etransform\u003c/a\u003e\u003c/code\u003e $ \\x -\u003e case x of\n   Neg (Lit i) -\u003e Lit (\u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e i)\n   _           -\u003e x\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transform",
          "package": "lens",
          "signature": "(a -\u003e a) -\u003e a -\u003e a",
          "source": "src/Control-Lens-Plated.html#transform",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in the tree in bottom-up manner For example replacing negative literals with literals negLits transform case of Neg Lit Lit negate",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transform",
          "normalized": "(a-\u003ea)-\u003ea-\u003ea",
          "package": "lens",
          "signature": "(a-\u003ea)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in the tree, in a bottom-up manner, monadically.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformM",
          "package": "lens",
          "signature": "(a -\u003e m a) -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Plated.html#transformM",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in the tree in bottom-up manner monadically",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformM",
          "normalized": "(a-\u003eb a)-\u003ea-\u003eb a",
          "package": "lens",
          "signature": "(a-\u003em a)-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in a tree using a user supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in a bottom-up manner with a monadic effect.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransformMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e m a) -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformMOf",
          "package": "lens",
          "signature": "LensLike' (WrappedMonad m) a a -\u003e (a -\u003e m a) -\u003e a -\u003e m a",
          "source": "src/Control-Lens-Plated.html#transformMOf",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in tree using user supplied Traversal in bottom-up manner with monadic effect transformMOf Monad Traversal",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformMOf",
          "normalized": "LensLike'(WrappedMonad a)b b-\u003e(b-\u003ea b)-\u003eb-\u003ea b",
          "package": "lens",
          "partial": "MOf",
          "signature": "LensLike'(WrappedMonad m)a a-\u003e(a-\u003em a)-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in the tree in a region indicated by a supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, in a bottom-up manner, monadically.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransformMOn\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e m a) -\u003e s -\u003e m s\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformMOn",
          "package": "lens",
          "signature": "LensLike (WrappedMonad m) s t a a -\u003e (a -\u003e m a) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Plated.html#transformMOn",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in the tree in region indicated by supplied Traversal in bottom-up manner monadically transformMOn Monad Plated Traversal",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformMOn",
          "normalized": "LensLike(WrappedMonad a)b c d d-\u003e(d-\u003ea d)-\u003eb-\u003ea c",
          "package": "lens",
          "partial": "MOn",
          "signature": "LensLike(WrappedMonad m)s t a a-\u003e(a-\u003em a)-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformMOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in a tree that lies in a region indicated by a supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, walking with a user supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in\n a bottom-up manner with a monadic effect.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransformMOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e m a) -\u003e s -\u003e m s\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformMOnOf",
          "package": "lens",
          "signature": "LensLike (WrappedMonad m) s t a a -\u003e LensLike' (WrappedMonad m) a a -\u003e (a -\u003e m a) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Plated.html#transformMOnOf",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in tree that lies in region indicated by supplied Traversal walking with user supplied Traversal in bottom-up manner with monadic effect transformMOnOf Monad Traversal Traversal",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformMOnOf",
          "normalized": "LensLike(WrappedMonad a)b c d d-\u003eLensLike'(WrappedMonad a)d d-\u003e(d-\u003ea d)-\u003eb-\u003ea c",
          "package": "lens",
          "partial": "MOn Of",
          "signature": "LensLike(WrappedMonad m)s t a a-\u003eLensLike'(WrappedMonad m)a a-\u003e(a-\u003em a)-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformMOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element by recursively applying a given \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e in a bottom-up manner.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransformOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e a) -\u003e a -\u003e a\n \u003ccode\u003e\u003ca\u003etransformOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e a a    -\u003e (a -\u003e a) -\u003e a -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformOf",
          "package": "lens",
          "signature": "ASetter' a a -\u003e (a -\u003e a) -\u003e a -\u003e a",
          "source": "src/Control-Lens-Plated.html#transformOf",
          "type": "function"
        },
        "index": {
          "description": "Transform every element by recursively applying given Setter in bottom-up manner transformOf Traversal transformOf Setter",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformOf",
          "normalized": "ASetter' a a-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "package": "lens",
          "partial": "Of",
          "signature": "ASetter' a a-\u003e(a-\u003ea)-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in the tree in a bottom-up manner over a region indicated by a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransformOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003etransformOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e (a -\u003e a) -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformOn",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e (a -\u003e a) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Plated.html#transformOn",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in the tree in bottom-up manner over region indicated by Setter transformOn Plated Traversal transformOn Plated Setter",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformOn",
          "normalized": "ASetter a b c c-\u003e(c-\u003ec)-\u003ea-\u003eb",
          "package": "lens",
          "partial": "On",
          "signature": "ASetter s t a a-\u003e(a-\u003ea)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform every element in a region indicated by a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e by recursively applying another \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e\n in a bottom-up manner.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransformOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e a a -\u003e (a -\u003e a) -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003etransformOnOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e a a    -\u003e (a -\u003e a) -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "transformOnOf",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e ASetter' a a -\u003e (a -\u003e a) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Plated.html#transformOnOf",
          "type": "function"
        },
        "index": {
          "description": "Transform every element in region indicated by Setter by recursively applying another Setter in bottom-up manner transformOnOf Setter Traversal transformOnOf Setter Setter",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "transformOnOf",
          "normalized": "ASetter a b c c-\u003eASetter' c c-\u003e(c-\u003ec)-\u003ea-\u003eb",
          "package": "lens",
          "partial": "On Of",
          "signature": "ASetter s t a a-\u003eASetter' a a-\u003e(a-\u003ea)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:transformOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve all of the transitive descendants of a \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e container, including itself.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "universe",
          "package": "lens",
          "signature": "a -\u003e [a]",
          "source": "src/Control-Lens-Plated.html#universe",
          "type": "function"
        },
        "index": {
          "description": "Retrieve all of the transitive descendants of Plated container including itself",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "universe",
          "normalized": "a-\u003e[a]",
          "package": "lens",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:universe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that knows how to locate immediate children, retrieve all of the transitive descendants of a node, including itself.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003euniverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e a a -\u003e a -\u003e [a]\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "universeOf",
          "package": "lens",
          "signature": "Getting [a] a a -\u003e a -\u003e [a]",
          "source": "src/Control-Lens-Plated.html#universeOf",
          "type": "function"
        },
        "index": {
          "description": "Given Fold that knows how to locate immediate children retrieve all of the transitive descendants of node including itself universeOf Fold",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "universeOf",
          "normalized": "Getting[a]a a-\u003ea-\u003e[a]",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting[a]a a-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:universeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that knows how to find \u003ccode\u003e\u003ca\u003ePlated\u003c/a\u003e\u003c/code\u003e parts of a container retrieve them and all of their descendants, recursively.\n\u003c/p\u003e",
          "module": "Control.Lens.Plated",
          "name": "universeOn",
          "package": "lens",
          "signature": "Getting [a] s a -\u003e s -\u003e [a]",
          "source": "src/Control-Lens-Plated.html#universeOn",
          "type": "function"
        },
        "index": {
          "description": "Given Fold that knows how to find Plated parts of container retrieve them and all of their descendants recursively",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "universeOn",
          "normalized": "Getting[a]b a-\u003eb-\u003e[a]",
          "package": "lens",
          "partial": "On",
          "signature": "Getting[a]s a-\u003es-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:universeOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that knows how to locate immediate children, retrieve all of the transitive descendants of a node, including itself that lie\n in a region indicated by another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003euniverseOnOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eignored\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Plated",
          "name": "universeOnOf",
          "package": "lens",
          "signature": "Getting [a] s a -\u003e Getting [a] a a -\u003e s -\u003e [a]",
          "source": "src/Control-Lens-Plated.html#universeOnOf",
          "type": "function"
        },
        "index": {
          "description": "Given Fold that knows how to locate immediate children retrieve all of the transitive descendants of node including itself that lie in region indicated by another Fold toListOf universeOnOf ignored",
          "hierarchy": "Control Lens Plated",
          "module": "Control.Lens.Plated",
          "name": "universeOnOf",
          "normalized": "Getting[a]b a-\u003eGetting[a]a a-\u003eb-\u003e[a]",
          "package": "lens",
          "partial": "On Of",
          "signature": "Getting[a]s a-\u003eGetting[a]a a-\u003es-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Plated.html#v:universeOnOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Prism",
          "name": "Prism",
          "package": "lens",
          "source": "src/Control-Lens-Prism.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "Prism",
          "package": "lens",
          "partial": "Prism",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf you see this in a signature for a function, the function is expecting a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "APrism",
          "package": "lens",
          "source": "src/Control-Lens-Prism.html#APrism",
          "type": "type"
        },
        "index": {
          "description": "If you see this in signature for function the function is expecting Prism",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "APrism",
          "package": "lens",
          "partial": "APrism",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#t:APrism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type APrism' = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAPrism\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "APrism'",
          "package": "lens",
          "source": "src/Control-Lens-Prism.html#APrism%27",
          "type": "type"
        },
        "index": {
          "description": "type APrism Simple APrism",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "APrism'",
          "package": "lens",
          "partial": "APrism'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#t:APrism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe generalization of \u003ccode\u003e\u003ca\u003eDownStar\u003c/a\u003e\u003c/code\u003e of a \"costrong\" \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eleft'\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eright'\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e We use \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e as approximate costrength as needed.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "Choice",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "description": "The generalization of DownStar of costrong Functor Minimal complete definition left or right Note We use traverse and extract as approximate costrength as needed",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "Choice",
          "package": "lens",
          "partial": "Choice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#t:Choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that can also be turned\n around with \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e to obtain a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e in the\n opposite direction.\n\u003c/p\u003e\u003cp\u003eThere are two laws that a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e should satisfy:\n\u003c/p\u003e\u003cp\u003eFirst, if I \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e a value with a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e and then \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e or use (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e), I will get it back:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e l b) &#8801; \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e b\n\u003c/pre\u003e\u003cp\u003eSecond, if you can extract a value \u003ccode\u003ea\u003c/code\u003e using a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e from a value \u003ccode\u003es\u003c/code\u003e, then the value \u003ccode\u003es\u003c/code\u003e is completely described my \u003ccode\u003el\u003c/code\u003e and \u003ccode\u003ea\u003c/code\u003e:\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e\u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e l s &#8801; \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e then \u003ccode\u003e\u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e l a &#8801; s\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese two laws imply that the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws hold for every \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e and that we \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e at most 1 element:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e l x \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e 1\n\u003c/pre\u003e\u003cp\u003eIt may help to think of this as a \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e that can be partial in one direction.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, you might have a \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e allows you to always\n go from a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e, and provide you with tools to check if an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e is\n a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e and/or to edit one if it is.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003enat\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003enat\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eprism\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoInteger\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \\ i -\u003e\n    if i \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e 0\n    then \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e i\n    else \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efromInteger\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e\u003cp\u003eNow we can ask if an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^?nat\n\u003c/code\u003e\u003c/strong\u003eJust 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(-5)^?nat\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cp\u003eWe can update the ones that are:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(-3,4) & both.nat *~ 2\n\u003c/code\u003e\u003c/strong\u003e(-3,8)\n\u003c/pre\u003e\u003cp\u003eAnd we can then convert from a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5 ^. re nat -- :: Natural\n\u003c/code\u003e\u003c/strong\u003e5\n\u003c/pre\u003e\u003cp\u003eSimilarly we can use a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e half of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft \"hello\" & _Left %~ length\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cp\u003eor to construct an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Left\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cp\u003esuch that if you query it with the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, you will get your original input back.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Left ^? _Left\n\u003c/code\u003e\u003c/strong\u003eJust 5\n\u003c/pre\u003e\u003cp\u003eAnother interesting way to think of a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is as the categorical dual of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n -- a co-\u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, so to speak. This is what permits the construction of \u003ccode\u003e\u003ca\u003eoutside\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Composition with a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is index-preserving.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "Prism",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Prism",
          "type": "type"
        },
        "index": {
          "description": "Prism is Traversal that can also be turned around with re to obtain Getter in the opposite direction There are two laws that Prism should satisfy First if re or review value with Prism and then preview or use will get it back preview review Just Second if you can extract value using Prism from value then the value is completely described my and If preview Just then review These two laws imply that the Traversal laws hold for every Prism and that we traverse at most element lengthOf It may help to think of this as Iso that can be partial in one direction Every Prism is valid Traversal Every Iso is valid Prism For example you might have Prism Integer Natural allows you to always go from Natural to an Integer and provide you with tools to check if an Integer is Natural and or to edit one if it is nat Prism Integer Natural nat prism toInteger if then Left else Right fromInteger Now we can ask if an Integer is Natural nat Just nat Nothing We can update the ones that are both.nat And we can then convert from Natural to an Integer re nat Natural Similarly we can use Prism to traverse the Left half of an Either Left hello Left length Left or to construct an Either re Left Left such that if you query it with the Prism you will get your original input back re Left Left Just Another interesting way to think of Prism is as the categorical dual of Lens co Lens so to speak This is what permits the construction of outside Note Composition with Prism is index-preserving",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "Prism",
          "package": "lens",
          "partial": "Prism",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#t:Prism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "Prism'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Prism%27",
          "type": "type"
        },
        "index": {
          "description": "Simple Prism",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "Prism'",
          "package": "lens",
          "partial": "Prism'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#t:Prism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e provides a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for tweaking the target of the value of \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e in a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _Just (+1) (Just 2)\n\u003c/code\u003e\u003c/strong\u003eJust 3\n\u003c/pre\u003e\u003cp\u003eUnlike \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e this is a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, and so you can use it to inject as well:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_Just # 5\n\u003c/code\u003e\u003c/strong\u003eJust 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Just\n\u003c/code\u003e\u003c/strong\u003eJust 5\n\u003c/pre\u003e\u003cp\u003eInterestingly,\n\u003c/p\u003e\u003cpre\u003e\n m \u003ccode\u003e^?\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Just\u003c/a\u003e\u003c/code\u003e &#8801; m\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eJust x ^? _Just\n\u003c/code\u003e\u003c/strong\u003eJust x\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eNothing ^? _Just\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "_Just",
          "package": "lens",
          "signature": "Prism (Maybe a) (Maybe b) a b",
          "source": "src/Control-Lens-Prism.html#_Just",
          "type": "function"
        },
        "index": {
          "description": "This Prism provides Traversal for tweaking the target of the value of Just in Maybe over Just Just Just Unlike traverse this is Prism and so you can use it to inject as well Just Just re Just Just Interestingly Just Just Just Just Nothing Just Nothing",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "_Just",
          "package": "lens",
          "partial": "Just",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:_Just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e provides a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for tweaking the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e half of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _Left (+1) (Left 2)\n\u003c/code\u003e\u003c/strong\u003eLeft 3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _Left (+1) (Right 2)\n\u003c/code\u003e\u003c/strong\u003eRight 2\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eRight 42 ^._Left :: String\n\u003c/code\u003e\u003c/strong\u003e\"\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft \"hello\" ^._Left\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cp\u003eIt also can be turned around to obtain the embedding into the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e half of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_Left # 5\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Left\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "_Left",
          "package": "lens",
          "signature": "Prism (Either a c) (Either b c) a b",
          "source": "src/Control-Lens-Prism.html#_Left",
          "type": "function"
        },
        "index": {
          "description": "This Prism provides Traversal for tweaking the Left half of an Either over Left Left Left over Left Right Right Right Left String Left hello Left hello It also can be turned around to obtain the embedding into the Left half of an Either Left Left re Left Left",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "_Left",
          "package": "lens",
          "partial": "Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:_Left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e provides the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e in a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eNothing ^? _Nothing\n\u003c/code\u003e\u003c/strong\u003eJust ()\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eJust () ^? _Nothing\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cp\u003eBut you can turn it around and use it to construct \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e as well:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_Nothing # ()\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "_Nothing",
          "package": "lens",
          "signature": "Prism' (Maybe a) ()",
          "source": "src/Control-Lens-Prism.html#_Nothing",
          "type": "function"
        },
        "index": {
          "description": "This Prism provides the Traversal of Nothing in Maybe Nothing Nothing Just Just Nothing Nothing But you can turn it around and use it to construct Nothing as well Nothing Nothing",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "_Nothing",
          "normalized": "Prism'(Maybe a)()",
          "package": "lens",
          "partial": "Nothing",
          "signature": "Prism'(Maybe a)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:_Nothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e provides a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for tweaking the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e half of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _Right (+1) (Left 2)\n\u003c/code\u003e\u003c/strong\u003eLeft 2\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _Right (+1) (Right 2)\n\u003c/code\u003e\u003c/strong\u003eRight 3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eRight \"hello\" ^._Right\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft \"hello\" ^._Right :: [Double]\n\u003c/code\u003e\u003c/strong\u003e[]\n\u003c/pre\u003e\u003cp\u003eIt also can be turned around to obtain the embedding into the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e half of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_Right # 5\n\u003c/code\u003e\u003c/strong\u003eRight 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Right\n\u003c/code\u003e\u003c/strong\u003eRight 5\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "_Right",
          "package": "lens",
          "signature": "Prism (Either c a) (Either c b) a b",
          "source": "src/Control-Lens-Prism.html#_Right",
          "type": "function"
        },
        "index": {
          "description": "This Prism provides Traversal for tweaking the Right half of an Either over Right Left Left over Right Right Right Right hello Right hello Left hello Right Double It also can be turned around to obtain the embedding into the Right half of an Either Right Right re Right Right",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "_Right",
          "package": "lens",
          "partial": "Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:_Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is an improper prism for text formatting based on \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is \"improper\" in the sense that it normalizes the text formatting, but round tripping\n is idempotent given sane 'Read'/'Show' instances.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_Show # 2\n\u003c/code\u003e\u003c/strong\u003e\"2\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"EQ\" ^? _Show :: Maybe Ordering\n\u003c/code\u003e\u003c/strong\u003eJust EQ\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Show\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eprism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ereadMaybe\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "_Show",
          "package": "lens",
          "signature": "Prism' String a",
          "source": "src/Control-Lens-Prism.html#_Show",
          "type": "function"
        },
        "index": {
          "description": "This is an improper prism for text formatting based on Read and Show This Prism is improper in the sense that it normalizes the text formatting but round tripping is idempotent given sane Read Show instances Show EQ Show Maybe Ordering Just EQ Show prism show readMaybe",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "_Show",
          "package": "lens",
          "partial": "Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:_Show"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eVoid\u003c/a\u003e\u003c/code\u003e is a logically uninhabited data type.\n\u003c/p\u003e\u003cp\u003eThis is a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e that will always fail to match.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "_Void",
          "package": "lens",
          "signature": "Prism s s a Void",
          "source": "src/Control-Lens-Prism.html#_Void",
          "type": "function"
        },
        "index": {
          "description": "Void is logically uninhabited data type This is Prism that will always fail to match",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "_Void",
          "package": "lens",
          "partial": "Void",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:_Void"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e to work over part of a structure.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "aside",
          "package": "lens",
          "signature": "APrism s t a b -\u003e Prism (e, s) (e, t) (e, a) (e, b)",
          "source": "src/Control-Lens-Prism.html#aside",
          "type": "function"
        },
        "index": {
          "description": "Use Prism to work over part of structure",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "aside",
          "normalized": "APrism a b c d-\u003ePrism(e,a)(e,b)(e,c)(e,d)",
          "package": "lens",
          "signature": "APrism s t a b-\u003ePrism(e,s)(e,t)(e,a)(e,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:aside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003elift\u003c/code\u003e a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e through a \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e functor, giving a Prism that matches only if all the elements of the container match the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "below",
          "package": "lens",
          "signature": "APrism' s a -\u003e Prism' (f s) (f a)",
          "source": "src/Control-Lens-Prism.html#below",
          "type": "function"
        },
        "index": {
          "description": "lift Prism through Traversable functor giving Prism that matches only if all the elements of the container match the Prism",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "below",
          "normalized": "APrism' a b-\u003ePrism'(c a)(c b)",
          "package": "lens",
          "signature": "APrism' s a-\u003ePrism'(f s)(f a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:below"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e so that you can reuse the same monomorphically typed \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e for different purposes.\n\u003c/p\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003ecloneLens\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ecloneTraversal\u003c/a\u003e\u003c/code\u003e for examples of why you might want to do this.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "clonePrism",
          "package": "lens",
          "signature": "APrism s t a b -\u003e Prism s t a b",
          "source": "src/Control-Lens-Prism.html#clonePrism",
          "type": "function"
        },
        "index": {
          "description": "Clone Prism so that you can reuse the same monomorphically typed Prism for different purposes See cloneLens and cloneTraversal for examples of why you might want to do this",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "clonePrism",
          "normalized": "APrism a b c d-\u003ePrism a b c d",
          "package": "lens",
          "partial": "Prism",
          "signature": "APrism s t a b-\u003ePrism s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:clonePrism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck to see if this \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e doesn't match.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eisn't _Left (Right 12)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eisn't _Left (Left 12)\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eisn't _Empty []\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "isn't",
          "package": "lens",
          "signature": "APrism s t a b -\u003e s -\u003e Bool",
          "source": "src/Control-Lens-Prism.html#isn%27t",
          "type": "function"
        },
        "index": {
          "description": "Check to see if this Prism doesn match isn Left Right True isn Left Left False isn Empty False",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "isn't",
          "normalized": "APrism a b c d-\u003ea-\u003eBool",
          "package": "lens",
          "signature": "APrism s t a b-\u003es-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:isn-39-t"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Prism",
          "name": "left'",
          "package": "lens",
          "signature": "p a b -\u003e p (Either a c) (Either b c)",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "left'",
          "normalized": "a b c-\u003ea(Either b d)(Either c d)",
          "package": "lens",
          "signature": "p a b-\u003ep(Either a c)(Either b c)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:left-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e compares for approximate equality with a given value and a predicate for testing.\n\u003c/p\u003e\u003cp\u003eTo comply with the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e laws the arguments you supply to \u003ccode\u003enearly a p\u003c/code\u003e are somewhat constrained.\n\u003c/p\u003e\u003cp\u003eWe assume \u003ccode\u003ep x\u003c/code\u003e holds iff \u003ccode\u003ex &#8801; a\u003c/code\u003e. Under that assumption then this is a valid \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is useful when working with a type where you can test equality for only a subset of its\n values, and the prism selects such a value.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "nearly",
          "package": "lens",
          "signature": "a -\u003e (a -\u003e Bool) -\u003e Prism' a ()",
          "source": "src/Control-Lens-Prism.html#nearly",
          "type": "function"
        },
        "index": {
          "description": "This Prism compares for approximate equality with given value and predicate for testing To comply with the Prism laws the arguments you supply to nearly are somewhat constrained We assume holds iff Under that assumption then this is valid Prism This is useful when working with type where you can test equality for only subset of its values and the prism selects such value",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "nearly",
          "normalized": "a-\u003e(a-\u003eBool)-\u003ePrism' a()",
          "package": "lens",
          "signature": "a-\u003e(a-\u003eBool)-\u003ePrism' a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:nearly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e compares for exact equality with a given value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eonly 4 # ()\n\u003c/code\u003e\u003c/strong\u003e4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5 ^? only 4\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "only",
          "package": "lens",
          "signature": "a -\u003e Prism' a ()",
          "source": "src/Control-Lens-Prism.html#only",
          "type": "function"
        },
        "index": {
          "description": "This Prism compares for exact equality with given value only only Nothing",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "only",
          "normalized": "a-\u003ePrism' a()",
          "package": "lens",
          "signature": "a-\u003ePrism' a()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:only"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e as a kind of first-class pattern.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eoutside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (t -\u003e r) (s -\u003e r) (b -\u003e r) (a -\u003e r)\u003c/pre\u003e",
          "module": "Control.Lens.Prism",
          "name": "outside",
          "package": "lens",
          "signature": "APrism s t a b -\u003e Lens (p t r) (p s r) (p b r) (p a r)",
          "source": "src/Control-Lens-Prism.html#outside",
          "type": "function"
        },
        "index": {
          "description": "Use Prism as kind of first-class pattern outside Prism Lens",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "outside",
          "normalized": "APrism a b c d-\u003eLens(e b f)(e a f)(e d f)(e c f)",
          "package": "lens",
          "signature": "APrism s t a b-\u003eLens(p t r)(p s r)(p b r)(p a r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:outside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e t a\u003c/code\u003e is used instead of \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e to permit the types of \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e to differ.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "prism",
          "package": "lens",
          "signature": "(b -\u003e t) -\u003e (s -\u003e Either t a) -\u003e Prism s t a b",
          "source": "src/Control-Lens-Prism.html#prism",
          "type": "function"
        },
        "index": {
          "description": "Build Prism Either is used instead of Maybe to permit the types of and to differ",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "prism",
          "normalized": "(a-\u003eb)-\u003e(c-\u003eEither b d)-\u003ePrism c b d a",
          "package": "lens",
          "signature": "(b-\u003et)-\u003e(s-\u003eEither t a)-\u003ePrism s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:prism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is usually used to build a \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e, when you have to use an operation like\n \u003ccode\u003e\u003ca\u003ecast\u003c/a\u003e\u003c/code\u003e which already returns a \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "prism'",
          "package": "lens",
          "signature": "(b -\u003e s) -\u003e (s -\u003e Maybe a) -\u003e Prism s s a b",
          "source": "src/Control-Lens-Prism.html#prism%27",
          "type": "function"
        },
        "index": {
          "description": "This is usually used to build Prism when you have to use an operation like cast which already returns Maybe",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "prism'",
          "normalized": "(a-\u003eb)-\u003e(b-\u003eMaybe c)-\u003ePrism b b c a",
          "package": "lens",
          "signature": "(b-\u003es)-\u003e(s-\u003eMaybe a)-\u003ePrism s s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:prism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Prism",
          "name": "right'",
          "package": "lens",
          "signature": "p a b -\u003e p (Either c a) (Either c b)",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "right'",
          "normalized": "a b c-\u003ea(Either d b)(Either d c)",
          "package": "lens",
          "signature": "p a b-\u003ep(Either c a)(Either c b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:right-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a pair of prisms, project sums.\n\u003c/p\u003e\u003cp\u003eViewing a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e as a co-\u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, this combinator can be seen to be dual to \u003ccode\u003e\u003ca\u003ealongside\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Prism",
          "name": "without",
          "package": "lens",
          "signature": "APrism s t a b -\u003e APrism u v c d -\u003e Prism (Either s u) (Either t v) (Either a c) (Either b d)",
          "source": "src/Control-Lens-Prism.html#without",
          "type": "function"
        },
        "index": {
          "description": "Given pair of prisms project sums Viewing Prism as co Lens this combinator can be seen to be dual to alongside",
          "hierarchy": "Control Lens Prism",
          "module": "Control.Lens.Prism",
          "name": "without",
          "normalized": "APrism a b c d-\u003eAPrism e f g h-\u003ePrism(Either a e)(Either b f)(Either c g)(Either d h)",
          "package": "lens",
          "signature": "APrism s t a b-\u003eAPrism u v c d-\u003ePrism(Either s u)(Either t v)(Either a c)(Either b d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Prism.html#v:without"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Reified",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Reified",
          "package": "lens",
          "partial": "Reified",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e\u003cp\u003eThis can also be useful for creatively combining folds as\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eReifiedFold\u003c/a\u003e\u003c/code\u003e s\u003c/code\u003e is isomorphic to \u003ccode\u003eReaderT s []\u003c/code\u003e and provides similar\n instances.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\")^..runFold ((,) \u003c$\u003e Fold _2 \u003c*\u003e Fold both)\n\u003c/code\u003e\u003c/strong\u003e[(\"world\",\"hello\"),(\"world\",\"world\")]\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedFold",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedFold",
          "type": "newtype"
        },
        "index": {
          "description": "Reify Fold so it can be stored safely in container This can also be useful for creatively combining folds as ReifiedFold is isomorphic to ReaderT and provides similar instances hello world runFold Fold Fold both world hello world world",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedFold",
          "package": "lens",
          "partial": "Reified Fold",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e\u003cp\u003eThis can also be useful when combining getters in novel ways, as\n \u003ccode\u003e\u003ca\u003eReifiedGetter\u003c/a\u003e\u003c/code\u003e is isomorphic to '(-\u003e)' and provides similar instances.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\",\"!!!\")^.runGetter ((,) \u003c$\u003e Getter _2 \u003c*\u003e Getter (_1.to length))\n\u003c/code\u003e\u003c/strong\u003e(\"world\",5)\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedGetter",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedGetter",
          "type": "newtype"
        },
        "index": {
          "description": "Reify Getter so it can be stored safely in container This can also be useful when combining getters in novel ways as ReifiedGetter is isomorphic to and provides similar instances hello world runGetter Getter Getter to length world",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedGetter",
          "package": "lens",
          "partial": "Reified Getter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedFold",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedFold",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedFold",
          "package": "lens",
          "partial": "Reified Indexed Fold",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedGetter",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedGetter",
          "type": "newtype"
        },
        "index": {
          "description": "Reify an IndexedGetter so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedGetter",
          "package": "lens",
          "partial": "Reified Indexed Getter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify an \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedLens",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedLens",
          "type": "newtype"
        },
        "index": {
          "description": "Reify an IndexedLens so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedLens",
          "package": "lens",
          "partial": "Reified Indexed Lens",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedIndexedLens'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eReifiedIndexedLens\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedLens'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedLens%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedIndexedLens Simple ReifiedIndexedLens",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedLens'",
          "package": "lens",
          "partial": "Reified Indexed Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedSetter",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedSetter",
          "type": "newtype"
        },
        "index": {
          "description": "Reify an IndexedSetter so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedSetter",
          "package": "lens",
          "partial": "Reified Indexed Setter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedIndexedSetter'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eReifiedIndexedSetter\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedSetter'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedSetter%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedIndexedSetter Simple ReifiedIndexedSetter",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedSetter'",
          "package": "lens",
          "partial": "Reified Indexed Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedSetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedTraversal",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedTraversal",
          "type": "newtype"
        },
        "index": {
          "description": "Reify an IndexedTraversal so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedTraversal",
          "package": "lens",
          "partial": "Reified Indexed Traversal",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eReifiedIndexedTraversal\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedTraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedTraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedIndexedTraversal Simple ReifiedIndexedTraversal",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIndexedTraversal'",
          "package": "lens",
          "partial": "Reified Indexed Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIndexedTraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIso",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIso",
          "type": "newtype"
        },
        "index": {
          "description": "Reify an Iso so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIso",
          "package": "lens",
          "partial": "Reified Iso",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedIso'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eReifiedIso\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIso'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedIso%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedIso Simple ReifiedIso",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedIso'",
          "package": "lens",
          "partial": "Reified Iso'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedIso-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedLens",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedLens",
          "type": "newtype"
        },
        "index": {
          "description": "Reify Lens so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedLens",
          "package": "lens",
          "partial": "Reified Lens",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedLens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eReifiedLens\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedLens'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedLens%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedLens Simple ReifiedLens",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedLens'",
          "package": "lens",
          "partial": "Reified Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedPrism",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedPrism",
          "type": "newtype"
        },
        "index": {
          "description": "Reify Prism so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedPrism",
          "package": "lens",
          "partial": "Reified Prism",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedPrism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedPrism'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eReifiedPrism\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedPrism'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedPrism%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedPrism Simple ReifiedPrism",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedPrism'",
          "package": "lens",
          "partial": "Reified Prism'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedPrism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReify a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e so it can be stored safely in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedSetter",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedSetter",
          "type": "newtype"
        },
        "index": {
          "description": "Reify Setter so it can be stored safely in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedSetter",
          "package": "lens",
          "partial": "Reified Setter",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedSetter'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eReifiedSetter\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedSetter'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedSetter%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedSetter Simple ReifiedSetter",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedSetter'",
          "package": "lens",
          "partial": "Reified Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedSetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA form of \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that can be stored monomorphically in a container.\n\u003c/p\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedTraversal",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedTraversal",
          "type": "newtype"
        },
        "index": {
          "description": "form of Traversal that can be stored monomorphically in container",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedTraversal",
          "package": "lens",
          "partial": "Reified Traversal",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eReifiedTraversal'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eReifiedTraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Reified",
          "name": "ReifiedTraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Reified.html#ReifiedTraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type ReifiedTraversal Simple ReifiedTraversal",
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "ReifiedTraversal'",
          "package": "lens",
          "partial": "Reified Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#t:ReifiedTraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Fold",
          "package": "lens",
          "signature": "Fold",
          "source": "src/Control-Lens-Reified.html#ReifiedFold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Fold",
          "package": "lens",
          "partial": "Fold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Getter",
          "package": "lens",
          "signature": "Getter",
          "source": "src/Control-Lens-Reified.html#ReifiedGetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Getter",
          "package": "lens",
          "partial": "Getter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Getter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "IndexedFold",
          "package": "lens",
          "signature": "IndexedFold",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedFold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "IndexedFold",
          "package": "lens",
          "partial": "Indexed Fold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:IndexedFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "IndexedGetter",
          "package": "lens",
          "signature": "IndexedGetter",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedGetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "IndexedGetter",
          "package": "lens",
          "partial": "Indexed Getter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:IndexedGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "IndexedLens",
          "package": "lens",
          "signature": "IndexedLens",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "IndexedLens",
          "package": "lens",
          "partial": "Indexed Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:IndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "IndexedSetter",
          "package": "lens",
          "signature": "IndexedSetter",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedSetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "IndexedSetter",
          "package": "lens",
          "partial": "Indexed Setter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:IndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "IndexedTraversal",
          "package": "lens",
          "signature": "IndexedTraversal",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedTraversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "IndexedTraversal",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:IndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Iso",
          "package": "lens",
          "signature": "Iso",
          "source": "src/Control-Lens-Reified.html#ReifiedIso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Iso",
          "package": "lens",
          "partial": "Iso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Lens",
          "package": "lens",
          "signature": "Lens",
          "source": "src/Control-Lens-Reified.html#ReifiedLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Lens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Prism",
          "package": "lens",
          "signature": "Prism",
          "source": "src/Control-Lens-Reified.html#ReifiedPrism",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Prism",
          "package": "lens",
          "partial": "Prism",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Prism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Setter",
          "package": "lens",
          "signature": "Setter",
          "source": "src/Control-Lens-Reified.html#ReifiedSetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Setter",
          "package": "lens",
          "partial": "Setter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Setter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "Traversal",
          "package": "lens",
          "signature": "Traversal",
          "source": "src/Control-Lens-Reified.html#ReifiedTraversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "Traversal",
          "package": "lens",
          "partial": "Traversal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:Traversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runFold",
          "package": "lens",
          "signature": "Fold s a",
          "source": "src/Control-Lens-Reified.html#ReifiedFold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runFold",
          "package": "lens",
          "partial": "Fold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runGetter",
          "package": "lens",
          "signature": "Getter s a",
          "source": "src/Control-Lens-Reified.html#ReifiedGetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runGetter",
          "package": "lens",
          "partial": "Getter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runIndexedFold",
          "package": "lens",
          "signature": "IndexedFold i s a",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedFold",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runIndexedFold",
          "package": "lens",
          "partial": "Indexed Fold",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runIndexedFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runIndexedGetter",
          "package": "lens",
          "signature": "IndexedGetter i s a",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedGetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runIndexedGetter",
          "package": "lens",
          "partial": "Indexed Getter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runIndexedGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runIndexedLens",
          "package": "lens",
          "signature": "IndexedLens i s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runIndexedLens",
          "package": "lens",
          "partial": "Indexed Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runIndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runIndexedSetter",
          "package": "lens",
          "signature": "IndexedSetter i s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedSetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runIndexedSetter",
          "package": "lens",
          "partial": "Indexed Setter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runIndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runIndexedTraversal",
          "package": "lens",
          "signature": "IndexedTraversal i s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedIndexedTraversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runIndexedTraversal",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runIndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runIso",
          "package": "lens",
          "signature": "Iso s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedIso",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runIso",
          "package": "lens",
          "partial": "Iso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runLens",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedLens",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runLens",
          "package": "lens",
          "partial": "Lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runPrism",
          "package": "lens",
          "signature": "Prism s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedPrism",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runPrism",
          "package": "lens",
          "partial": "Prism",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runPrism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runSetter",
          "package": "lens",
          "signature": "Setter s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedSetter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runSetter",
          "package": "lens",
          "partial": "Setter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Reified",
          "name": "runTraversal",
          "package": "lens",
          "signature": "Traversal s t a b",
          "source": "src/Control-Lens-Reified.html#ReifiedTraversal",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Reified",
          "module": "Control.Lens.Reified",
          "name": "runTraversal",
          "package": "lens",
          "partial": "Traversal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Reified.html#v:runTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e is a type-restricted form of a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e that can only be used for\n writing back via \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ereuse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Review",
          "name": "Review",
          "package": "lens",
          "source": "src/Control-Lens-Review.html",
          "type": "module"
        },
        "index": {
          "description": "Review is type-restricted form of Prism that can only be used for writing back via re review reuse",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "Review",
          "package": "lens",
          "partial": "Review",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf you see this in a signature for a function, the function is expecting a \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e\n (in practice, this usually means a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Control.Lens.Review",
          "name": "AReview",
          "package": "lens",
          "source": "src/Control-Lens-Review.html#AReview",
          "type": "type"
        },
        "index": {
          "description": "If you see this in signature for function the function is expecting Review in practice this usually means Prism",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "AReview",
          "package": "lens",
          "partial": "AReview",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:AReview"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eAReview\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Review",
          "name": "AReview'",
          "package": "lens",
          "source": "src/Control-Lens-Review.html#AReview%27",
          "type": "type"
        },
        "index": {
          "description": "Simple AReview",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "AReview'",
          "package": "lens",
          "partial": "AReview'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:AReview-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMinimal definition either \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eFormally, the class \u003ccode\u003e\u003ca\u003eBifunctor\u003c/a\u003e\u003c/code\u003e represents a bifunctor\n from \u003ccode\u003eHask\u003c/code\u003e -\u003e \u003ccode\u003eHask\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIntuitively it is a bifunctor where both the first and second arguments are covariant.\n\u003c/p\u003e\u003cp\u003eYou can define a \u003ccode\u003e\u003ca\u003eBifunctor\u003c/a\u003e\u003c/code\u003e by either defining \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e or by defining both\n \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf you supply \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e, you should ensure that:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf you supply \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e, ensure:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eIf you supply both, you should also ensure:\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e f g &#8801; \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e\u003cp\u003eThese ensure by parametricity:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e  (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g) (h \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e i) &#8801; \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e f h \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e g i\n \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e  (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g) &#8801; \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e  f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e  g\n \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g) &#8801; \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e g\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "Bifunctor",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "description": "Minimal definition either bimap or first and second Formally the class Bifunctor represents bifunctor from Hask Hask Intuitively it is bifunctor where both the first and second arguments are covariant You can define Bifunctor by either defining bimap or by defining both first and second If you supply bimap you should ensure that bimap id id id If you supply first and second ensure first id id second id id If you supply both you should also ensure bimap first second These ensure by parametricity bimap bimap bimap first first first second second second",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "Bifunctor",
          "package": "lens",
          "partial": "Bifunctor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:Bifunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a limited form of a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e that can only be used for \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e\u003cp\u003eLike with a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, there are no laws to state for a \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can generate a \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e by using \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e. You can also use any \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e\n directly as a \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Review",
          "name": "Review",
          "package": "lens",
          "source": "src/Control-Lens-Review.html#Review",
          "type": "type"
        },
        "index": {
          "description": "This is limited form of Prism that can only be used for re operations Like with Getter there are no laws to state for Review You can generate Review by using unto You can also use any Prism or Iso directly as Review",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "Review",
          "package": "lens",
          "partial": "Review",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:Review"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.Review",
          "name": "Review'",
          "package": "lens",
          "source": "src/Control-Lens-Review.html#Review%27",
          "type": "type"
        },
        "index": {
          "description": "Simple Review",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "Review'",
          "package": "lens",
          "partial": "Review'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:Review-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class is provided mostly for backwards compatibility with lens 3.8,\n but it can also shorten type signatures.\n\u003c/p\u003e",
          "module": "Control.Lens.Review",
          "name": "Reviewable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Review.html#Reviewable",
          "type": "class"
        },
        "index": {
          "description": "This class is provided mostly for backwards compatibility with lens but it can also shorten type signatures",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "Reviewable",
          "package": "lens",
          "partial": "Reviewable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#t:Reviewable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap over both arguments at the same time.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003ebimap\u003c/a\u003e\u003c/code\u003e f g &#8801; \u003ccode\u003e\u003ca\u003efirst\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esecond\u003c/a\u003e\u003c/code\u003e g\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "bimap",
          "package": "lens",
          "signature": "(a -\u003e b) -\u003e (c -\u003e d) -\u003e p a c -\u003e p b d",
          "type": "method"
        },
        "index": {
          "description": "Map over both arguments at the same time bimap first second",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "bimap",
          "normalized": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ee a c-\u003ee b d",
          "package": "lens",
          "signature": "(a-\u003eb)-\u003e(c-\u003ed)-\u003ep a c-\u003ep b d",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:bimap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e around to build a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf you have an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e is a more powerful version of this function\n that will return an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e instead of a mere \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5 ^.re _Left\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e6 ^.re (_Left.unto succ)\n\u003c/code\u003e\u003c/strong\u003eLeft 7\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e  &#8801; \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereuse\u003c/a\u003e\u003c/code\u003e   &#8801; \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e   \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereuses\u003c/a\u003e\u003c/code\u003e  &#8801; \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e  \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e b t\n \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b   -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e b t\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "re",
          "package": "lens",
          "signature": "AReview s t a b -\u003e Getter b t",
          "source": "src/Control-Lens-Review.html#re",
          "type": "function"
        },
        "index": {
          "description": "Turn Prism or Iso around to build Getter If you have an Iso from is more powerful version of this function that will return an Iso instead of mere Getter re Left Left re Left.unto succ Left review view re reviews views re reuse use re reuses uses re re Prism Getter re Iso Getter",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "re",
          "normalized": "AReview a b c d-\u003eGetter d b",
          "package": "lens",
          "signature": "AReview s t a b-\u003eGetter b t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:re"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis can be used to turn an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e around and \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e a value (or the current environment) through it the other way.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereuse\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereuse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003egets\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (reuse _Left) 5\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (reuse (unto succ)) 5\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a -\u003e m s\n \u003ccode\u003e\u003ca\u003ereuse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a   -\u003e m s\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "reuse",
          "package": "lens",
          "signature": "AReview s t a b -\u003e m t",
          "source": "src/Control-Lens-Review.html#reuse",
          "type": "function"
        },
        "index": {
          "description": "This can be used to turn an Iso or Prism around and use value or the current environment through it the other way reuse use re reuse unto gets evalState reuse Left Left evalState reuse unto succ reuse MonadState Prism reuse MonadState Iso",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "reuse",
          "normalized": "AReview a b c d-\u003ee b",
          "package": "lens",
          "signature": "AReview s t a b-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:reuse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis can be used to turn an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e around and \u003ccode\u003e\u003ca\u003euse\u003c/a\u003e\u003c/code\u003e the current state through it the other way,\n applying a function.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereuses\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003euses\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereuses\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e f) g &#8801; \u003ccode\u003e\u003ca\u003egets\u003c/a\u003e\u003c/code\u003e (g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (reuses _Left isLeft) (5 :: Int)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a -\u003e (s -\u003e r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ereuses\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a   -\u003e (s -\u003e r) -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "reuses",
          "package": "lens",
          "signature": "AReview s t a b -\u003e (t -\u003e r) -\u003e m r",
          "source": "src/Control-Lens-Review.html#reuses",
          "type": "function"
        },
        "index": {
          "description": "This can be used to turn an Iso or Prism around and use the current state through it the other way applying function reuses uses re reuses unto gets evalState reuses Left isLeft Int True reuses MonadState Prism reuses MonadState Iso",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "reuses",
          "normalized": "AReview a b c d-\u003e(b-\u003ee)-\u003ef e",
          "package": "lens",
          "signature": "AReview s t a b-\u003e(t-\u003er)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:reuses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis can be used to turn an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e around and \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e a value (or the current environment) through it the other way.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereview _Left \"mustard\"\n\u003c/code\u003e\u003c/strong\u003eLeft \"mustard\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereview (unto succ) 5\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e\u003cp\u003eUsually \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e is used in the \u003ccode\u003e(-\u003e)\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, in which case it may be useful to think of\n it as having one of these more restricted type signatures:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a   -\u003e a -\u003e s\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s\n\u003c/pre\u003e\u003cp\u003eHowever, when working with a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack, it is sometimes useful to be able to \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e the current environment, in which case one of\n these more slightly more liberal type signatures may be beneficial to think of it as having:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a   -\u003e m s\n \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a -\u003e m s\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "review",
          "package": "lens",
          "signature": "AReview s t a b -\u003e m t",
          "source": "src/Control-Lens-Review.html#review",
          "type": "function"
        },
        "index": {
          "description": "This can be used to turn an Iso or Prism around and view value or the current environment through it the other way review view re review unto id review Left mustard Left mustard review unto succ Usually review is used in the Monad with Prism or Iso in which case it may be useful to think of it as having one of these more restricted type signatures review Iso review Prism However when working with Monad transformer stack it is sometimes useful to be able to review the current environment in which case one of these more slightly more liberal type signatures may be beneficial to think of it as having review MonadReader Iso review MonadReader Prism",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "review",
          "normalized": "AReview a b c d-\u003ee b",
          "package": "lens",
          "signature": "AReview s t a b-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:review"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis can be used to turn an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e around and \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e a value (or the current environment) through it the other way,\n applying a function.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eviews\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e f) g &#8801; g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereviews _Left isRight \"mustard\"\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereviews (unto succ) (*2) 3\n\u003c/code\u003e\u003c/strong\u003e8\n\u003c/pre\u003e\u003cp\u003eUsually this function is used in the \u003ccode\u003e(-\u003e)\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, in which case it may be useful to think of\n it as having one of these more restricted type signatures:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a   -\u003e (s -\u003e r) -\u003e a -\u003e r\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a -\u003e (s -\u003e r) -\u003e a -\u003e r\n\u003c/pre\u003e\u003cp\u003eHowever, when working with a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack, it is sometimes useful to be able to \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e the current environment, in which case one of\n these more slightly more liberal type signatures may be beneficial to think of it as having:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a   -\u003e (s -\u003e r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadReader\u003c/a\u003e\u003c/code\u003e a m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a -\u003e (s -\u003e r) -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "reviews",
          "package": "lens",
          "signature": "AReview s t a b -\u003e (t -\u003e r) -\u003e m r",
          "source": "src/Control-Lens-Review.html#reviews",
          "type": "function"
        },
        "index": {
          "description": "This can be used to turn an Iso or Prism around and view value or the current environment through it the other way applying function reviews views re reviews unto reviews Left isRight mustard False reviews unto succ Usually this function is used in the Monad with Prism or Iso in which case it may be useful to think of it as having one of these more restricted type signatures reviews Iso reviews Prism However when working with Monad transformer stack it is sometimes useful to be able to review the current environment in which case one of these more slightly more liberal type signatures may be beneficial to think of it as having reviews MonadReader Iso reviews MonadReader Prism",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "reviews",
          "normalized": "AReview a b c d-\u003e(b-\u003ee)-\u003ef e",
          "package": "lens",
          "signature": "AReview s t a b-\u003e(t-\u003er)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:reviews"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e around to get a \u003ccode\u003e\u003ca\u003eReview\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eun\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eun\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eun (to length) # [1,2,3]\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "un",
          "package": "lens",
          "signature": "Getting a s a -\u003e Optic' p f a s",
          "source": "src/Control-Lens-Review.html#un",
          "type": "function"
        },
        "index": {
          "description": "Turn Getter around to get Review un unto view unto un to un to length",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "un",
          "normalized": "Getting a b a-\u003eOptic' c d a b",
          "package": "lens",
          "signature": "Getting a s a-\u003eOptic' p f a s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:un"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn analogue of \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e :: (b -\u003e t) -\u003e \u003ccode\u003e\u003ca\u003eReview'\u003c/a\u003e\u003c/code\u003e t b\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunto\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eun\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Review",
          "name": "unto",
          "package": "lens",
          "signature": "(b -\u003e t) -\u003e Optic p f s t a b",
          "source": "src/Control-Lens-Review.html#unto",
          "type": "function"
        },
        "index": {
          "description": "An analogue of to for review unto Review unto un to",
          "hierarchy": "Control Lens Review",
          "module": "Control.Lens.Review",
          "name": "unto",
          "normalized": "(a-\u003eb)-\u003eOptic c d e b f a",
          "package": "lens",
          "signature": "(b-\u003et)-\u003eOptic p f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Review.html#v:unto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b\u003c/code\u003e is a generalization of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e. It allows you to map into a\n structure and change out the contents, but it isn't strong enough to allow you to\n enumerate those contents. Starting with \u003ccode\u003e\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e b) -\u003e f a -\u003e f b\u003c/code\u003e\n we monomorphize the type to obtain \u003ccode\u003e(a -\u003e b) -\u003e s -\u003e t\u003c/code\u003e and then decorate it with \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e to obtain:\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b = (a -\u003e \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e b) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e t\n\u003c/pre\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, since \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEverything you can do with a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, you can do with a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e. There\n are combinators that generalize \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e and (\u003ccode\u003e\u003ca\u003e\u003c$\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Setter",
          "name": "Setter",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html",
          "type": "module"
        },
        "index": {
          "description": "Setter is generalization of fmap from Functor It allows you to map into structure and change out the contents but it isn strong enough to allow you to enumerate those contents Starting with fmap Functor we monomorphize the type to obtain and then decorate it with Identity to obtain type Setter Identity Identity Every Traversal is valid Setter since Identity is Applicative Everything you can do with Functor you can do with Setter There are combinators that generalize fmap and",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Setter",
          "package": "lens",
          "partial": "Setter",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRunning a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e instantiates it to a concrete type.\n\u003c/p\u003e\u003cp\u003eWhen consuming a setter directly to perform a mapping, you can use this type, but most\n user code will not need to use this type.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "ASetter",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html#ASetter",
          "type": "type"
        },
        "index": {
          "description": "Running Setter instantiates it to concrete type When consuming setter directly to perform mapping you can use this type but most user code will not need to use this type",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "ASetter",
          "package": "lens",
          "partial": "ASetter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:ASetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a useful alias for use when consuming a \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMost user code will never have to use this type.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eASetter'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eASetter\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "ASetter'",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html#ASetter%27",
          "type": "type"
        },
        "index": {
          "description": "This is useful alias for use when consuming Setter Most user code will never have to use this type type ASetter Simple ASetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "ASetter'",
          "package": "lens",
          "partial": "ASetter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:ASetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRunning an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e instantiates it to a concrete type.\n\u003c/p\u003e\u003cp\u003eWhen consuming a setter directly to perform a mapping, you can use this type, but most\n user code will not need to use this type.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "AnIndexedSetter",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html#AnIndexedSetter",
          "type": "type"
        },
        "index": {
          "description": "Running an IndexedSetter instantiates it to concrete type When consuming setter directly to perform mapping you can use this type but most user code will not need to use this type",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "AnIndexedSetter",
          "package": "lens",
          "partial": "An Indexed Setter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:AnIndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eAnIndexedSetter'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eAnIndexedSetter\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "AnIndexedSetter'",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html#AnIndexedSetter%27",
          "type": "type"
        },
        "index": {
          "description": "type AnIndexedSetter Simple AnIndexedSetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "AnIndexedSetter'",
          "package": "lens",
          "partial": "An Indexed Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:AnIndexedSetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentity functor and monad.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "Identity",
          "package": "lens",
          "type": "newtype"
        },
        "index": {
          "description": "Identity functor and monad",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Identity",
          "package": "lens",
          "partial": "Identity",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e laws are still required to hold.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "IndexedSetter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedSetter",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedSetter is valid Setter The Setter laws are still required to hold",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "IndexedSetter",
          "package": "lens",
          "partial": "Indexed Setter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:IndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexedSetter'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "IndexedSetter'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedSetter%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedSetter Simple IndexedSetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "IndexedSetter'",
          "package": "lens",
          "partial": "Indexed Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:IndexedSetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAnything \u003ccode\u003e\u003ca\u003eSettable\u003c/a\u003e\u003c/code\u003e must be isomorphic to the \u003ccode\u003e\u003ca\u003eIdentity\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "Settable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Setter.html#Settable",
          "type": "class"
        },
        "index": {
          "description": "Anything Settable must be isomorphic to the Identity Functor",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Settable",
          "package": "lens",
          "partial": "Settable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Settable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe only \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e law that can apply to a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e is that\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l y (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l x a) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l y a\n\u003c/pre\u003e\u003cp\u003eYou can't \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e in general, so the other two laws are irrelevant.\n\u003c/p\u003e\u003cp\u003eHowever, two \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e laws apply to a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l g &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003eThese can be stated more directly:\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n l f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euntainted\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l g &#8801; l (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euntainted\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003eYou can compose a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e\n and the result is always only a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e and nothing more.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover traverse f [a,b,c,d]\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c,f d]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _1 f (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (traverse._1) f [(a,b),(c,d)]\n\u003c/code\u003e\u003c/strong\u003e[(f a,b),(f c,d)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover both f (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,f b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (traverse.both) f [(a,b),(c,d)]\n\u003c/code\u003e\u003c/strong\u003e[(f a,f b),(f c,f d)]\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "Setter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Setter",
          "type": "type"
        },
        "index": {
          "description": "The only LensLike law that can apply to Setter is that set set set You can view Setter in general so the other two laws are irrelevant However two Functor laws apply to Setter over id id over over over These can be stated more directly pure pure untainted untainted You can compose Setter with Lens or Traversal using from the Prelude and the result is always only Setter and nothing more over traverse over over traverse over both over traverse.both",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Setter",
          "package": "lens",
          "partial": "Setter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e is just a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e that doesn't change the types.\n\u003c/p\u003e\u003cp\u003eThese are particularly common when talking about monomorphic containers. \u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003esets\u003c/code\u003e Data.Text.map :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "Setter'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Setter%27",
          "type": "type"
        },
        "index": {
          "description": "Setter is just Setter that doesn change the types These are particularly common when talking about monomorphic containers e.g sets Data.Text.map Setter Text Char type Setter Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Setter'",
          "package": "lens",
          "partial": "Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient alias when defining highly polymorphic code that takes both\n \u003ccode\u003e\u003ca\u003eASetter\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eAnIndexedSetter\u003c/a\u003e\u003c/code\u003e as appropriate. If a function takes this it is\n expecting one of those two things based on context.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "Setting",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html#Setting",
          "type": "type"
        },
        "index": {
          "description": "This is convenient alias when defining highly polymorphic code that takes both ASetter and AnIndexedSetter as appropriate If function takes this it is expecting one of those two things based on context",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Setting",
          "package": "lens",
          "partial": "Setting",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient alias when defining highly polymorphic code that takes both\n \u003ccode\u003e\u003ca\u003eASetter'\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eAnIndexedSetter'\u003c/a\u003e\u003c/code\u003e as appropriate. If a function takes this it is\n expecting one of those two things based on context.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "Setting'",
          "package": "lens",
          "source": "src/Control-Lens-Setter.html#Setting%27",
          "type": "type"
        },
        "index": {
          "description": "This is convenient alias when defining highly polymorphic code that takes both ASetter and AnIndexedSetter as appropriate If function takes this it is expecting one of those two things based on context",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Setting'",
          "package": "lens",
          "partial": "Setting'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#t:Setting-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Setter",
          "name": "Identity",
          "package": "lens",
          "signature": "Identity",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "Identity",
          "package": "lens",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:Identity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to map over the input of a \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe most common \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e to use this with is \u003ccode\u003e(-\u003e)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(argument %~ f) g x\n\u003c/code\u003e\u003c/strong\u003eg (f x)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(argument %~ show) length [1,2,3]\n\u003c/code\u003e\u003c/strong\u003e7\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(argument %~ f) h x y\n\u003c/code\u003e\u003c/strong\u003eh (f x) y\n\u003c/pre\u003e\u003cp\u003eMap over the argument of the result of a function -- i.e., its second\n argument:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(mapped.argument %~ f) h x y\n\u003c/code\u003e\u003c/strong\u003eh x (f y)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eargument\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e (b -\u003e r) (a -\u003e r) a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "argument",
          "package": "lens",
          "signature": "Setter (p b r) (p a r) a b",
          "source": "src/Control-Lens-Setter.html#argument",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to map over the input of Profunctor The most common Profunctor to use this with is argument argument show length argument Map over the argument of the result of function i.e its second argument mapped.argument argument Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "argument",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:argument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in our monadic\n state with a new value, irrespective of the old.\n\u003c/p\u003e\u003cp\u003eThis is an alias for (\u003ccode\u003e\u003ca\u003e.=\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do assign _1 c; assign _2 d) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(c,d)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (both .= c) (a,b)\n\u003c/code\u003e\u003c/strong\u003e(c,c)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eassign\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n \u003ccode\u003e\u003ca\u003eassign\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n \u003ccode\u003e\u003ca\u003eassign\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n \u003ccode\u003e\u003ca\u003eassign\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "assign",
          "package": "lens",
          "signature": "ASetter s s a b -\u003e b -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#assign",
          "type": "function"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal in our monadic state with new value irrespective of the old This is an alias for execState do assign assign execState both assign MonadState Iso assign MonadState Lens assign MonadState Traversal assign MonadState Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "assign",
          "normalized": "ASetter a a b c-\u003ec-\u003ed()",
          "package": "lens",
          "signature": "ASetter s s a b-\u003eb-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:assign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun an arrow command and use the output to set all the targets of\n a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to the result.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eassignA\u003c/a\u003e\u003c/code\u003e can be used very similarly to (\u003ccode\u003e\u003ca\u003e\u003c~\u003c/a\u003e\u003c/code\u003e), except that the type of\n the object being modified can change; for example:\n\u003c/p\u003e\u003cpre\u003e\n runKleisli action ((), (), ()) where\n   action =      assignA _1 (Kleisli (const getVal1))\n            \u003e\u003e\u003e assignA _2 (Kleisli (const getVal2))\n            \u003e\u003e\u003e assignA _3 (Kleisli (const getVal3))\n   getVal1 :: Either String Int\n   getVal1 = ...\n   getVal2 :: Either String Bool\n   getVal2 = ...\n   getVal3 :: Either String Char\n   getVal3 = ...\n\u003c/pre\u003e\u003cp\u003ehas the type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eassignA\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eArrow\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e p s b -\u003e p s t\n \u003ccode\u003e\u003ca\u003eassignA\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eArrow\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e p s b -\u003e p s t\n \u003ccode\u003e\u003ca\u003eassignA\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eArrow\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e p s b -\u003e p s t\n \u003ccode\u003e\u003ca\u003eassignA\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eArrow\u003c/a\u003e\u003c/code\u003e p =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e p s b -\u003e p s t\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "assignA",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e p s b -\u003e p s t",
          "source": "src/Control-Lens-Setter.html#assignA",
          "type": "function"
        },
        "index": {
          "description": "Run an arrow command and use the output to set all the targets of Lens Setter or Traversal to the result assignA can be used very similarly to except that the type of the object being modified can change for example runKleisli action where action assignA Kleisli const getVal1 assignA Kleisli const getVal2 assignA Kleisli const getVal3 getVal1 Either String Int getVal1 getVal2 Either String Bool getVal2 getVal3 Either String Char getVal3 has the type Either String Int Bool Char assignA Arrow Iso assignA Arrow Lens assignA Arrow Traversal assignA Arrow Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "assignA",
          "normalized": "ASetter a b c d-\u003ee a d-\u003ee a b",
          "package": "lens",
          "signature": "ASetter s t a b-\u003ep s b-\u003ep s t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:assignA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalization of \u003ccode\u003e\u003ca\u003ecensor\u003c/a\u003e\u003c/code\u003e that alows you to \u003ccode\u003e\u003ca\u003ecensor\u003c/a\u003e\u003c/code\u003e just a\n portion of the resulting \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "censoring",
          "package": "lens",
          "signature": "Setter w w u v -\u003e (u -\u003e v) -\u003e m a -\u003e m a",
          "source": "src/Control-Lens-Setter.html#censoring",
          "type": "function"
        },
        "index": {
          "description": "This is generalization of censor that alows you to censor just portion of the resulting MonadWriter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "censoring",
          "normalized": "Setter a a b c-\u003e(b-\u003ec)-\u003ed e-\u003ed e",
          "package": "lens",
          "signature": "Setter w w u v-\u003e(u-\u003ev)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:censoring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an \u003ccode\u003e\u003ca\u003eIndexPreservingSetter\u003c/a\u003e\u003c/code\u003e from any \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "cloneIndexPreservingSetter",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e IndexPreservingSetter s t a b",
          "source": "src/Control-Lens-Setter.html#cloneIndexPreservingSetter",
          "type": "function"
        },
        "index": {
          "description": "Build an IndexPreservingSetter from any Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "cloneIndexPreservingSetter",
          "normalized": "ASetter a b c d-\u003eIndexPreservingSetter a b c d",
          "package": "lens",
          "partial": "Index Preserving Setter",
          "signature": "ASetter s t a b-\u003eIndexPreservingSetter s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:cloneIndexPreservingSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "cloneIndexedSetter",
          "package": "lens",
          "signature": "AnIndexedSetter i s t a b -\u003e IndexedSetter i s t a b",
          "source": "src/Control-Lens-Setter.html#cloneIndexedSetter",
          "type": "function"
        },
        "index": {
          "description": "Clone an IndexedSetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "cloneIndexedSetter",
          "normalized": "AnIndexedSetter a b c d e-\u003eIndexedSetter a b c d e",
          "package": "lens",
          "partial": "Indexed Setter",
          "signature": "AnIndexedSetter i s t a b-\u003eIndexedSetter i s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:cloneIndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRestore \u003ccode\u003e\u003ca\u003eASetter\u003c/a\u003e\u003c/code\u003e to a full \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "cloneSetter",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e Setter s t a b",
          "source": "src/Control-Lens-Setter.html#cloneSetter",
          "type": "function"
        },
        "index": {
          "description": "Restore ASetter to full Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "cloneSetter",
          "normalized": "ASetter a b c d-\u003eSetter a b c d",
          "package": "lens",
          "partial": "Setter",
          "signature": "ASetter s t a b-\u003eSetter s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:cloneSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to map over all of the inputs to a \u003ccode\u003e\u003ca\u003eContravariant\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003econtramap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econtramapped\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egetPredicate (over contramapped (*2) (Predicate even)) 5\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003egetOp (over contramapped (*5) (Op show)) 100\n\u003c/code\u003e\u003c/strong\u003e\"500\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ePrelude.map ($ 1) $ over (mapped . _Unwrapping' Op . contramapped) (*12) [(*2),(+1),(^3)]\n\u003c/code\u003e\u003c/strong\u003e[24,13,1728]\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "contramapped",
          "package": "lens",
          "signature": "Setter (f b) (f a) a b",
          "source": "src/Control-Lens-Setter.html#contramapped",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to map over all of the inputs to Contravariant contramap over contramapped getPredicate over contramapped Predicate even True getOp over contramapped Op show Prelude.map over mapped Unwrapping Op contramapped",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "contramapped",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:contramapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalization of \u003ccode\u003e\u003ca\u003ecensor\u003c/a\u003e\u003c/code\u003e that alows you to \u003ccode\u003e\u003ca\u003ecensor\u003c/a\u003e\u003c/code\u003e just a\n portion of the resulting \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e, with access to the index of an\n \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "icensoring",
          "package": "lens",
          "signature": "IndexedSetter i w w u v -\u003e (i -\u003e u -\u003e v) -\u003e m a -\u003e m a",
          "source": "src/Control-Lens-Setter.html#icensoring",
          "type": "function"
        },
        "index": {
          "description": "This is generalization of censor that alows you to censor just portion of the resulting MonadWriter with access to the index of an IndexedSetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "icensoring",
          "normalized": "IndexedSetter a b b c d-\u003e(a-\u003ec-\u003ed)-\u003ee f-\u003ee f",
          "package": "lens",
          "signature": "IndexedSetter i w w u v-\u003e(i-\u003eu-\u003ev)-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:icensoring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eMap with index. (Deprecated alias for \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003eWhen you do not need access to the index, then \u003ccode\u003e\u003ca\u003emapOf\u003c/a\u003e\u003c/code\u003e is more liberal in what it can accept.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eimapOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eimapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e i s t a b    -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eimapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eimapOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "imapOf",
          "package": "lens",
          "signature": "AnIndexedSetter i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#imapOf",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use iover Map with index Deprecated alias for iover When you do not need access to the index then mapOf is more liberal in what it can accept mapOf imapOf const imapOf IndexedSetter imapOf IndexedLens imapOf IndexedTraversal",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "imapOf",
          "normalized": "AnIndexedSetter a b c d e-\u003e(a-\u003ed-\u003ee)-\u003eb-\u003ec",
          "package": "lens",
          "partial": "Of",
          "signature": "AnIndexedSetter i s t a b-\u003e(i-\u003ea-\u003eb)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:imapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap with index. This is an alias for \u003ccode\u003e\u003ca\u003eimapOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen you do not need access to the index, then \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e is more liberal in what it can accept.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e i s t a b    -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "iover",
          "package": "lens",
          "signature": "AnIndexedSetter i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#iover",
          "type": "function"
        },
        "index": {
          "description": "Map with index This is an alias for imapOf When you do not need access to the index then over is more liberal in what it can accept over iover const iover over Indexed iover IndexedSetter iover IndexedLens iover IndexedTraversal",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "iover",
          "normalized": "AnIndexedSetter a b c d e-\u003e(a-\u003ed-\u003ee)-\u003eb-\u003ec",
          "package": "lens",
          "signature": "AnIndexedSetter i s t a b-\u003e(i-\u003ea-\u003eb)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:iover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalization of \u003ccode\u003e\u003ca\u003epass\u003c/a\u003e\u003c/code\u003e that alows you to modify just a\n portion of the resulting \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e with access to the index of an\n \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "ipassing",
          "package": "lens",
          "signature": "IndexedSetter i w w u v -\u003e m (a, i -\u003e u -\u003e v) -\u003e m a",
          "source": "src/Control-Lens-Setter.html#ipassing",
          "type": "function"
        },
        "index": {
          "description": "This is generalization of pass that alows you to modify just portion of the resulting MonadWriter with access to the index of an IndexedSetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "ipassing",
          "normalized": "IndexedSetter a b b c d-\u003ee(f,a-\u003ec-\u003ed)-\u003ee f",
          "package": "lens",
          "signature": "IndexedSetter i w w u v-\u003em(a,i-\u003eu-\u003ev)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:ipassing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e from an \u003ccode\u003e\u003ca\u003eimap\u003c/a\u003e\u003c/code\u003e-like function.\n\u003c/p\u003e\u003cp\u003eYour supplied function \u003ccode\u003ef\u003c/code\u003e is required to satisfy:\n\u003c/p\u003e\u003cpre\u003e\n f \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n f g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f h &#8801; f (g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e h)\n\u003c/pre\u003e\u003cp\u003eEquational reasoning:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eisets\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eisets\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eAnother way to view \u003ccode\u003e\u003ca\u003esets\u003c/a\u003e\u003c/code\u003e is that it takes a \"semantic editor combinator\"\n and transforms it into a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "isets",
          "package": "lens",
          "signature": "((i -\u003e a -\u003e b) -\u003e s -\u003e t) -\u003e IndexedSetter i s t a b",
          "source": "src/Control-Lens-Setter.html#isets",
          "type": "function"
        },
        "index": {
          "description": "Build an IndexedSetter from an imap like function Your supplied function is required to satisfy id id Equational reasoning isets iover id iover isets id Another way to view sets is that it takes semantic editor combinator and transforms it into Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "isets",
          "normalized": "((a-\u003eb-\u003ec)-\u003ed-\u003ee)-\u003eIndexedSetter a d e b c",
          "package": "lens",
          "signature": "((i-\u003ea-\u003eb)-\u003es-\u003et)-\u003eIndexedSetter i s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:isets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003esetter\u003c/code\u003e can be used to modify all of the values in a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou sometimes have to use this rather than \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e -- due to\n temporary insanity \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e is not a superclass of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elifted\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover lifted f [a,b,c]\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset lifted b (Just a)\n\u003c/code\u003e\u003c/strong\u003eJust b\n\u003c/pre\u003e\u003cp\u003eIf you want an \u003ccode\u003e\u003ca\u003eIndexPreservingSetter\u003c/a\u003e\u003c/code\u003e use \u003ccode\u003e\u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eliftM\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "lifted",
          "package": "lens",
          "signature": "Setter (m a) (m b) a b",
          "source": "src/Control-Lens-Setter.html#lifted",
          "type": "function"
        },
        "index": {
          "description": "This setter can be used to modify all of the values in Monad You sometimes have to use this rather than mapped due to temporary insanity Functor is not superclass of Monad liftM over lifted over lifted set lifted Just Just If you want an IndexPreservingSetter use setting liftM",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "lifted",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:lifted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003emapOf\u003c/a\u003e\u003c/code\u003e is a deprecated alias for \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "mapOf",
          "package": "lens",
          "signature": "Setting p s t a b -\u003e p a b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#mapOf",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use over mapOf is deprecated alias for over",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "mapOf",
          "normalized": "Setting a b c d e-\u003ea d e-\u003eb-\u003ec",
          "package": "lens",
          "partial": "Of",
          "signature": "Setting p s t a b-\u003ep a b-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:mapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to map over all of the values in a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c$\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover mapped f [a,b,c]\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover mapped (+1) [1,2,3]\n\u003c/code\u003e\u003c/strong\u003e[2,3,4]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset mapped x [a,b,c]\n\u003c/code\u003e\u003c/strong\u003e[x,x,x]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[[a,b],[c]] & mapped.mapped +~ x\n\u003c/code\u003e\u003c/strong\u003e[[a + x,b + x],[c + x]]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (mapped._2) length [(\"hello\",\"world\"),(\"leaders\",\"!!!\")]\n\u003c/code\u003e\u003c/strong\u003e[(\"hello\",5),(\"leaders\",3)]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e (f a) (f b) a b\n\u003c/pre\u003e\u003cp\u003eIf you want an \u003ccode\u003e\u003ca\u003eIndexPreservingSetter\u003c/a\u003e\u003c/code\u003e use \u003ccode\u003e\u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "mapped",
          "package": "lens",
          "signature": "Setter (f a) (f b) a b",
          "source": "src/Control-Lens-Setter.html#mapped",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to map over all of the values in Functor fmap over mapped fmapDefault over traverse set mapped over mapped over mapped set mapped mapped.mapped over mapped length hello world leaders hello leaders mapped Functor Setter If you want an IndexPreservingSetter use setting fmap",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "mapped",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:mapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n with a function.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esets\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esets\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eGiven any valid \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e, you can also rely on the law:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l g = \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover mapped f (over mapped g [a,b,c]) == over mapped (f . g) [a,b,c]\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cp\u003eAnother way to view \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e is to say that it transforms a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e into a\n \"semantic editor combinator\".\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover mapped f (Just a)\n\u003c/code\u003e\u003c/strong\u003eJust (f a)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover mapped (*10) [1,2,3]\n\u003c/code\u003e\u003c/strong\u003e[10,20,30]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _1 f (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _1 show (10,20)\n\u003c/code\u003e\u003c/strong\u003e(\"10\",20)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e b) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eASetter\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e b) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "over",
          "package": "lens",
          "signature": "Setting p s t a b -\u003e p a b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#over",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Lens or all the targets of Setter or Traversal with function fmap over mapped fmapDefault over traverse sets over id over sets id Given any valid Setter you can also rely on the law over over over e.g over mapped over mapped over mapped True Another way to view over is to say that it transforms Setter into semantic editor combinator over mapped Just Just over mapped over over show over Setter over ASetter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "over",
          "normalized": "Setting a b c d e-\u003ea d e-\u003eb-\u003ec",
          "package": "lens",
          "signature": "Setting p s t a b-\u003ep a b-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:over"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a generalization of \u003ccode\u003e\u003ca\u003epass\u003c/a\u003e\u003c/code\u003e that alows you to modify just a\n portion of the resulting \u003ccode\u003e\u003ca\u003eMonadWriter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "passing",
          "package": "lens",
          "signature": "Setter w w u v -\u003e m (a, u -\u003e v) -\u003e m a",
          "source": "src/Control-Lens-Setter.html#passing",
          "type": "function"
        },
        "index": {
          "description": "This is generalization of pass that alows you to modify just portion of the resulting MonadWriter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "passing",
          "normalized": "Setter a a b c-\u003ed(e,b-\u003ec)-\u003ed e",
          "package": "lens",
          "signature": "Setter w w u v-\u003em(a,u-\u003ev)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:passing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Setter",
          "name": "runIdentity",
          "package": "lens",
          "signature": "a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "runIdentity",
          "package": "lens",
          "partial": "Identity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:runIdentity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite to a fragment of a larger \u003ccode\u003eWriter\u003c/code\u003e format.\n\u003c/p\u003e",
          "module": "Control.Lens.Setter",
          "name": "scribe",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e b -\u003e m ()",
          "source": "src/Control-Lens-Setter.html#scribe",
          "type": "function"
        },
        "index": {
          "description": "Write to fragment of larger Writer format",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "scribe",
          "normalized": "ASetter a b c d-\u003ed-\u003ee()",
          "package": "lens",
          "signature": "ASetter s t a b-\u003eb-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:scribe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e with a constant value.\n\u003c/p\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c$\u003c/a\u003e\u003c/code\u003e) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emapped\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset _2 \"hello\" (1,())\n\u003c/code\u003e\u003c/strong\u003e(1,\"hello\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset mapped () [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e[(),(),(),()]\n\u003c/pre\u003e\u003cp\u003eNote: Attempting to \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e will fail at compile time with an\n relatively nice error message.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b    -\u003e b -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e b -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e b -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e b -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "set",
          "package": "lens",
          "signature": "ASetter s t a b -\u003e b -\u003e s -\u003e t",
          "source": "src/Control-Lens-Setter.html#set",
          "type": "function"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal with constant value set mapped set hello hello set mapped Note Attempting to set Fold or Getter will fail at compile time with an relatively nice error message set Setter set Iso set Lens set Traversal",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "set",
          "normalized": "ASetter a b c d-\u003ed-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a b-\u003eb-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or all of the targets of a \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e\n or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e with a constant value, without changing its type.\n\u003c/p\u003e\u003cp\u003eThis is a type restricted version of \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e, which retains the type of the original.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset' mapped x [a,b,c,d]\n\u003c/code\u003e\u003c/strong\u003e[x,x,x,x]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset' _2 \"hello\" (1,\"world\")\n\u003c/code\u003e\u003c/strong\u003e(1,\"hello\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eset' mapped 0 [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e[0,0,0,0]\n\u003c/pre\u003e\u003cp\u003eNote: Attempting to adjust \u003ccode\u003e\u003ca\u003eset'\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e will fail at compile time with an\n relatively nice error message.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003eset'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003eset'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e s -\u003e s\n \u003ccode\u003e\u003ca\u003eset'\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e s -\u003e s\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "set'",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e s -\u003e s",
          "source": "src/Control-Lens-Setter.html#set%27",
          "type": "function"
        },
        "index": {
          "description": "Replace the target of Lens or all of the targets of Setter or Traversal with constant value without changing its type This is type restricted version of set which retains the type of the original set mapped set hello world hello set mapped Note Attempting to adjust set Fold or Getter will fail at compile time with an relatively nice error message set Setter set Iso set Lens set Traversal",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "set'",
          "normalized": "ASetter' a b-\u003eb-\u003ea-\u003ea",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003es-\u003es",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:set-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexPreservingSetter\u003c/a\u003e\u003c/code\u003e depending on your choice of \u003ccode\u003e\u003ca\u003eProfunctor\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esets\u003c/a\u003e\u003c/code\u003e :: ((a -\u003e b) -\u003e s -\u003e t) -\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "sets",
          "package": "lens",
          "signature": "(p a b -\u003e q s t) -\u003e Optical p q f s t a b",
          "source": "src/Control-Lens-Setter.html#sets",
          "type": "function"
        },
        "index": {
          "description": "Build Setter IndexedSetter or IndexPreservingSetter depending on your choice of Profunctor sets Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "sets",
          "normalized": "(a b c-\u003ed e f)-\u003eOptical a d g e f b c",
          "package": "lens",
          "signature": "(p a b-\u003eq s t)-\u003eOptical p q f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:sets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild an index-preserving \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e from a map-like function.\n\u003c/p\u003e\u003cp\u003eYour supplied function \u003ccode\u003ef\u003c/code\u003e is required to satisfy:\n\u003c/p\u003e\u003cpre\u003e\n f \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n f g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f h &#8801; f (g \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e h)\n\u003c/pre\u003e\u003cp\u003eEquational reasoning:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eAnother way to view \u003ccode\u003e\u003ca\u003esets\u003c/a\u003e\u003c/code\u003e is that it takes a \"semantic editor combinator\"\n and transforms it into a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e :: ((a -\u003e b) -\u003e s -\u003e t) -\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Setter",
          "name": "setting",
          "package": "lens",
          "signature": "((a -\u003e b) -\u003e s -\u003e t) -\u003e IndexPreservingSetter s t a b",
          "source": "src/Control-Lens-Setter.html#setting",
          "type": "function"
        },
        "index": {
          "description": "Build an index-preserving Setter from map-like function Your supplied function is required to satisfy id id Equational reasoning setting over id over setting id Another way to view sets is that it takes semantic editor combinator and transforms it into Setter setting Setter",
          "hierarchy": "Control Lens Setter",
          "module": "Control.Lens.Setter",
          "name": "setting",
          "normalized": "((a-\u003eb)-\u003ec-\u003ed)-\u003eIndexPreservingSetter c d a b",
          "package": "lens",
          "signature": "((a-\u003eb)-\u003es-\u003et)-\u003eIndexPreservingSetter s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Setter.html#v:setting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "TH",
          "package": "lens",
          "source": "src/Control-Lens-TH.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "TH",
          "package": "lens",
          "partial": "TH",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "FieldRules",
          "package": "lens",
          "source": "src/Control-Lens-TH.html#FieldRules",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "FieldRules",
          "package": "lens",
          "partial": "Field Rules",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#t:FieldRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlags for \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e construction\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "LensFlag",
          "package": "lens",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "data"
        },
        "index": {
          "description": "Flags for Lens construction",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "LensFlag",
          "package": "lens",
          "partial": "Lens Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#t:LensFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis configuration describes the options we'll be using to make\n isomorphisms or lenses.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "LensRules",
          "package": "lens",
          "source": "src/Control-Lens-TH.html#LensRules",
          "type": "data"
        },
        "index": {
          "description": "This configuration describes the options we ll be using to make isomorphisms or lenses",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "LensRules",
          "package": "lens",
          "partial": "Lens Rules",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#t:LensRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "BuildTraversals",
          "package": "lens",
          "signature": "BuildTraversals",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "BuildTraversals",
          "package": "lens",
          "partial": "Build Traversals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:BuildTraversals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "ClassRequired",
          "package": "lens",
          "signature": "ClassRequired",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "ClassRequired",
          "package": "lens",
          "partial": "Class Required",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:ClassRequired"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "CreateClass",
          "package": "lens",
          "signature": "CreateClass",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "CreateClass",
          "package": "lens",
          "partial": "Create Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:CreateClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "CreateInstance",
          "package": "lens",
          "signature": "CreateInstance",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "CreateInstance",
          "package": "lens",
          "partial": "Create Instance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:CreateInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "FieldRules",
          "package": "lens",
          "signature": "FieldRules ([String] -\u003e String -\u003e Maybe String) (String -\u003e String) (String -\u003e Maybe String) (String -\u003e Maybe String)",
          "source": "src/Control-Lens-TH.html#FieldRules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "FieldRules",
          "normalized": "FieldRules([String]-\u003eString-\u003eMaybe String)(String-\u003eString)(String-\u003eMaybe String)(String-\u003eMaybe String)",
          "package": "lens",
          "partial": "Field Rules",
          "signature": "FieldRules([String]-\u003eString-\u003eMaybe String)(String-\u003eString)(String-\u003eMaybe String)(String-\u003eMaybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:FieldRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "GenerateSignatures",
          "package": "lens",
          "signature": "GenerateSignatures",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "GenerateSignatures",
          "package": "lens",
          "partial": "Generate Signatures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:GenerateSignatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "HandleSingletons",
          "package": "lens",
          "signature": "HandleSingletons",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "HandleSingletons",
          "package": "lens",
          "partial": "Handle Singletons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:HandleSingletons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "LensRules",
          "package": "lens",
          "signature": "LensRules (String -\u003e Maybe String) (String -\u003e Maybe String) (String -\u003e Maybe (String, String)) (Set LensFlag)",
          "source": "src/Control-Lens-TH.html#LensRules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "LensRules",
          "normalized": "LensRules(String-\u003eMaybe String)(String-\u003eMaybe String)(String-\u003eMaybe(String,String))(Set LensFlag)",
          "package": "lens",
          "partial": "Lens Rules",
          "signature": "LensRules(String-\u003eMaybe String)(String-\u003eMaybe String)(String-\u003eMaybe(String,String))(Set LensFlag)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:LensRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "PartialLenses",
          "package": "lens",
          "signature": "PartialLenses",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "PartialLenses",
          "package": "lens",
          "partial": "Partial Lenses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:PartialLenses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "SimpleLenses",
          "package": "lens",
          "signature": "SimpleLenses",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "SimpleLenses",
          "package": "lens",
          "partial": "Simple Lenses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:SimpleLenses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "SingletonAndField",
          "package": "lens",
          "signature": "SingletonAndField",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "SingletonAndField",
          "package": "lens",
          "partial": "Singleton And Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:SingletonAndField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "SingletonIso",
          "package": "lens",
          "signature": "SingletonIso",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "SingletonIso",
          "package": "lens",
          "partial": "Singleton Iso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:SingletonIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "SingletonRequired",
          "package": "lens",
          "signature": "SingletonRequired",
          "source": "src/Control-Lens-TH.html#LensFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "SingletonRequired",
          "package": "lens",
          "partial": "Singleton Required",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:SingletonRequired"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIn the situations that a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e would be partial, when \u003ccode\u003e\u003ca\u003epartialLenses\u003c/a\u003e\u003c/code\u003e is\n used, this flag instead causes traversals to be generated. Only one can be\n used, and if neither are, then compile-time errors are generated.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "buildTraversals",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#buildTraversals",
          "type": "function"
        },
        "index": {
          "description": "In the situations that Lens would be partial when partialLenses is used this flag instead causes traversals to be generated Only one can be used and if neither are then compile-time errors are generated",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "buildTraversals",
          "package": "lens",
          "partial": "Traversals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:buildTraversals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField rules for fields in the form \u003ccode\u003e prefixFieldname or _prefixFieldname \u003c/code\u003e\n If you want all fields to be lensed, then there is no reason to use an \u003ccode\u003e_\u003c/code\u003e before the prefix.\n If any of the record fields leads with an \u003ccode\u003e_\u003c/code\u003e then it is assume a field without an \u003ccode\u003e_\u003c/code\u003e should not have a lens created.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "camelCaseFields",
          "package": "lens",
          "signature": "FieldRules",
          "source": "src/Control-Lens-TH.html#camelCaseFields",
          "type": "function"
        },
        "index": {
          "description": "Field rules for fields in the form prefixFieldname or prefixFieldname If you want all fields to be lensed then there is no reason to use an before the prefix If any of the record fields leads with an then it is assume field without an should not have lens created",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "camelCaseFields",
          "package": "lens",
          "partial": "Case Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:camelCaseFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDie if the \u003ccode\u003e\u003ca\u003elensClass\u003c/a\u003e\u003c/code\u003e fails to match.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "classRequired",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#classRequired",
          "type": "function"
        },
        "index": {
          "description": "Die if the lensClass fails to match",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "classRequired",
          "package": "lens",
          "partial": "Required",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:classRequired"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRules for making lenses and traversals that precompose another \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "classyRules",
          "package": "lens",
          "signature": "LensRules",
          "source": "src/Control-Lens-TH.html#classyRules",
          "type": "function"
        },
        "index": {
          "description": "Rules for making lenses and traversals that precompose another Lens",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "classyRules",
          "package": "lens",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:classyRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.TH",
          "name": "classyRules_",
          "package": "lens",
          "signature": "LensRules",
          "source": "src/Control-Lens-TH.html#classyRules_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "classyRules_",
          "package": "lens",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:classyRules_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the class if the constructor is \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e and the \u003ccode\u003e\u003ca\u003elensClass\u003c/a\u003e\u003c/code\u003e rule matches.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "createClass",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#createClass",
          "type": "function"
        },
        "index": {
          "description": "Create the class if the constructor is Simple and the lensClass rule matches",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "createClass",
          "package": "lens",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:createClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate the instance if the constructor is \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e and the \u003ccode\u003e\u003ca\u003elensClass\u003c/a\u003e\u003c/code\u003e rule matches.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "createInstance",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#createInstance",
          "type": "function"
        },
        "index": {
          "description": "Create the instance if the constructor is Simple and the lensClass rule matches",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "createInstance",
          "package": "lens",
          "partial": "Instance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:createInstance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor each record in the declaration quote, make lenses and traversals for\n it, and create a class when the type has no arguments. All record syntax\n in the input will be stripped off.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n declareClassy [d|\n   data Foo = Foo { fooX, fooY :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e }\n     deriving \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\n   |]\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n data Foo = Foo \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e deriving \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\n class HasFoo t where\n   foo :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e t Foo\n instance HasFoo Foo where foo = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n fooX, fooY :: HasFoo t =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e t \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e declareClassy = \u003ccode\u003e\u003ca\u003edeclareLensesWith\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eclassyRules\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e&\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elensField\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e)\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "declareClassy",
          "package": "lens",
          "signature": "Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareClassy",
          "type": "function"
        },
        "index": {
          "description": "For each record in the declaration quote make lenses and traversals for it and create class when the type has no arguments All record syntax in the input will be stripped off e.g declareClassy data Foo Foo fooX fooY Int deriving Show will create data Foo Foo Int Int deriving Show class HasFoo where foo Lens Foo instance HasFoo Foo where foo id fooX fooY HasFoo Lens Int declareClassy declareLensesWith classyRules lensField Just",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareClassy",
          "normalized": "Q[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Classy",
          "signature": "Q[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareClassy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003emakeClassyFor\u003c/a\u003e\u003c/code\u003e, but takes a declaration quote.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "declareClassyFor",
          "package": "lens",
          "signature": "[(String, (String, String))] -\u003e [(String, String)] -\u003e Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareClassyFor",
          "type": "function"
        },
        "index": {
          "description": "Similar to makeClassyFor but takes declaration quote",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareClassyFor",
          "normalized": "[(String,(String,String))]-\u003e[(String,String)]-\u003eQ[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Classy For",
          "signature": "[(String,(String,String))]-\u003e[(String,String)]-\u003eQ[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareClassyFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e declareFields = \u003ccode\u003e\u003ca\u003edeclareFieldsWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultFieldRules\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "declareFields",
          "package": "lens",
          "signature": "Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareFields",
          "type": "function"
        },
        "index": {
          "description": "declareFields declareFieldsWith defaultFieldRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareFields",
          "normalized": "Q[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Fields",
          "signature": "Q[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclare fields for each records in the given declarations, using the\n specified \u003ccode\u003e\u003ca\u003eFieldRules\u003c/a\u003e\u003c/code\u003e. Any record syntax in the input will be stripped\n off.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "declareFieldsWith",
          "package": "lens",
          "signature": "FieldRules -\u003e Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareFieldsWith",
          "type": "function"
        },
        "index": {
          "description": "Declare fields for each records in the given declarations using the specified FieldRules Any record syntax in the input will be stripped off",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareFieldsWith",
          "normalized": "FieldRules-\u003eQ[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Fields With",
          "signature": "FieldRules-\u003eQ[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareFieldsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor each datatype declaration, make a top level isomorphism injecting\n \u003cem\u003einto\u003c/em\u003e the type. The types are required to be for a type with a single\n constructor that has a single argument.\n\u003c/p\u003e\u003cp\u003eAll record syntax in the input will be stripped off.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n declareIso [d|\n   newtype WrappedInt = Wrap { unrwap :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e }\n   newtype \u003ccode\u003eList\u003c/code\u003e a = \u003ccode\u003eList\u003c/code\u003e [a]\n   |]\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n newtype WrappedList = Wrap \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n newtype List a = List [a]\n \u003ccode\u003ewrap\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e Int WrappedInt\n \u003ccode\u003eunwrap\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e WrappedInt Int\n \u003ccode\u003elist\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e [a] [b] (\u003ccode\u003eList\u003c/code\u003e a) (\u003ccode\u003eList\u003c/code\u003e b)\n\u003c/pre\u003e\u003cpre\u003e declareIso = \u003ccode\u003e\u003ca\u003edeclareLensesWith\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eisoRules\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e&\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elensField\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e)\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "declareIso",
          "package": "lens",
          "signature": "Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareIso",
          "type": "function"
        },
        "index": {
          "description": "For each datatype declaration make top level isomorphism injecting into the type The types are required to be for type with single constructor that has single argument All record syntax in the input will be stripped off e.g declareIso newtype WrappedInt Wrap unrwap Int newtype List List will create newtype WrappedList Wrap Int newtype List List wrap Iso Int WrappedInt unwrap Iso WrappedInt Int list Iso List List declareIso declareLensesWith isoRules lensField Just",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareIso",
          "normalized": "Q[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Iso",
          "signature": "Q[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake lenses for all records in the given declaration quote. All record\n syntax in the input will be stripped off.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n declareLenses [d|\n   data Foo = Foo { fooX, fooY :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e }\n     deriving \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\n   |]\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n data Foo = Foo \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e deriving \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e\n fooX, fooY :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e Foo Int\n\u003c/pre\u003e\u003cpre\u003e declareLenses = \u003ccode\u003e\u003ca\u003edeclareLensesWith\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003elensRules\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e&\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elensField\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e)\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "declareLenses",
          "package": "lens",
          "signature": "Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareLenses",
          "type": "function"
        },
        "index": {
          "description": "Make lenses for all records in the given declaration quote All record syntax in the input will be stripped off e.g declareLenses data Foo Foo fooX fooY Int deriving Show will create data Foo Foo Int Int deriving Show fooX fooY Lens Foo Int declareLenses declareLensesWith lensRules lensField Just",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareLenses",
          "normalized": "Q[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Lenses",
          "signature": "Q[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareLenses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003emakeLensesFor\u003c/a\u003e\u003c/code\u003e, but takes a declaration quote.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "declareLensesFor",
          "package": "lens",
          "signature": "[(String, String)] -\u003e Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareLensesFor",
          "type": "function"
        },
        "index": {
          "description": "Similar to makeLensesFor but takes declaration quote",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareLensesFor",
          "normalized": "[(String,String)]-\u003eQ[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Lenses For",
          "signature": "[(String,String)]-\u003eQ[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareLensesFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclare lenses for each records in the given declarations, using the\n specified \u003ccode\u003e\u003ca\u003eLensRules\u003c/a\u003e\u003c/code\u003e. Any record syntax in the input will be stripped\n off.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "declareLensesWith",
          "package": "lens",
          "signature": "LensRules -\u003e Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareLensesWith",
          "type": "function"
        },
        "index": {
          "description": "Declare lenses for each records in the given declarations using the specified LensRules Any record syntax in the input will be stripped off",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareLensesWith",
          "normalized": "LensRules-\u003eQ[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Lenses With",
          "signature": "LensRules-\u003eQ[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareLensesWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e for each constructor of each data type.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n declarePrisms [d|\n   data Exp = Lit Int | Var String | Lambda{ bound::String, body::Exp }\n   |]\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n data Exp = Lit Int | Var String | Lambda { bound::String, body::Exp }\n _Lit :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e Exp Int\n _Var :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e Exp String\n _Lambda :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e Exp (String, Exp)\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "declarePrisms",
          "package": "lens",
          "signature": "Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declarePrisms",
          "type": "function"
        },
        "index": {
          "description": "Generate Prism for each constructor of each data type e.g declarePrisms data Exp Lit Int Var String Lambda bound String body Exp will create data Exp Lit Int Var String Lambda bound String body Exp Lit Prism Exp Int Var Prism Exp String Lambda Prism Exp String Exp",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declarePrisms",
          "normalized": "Q[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Prisms",
          "signature": "Q[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declarePrisms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild \u003ccode\u003e\u003ca\u003eWrapped\u003c/a\u003e\u003c/code\u003e instance for each newtype.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "declareWrapped",
          "package": "lens",
          "signature": "Q [Dec] -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#declareWrapped",
          "type": "function"
        },
        "index": {
          "description": "Build Wrapped instance for each newtype",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "declareWrapped",
          "normalized": "Q[Dec]-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Wrapped",
          "signature": "Q[Dec]-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:declareWrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e defaultFieldRules = \u003ccode\u003e\u003ca\u003ecamelCaseFields\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "defaultFieldRules",
          "package": "lens",
          "signature": "FieldRules",
          "source": "src/Control-Lens-TH.html#defaultFieldRules",
          "type": "function"
        },
        "index": {
          "description": "defaultFieldRules camelCaseFields",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "defaultFieldRules",
          "package": "lens",
          "partial": "Field Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:defaultFieldRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault \u003ccode\u003e\u003ca\u003eLensRules\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "defaultRules",
          "package": "lens",
          "signature": "LensRules",
          "source": "src/Control-Lens-TH.html#defaultRules",
          "type": "function"
        },
        "index": {
          "description": "Default LensRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "defaultRules",
          "package": "lens",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:defaultRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndicate whether or not to supply the signatures for the generated\n lenses.\n\u003c/p\u003e\u003cp\u003eDisabling this can be useful if you want to provide a more restricted type\n signature or if you want to supply hand-written haddocks.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "generateSignatures",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#generateSignatures",
          "type": "function"
        },
        "index": {
          "description": "Indicate whether or not to supply the signatures for the generated lenses Disabling this can be useful if you want to provide more restricted type signature or if you want to supply hand-written haddocks",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "generateSignatures",
          "package": "lens",
          "partial": "Signatures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:generateSignatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHandle singleton constructors specially.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "handleSingletons",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#handleSingletons",
          "type": "function"
        },
        "index": {
          "description": "Handle singleton constructors specially",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "handleSingletons",
          "package": "lens",
          "partial": "Singletons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:handleSingletons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRules for making an isomorphism from a data type.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "isoRules",
          "package": "lens",
          "signature": "LensRules",
          "source": "src/Control-Lens-TH.html#isoRules",
          "type": "function"
        },
        "index": {
          "description": "Rules for making an isomorphism from data type",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "isoRules",
          "package": "lens",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:isoRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve options such as the name of the class and method to put in it to\n build a class around monomorphic data types.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "lensClass",
          "package": "lens",
          "signature": "Lens' LensRules (String -\u003e Maybe (String, String))",
          "source": "src/Control-Lens-TH.html#lensClass",
          "type": "function"
        },
        "index": {
          "description": "Retrieve options such as the name of the class and method to put in it to build class around monomorphic data types",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "lensClass",
          "normalized": "Lens' LensRules(String-\u003eMaybe(String,String))",
          "package": "lens",
          "partial": "Class",
          "signature": "Lens' LensRules(String-\u003eMaybe(String,String))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:lensClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e to access the convention for naming fields in our \u003ccode\u003e\u003ca\u003eLensRules\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eDefaults to stripping the _ off of the field name, lowercasing the name, and\n rejecting the field if it doesn't start with an '_'.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "lensField",
          "package": "lens",
          "signature": "Lens' LensRules (String -\u003e Maybe String)",
          "source": "src/Control-Lens-TH.html#lensField",
          "type": "function"
        },
        "index": {
          "description": "Lens to access the convention for naming fields in our LensRules Defaults to stripping the off of the field name lowercasing the name and rejecting the field if it doesn start with an",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "lensField",
          "normalized": "Lens' LensRules(String-\u003eMaybe String)",
          "package": "lens",
          "partial": "Field",
          "signature": "Lens' LensRules(String-\u003eMaybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:lensField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve options such as the name of the class and method to put in it to\n build a class around monomorphic data types.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "lensFlags",
          "package": "lens",
          "signature": "Lens' LensRules (Set LensFlag)",
          "source": "src/Control-Lens-TH.html#lensFlags",
          "type": "function"
        },
        "index": {
          "description": "Retrieve options such as the name of the class and method to put in it to build class around monomorphic data types",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "lensFlags",
          "package": "lens",
          "partial": "Flags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:lensFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e to access the convention for naming top level isomorphisms in our\n \u003ccode\u003e\u003ca\u003eLensRules\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eDefaults to lowercasing the first letter of the constructor.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "lensIso",
          "package": "lens",
          "signature": "Lens' LensRules (String -\u003e Maybe String)",
          "source": "src/Control-Lens-TH.html#lensIso",
          "type": "function"
        },
        "index": {
          "description": "Lens to access the convention for naming top level isomorphisms in our LensRules Defaults to lowercasing the first letter of the constructor",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "lensIso",
          "normalized": "Lens' LensRules(String-\u003eMaybe String)",
          "package": "lens",
          "partial": "Iso",
          "signature": "Lens' LensRules(String-\u003eMaybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:lensIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRules for making fairly simple partial lenses, ignoring the special cases\n for isomorphisms and traversals, and not making any classes.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "lensRules",
          "package": "lens",
          "signature": "LensRules",
          "source": "src/Control-Lens-TH.html#lensRules",
          "type": "function"
        },
        "index": {
          "description": "Rules for making fairly simple partial lenses ignoring the special cases for isomorphisms and traversals and not making any classes",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "lensRules",
          "package": "lens",
          "partial": "Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:lensRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake lenses and traversals for a type, and create a class when the\n type has no arguments.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n data Foo = Foo { _fooX, _fooY :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e }\n \u003ccode\u003e\u003ca\u003emakeClassy\u003c/a\u003e\u003c/code\u003e ''Foo\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n class HasFoo t where\n   foo :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e t Foo\n instance HasFoo Foo where foo = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n fooX, fooY :: HasFoo t =\u003e \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e t \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emakeClassy\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003emakeLensesWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eclassyRules\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makeClassy",
          "package": "lens",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeClassy",
          "type": "function"
        },
        "index": {
          "description": "Make lenses and traversals for type and create class when the type has no arguments e.g data Foo Foo fooX fooY Int makeClassy Foo will create class HasFoo where foo Simple Lens Foo instance HasFoo Foo where foo id fooX fooY HasFoo Simple Lens Int makeClassy makeLensesWith classyRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeClassy",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Classy",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeClassy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive lenses and traversals, using a named wrapper class, and\n specifying explicit pairings of \u003ccode\u003e(fieldName, traversalName)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eExample usage:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emakeClassyFor\u003c/a\u003e\u003c/code\u003e \"HasFoo\" \"foo\" [(\"_foo\", \"fooLens\"), (\"bar\", \"lbar\")] ''Foo\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makeClassyFor",
          "package": "lens",
          "signature": "String -\u003e String -\u003e [(String, String)] -\u003e Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeClassyFor",
          "type": "function"
        },
        "index": {
          "description": "Derive lenses and traversals using named wrapper class and specifying explicit pairings of fieldName traversalName Example usage makeClassyFor HasFoo foo foo fooLens bar lbar Foo",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeClassyFor",
          "normalized": "String-\u003eString-\u003e[(String,String)]-\u003eName-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Classy For",
          "signature": "String-\u003eString-\u003e[(String,String)]-\u003eName-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeClassyFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake lenses and traversals for a type, and create a class when the type\n has no arguments.  Works the same as \u003ccode\u003e\u003ca\u003emakeClassy\u003c/a\u003e\u003c/code\u003e except that (a) it\n expects that record field names do not begin with an underscore, (b) all\n record fields are made into lenses, and (c) the resulting lens is prefixed\n with an underscore.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "makeClassy_",
          "package": "lens",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeClassy_",
          "type": "function"
        },
        "index": {
          "description": "Make lenses and traversals for type and create class when the type has no arguments Works the same as makeClassy except that it expects that record field names do not begin with an underscore all record fields are made into lenses and the resulting lens is prefixed with an underscore",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeClassy_",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Classy",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeClassy_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate overloaded field accessors.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n data Foo a = Foo { _fooX :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e, _fooY : a }\n newtype Bar = Bar { _barX :: \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e }\n makeFields ''Foo\n makeFields ''Bar\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n _fooXLens :: Lens' (Foo a) Int\n _fooYLens :: Lens (Foo a) (Foo b) a b\n class HasX s a | s -\u003e a where\n   x :: Lens' s a\n instance HasX (Foo a) Int where\n   x = _fooXLens\n class HasY s a | s -\u003e a where\n   y :: Lens' s a\n instance HasY (Foo a) a where\n   y = _fooYLens\n _barXLens :: Iso' Bar Char\n instance HasX Bar Char where\n   x = _barXLens\n\u003c/pre\u003e\u003cpre\u003e\n makeFields = \u003ccode\u003e\u003ca\u003emakeFieldsWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edefaultFieldRules\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makeFields",
          "package": "lens",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeFields",
          "type": "function"
        },
        "index": {
          "description": "Generate overloaded field accessors e.g data Foo Foo fooX Int fooY newtype Bar Bar barX Char makeFields Foo makeFields Bar will create fooXLens Lens Foo Int fooYLens Lens Foo Foo class HasX where Lens instance HasX Foo Int where fooXLens class HasY where Lens instance HasY Foo where fooYLens barXLens Iso Bar Char instance HasX Bar Char where barXLens makeFields makeFieldsWith defaultFieldRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeFields",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Fields",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake fields with the specified \u003ccode\u003e\u003ca\u003eFieldRules\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "makeFieldsWith",
          "package": "lens",
          "signature": "FieldRules -\u003e Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeFieldsWith",
          "type": "function"
        },
        "index": {
          "description": "Make fields with the specified FieldRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeFieldsWith",
          "normalized": "FieldRules-\u003eName-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Fields With",
          "signature": "FieldRules-\u003eName-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeFieldsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a top level isomorphism injecting \u003cem\u003einto\u003c/em\u003e the type.\n\u003c/p\u003e\u003cp\u003eThe supplied name is required to be for a type with a single constructor\n that has a single argument.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n newtype \u003ccode\u003eList\u003c/code\u003e a = \u003ccode\u003eList\u003c/code\u003e [a]\n \u003ccode\u003e\u003ca\u003emakeIso\u003c/a\u003e\u003c/code\u003e ''List\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003elist\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e [a] [b] (\u003ccode\u003eList\u003c/code\u003e a) (\u003ccode\u003eList\u003c/code\u003e b)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emakeIso\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003emakeLensesWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eisoRules\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makeIso",
          "package": "lens",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeIso",
          "type": "function"
        },
        "index": {
          "description": "Make top level isomorphism injecting into the type The supplied name is required to be for type with single constructor that has single argument e.g newtype List List makeIso List will create list Iso List List makeIso makeLensesWith isoRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeIso",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Iso",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild lenses (and traversals) with a sensible default configuration.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n data FooBar\n   = Foo { _x, _y :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e }\n   | Bar { _x :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e }\n \u003ccode\u003e\u003ca\u003emakeLenses\u003c/a\u003e\u003c/code\u003e ''FooBar\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n x :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e FooBar \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n x f (Foo a b) = (a' -\u003e Foo a' b) \u003c$\u003e f a\n x f (Bar a)   = Bar \u003c$\u003e f a\n y :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e FooBar \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n y f (Foo a b) = (b' -\u003e Foo a  b') \u003c$\u003e f b\n y _ c@(Bar _) = pure c\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emakeLenses\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003emakeLensesWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003elensRules\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makeLenses",
          "package": "lens",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeLenses",
          "type": "function"
        },
        "index": {
          "description": "Build lenses and traversals with sensible default configuration e.g data FooBar Foo Int Bar Int makeLenses FooBar will create Lens FooBar Int Foo Foo Bar Bar Traversal FooBar Int Foo Foo Bar pure makeLenses makeLensesWith lensRules",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeLenses",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Lenses",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeLenses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDerive lenses and traversals, specifying explicit pairings\n of \u003ccode\u003e(fieldName, lensName)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf you map multiple names to the same label, and it is present in the same\n constructor then this will generate a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emakeLensesFor\u003c/a\u003e\u003c/code\u003e [(\"_foo\", \"fooLens\"), (\"baz\", \"lbaz\")] ''Foo\n \u003ccode\u003e\u003ca\u003emakeLensesFor\u003c/a\u003e\u003c/code\u003e [(\"_barX\", \"bar\"), (\"_barY\", \"bar\")] ''Bar\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makeLensesFor",
          "package": "lens",
          "signature": "[(String, String)] -\u003e Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeLensesFor",
          "type": "function"
        },
        "index": {
          "description": "Derive lenses and traversals specifying explicit pairings of fieldName lensName If you map multiple names to the same label and it is present in the same constructor then this will generate Traversal e.g makeLensesFor foo fooLens baz lbaz Foo makeLensesFor barX bar barY bar Bar",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeLensesFor",
          "normalized": "[(String,String)]-\u003eName-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Lenses For",
          "signature": "[(String,String)]-\u003eName-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeLensesFor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild lenses with a custom configuration.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "makeLensesWith",
          "package": "lens",
          "signature": "LensRules -\u003e Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makeLensesWith",
          "type": "function"
        },
        "index": {
          "description": "Build lenses with custom configuration",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeLensesWith",
          "normalized": "LensRules-\u003eName-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Lenses With",
          "signature": "LensRules-\u003eName-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeLensesWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e for each constructor of a data type.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n data FooBarBaz a\n   = Foo Int\n   | Bar a\n   | Baz Int Char\n makePrisms ''FooBarBaz\n\u003c/pre\u003e\u003cp\u003ewill create\n\u003c/p\u003e\u003cpre\u003e\n _Foo :: Prism' (FooBarBaz a) Int\n _Bar :: Prism (FooBarBaz a) (FooBarBaz b) a b\n _Baz :: Prism' (FooBarBaz a) (Int, Char)\n\u003c/pre\u003e",
          "module": "Control.Lens.TH",
          "name": "makePrisms",
          "package": "lens",
          "signature": "Name -\u003e Q [Dec]",
          "source": "src/Control-Lens-TH.html#makePrisms",
          "type": "function"
        },
        "index": {
          "description": "Generate Prism for each constructor of data type e.g data FooBarBaz Foo Int Bar Baz Int Char makePrisms FooBarBaz will create Foo Prism FooBarBaz Int Bar Prism FooBarBaz FooBarBaz Baz Prism FooBarBaz Int Char",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makePrisms",
          "normalized": "Name-\u003eQ[Dec]",
          "package": "lens",
          "partial": "Prisms",
          "signature": "Name-\u003eQ[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makePrisms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild \u003ccode\u003e\u003ca\u003eWrapped\u003c/a\u003e\u003c/code\u003e instance for a given newtype\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "makeWrapped",
          "package": "lens",
          "signature": "Name -\u003e DecsQ",
          "source": "src/Control-Lens-TH.html#makeWrapped",
          "type": "function"
        },
        "index": {
          "description": "Build Wrapped instance for given newtype",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "makeWrapped",
          "normalized": "Name-\u003eDecsQ",
          "package": "lens",
          "partial": "Wrapped",
          "signature": "Name-\u003eDecsQ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:makeWrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnables the generation of partial lenses, generating runtime errors for\n every constructor that does not have a valid definition for the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e. This\n occurs when the constructor lacks the field, or has multiple fields mapped\n to the same \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "partialLenses",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#partialLenses",
          "type": "function"
        },
        "index": {
          "description": "Enables the generation of partial lenses generating runtime errors for every constructor that does not have valid definition for the Lens This occurs when the constructor lacks the field or has multiple fields mapped to the same Lens",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "partialLenses",
          "package": "lens",
          "partial": "Lenses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:partialLenses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOnly Generate valid \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e lenses.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "simpleLenses",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#simpleLenses",
          "type": "function"
        },
        "index": {
          "description": "Only Generate valid Simple lenses",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "simpleLenses",
          "package": "lens",
          "partial": "Lenses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:simpleLenses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen building a singleton \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e) for a record constructor, build\n both the \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e) for the record and the one for the field.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "singletonAndField",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#singletonAndField",
          "type": "function"
        },
        "index": {
          "description": "When building singleton Iso or Lens for record constructor build both the Iso or Lens for the record and the one for the field",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "singletonAndField",
          "package": "lens",
          "partial": "And Field",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:singletonAndField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e for singleton constructors.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "singletonIso",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#singletonIso",
          "type": "function"
        },
        "index": {
          "description": "Use Iso for singleton constructors",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "singletonIso",
          "package": "lens",
          "partial": "Iso",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:singletonIso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpect a single constructor, single field newtype or data type.\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "singletonRequired",
          "package": "lens",
          "signature": "Lens' LensRules Bool",
          "source": "src/Control-Lens-TH.html#singletonRequired",
          "type": "function"
        },
        "index": {
          "description": "Expect single constructor single field newtype or data type",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "singletonRequired",
          "package": "lens",
          "partial": "Required",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:singletonRequired"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField rules for fields in the form \u003ccode\u003e _prefix_fieldname \u003c/code\u003e\n\u003c/p\u003e",
          "module": "Control.Lens.TH",
          "name": "underscoreFields",
          "package": "lens",
          "signature": "FieldRules",
          "source": "src/Control-Lens-TH.html#underscoreFields",
          "type": "function"
        },
        "index": {
          "description": "Field rules for fields in the form prefix fieldname",
          "hierarchy": "Control Lens TH",
          "module": "Control.Lens.TH",
          "name": "underscoreFields",
          "package": "lens",
          "partial": "Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-TH.html#v:underscoreFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\u003c/code\u003e is a generalization of \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e from\n \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e. It allows you to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e over a structure and change out\n its contents with monadic or \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e side-effects. Starting from\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e t, \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f) =\u003e (a -\u003e f b) -\u003e t a -\u003e f (t b)\n\u003c/pre\u003e\u003cp\u003ewe monomorphize the contents and result to obtain\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b = forall f. \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e\u003cp\u003eWhile a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e isn't quite a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, it _can_ be used for\n \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, because given a\n \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e \u003ccode\u003em\u003c/code\u003e, we have an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e\n for \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eConst\u003c/a\u003e\u003c/code\u003e m)\u003c/code\u003e. Everything you know how to do with a \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e\n container, you can with with a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, and here we provide\n combinators that generalize the usual \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Traversal",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html",
          "type": "module"
        },
        "index": {
          "description": "Traversal is generalization of traverse from Traversable It allows you to traverse over structure and change out its contents with monadic or Applicative side-effects Starting from traverse Traversable Applicative we monomorphize the contents and result to obtain type Traversal forall Applicative While Traversal isn quite Fold it can be used for Getting like Fold because given Monoid we have an Applicative for Const Everything you know how to do with Traversable container you can with with Traversal and here we provide combinators that generalize the usual Traversable operations",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversal",
          "package": "lens",
          "partial": "Traversal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#ATraversal",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal",
          "package": "lens",
          "partial": "ATraversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:ATraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eATraversal'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eATraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#ATraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type ATraversal Simple ATraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal'",
          "package": "lens",
          "partial": "ATraversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:ATraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects a \u003ccode\u003e\u003ca\u003eTraversal1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal1",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#ATraversal1",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects Traversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal1",
          "package": "lens",
          "partial": "ATraversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:ATraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eATraversal1'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eATraversal1\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#ATraversal1%27",
          "type": "type"
        },
        "index": {
          "description": "type ATraversal1 Simple ATraversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ATraversal1'",
          "package": "lens",
          "partial": "ATraversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:ATraversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#AnIndexedTraversal",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects an IndexedTraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal",
          "package": "lens",
          "partial": "An Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:AnIndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eAnIndexedTraversal'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eAnIndexedTraversal\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#AnIndexedTraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type AnIndexedTraversal Simple AnIndexedTraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal'",
          "package": "lens",
          "partial": "An Indexed Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:AnIndexedTraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects an \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal1",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#AnIndexedTraversal1",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects an IndexedTraversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal1",
          "package": "lens",
          "partial": "An Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:AnIndexedTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eAnIndexedTraversal1'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eAnIndexedTraversal1\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#AnIndexedTraversal1%27",
          "type": "type"
        },
        "index": {
          "description": "type AnIndexedTraversal1 Simple AnIndexedTraversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "AnIndexedTraversal1'",
          "package": "lens",
          "partial": "An Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:AnIndexedTraversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used to characterize a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ea.k.a. indexed Cartesian store comonad, indexed Kleene store comonad, or an indexed \u003ccode\u003eFunList\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://twanvl.nl/blog/haskell/non-regular1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e is like a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that has already been applied to some structure.\n\u003c/p\u003e\u003cp\u003eWhere a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds an \u003ccode\u003ea\u003c/code\u003e and a function from \u003ccode\u003eb\u003c/code\u003e to\n \u003ccode\u003et\u003c/code\u003e, a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds \u003ccode\u003eN\u003c/code\u003e \u003ccode\u003ea\u003c/code\u003es and a function from \u003ccode\u003eN\u003c/code\u003e\n \u003ccode\u003eb\u003c/code\u003es to \u003ccode\u003et\u003c/code\u003e, (where \u003ccode\u003eN\u003c/code\u003e might be infinite).\n\u003c/p\u003e\u003cp\u003eMnemonically, a \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e holds many stores and you can easily add more.\n\u003c/p\u003e\u003cp\u003eThis is a final encoding of \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar",
          "type": "newtype"
        },
        "index": {
          "description": "This is used to characterize Traversal a.k.a indexed Cartesian store comonad indexed Kleene store comonad or an indexed FunList http twanvl.nl blog haskell non-regular1 Bazaar is like Traversal that has already been applied to some structure Where Context holds an and function from to Bazaar holds and function from to where might be infinite Mnemonically Bazaar holds many stores and you can easily add more This is final encoding of Bazaar",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar",
          "package": "lens",
          "partial": "Bazaar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Bazaar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis alias is helpful when it comes to reducing repetition in type signatures.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eBazaar'\u003c/a\u003e\u003c/code\u003e p a t = \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e p a a t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar%27",
          "type": "type"
        },
        "index": {
          "description": "This alias is helpful when it comes to reducing repetition in type signatures type Bazaar Bazaar",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar'",
          "package": "lens",
          "partial": "Bazaar'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Bazaar-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is used to characterize a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003ea.k.a. indexed Cartesian store comonad, indexed Kleene store comonad, or an indexed \u003ccode\u003eFunList\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://twanvl.nl/blog/haskell/non-regular1\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e is like a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that has already been applied to some structure.\n\u003c/p\u003e\u003cp\u003eWhere a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eContext\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds an \u003ccode\u003ea\u003c/code\u003e and a function from \u003ccode\u003eb\u003c/code\u003e to\n \u003ccode\u003et\u003c/code\u003e, a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e a b t\u003c/code\u003e holds \u003ccode\u003eN\u003c/code\u003e \u003ccode\u003ea\u003c/code\u003es and a function from \u003ccode\u003eN\u003c/code\u003e\n \u003ccode\u003eb\u003c/code\u003es to \u003ccode\u003et\u003c/code\u003e, (where \u003ccode\u003eN\u003c/code\u003e might be infinite).\n\u003c/p\u003e\u003cp\u003eMnemonically, a \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e holds many stores and you can easily add more.\n\u003c/p\u003e\u003cp\u003eThis is a final encoding of \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar1",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar1",
          "type": "newtype"
        },
        "index": {
          "description": "This is used to characterize Traversal a.k.a indexed Cartesian store comonad indexed Kleene store comonad or an indexed FunList http twanvl.nl blog haskell non-regular1 Bazaar1 is like Traversal that has already been applied to some structure Where Context holds an and function from to Bazaar1 holds and function from to where might be infinite Mnemonically Bazaar1 holds many stores and you can easily add more This is final encoding of Bazaar1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar1",
          "package": "lens",
          "partial": "Bazaar",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Bazaar1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis alias is helpful when it comes to reducing repetition in type signatures.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eBazaar1'\u003c/a\u003e\u003c/code\u003e p a t = \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e p a a t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar1'",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Bazaar.html#Bazaar1%27",
          "type": "type"
        },
        "index": {
          "description": "This alias is helpful when it comes to reducing repetition in type signatures type Bazaar1 Bazaar1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Bazaar1'",
          "package": "lens",
          "partial": "Bazaar",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Bazaar1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e constraint is used to allow an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e to be used\n directly as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws are still required to hold.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedTraversal is valid Traversal or IndexedFold The Indexed constraint is used to allow an IndexedTraversal to be used directly as Traversal The Traversal laws are still required to hold",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:IndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedTraversal Simple IndexedTraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal'",
          "package": "lens",
          "partial": "Indexed Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:IndexedTraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal1",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:IndexedTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal1%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "IndexedTraversal1'",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:IndexedTraversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFunctors representing data structures that can be traversed from\n left to right.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances are similar to \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, e.g. given a data type\n\u003c/p\u003e\u003cpre\u003e data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)\n\u003c/pre\u003e\u003cp\u003ea suitable instance would be\n\u003c/p\u003e\u003cpre\u003e instance Traversable Tree where\n    traverse f Empty = pure Empty\n    traverse f (Leaf x) = Leaf \u003c$\u003e f x\n    traverse f (Node l k r) = Node \u003c$\u003e traverse f l \u003c*\u003e f k \u003c*\u003e traverse f r\n\u003c/pre\u003e\u003cp\u003eThis is suitable even for abstract types, as the laws for \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e\n imply a form of associativity.\n\u003c/p\u003e\u003cp\u003eThe superclass instances should satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e should be equivalent to traversal\n    with the identity applicative functor (\u003ccode\u003e\u003ca\u003efmapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e In the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e instance, \u003ccode\u003e\u003ca\u003efoldMap\u003c/a\u003e\u003c/code\u003e should be\n    equivalent to traversal with a constant applicative functor\n    (\u003ccode\u003e\u003ca\u003efoldMapDefault\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Traversable",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "description": "Functors representing data structures that can be traversed from left to right Minimal complete definition traverse or sequenceA Instances are similar to Functor e.g given data type data Tree Empty Leaf Node Tree Tree suitable instance would be instance Traversable Tree where traverse Empty pure Empty traverse Leaf Leaf traverse Node Node traverse traverse This is suitable even for abstract types as the laws for imply form of associativity The superclass instances should satisfy the following In the Functor instance fmap should be equivalent to traversal with the identity applicative functor fmapDefault In the Foldable instance foldMap should be equivalent to traversal with constant applicative functor foldMapDefault",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversable",
          "package": "lens",
          "partial": "Traversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "Traversable1",
          "package": "lens",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversable1",
          "package": "lens",
          "partial": "Traversable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversable1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e can be used directly as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (but not as a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e) and provides\n the ability to both read and update multiple fields, subject to some relatively weak \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e\u003cp\u003eThese have also been known as multilenses, but they have the signature and spirit of\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (f a) (f b) a b\n\u003c/pre\u003e\u003cp\u003eand the more evocative name suggests their application.\n\u003c/p\u003e\u003cp\u003eMost of the time the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e you will want to use is just \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e, but you can also pass any\n \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, and composition of a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e) with a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e)\n using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) forms a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe laws for a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003et\u003c/code\u003e follow from the laws for \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e as stated in \"The Essence of the Iterator Pattern\".\n\u003c/p\u003e\u003cpre\u003e\n t \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e (t f) \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e t g &#8801; \u003ccode\u003e\u003ca\u003egetCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e t (\u003ccode\u003e\u003ca\u003eCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003eOne consequence of this requirement is that a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e needs to leave the same number of elements as a\n candidate for subsequent \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that it started with. Another testament to the strength of these laws\n is that the caveat expressed in section 5.5 of the \"Essence of the Iterator Pattern\" about exotic\n \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e instances that \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the same entry multiple times was actually already ruled out by the\n second law in that same paper!\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Traversal",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal",
          "type": "type"
        },
        "index": {
          "description": "Traversal can be used directly as Setter or Fold but not as Lens and provides the ability to both read and update multiple fields subject to some relatively weak Traversal laws These have also been known as multilenses but they have the signature and spirit of traverse Traversable Traversal and the more evocative name suggests their application Most of the time the Traversal you will want to use is just traverse but you can also pass any Lens or Iso as Traversal and composition of Traversal or Lens or Iso with Traversal or Lens or Iso using forms valid Traversal The laws for Traversal follow from the laws for Traversable as stated in The Essence of the Iterator Pattern pure pure fmap getCompose Compose fmap One consequence of this requirement is that Traversal needs to leave the same number of elements as candidate for subsequent Traversal that it started with Another testament to the strength of these laws is that the caveat expressed in section of the Essence of the Iterator Pattern about exotic Traversable instances that traverse the same entry multiple times was actually already ruled out by the second law in that same paper",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversal",
          "package": "lens",
          "partial": "Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Traversal'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal%27",
          "type": "type"
        },
        "index": {
          "description": "type Traversal Simple Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversal'",
          "package": "lens",
          "partial": "Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "Traversal1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversal1",
          "package": "lens",
          "partial": "Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "Traversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal1%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversal1'",
          "package": "lens",
          "partial": "Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllows \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e of the value at the largest index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "TraverseMax",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#TraverseMax",
          "type": "class"
        },
        "index": {
          "description": "Allows IndexedTraversal of the value at the largest index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "TraverseMax",
          "package": "lens",
          "partial": "Traverse Max",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:TraverseMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllows \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e the value at the smallest index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "TraverseMin",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#TraverseMin",
          "type": "class"
        },
        "index": {
          "description": "Allows IndexedTraversal the value at the smallest index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "TraverseMin",
          "package": "lens",
          "partial": "Traverse Min",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:TraverseMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen you see this as an argument to a function, it expects\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e to be indexed if \u003ccode\u003ep\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i,\n\u003c/li\u003e\u003cli\u003e to be unindexed if \u003ccode\u003ep\u003c/code\u003e is \u003ccode\u003e(-\u003e)\u003c/code\u003e,\n\u003c/li\u003e\u003cli\u003e a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e if \u003ccode\u003ef\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e,\n\u003c/li\u003e\u003cli\u003e a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e if  \u003ccode\u003ef\u003c/code\u003e is only \u003ccode\u003eGettable\u003c/code\u003e,\n\u003c/li\u003e\u003cli\u003e a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e if \u003ccode\u003ep\u003c/code\u003e is only a \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e,\n\u003c/li\u003e\u003cli\u003e a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e if \u003ccode\u003ef\u003c/code\u003e is \u003ccode\u003eGettable\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Traversing",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#Traversing",
          "type": "type"
        },
        "index": {
          "description": "When you see this as an argument to function it expects to be indexed if is an instance of Indexed to be unindexed if is Traversal if is Applicative Getter if is only Gettable Lens if is only Functor Fold if is Gettable and Applicative",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversing",
          "package": "lens",
          "partial": "Traversing",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eTraversing'\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eTraversing\u003c/a\u003e\u003c/code\u003e f)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "Traversing'",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#Traversing%27",
          "type": "type"
        },
        "index": {
          "description": "type Traversing Simple Traversing",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversing'",
          "package": "lens",
          "partial": "Traversing'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversing-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "Traversing1",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#Traversing1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversing1",
          "package": "lens",
          "partial": "Traversing",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversing1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "Traversing1'",
          "package": "lens",
          "source": "src/Control-Lens-Traversal.html#Traversing1%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "Traversing1'",
          "package": "lens",
          "partial": "Traversing",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversing1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a different \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e to each side of a \u003ccode\u003e\u003ca\u003eBitraversable\u003c/a\u003e\u003c/code\u003e container.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b                -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s' t' a b                -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (r s s') (r t t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b       -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s' t' a b       -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i (r s s') (r t t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e s' t' a b -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e (r s s') (r t t') a b\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b                -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s' t' a b                -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (s,s') (t,t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b                     -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s' t' a b                     -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (s,s') (t,t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s' a                          -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s' a                        -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a                     -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s' a                      -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a                -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s' a                 -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m (s,s') a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b       -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s' t' a b       -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i (s,s') (t,t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b            -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s' t' a b            -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i (s,s') (t,t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a                -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s' a                 -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a              -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s' a               -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a            -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s' a             -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a       -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s' a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m (s,s') a\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e s' t' a b -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e (s,s') (t,t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingLens\u003c/a\u003e\u003c/code\u003e s' t' a b      -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e (s,s') (t,t') a b\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e s' a           -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e s' a         -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingAction\u003c/a\u003e\u003c/code\u003e m s a      -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingAction\u003c/a\u003e\u003c/code\u003e m s' a       -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingMonadicFold\u003c/a\u003e\u003c/code\u003e m (s,s') a\n \u003ccode\u003e\u003ca\u003ebeside\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexPreservingMonadicFold\u003c/a\u003e\u003c/code\u003e m s a -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingMonadicFold\u003c/a\u003e\u003c/code\u003e m s' a  -\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingMonadicFold\u003c/a\u003e\u003c/code\u003e m (s,s') a\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",[\"world\",\"!!!\"])^..beside id traverse\n\u003c/code\u003e\u003c/strong\u003e[\"hello\",\"world\",\"!!!\"]\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "beside",
          "package": "lens",
          "signature": "Optical p q f s t a b -\u003e Optical p q f s' t' a b -\u003e Optical p q f (r s s') (r t t') a b",
          "source": "src/Control-Lens-Traversal.html#beside",
          "type": "function"
        },
        "index": {
          "description": "Apply different Traversal or Fold to each side of Bitraversable container beside Traversal Traversal Traversal beside IndexedTraversal IndexedTraversal IndexedTraversal beside IndexPreservingTraversal IndexPreservingTraversal IndexPreservingTraversal beside Traversal Traversal Traversal beside Lens Lens Traversal beside Fold Fold Fold beside Getter Getter Fold beside Action Action MonadicFold beside MonadicFold MonadicFold MonadicFold beside IndexedTraversal IndexedTraversal IndexedTraversal beside IndexedLens IndexedLens IndexedTraversal beside IndexedFold IndexedFold IndexedFold beside IndexedGetter IndexedGetter IndexedFold beside IndexedAction IndexedAction IndexedMonadicFold beside IndexedMonadicFold IndexedMonadicFold IndexedMonadicFold beside IndexPreservingTraversal IndexPreservingTraversal IndexPreservingTraversal beside IndexPreservingLens IndexPreservingLens IndexPreservingTraversal beside IndexPreservingFold IndexPreservingFold IndexPreservingFold beside IndexPreservingGetter IndexPreservingGetter IndexPreservingFold beside IndexPreservingAction IndexPreservingAction IndexPreservingMonadicFold beside IndexPreservingMonadicFold IndexPreservingMonadicFold IndexPreservingMonadicFold hello world beside id traverse hello world",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "beside",
          "normalized": "Optical a b c d e f g-\u003eOptical a b c h i f g-\u003eOptical a b c(j d h)(j e i)f g",
          "package": "lens",
          "signature": "Optical p q f s t a b-\u003eOptical p q f s' t' a b-\u003eOptical p q f(r s s')(r t t')a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:beside"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse both parts of a \u003ccode\u003e\u003ca\u003eBitraversable\u003c/a\u003e\u003c/code\u003e container with matching types.\n\u003c/p\u003e\u003cp\u003eUsually that type will be a pair.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2) & both *~ 10\n\u003c/code\u003e\u003c/strong\u003e(10,20)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover both length (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(5,5)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\")^.both\n\u003c/code\u003e\u003c/strong\u003e\"helloworld\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eboth\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (a, a)       (b, b)       a b\n \u003ccode\u003e\u003ca\u003eboth\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a a) (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e b b) a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "both",
          "package": "lens",
          "signature": "Traversal (r a a) (r b b) a b",
          "source": "src/Control-Lens-Traversal.html#both",
          "type": "function"
        },
        "index": {
          "description": "Traverse both parts of Bitraversable container with matching types Usually that type will be pair both over both length hello world hello world both helloworld both Traversal both Traversal Either Either",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "both",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:both"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e yielding an \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e that passes through\n whatever index it is composed with.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexPreservingTraversal",
          "package": "lens",
          "signature": "ATraversal s t a b -\u003e IndexPreservingTraversal s t a b",
          "source": "src/Control-Lens-Traversal.html#cloneIndexPreservingTraversal",
          "type": "function"
        },
        "index": {
          "description": "Clone Traversal yielding an IndexPreservingTraversal that passes through whatever index it is composed with",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexPreservingTraversal",
          "normalized": "ATraversal a b c d-\u003eIndexPreservingTraversal a b c d",
          "package": "lens",
          "partial": "Index Preserving Traversal",
          "signature": "ATraversal s t a b-\u003eIndexPreservingTraversal s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:cloneIndexPreservingTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone a \u003ccode\u003e\u003ca\u003eTraversal1\u003c/a\u003e\u003c/code\u003e yielding an \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal1\u003c/a\u003e\u003c/code\u003e that passes through\n whatever index it is composed with.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexPreservingTraversal1",
          "package": "lens",
          "signature": "ATraversal1 s t a b -\u003e IndexPreservingTraversal1 s t a b",
          "source": "src/Control-Lens-Traversal.html#cloneIndexPreservingTraversal1",
          "type": "function"
        },
        "index": {
          "description": "Clone Traversal1 yielding an IndexPreservingTraversal1 that passes through whatever index it is composed with",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexPreservingTraversal1",
          "normalized": "ATraversal a b c d-\u003eIndexPreservingTraversal a b c d",
          "package": "lens",
          "partial": "Index Preserving Traversal",
          "signature": "ATraversal s t a b-\u003eIndexPreservingTraversal s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:cloneIndexPreservingTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e yielding an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with the same index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexedTraversal",
          "package": "lens",
          "signature": "AnIndexedTraversal i s t a b -\u003e IndexedTraversal i s t a b",
          "source": "src/Control-Lens-Traversal.html#cloneIndexedTraversal",
          "type": "function"
        },
        "index": {
          "description": "Clone an IndexedTraversal yielding an IndexedTraversal with the same index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexedTraversal",
          "normalized": "AnIndexedTraversal a b c d e-\u003eIndexedTraversal a b c d e",
          "package": "lens",
          "partial": "Indexed Traversal",
          "signature": "AnIndexedTraversal i s t a b-\u003eIndexedTraversal i s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:cloneIndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClone an \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e yielding an \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e with the same index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexedTraversal1",
          "package": "lens",
          "signature": "AnIndexedTraversal1 i s t a b -\u003e IndexedTraversal1 i s t a b",
          "source": "src/Control-Lens-Traversal.html#cloneIndexedTraversal1",
          "type": "function"
        },
        "index": {
          "description": "Clone an IndexedTraversal1 yielding an IndexedTraversal1 with the same index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "cloneIndexedTraversal1",
          "normalized": "AnIndexedTraversal a b c d e-\u003eIndexedTraversal a b c d e",
          "package": "lens",
          "partial": "Indexed Traversal",
          "signature": "AnIndexedTraversal i s t a b-\u003eIndexedTraversal i s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:cloneIndexedTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e is completely characterized by its behavior on a \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eCloning a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e is one way to make sure you aren't given\n something weaker, such as a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e and can be\n used as a way to pass around traversals that have to be monomorphic in \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: This only accepts a proper \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e). To clone a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n as such, use \u003ccode\u003e\u003ca\u003ecloneLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: It is usually better to use \u003ccode\u003e\u003ca\u003eReifiedTraversal\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003ereflectTraversal\u003c/a\u003e\u003c/code\u003e than to \u003ccode\u003e\u003ca\u003ecloneTraversal\u003c/a\u003e\u003c/code\u003e. The\n former can execute at full speed, while the latter needs to round trip through\n the \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet foo l a = (view (coerced (cloneTraversal l)) a, set (cloneTraversal l) 10 a)\n\u003c/code\u003e\u003c/strong\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efoo both (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"helloworld\",(10,10))\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecloneTraversal\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e (-\u003e) a b) s t a b -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "cloneTraversal",
          "package": "lens",
          "signature": "ATraversal s t a b -\u003e Traversal s t a b",
          "source": "src/Control-Lens-Traversal.html#cloneTraversal",
          "type": "function"
        },
        "index": {
          "description": "Traversal is completely characterized by its behavior on Bazaar Cloning Traversal is one way to make sure you aren given something weaker such as Fold and can be used as way to pass around traversals that have to be monomorphic in Note This only accepts proper Traversal or Lens To clone Lens as such use cloneLens Note It is usually better to use ReifiedTraversal and reflectTraversal than to cloneTraversal The former can execute at full speed while the latter needs to round trip through the Bazaar let foo view coerced cloneTraversal set cloneTraversal foo both hello world helloworld cloneTraversal LensLike Bazaar Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "cloneTraversal",
          "normalized": "ATraversal a b c d-\u003eTraversal a b c d",
          "package": "lens",
          "partial": "Traversal",
          "signature": "ATraversal s t a b-\u003eTraversal s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:cloneTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal1\u003c/a\u003e\u003c/code\u003e is completely characterized by its behavior on a \u003ccode\u003e\u003ca\u003eBazaar1\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "cloneTraversal1",
          "package": "lens",
          "signature": "ATraversal1 s t a b -\u003e Traversal1 s t a b",
          "source": "src/Control-Lens-Traversal.html#cloneTraversal1",
          "type": "function"
        },
        "index": {
          "description": "Traversal1 is completely characterized by its behavior on Bazaar1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "cloneTraversal1",
          "normalized": "ATraversal a b c d-\u003eTraversal a b c d",
          "package": "lens",
          "partial": "Traversal",
          "signature": "ATraversal s t a b-\u003eTraversal s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:cloneTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisit all but the first \u003cem\u003en\u003c/em\u003e targets of a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(\"hello\",\"world\") ^? dropping 1 both\n\u003c/code\u003e\u003c/strong\u003eJust \"world\"\n\u003c/pre\u003e\u003cp\u003eDropping works on infinite traversals as well:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1..] ^? dropping 1 folded\n\u003c/code\u003e\u003c/strong\u003eJust 2\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a                   -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a                        -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a                     -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a                -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a               -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a              -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a                -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a            -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n \u003ccode\u003e\u003ca\u003edropping\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a       -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "dropping",
          "package": "lens",
          "signature": "Int -\u003e Over p (Indexing f) s t a a -\u003e Over p f s t a a",
          "source": "src/Control-Lens-Traversal.html#dropping",
          "type": "function"
        },
        "index": {
          "description": "Visit all but the first targets of Traversal Fold Getter or Lens hello world dropping both Just world Dropping works on infinite traversals as well dropping folded Just dropping Int Traversal Traversal dropping Int Lens Traversal dropping Int Iso Traversal dropping Int Prism Traversal dropping Int Getter Fold dropping Int Fold Fold dropping Int Action MonadicFold dropping Int MonadicFold MonadicFold dropping Int IndexedTraversal IndexedTraversal dropping Int IndexedLens IndexedTraversal dropping Int IndexedGetter IndexedFold dropping Int IndexedFold IndexedFold dropping Int IndexedAction IndexedMonadicFold dropping Int IndexedMonadicFold IndexedMonadicFold",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "dropping",
          "normalized": "Int-\u003eOver a(Indexing b)c d e e-\u003eOver a b c d e e",
          "package": "lens",
          "signature": "Int-\u003eOver p(Indexing f)s t a a-\u003eOver p f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:dropping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the \u003cem\u003enth\u003c/em\u003e element of a \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e container.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eelement\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eelementOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "element",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int (t a) a",
          "source": "src/Control-Lens-Traversal.html#element",
          "type": "function"
        },
        "index": {
          "description": "Traverse the nth element of Traversable container element elementOf traverse",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "element",
          "normalized": "Int-\u003eIndexedTraversal' Int(a b)b",
          "package": "lens",
          "signature": "Int-\u003eIndexedTraversal' Int(t a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:element"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the \u003cem\u003enth\u003c/em\u003e element \u003ccode\u003e\u003ca\u003eelementOf\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e if it exists.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[[1],[3,4]] & elementOf (traverse.traverse) 1 .~ 5\n\u003c/code\u003e\u003c/strong\u003e[[1],[5,4]]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[[1],[3,4]] ^? elementOf (folded.folded) 1\n\u003c/code\u003e\u003c/strong\u003eJust 3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etimingOut $ ['a'..] ^?! elementOf folded 5\n\u003c/code\u003e\u003c/strong\u003e'f'\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etimingOut $ take 10 $ elementOf traverse 3 .~ 16 $ [0..]\n\u003c/code\u003e\u003c/strong\u003e[0,1,2,16,4,5,6,7,8,9]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eelementOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003eelementOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "elementOf",
          "package": "lens",
          "signature": "LensLike (Indexing f) s t a a -\u003e Int -\u003e IndexedLensLike Int f s t a a",
          "source": "src/Control-Lens-Traversal.html#elementOf",
          "type": "function"
        },
        "index": {
          "description": "Traverse the nth element elementOf Traversal Lens or Iso if it exists elementOf traverse.traverse elementOf folded.folded Just timingOut elementOf folded timingOut take elementOf traverse elementOf Traversal Int IndexedTraversal Int elementOf Fold Int IndexedFold Int",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "elementOf",
          "normalized": "LensLike(Indexing a)b c d d-\u003eInt-\u003eIndexedLensLike Int a b c d d",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike(Indexing f)s t a a-\u003eInt-\u003eIndexedLensLike Int f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:elementOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse elements of a \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e container where their ordinal positions matches a predicate.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eelements\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eelementsOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "elements",
          "package": "lens",
          "signature": "(Int -\u003e Bool) -\u003e IndexedTraversal' Int (t a) a",
          "source": "src/Control-Lens-Traversal.html#elements",
          "type": "function"
        },
        "index": {
          "description": "Traverse elements of Traversable container where their ordinal positions matches predicate elements elementsOf traverse",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "elements",
          "normalized": "(Int-\u003eBool)-\u003eIndexedTraversal' Int(a b)b",
          "package": "lens",
          "signature": "(Int-\u003eBool)-\u003eIndexedTraversal' Int(t a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:elements"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse (or fold) selected elements of a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e) where their ordinal positions match a predicate.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eelementsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e (\u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003eelementsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e (\u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "elementsOf",
          "package": "lens",
          "signature": "LensLike (Indexing f) s t a a -\u003e (Int -\u003e Bool) -\u003e IndexedLensLike Int f s t a a",
          "source": "src/Control-Lens-Traversal.html#elementsOf",
          "type": "function"
        },
        "index": {
          "description": "Traverse or fold selected elements of Traversal or Fold where their ordinal positions match predicate elementsOf Traversal Int Bool IndexedTraversal Int elementsOf Fold Int Bool IndexedFold Int",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "elementsOf",
          "normalized": "LensLike(Indexing a)b c d d-\u003e(Int-\u003eBool)-\u003eIndexedLensLike Int a b c d d",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike(Indexing f)s t a a-\u003e(Int-\u003eBool)-\u003eIndexedLensLike Int f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:elementsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry the first \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e), falling back on the second \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e) if it returns no entries.\n\u003c/p\u003e\u003cp\u003eThis is only a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e if the second \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e is disjoint from the result of the first or returns\n exactly the same results. These conditions are trivially met when given a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \"affine\" Traversal -- one that\n has 0 or 1 target.\n\u003c/p\u003e\u003cp\u003eMutatis mutandis for \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s t a b     -\u003e \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e s t a b     -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e\u003cp\u003eThese cases are also supported, trivially, but are boring, because the left hand side always succeeds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e s t a b  -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a        -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n\u003c/pre\u003e\u003cp\u003eIf both of the inputs are indexed, the result is also indexed, so you can apply this to a pair of indexed\n traversals or indexed folds, obtaining an indexed traversal or indexed fold.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n\u003c/pre\u003e\u003cp\u003eThese cases are also supported, trivially, but are boring, because the left hand side always succeeds.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b\n \u003ccode\u003e\u003ca\u003efailing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a        -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "failing",
          "package": "lens",
          "signature": "Traversing p f s t a b -\u003e Traversing p f s t a b -\u003e Over p f s t a b",
          "source": "src/Control-Lens-Traversal.html#failing",
          "type": "function"
        },
        "index": {
          "description": "Try the first Traversal or Fold falling back on the second Traversal or Fold if it returns no entries This is only valid Traversal if the second Traversal is disjoint from the result of the first or returns exactly the same results These conditions are trivially met when given Lens Iso Getter Prism or affine Traversal one that has or target Mutatis mutandis for Fold failing Traversal Traversal Traversal failing Prism Prism Traversal failing Fold Fold Fold These cases are also supported trivially but are boring because the left hand side always succeeds failing Lens Traversal Traversal failing Iso Traversal Traversal failing Equality Traversal Traversal failing Getter Fold Fold If both of the inputs are indexed the result is also indexed so you can apply this to pair of indexed traversals or indexed folds obtaining an indexed traversal or indexed fold failing IndexedTraversal IndexedTraversal IndexedTraversal failing IndexedFold IndexedFold IndexedFold These cases are also supported trivially but are boring because the left hand side always succeeds failing IndexedLens IndexedTraversal IndexedTraversal failing IndexedGetter IndexedGetter IndexedFold",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "failing",
          "normalized": "Traversing a b c d e f-\u003eTraversing a b c d e f-\u003eOver a b c d e f",
          "package": "lens",
          "signature": "Traversing p f s t a b-\u003eTraversing p f s t a b-\u003eOver p f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:failing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to map a function over this \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, failing if the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e has no targets.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efailover (element 3) (*2) [1,2] :: Maybe [Int]\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efailover _Left (*2) (Right 4) :: Maybe (Either Int Int)\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efailover _Right (*2) (Right 4) :: Maybe (Either Int Int)\n\u003c/code\u003e\u003c/strong\u003eJust (Right 8)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efailover\u003c/a\u003e\u003c/code\u003e :: Alternative m =\u003e Traversal s t a b -\u003e (a -\u003e b) -\u003e s -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "failover",
          "package": "lens",
          "signature": "Over p ((,) Any) s t a b -\u003e p a b -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#failover",
          "type": "function"
        },
        "index": {
          "description": "Try to map function over this Traversal failing if the Traversal has no targets failover element Maybe Int Nothing failover Left Right Maybe Either Int Int Nothing failover Right Right Maybe Either Int Int Just Right failover Alternative Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "failover",
          "normalized": "Over a((,)Any)b c d e-\u003ea d e-\u003eb-\u003ef c",
          "package": "lens",
          "signature": "Over p((,)Any)s t a b-\u003ep a b-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:failover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e is a flipped version of \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e, consistent with the definition of \u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eforMOf both (1,3) $ \\x -\u003e [x, x + 1]\n\u003c/code\u003e\u003c/strong\u003e[(1,3),(1,4),(2,3),(2,4)]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e l)\n \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e l s &#8801; \u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e l s \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e s -\u003e (a -\u003e m b) -\u003e m t\n \u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e s -\u003e (a -\u003e m b) -\u003e m t\n \u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e s -\u003e (a -\u003e m b) -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "forMOf",
          "package": "lens",
          "signature": "Over p (WrappedMonad m) s t a b -\u003e s -\u003e p a (m b) -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#forMOf",
          "type": "function"
        },
        "index": {
          "description": "forMOf is flipped version of mapMOf consistent with the definition of forM forMOf both forM forMOf traverse forMOf flip mapMOf iforMOf forM Indexed forMOf Monad Iso forMOf Monad Lens forMOf Monad Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "forMOf",
          "normalized": "Over a(WrappedMonad b)c d e f-\u003ec-\u003ea e(b f)-\u003eb d",
          "package": "lens",
          "partial": "MOf",
          "signature": "Over p(WrappedMonad m)s t a b-\u003es-\u003ep a(m b)-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:forMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e with the arguments flipped, such that:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eforOf each (1,2,3) print\n\u003c/code\u003e\u003c/strong\u003e1\n2\n3\n((),(),())\n\u003c/pre\u003e\u003cp\u003eThis function is only provided for consistency, \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e is strictly more general.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efor\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eifor\u003c/a\u003e\u003c/code\u003e l s &#8801; \u003ccode\u003e\u003ca\u003efor\u003c/a\u003e\u003c/code\u003e l s \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b -\u003e s -\u003e (a -\u003e f b) -\u003e f t\n \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b -\u003e s -\u003e (a -\u003e f b) -\u003e f t\n \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e s -\u003e (a -\u003e f b) -\u003e f t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "forOf",
          "package": "lens",
          "signature": "Over p f s t a b -\u003e s -\u003e p a (f b) -\u003e f t",
          "source": "src/Control-Lens-Traversal.html#forOf",
          "type": "function"
        },
        "index": {
          "description": "version of traverseOf with the arguments flipped such that forOf each print This function is only provided for consistency flip is strictly more general forOf flip forOf flip traverseOf for forOf traverse ifor for Indexed forOf Functor Iso forOf Functor Lens forOf Applicative Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "forOf",
          "normalized": "Over a b c d e f-\u003ec-\u003ea e(b f)-\u003eb d",
          "package": "lens",
          "partial": "Of",
          "signature": "Over p f s t a b-\u003es-\u003ep a(f b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:forOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe one-level version of \u003ccode\u003e\u003ca\u003econtextsOf\u003c/a\u003e\u003c/code\u003e. This extracts a list of the immediate children according to a given \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e as editable contexts.\n\u003c/p\u003e\u003cp\u003eGiven a context you can use \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e to see the values, \u003ccode\u003e\u003ca\u003epeek\u003c/a\u003e\u003c/code\u003e at what the structure would be like with an edited result, or simply \u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e the original structure.\n\u003c/p\u003e\u003cpre\u003e\n propChildren l x = childrenOf l x \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epos\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e l x)\n propId l x = \u003ccode\u003e\u003ca\u003eall\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e x) [\u003ccode\u003e\u003ca\u003eextract\u003c/a\u003e\u003c/code\u003e w | w \u003c- \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e l x]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a                -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e (-\u003e) a s]\n \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a               -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e (-\u003e) a s]\n \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a          -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e (-\u003e) a s]\n \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a      -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i) a s]\n \u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a -\u003e s -\u003e [\u003ccode\u003e\u003ca\u003ePretext'\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e i) a s]\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "holesOf",
          "package": "lens",
          "signature": "Over p (Bazaar p a a) s t a a -\u003e s -\u003e [Pretext p a a t]",
          "source": "src/Control-Lens-Traversal.html#holesOf",
          "type": "function"
        },
        "index": {
          "description": "The one-level version of contextsOf This extracts list of the immediate children according to given Traversal as editable contexts Given context you can use pos to see the values peek at what the structure would be like with an edited result or simply extract the original structure propChildren childrenOf map pos holesOf propId all extract holesOf holesOf Iso Pretext holesOf Lens Pretext holesOf Traversal Pretext holesOf IndexedLens Pretext Indexed holesOf IndexedTraversal Pretext Indexed",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "holesOf",
          "normalized": "Over a(Bazaar a b b)c d b b-\u003ec-\u003e[Pretext a b b d]",
          "package": "lens",
          "partial": "Of",
          "signature": "Over p(Bazaar p a a)s t a a-\u003es-\u003e[Pretext p a a t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:holesOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to map a function which uses the index over this \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e, failing if the \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e has no targets.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eifailover\u003c/a\u003e\u003c/code\u003e :: Alternative m =\u003e IndexedTraversal i s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ifailover",
          "package": "lens",
          "signature": "Over (Indexed i) ((,) Any) s t a b -\u003e (i -\u003e a -\u003e b) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#ifailover",
          "type": "function"
        },
        "index": {
          "description": "Try to map function which uses the index over this IndexedTraversal failing if the IndexedTraversal has no targets ifailover Alternative IndexedTraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ifailover",
          "normalized": "Over(Indexed a)((,)Any)b c d e-\u003e(a-\u003ed-\u003ee)-\u003eb-\u003ef c",
          "package": "lens",
          "signature": "Over(Indexed i)((,)Any)s t a b-\u003e(i-\u003ea-\u003eb)-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:ifailover"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure targeted by a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to a monadic action,\n evaluate these actions from left to right, and collect the results, with access\n its position (and the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforMOf\u003c/a\u003e\u003c/code\u003e l a &#8801; \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e l a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e s -\u003e (i -\u003e a -\u003e m b) -\u003e m t\n \u003ccode\u003e\u003ca\u003eiforMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e s -\u003e (i -\u003e a -\u003e m b) -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "iforMOf",
          "package": "lens",
          "signature": "(Indexed i a (WrappedMonad m b) -\u003e s -\u003e WrappedMonad m t) -\u003e s -\u003e (i -\u003e a -\u003e m b) -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#iforMOf",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure targeted by Lens to monadic action evaluate these actions from left to right and collect the results with access its position and the arguments flipped forMOf iforMOf const iforMOf flip imapMOf iforMOf Monad IndexedLens iforMOf Monad IndexedTraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "iforMOf",
          "normalized": "(Indexed a b(WrappedMonad c d)-\u003ee-\u003eWrappedMonad c f)-\u003ee-\u003e(a-\u003eb-\u003ec d)-\u003ec f",
          "package": "lens",
          "partial": "MOf",
          "signature": "(Indexed i a(WrappedMonad m b)-\u003es-\u003eWrappedMonad m t)-\u003es-\u003e(i-\u003ea-\u003em b)-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:iforMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse with an index (and the arguments flipped).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eforOf\u003c/a\u003e\u003c/code\u003e l a &#8801; \u003ccode\u003e\u003ca\u003eiforOf\u003c/a\u003e\u003c/code\u003e l a \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eiforOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eiforOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b       -\u003e s -\u003e (i -\u003e a -\u003e f b) -\u003e f t\n \u003ccode\u003e\u003ca\u003eiforOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b  -\u003e s -\u003e (i -\u003e a -\u003e f b) -\u003e f t\n \u003ccode\u003e\u003ca\u003eiforOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003eApply\u003c/code\u003e f       =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e s -\u003e (i -\u003e a -\u003e f b) -\u003e f t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "iforOf",
          "package": "lens",
          "signature": "(Indexed i a (f b) -\u003e s -\u003e f t) -\u003e s -\u003e (i -\u003e a -\u003e f b) -\u003e f t",
          "source": "src/Control-Lens-Traversal.html#iforOf",
          "type": "function"
        },
        "index": {
          "description": "Traverse with an index and the arguments flipped forOf iforOf const iforOf flip itraverseOf iforOf Functor IndexedLens iforOf Applicative IndexedTraversal iforOf Apply IndexedTraversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "iforOf",
          "normalized": "(Indexed a b(c d)-\u003ee-\u003ec f)-\u003ee-\u003e(a-\u003eb-\u003ec d)-\u003ec f",
          "package": "lens",
          "partial": "Of",
          "signature": "(Indexed i a(f b)-\u003es-\u003ef t)-\u003es-\u003e(i-\u003ea-\u003ef b)-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:iforOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the trivial empty \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eignored\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s s a b\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eignored\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e6 & ignored %~ absurd\n\u003c/code\u003e\u003c/strong\u003e6\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ignored",
          "package": "lens",
          "signature": "pafb -\u003e s -\u003e f s",
          "source": "src/Control-Lens-Traversal.html#ignored",
          "type": "function"
        },
        "index": {
          "description": "This is the trivial empty Traversal ignored IndexedTraversal ignored const pure ignored absurd",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ignored",
          "normalized": "a-\u003eb-\u003ec b",
          "package": "lens",
          "signature": "pafb-\u003es-\u003ef s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:ignored"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e allows you to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the individual stores in\n a \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e with access to their indices.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "iloci",
          "package": "lens",
          "signature": "IndexedTraversal i (Bazaar (Indexed i) a c s) (Bazaar (Indexed i) b c s) a b",
          "source": "src/Control-Lens-Traversal.html#iloci",
          "type": "function"
        },
        "index": {
          "description": "This IndexedTraversal allows you to traverse the individual stores in Bazaar with access to their indices",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "iloci",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:iloci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralizes \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e to an arbitrary \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eimapAccumLOf\u003c/a\u003e\u003c/code\u003e accumulates state from left to right.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eimapAccumLOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eimapAccumLOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003eimapAccumLOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "imapAccumLOf",
          "package": "lens",
          "signature": "Over (Indexed i) (State acc) s t a b -\u003e (i -\u003e acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)",
          "source": "src/Control-Lens-Traversal.html#imapAccumLOf",
          "type": "function"
        },
        "index": {
          "description": "Generalizes mapAccumL to an arbitrary IndexedTraversal with access to the index imapAccumLOf accumulates state from left to right mapAccumLOf imapAccumLOf const imapAccumLOf IndexedLens acc acc acc acc imapAccumLOf IndexedTraversal acc acc acc acc",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "imapAccumLOf",
          "normalized": "Over(Indexed a)(State b)c d e f-\u003e(a-\u003eb-\u003ee-\u003e(b,f))-\u003eb-\u003ec-\u003e(b,d)",
          "package": "lens",
          "partial": "Accum LOf",
          "signature": "Over(Indexed i)(State acc)s t a b-\u003e(i-\u003eacc-\u003ea-\u003e(acc,b))-\u003eacc-\u003es-\u003e(acc,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:imapAccumLOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralizes \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e to an arbitrary \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e with access to the index.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eimapAccumROf\u003c/a\u003e\u003c/code\u003e accumulates state from right to left.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eimapAccumROf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eimapAccumROf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b      -\u003e (i -\u003e acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003eimapAccumROf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "imapAccumROf",
          "package": "lens",
          "signature": "Over (Indexed i) (Backwards (State acc)) s t a b -\u003e (i -\u003e acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)",
          "source": "src/Control-Lens-Traversal.html#imapAccumROf",
          "type": "function"
        },
        "index": {
          "description": "Generalizes mapAccumR to an arbitrary IndexedTraversal with access to the index imapAccumROf accumulates state from right to left mapAccumROf imapAccumROf const imapAccumROf IndexedLens acc acc acc acc imapAccumROf IndexedTraversal acc acc acc acc",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "imapAccumROf",
          "normalized": "Over(Indexed a)(Backwards(State b))c d e f-\u003e(a-\u003eb-\u003ee-\u003e(b,f))-\u003eb-\u003ec-\u003e(b,d)",
          "package": "lens",
          "partial": "Accum ROf",
          "signature": "Over(Indexed i)(Backwards(State acc))s t a b-\u003e(i-\u003eacc-\u003ea-\u003e(acc,b))-\u003eacc-\u003es-\u003e(acc,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:imapAccumROf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure targeted by a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to a monadic action,\n evaluate these actions from left to right, and collect the results, with access\n its position.\n\u003c/p\u003e\u003cp\u003eWhen you don't need access to the index \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e is more liberal in what it can accept.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e       i s t a b -\u003e (i -\u003e a -\u003e m b) -\u003e s -\u003e m t\n \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e  i s t a b -\u003e (i -\u003e a -\u003e m b) -\u003e s -\u003e m t\n \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003eBind\u003c/code\u003e  m =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e m b) -\u003e s -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "imapMOf",
          "package": "lens",
          "signature": "(Indexed i a (WrappedMonad m b) -\u003e s -\u003e WrappedMonad m t) -\u003e (i -\u003e a -\u003e m b) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#imapMOf",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure targeted by Lens to monadic action evaluate these actions from left to right and collect the results with access its position When you don need access to the index mapMOf is more liberal in what it can accept mapMOf imapMOf const imapMOf Monad IndexedLens imapMOf Monad IndexedTraversal imapMOf Bind IndexedTraversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "imapMOf",
          "normalized": "(Indexed a b(WrappedMonad c d)-\u003ee-\u003eWrappedMonad c f)-\u003e(a-\u003eb-\u003ec d)-\u003ee-\u003ec f",
          "package": "lens",
          "partial": "MOf",
          "signature": "(Indexed i a(WrappedMonad m b)-\u003es-\u003eWrappedMonad m t)-\u003e(i-\u003ea-\u003em b)-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:imapMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn indexed version of \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e that receives the entire list of indices as its index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ipartsOf",
          "package": "lens",
          "signature": "Traversing (Indexed i) f s t a a -\u003e Over p f s t [a] [a]",
          "source": "src/Control-Lens-Traversal.html#ipartsOf",
          "type": "function"
        },
        "index": {
          "description": "An indexed version of partsOf that receives the entire list of indices as its index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ipartsOf",
          "normalized": "Traversing(Indexed a)b c d e e-\u003eOver f b c d[e][e]",
          "package": "lens",
          "partial": "Of",
          "signature": "Traversing(Indexed i)f s t a a-\u003eOver p f s t[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:ipartsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type-restricted version of \u003ccode\u003e\u003ca\u003eipartsOf\u003c/a\u003e\u003c/code\u003e that can only be used with an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "ipartsOf'",
          "package": "lens",
          "signature": "Over (Indexed i) (Bazaar' (Indexed i) a) s t a a -\u003e Over p f s t [a] [a]",
          "source": "src/Control-Lens-Traversal.html#ipartsOf%27",
          "type": "function"
        },
        "index": {
          "description": "type-restricted version of ipartsOf that can only be used with an IndexedTraversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "ipartsOf'",
          "normalized": "Over(Indexed a)(Bazaar'(Indexed a)b)c d b b-\u003eOver e f c d[b][b]",
          "package": "lens",
          "partial": "Of'",
          "signature": "Over(Indexed i)(Bazaar'(Indexed i)a)s t a a-\u003eOver p f s t[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:ipartsOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraversal with an index.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNB:\u003c/em\u003e When you don't need access to the index then you can just apply your \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e\n directly as a function!\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003ewithIndex\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e l = \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f     =\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b       -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t\n \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b  -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t\n \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003eApply\u003c/code\u003e f       =\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "itraverseOf",
          "package": "lens",
          "signature": "(Indexed i a (f b) -\u003e s -\u003e f t) -\u003e (i -\u003e a -\u003e f b) -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Traversal.html#itraverseOf",
          "type": "function"
        },
        "index": {
          "description": "Traversal with an index NB When you don need access to the index then you can just apply your IndexedTraversal directly as function itraverseOf withIndex traverseOf itraverseOf const id itraverseOf Functor IndexedLens itraverseOf Applicative IndexedTraversal itraverseOf Apply IndexedTraversal1",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "itraverseOf",
          "normalized": "(Indexed a b(c d)-\u003ee-\u003ec f)-\u003e(a-\u003eb-\u003ec d)-\u003ee-\u003ec f",
          "package": "lens",
          "partial": "Of",
          "signature": "(Indexed i a(f b)-\u003es-\u003ef t)-\u003e(i-\u003ea-\u003ef b)-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:itraverseOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn indexed version of \u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e that receives the entire list of indices as its index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "iunsafePartsOf",
          "package": "lens",
          "signature": "Traversing (Indexed i) f s t a b -\u003e Over p f s t [a] [b]",
          "source": "src/Control-Lens-Traversal.html#iunsafePartsOf",
          "type": "function"
        },
        "index": {
          "description": "An indexed version of unsafePartsOf that receives the entire list of indices as its index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "iunsafePartsOf",
          "normalized": "Traversing(Indexed a)b c d e f-\u003eOver g b c d[e][f]",
          "package": "lens",
          "partial": "Parts Of",
          "signature": "Traversing(Indexed i)f s t a b-\u003eOver p f s t[a][b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:iunsafePartsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "iunsafePartsOf'",
          "package": "lens",
          "signature": "forall i s t a b.  Over (Indexed i) (Bazaar (Indexed i) a b) s t a b -\u003e IndexedLens [i] s t [a] [b]",
          "source": "src/Control-Lens-Traversal.html#iunsafePartsOf%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "iunsafePartsOf'",
          "normalized": "a b c d e f Over(Indexed b)(Bazaar(Indexed b)e g)c d e g-\u003eIndexedLens[b]c d[e][g]",
          "package": "lens",
          "partial": "Parts Of'",
          "signature": "forall i s t a b. Over(Indexed i)(Bazaar(Indexed i)a b)s t a b-\u003eIndexedLens[i]s t[a][b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:iunsafePartsOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e allows you to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the individual stores in a \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "loci",
          "package": "lens",
          "signature": "Traversal (Bazaar (-\u003e) a c s) (Bazaar (-\u003e) b c s) a b",
          "source": "src/Control-Lens-Traversal.html#loci",
          "type": "function"
        },
        "index": {
          "description": "This Traversal allows you to traverse the individual stores in Bazaar",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "loci",
          "normalized": "Traversal(Bazaar(-\u003e)a b c)(Bazaar(-\u003e)d b c)a d",
          "package": "lens",
          "signature": "Traversal(Bazaar(-\u003e)a c s)(Bazaar(-\u003e)b c s)a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:loci"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis generalizes \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e to an arbitrary \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumL\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e accumulates \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e from left to right.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e acc) s t a b -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003emapAccumLOf\u003c/a\u003e\u003c/code\u003e l f acc0 s = \u003ccode\u003e\u003ca\u003eswap\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003erunState\u003c/a\u003e\u003c/code\u003e (l (a -\u003e \u003ccode\u003e\u003ca\u003estate\u003c/a\u003e\u003c/code\u003e (acc -\u003e \u003ccode\u003e\u003ca\u003eswap\u003c/a\u003e\u003c/code\u003e (f acc a))) s) acc0)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "mapAccumLOf",
          "package": "lens",
          "signature": "Over p (State acc) s t a b -\u003e p acc (a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)",
          "source": "src/Control-Lens-Traversal.html#mapAccumLOf",
          "type": "function"
        },
        "index": {
          "description": "This generalizes mapAccumL to an arbitrary Traversal mapAccumL mapAccumLOf traverse mapAccumLOf accumulates State from left to right mapAccumLOf Iso acc acc acc acc mapAccumLOf Lens acc acc acc acc mapAccumLOf Traversal acc acc acc acc mapAccumLOf LensLike State acc acc acc acc acc mapAccumLOf acc0 swap runState state acc swap acc acc0",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "mapAccumLOf",
          "normalized": "Over a(State b)c d e f-\u003ea b(e-\u003e(b,f))-\u003eb-\u003ec-\u003e(b,d)",
          "package": "lens",
          "partial": "Accum LOf",
          "signature": "Over p(State acc)s t a b-\u003ep acc(a-\u003e(acc,b))-\u003eacc-\u003es-\u003e(acc,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:mapAccumLOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis generalizes \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e to an arbitrary \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumR\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e accumulates \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e from right to left.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n \u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapAccumROf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eBackwards\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e acc)) s t a b -\u003e (acc -\u003e a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "mapAccumROf",
          "package": "lens",
          "signature": "Over p (Backwards (State acc)) s t a b -\u003e p acc (a -\u003e (acc, b)) -\u003e acc -\u003e s -\u003e (acc, t)",
          "source": "src/Control-Lens-Traversal.html#mapAccumROf",
          "type": "function"
        },
        "index": {
          "description": "This generalizes mapAccumR to an arbitrary Traversal mapAccumR mapAccumROf traverse mapAccumROf accumulates State from right to left mapAccumROf Iso acc acc acc acc mapAccumROf Lens acc acc acc acc mapAccumROf Traversal acc acc acc acc mapAccumROf LensLike Backwards State acc acc acc acc acc",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "mapAccumROf",
          "normalized": "Over a(Backwards(State b))c d e f-\u003ea b(e-\u003e(b,f))-\u003eb-\u003ec-\u003e(b,d)",
          "package": "lens",
          "partial": "Accum ROf",
          "signature": "Over p(Backwards(State acc))s t a b-\u003ep acc(a-\u003e(acc,b))-\u003eacc-\u003es-\u003e(acc,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:mapAccumROf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure targeted by a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to a monadic action,\n evaluate these actions from left to right, and collect the results.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapMOf both (\\x -\u003e [x, x + 1]) (1,3)\n\u003c/code\u003e\u003c/strong\u003e[(1,3),(1,4),(2,3),(2,4)]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eimapMOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eforM\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e m b) -\u003e s -\u003e m t\n \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e m b) -\u003e s -\u003e m t\n \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e m b) -\u003e s -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "mapMOf",
          "package": "lens",
          "signature": "Over p (WrappedMonad m) s t a b -\u003e p a (m b) -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#mapMOf",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure targeted by Lens to monadic action evaluate these actions from left to right and collect the results mapMOf both mapM mapMOf traverse imapMOf forM Indexed mapMOf Monad Iso mapMOf Monad Lens mapMOf Monad Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "mapMOf",
          "normalized": "Over a(WrappedMonad b)c d e f-\u003ea e(b f)-\u003ec-\u003eb d",
          "package": "lens",
          "partial": "MOf",
          "signature": "Over p(WrappedMonad m)s t a b-\u003ep a(m b)-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:mapMOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e turns a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that resembles an early version of the \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e) type.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e You should really try to maintain the invariant of the number of children in the list.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c) & partsOf each .~ [x,y,z]\n\u003c/code\u003e\u003c/strong\u003e(x,y,z)\n\u003c/pre\u003e\u003cp\u003eAny extras will be lost. If you do not supply enough, then the remainder will come from the original structure.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c) & partsOf each .~ [w,x,y,z]\n\u003c/code\u003e\u003c/strong\u003e(w,x,y)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a,b,c) & partsOf each .~ [x,y]\n\u003c/code\u003e\u003c/strong\u003e(x,y,c)\n\u003c/pre\u003e\u003cp\u003eSo technically, this is only a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e if you do not change the number of results it returns.\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e the result is merely a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s [a]\n \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s [a]\n \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s [a]\n \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s [a]\n \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "partsOf",
          "package": "lens",
          "signature": "Traversing (-\u003e) f s t a a -\u003e LensLike f s t [a] [a]",
          "source": "src/Control-Lens-Traversal.html#partsOf",
          "type": "function"
        },
        "index": {
          "description": "partsOf turns Traversal into Lens that resembles an early version of the uniplate or biplate type Note You should really try to maintain the invariant of the number of children in the list partsOf each Any extras will be lost If you do not supply enough then the remainder will come from the original structure partsOf each partsOf each So technically this is only Lens if you do not change the number of results it returns When applied to Fold the result is merely Getter partsOf Iso Lens partsOf Lens Lens partsOf Traversal Lens partsOf Fold Getter partsOf Getter Getter",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "partsOf",
          "normalized": "Traversing(-\u003e)a b c d d-\u003eLensLike a b c[d][d]",
          "package": "lens",
          "partial": "Of",
          "signature": "Traversing(-\u003e)f s t a a-\u003eLensLike f s t[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:partsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type-restricted version of \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e that can only be used with a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "partsOf'",
          "package": "lens",
          "signature": "ATraversal s t a a -\u003e Lens s t [a] [a]",
          "source": "src/Control-Lens-Traversal.html#partsOf%27",
          "type": "function"
        },
        "index": {
          "description": "type-restricted version of partsOf that can only be used with Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "partsOf'",
          "normalized": "ATraversal a b c c-\u003eLens a b[c][c]",
          "package": "lens",
          "partial": "Of'",
          "signature": "ATraversal s t a a-\u003eLens s t[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:partsOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis permits the use of \u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e over an arbitrary \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003escanl1Of\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003escanl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003escanl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a      -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003escanl1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "scanl1Of",
          "package": "lens",
          "signature": "LensLike (State (Maybe a)) s t a a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Traversal.html#scanl1Of",
          "type": "function"
        },
        "index": {
          "description": "This permits the use of scanl1 over an arbitrary Traversal or Lens scanl1 scanl1Of traverse scanl1Of Iso scanl1Of Lens scanl1Of Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "scanl1Of",
          "normalized": "LensLike(State(Maybe a))b c a a-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ec",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike(State(Maybe a))s t a a-\u003e(a-\u003ea-\u003ea)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:scanl1Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis permits the use of \u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e over an arbitrary \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003escanr1Of\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003escanr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a a       -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003escanr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a      -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t\n \u003ccode\u003e\u003ca\u003escanr1Of\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "scanr1Of",
          "package": "lens",
          "signature": "LensLike (Backwards (State (Maybe a))) s t a a -\u003e (a -\u003e a -\u003e a) -\u003e s -\u003e t",
          "source": "src/Control-Lens-Traversal.html#scanr1Of",
          "type": "function"
        },
        "index": {
          "description": "This permits the use of scanr1 over an arbitrary Traversal or Lens scanr1 scanr1Of traverse scanr1Of Iso scanr1Of Lens scanr1Of Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "scanr1Of",
          "normalized": "LensLike(Backwards(State(Maybe a)))b c a a-\u003e(a-\u003ea-\u003ea)-\u003eb-\u003ec",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike(Backwards(State(Maybe a)))s t a a-\u003e(a-\u003ea-\u003ea)-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:scanr1Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate each action in the structure from left to right, and collect\n the results.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esequenceAOf both ([1,2],[3,4])\n\u003c/code\u003e\u003c/strong\u003e[(1,3),(1,4),(2,3),(2,4)]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequenceA\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esequenceAOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esequenceAOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; l \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequenceAOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t (f b) b       -\u003e s -\u003e f t\n \u003ccode\u003e\u003ca\u003esequenceAOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t (f b) b      -\u003e s -\u003e f t\n \u003ccode\u003e\u003ca\u003esequenceAOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t (f b) b -\u003e s -\u003e f t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "sequenceAOf",
          "package": "lens",
          "signature": "LensLike f s t (f b) b -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Traversal.html#sequenceAOf",
          "type": "function"
        },
        "index": {
          "description": "Evaluate each action in the structure from left to right and collect the results sequenceAOf both sequenceA sequenceAOf traverse traverse id sequenceAOf traverseOf id id sequenceAOf Functor Iso sequenceAOf Functor Lens sequenceAOf Applicative Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "sequenceAOf",
          "normalized": "LensLike a b c(a d)d-\u003eb-\u003ea c",
          "package": "lens",
          "partial": "AOf",
          "signature": "LensLike f s t(f b)b-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:sequenceAOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequence the (monadic) effects targeted by a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e in a container from left to right.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esequenceOf each ([1,2],[3,4],[5,6])\n\u003c/code\u003e\u003c/strong\u003e[(1,3,5),(1,3,6),(1,4,5),(1,4,6),(2,3,5),(2,3,6),(2,4,5),(2,4,6)]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequence\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esequenceOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esequenceOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003emapMOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esequenceOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003eunwrapMonad\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eWrapMonad\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esequenceOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t (m b) b       -\u003e s -\u003e m t\n \u003ccode\u003e\u003ca\u003esequenceOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t (m b) b      -\u003e s -\u003e m t\n \u003ccode\u003e\u003ca\u003esequenceOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t (m b) b -\u003e s -\u003e m t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "sequenceOf",
          "package": "lens",
          "signature": "LensLike (WrappedMonad m) s t (m b) b -\u003e s -\u003e m t",
          "source": "src/Control-Lens-Traversal.html#sequenceOf",
          "type": "function"
        },
        "index": {
          "description": "Sequence the monadic effects targeted by Lens in container from left to right sequenceOf each sequence sequenceOf traverse sequenceOf mapMOf id sequenceOf unwrapMonad WrapMonad sequenceOf Monad Iso sequenceOf Monad Lens sequenceOf Monad Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "sequenceOf",
          "normalized": "LensLike(WrappedMonad a)b c(a d)d-\u003eb-\u003ea c",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike(WrappedMonad m)s t(m b)b-\u003es-\u003em t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:sequenceOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis converts a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that you \"know\" will target one or more elements to a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e. It can\n also be used to transform a non-empty \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or a non-empty \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e into an\n \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe resulting \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e will be partial if the supplied \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e returns\n no results.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3] ^. singular _head\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[] ^. singular _head\n\u003c/code\u003e\u003c/strong\u003e*** Exception: singular: empty traversal\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft 4 ^. singular _Left\n\u003c/code\u003e\u003c/strong\u003e4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1..10] ^. singular (ix 7)\n\u003c/code\u003e\u003c/strong\u003e8\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a          -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a\n \u003ccode\u003e\u003ca\u003esingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                   -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003esingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a          -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003esingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a a -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a a\n \u003ccode\u003e\u003ca\u003esingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003esingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "singular",
          "package": "lens",
          "signature": "Traversing p f s t a a -\u003e Over p f s t a a",
          "source": "src/Control-Lens-Traversal.html#singular",
          "type": "function"
        },
        "index": {
          "description": "This converts Traversal that you know will target one or more elements to Lens It can also be used to transform non-empty Fold into Getter or non-empty MonadicFold into an Action The resulting Lens Getter or Action will be partial if the supplied Traversal returns no results singular head singular head Exception singular empty traversal Left singular Left singular ix singular Traversal Lens singular Fold Getter singular MonadicFold Action singular IndexedTraversal IndexedLens singular IndexedFold IndexedGetter singular IndexedMonadicFold IndexedAction",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "singular",
          "normalized": "Traversing a b c d e e-\u003eOver a b c d e e",
          "package": "lens",
          "signature": "Traversing p f s t a a-\u003eOver p f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:singular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisit the first \u003cem\u003en\u003c/em\u003e targets of a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[(\"hello\",\"world\"),(\"!!!\",\"!!!\")]^.. taking 2 (traverse.both)\n\u003c/code\u003e\u003c/strong\u003e[\"hello\",\"world\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etimingOut $ [1..] ^.. taking 3 traverse\n\u003c/code\u003e\u003c/strong\u003e[1,2,3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (taking 5 traverse) succ \"hello world\"\n\u003c/code\u003e\u003c/strong\u003e\"ifmmp world\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a                   -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a                        -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a                       -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                         -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a                     -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a                -\u003e \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i s a               -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a              -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a                -\u003e \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a            -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n \u003ccode\u003e\u003ca\u003etaking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a       -\u003e \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "taking",
          "package": "lens",
          "signature": "Int -\u003e Traversing p f s t a a -\u003e Over p f s t a a",
          "source": "src/Control-Lens-Traversal.html#taking",
          "type": "function"
        },
        "index": {
          "description": "Visit the first targets of Traversal Fold Getter or Lens hello world taking traverse.both hello world timingOut taking traverse over taking traverse succ hello world ifmmp world taking Int Traversal Traversal taking Int Lens Traversal taking Int Iso Traversal taking Int Prism Traversal taking Int Getter Fold taking Int Fold Fold taking Int Action MonadicFold taking Int MonadicFold MonadicFold taking Int IndexedTraversal IndexedTraversal taking Int IndexedLens IndexedTraversal taking Int IndexedGetter IndexedFold taking Int IndexedFold IndexedFold taking Int IndexedAction IndexedMonadicFold taking Int IndexedMonadicFold IndexedMonadicFold",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "taking",
          "normalized": "Int-\u003eTraversing a b c d e e-\u003eOver a b c d e e",
          "package": "lens",
          "signature": "Int-\u003eTraversing p f s t a a-\u003eOver p f s t a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:taking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis generalizes \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e to an arbitrary \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e handles ragged inputs more intelligently, but for non-ragged inputs:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etransposeOf traverse [[1,2,3],[4,5,6]]\n\u003c/code\u003e\u003c/strong\u003e[[1,4],[2,5],[3,6]]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etransposeOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eSince every \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, we can use this as a form of\n monadic strength as well:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etransposeOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_2\u003c/a\u003e\u003c/code\u003e :: (b, [a]) -\u003e [(b, a)]\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "transposeOf",
          "package": "lens",
          "signature": "LensLike ZipList s t [a] a -\u003e s -\u003e [t]",
          "source": "src/Control-Lens-Traversal.html#transposeOf",
          "type": "function"
        },
        "index": {
          "description": "This generalizes transpose to an arbitrary Traversal Note transpose handles ragged inputs more intelligently but for non-ragged inputs transposeOf traverse transpose transposeOf traverse Since every Lens is Traversal we can use this as form of monadic strength as well transposeOf",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "transposeOf",
          "normalized": "LensLike ZipList a b[c]c-\u003ea-\u003e[b]",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike ZipList s t[a]a-\u003es-\u003e[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:transposeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure to an action, evaluate\n these actions from left to right, and collect the results.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traverse",
          "package": "lens",
          "signature": "(a -\u003e f b) -\u003e t a -\u003e f (t b)",
          "type": "method"
        },
        "index": {
          "description": "Map each element of structure to an action evaluate these actions from left to right and collect the results",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traverse",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "lens",
          "signature": "(a-\u003ef b)-\u003et a-\u003ef(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "traverse1",
          "package": "lens",
          "signature": "(a -\u003e f b) -\u003e t a -\u003e f (t b)",
          "type": "method"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traverse1",
          "normalized": "(a-\u003eb c)-\u003ed a-\u003eb(d c)",
          "package": "lens",
          "signature": "(a-\u003ef b)-\u003et a-\u003ef(t b)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traverse1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e of the element at the largest index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traverseMax",
          "package": "lens",
          "signature": "IndexedTraversal' k (m v) v",
          "source": "src/Control-Lens-Traversal.html#traverseMax",
          "type": "method"
        },
        "index": {
          "description": "IndexedTraversal of the element at the largest index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traverseMax",
          "package": "lens",
          "partial": "Max",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traverseMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e of the element with the smallest index.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traverseMin",
          "package": "lens",
          "signature": "IndexedTraversal' k (m v) v",
          "source": "src/Control-Lens-Traversal.html#traverseMin",
          "type": "method"
        },
        "index": {
          "description": "IndexedTraversal of the element with the smallest index",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traverseMin",
          "package": "lens",
          "partial": "Min",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traverseMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap each element of a structure targeted by a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e,\n evaluate these actions from left to right, and collect the results.\n\u003c/p\u003e\u003cp\u003eThis function is only provided for consistency, \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e is strictly more general.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etraverseOf each print (1,2,3)\n\u003c/code\u003e\u003c/strong\u003e1\n2\n3\n((),(),())\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eitraverseOf\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis yields the obvious law:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n \u003ccode\u003e\u003ca\u003etraverseOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e (a -\u003e f b) -\u003e s -\u003e f t\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traverseOf",
          "package": "lens",
          "signature": "Over p f s t a b -\u003e p a (f b) -\u003e s -\u003e f t",
          "source": "src/Control-Lens-Traversal.html#traverseOf",
          "type": "function"
        },
        "index": {
          "description": "Map each element of structure targeted by Lens or Traversal evaluate these actions from left to right and collect the results This function is only provided for consistency id is strictly more general traverseOf each print traverseOf id itraverseOf traverseOf Indexed This yields the obvious law traverse traverseOf traverse traverseOf Functor Iso traverseOf Functor Lens traverseOf Applicative Traversal",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traverseOf",
          "normalized": "Over a b c d e f-\u003ea e(b f)-\u003ec-\u003eb d",
          "package": "lens",
          "partial": "Of",
          "signature": "Over p f s t a b-\u003ep a(f b)-\u003es-\u003ef t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traverseOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse any \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e container. This is an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e that is indexed by ordinal position.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traversed",
          "package": "lens",
          "signature": "IndexedTraversal Int (f a) (f b) a b",
          "source": "src/Control-Lens-Traversal.html#traversed",
          "type": "function"
        },
        "index": {
          "description": "Traverse any Traversable container This is an IndexedTraversal that is indexed by ordinal position",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traversed",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traversed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse any \u003ccode\u003e\u003ca\u003eTraversable1\u003c/a\u003e\u003c/code\u003e container. This is an \u003ccode\u003e\u003ca\u003eIndexedTraversal1\u003c/a\u003e\u003c/code\u003e that is indexed by ordinal position.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traversed1",
          "package": "lens",
          "signature": "IndexedTraversal1 Int (f a) (f b) a b",
          "source": "src/Control-Lens-Traversal.html#traversed1",
          "type": "function"
        },
        "index": {
          "description": "Traverse any Traversable1 container This is an IndexedTraversal1 that is indexed by ordinal position",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traversed1",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traversed1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse any \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e container. This is an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e that is indexed by ordinal position.\n\u003c/p\u003e",
          "module": "Control.Lens.Traversal",
          "name": "traversed64",
          "package": "lens",
          "signature": "IndexedTraversal Int64 (f a) (f b) a b",
          "source": "src/Control-Lens-Traversal.html#traversed64",
          "type": "function"
        },
        "index": {
          "description": "Traverse any Traversable container This is an IndexedTraversal that is indexed by ordinal position",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "traversed64",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:traversed64"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e turns a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e) family.\n\u003c/p\u003e\u003cp\u003eIf you do not need the types of \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e to be different, it is recommended that\n you use \u003ccode\u003e\u003ca\u003epartsOf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIt is generally safer to traverse with the \u003ccode\u003e\u003ca\u003eBazaar\u003c/a\u003e\u003c/code\u003e rather than use this\n combinator. However, it is sometimes convenient.\n\u003c/p\u003e\u003cp\u003eThis is unsafe because if you don't supply at least as many \u003ccode\u003eb\u003c/code\u003e's as you were\n given \u003ccode\u003ea\u003c/code\u003e's, then the reconstruction of \u003ccode\u003et\u003c/code\u003e \u003cem\u003ewill\u003c/em\u003e result in an error!\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e the result is merely a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e (and becomes safe).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a b       -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t [a] [b]\n \u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b      -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t [a] [b]\n \u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t [a] [b]\n \u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a          -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s [a]\n \u003ccode\u003e\u003ca\u003eunsafePartsOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a        -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "unsafePartsOf",
          "package": "lens",
          "signature": "Traversing (-\u003e) f s t a b -\u003e LensLike f s t [a] [b]",
          "source": "src/Control-Lens-Traversal.html#unsafePartsOf",
          "type": "function"
        },
        "index": {
          "description": "unsafePartsOf turns Traversal into uniplate or biplate family If you do not need the types of and to be different it is recommended that you use partsOf It is generally safer to traverse with the Bazaar rather than use this combinator However it is sometimes convenient This is unsafe because if you don supply at least as many as you were given then the reconstruction of will result in an error When applied to Fold the result is merely Getter and becomes safe unsafePartsOf Iso Lens unsafePartsOf Lens Lens unsafePartsOf Traversal Lens unsafePartsOf Fold Getter unsafePartsOf Getter Getter",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "unsafePartsOf",
          "normalized": "Traversing(-\u003e)a b c d e-\u003eLensLike a b c[d][e]",
          "package": "lens",
          "partial": "Parts Of",
          "signature": "Traversing(-\u003e)f s t a b-\u003eLensLike f s t[a][b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:unsafePartsOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Traversal",
          "name": "unsafePartsOf'",
          "package": "lens",
          "signature": "ATraversal s t a b -\u003e Lens s t [a] [b]",
          "source": "src/Control-Lens-Traversal.html#unsafePartsOf%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "unsafePartsOf'",
          "normalized": "ATraversal a b c d-\u003eLens a b[c][d]",
          "package": "lens",
          "partial": "Parts Of'",
          "signature": "ATraversal s t a b-\u003eLens s t[a][b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:unsafePartsOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis converts a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that you \"know\" will target only one element to a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e. It can also be\n used to transform a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e into an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe resulting \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e will be partial if the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e targets nothing\n or more than one element.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunsafeSingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a b          -\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b\n \u003ccode\u003e\u003ca\u003eunsafeSingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a                   -\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a\n \u003ccode\u003e\u003ca\u003eunsafeSingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e m s a          -\u003e \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e m s a\n \u003ccode\u003e\u003ca\u003eunsafeSingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i s t a b -\u003e \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i s t a b\n \u003ccode\u003e\u003ca\u003eunsafeSingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e i s a          -\u003e \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e i s a\n \u003ccode\u003e\u003ca\u003eunsafeSingular\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e i m s a -\u003e \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e i m s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Traversal",
          "name": "unsafeSingular",
          "package": "lens",
          "signature": "Traversing p f s t a b -\u003e Over p f s t a b",
          "source": "src/Control-Lens-Traversal.html#unsafeSingular",
          "type": "function"
        },
        "index": {
          "description": "This converts Traversal that you know will target only one element to Lens It can also be used to transform Fold into Getter or MonadicFold into an Action The resulting Lens Getter or Action will be partial if the Traversal targets nothing or more than one element unsafeSingular Traversal Lens unsafeSingular Fold Getter unsafeSingular MonadicFold Action unsafeSingular IndexedTraversal IndexedLens unsafeSingular IndexedFold IndexedGetter unsafeSingular IndexedMonadicFold IndexedAction",
          "hierarchy": "Control Lens Traversal",
          "module": "Control.Lens.Traversal",
          "name": "unsafeSingular",
          "normalized": "Traversing a b c d e f-\u003eOver a b c d e f",
          "package": "lens",
          "partial": "Singular",
          "signature": "Traversing p f s t a b-\u003eOver p f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:unsafeSingular"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Tuple",
          "name": "Tuple",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Tuple",
          "package": "lens",
          "partial": "Tuple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to 1st field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field1",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field1",
          "type": "class"
        },
        "index": {
          "description": "Provides access to st field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field1",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to the 2nd field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field2",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field2",
          "type": "class"
        },
        "index": {
          "description": "Provides access to the nd field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field2",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to the 3rd field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field3",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field3",
          "type": "class"
        },
        "index": {
          "description": "Provides access to the rd field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field3",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvide access to the 4th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field4",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field4",
          "type": "class"
        },
        "index": {
          "description": "Provide access to the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field4",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to the 5th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field5",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field5",
          "type": "class"
        },
        "index": {
          "description": "Provides access to the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field5",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to the 6th element of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field6",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field6",
          "type": "class"
        },
        "index": {
          "description": "Provides access to the th element of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field6",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvide access to the 7th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field7",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field7",
          "type": "class"
        },
        "index": {
          "description": "Provide access to the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field7",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvide access to the 8th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field8",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field8",
          "type": "class"
        },
        "index": {
          "description": "Provide access to the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field8",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides access to the 9th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "Field9",
          "package": "lens",
          "source": "src/Control-Lens-Tuple.html#Field9",
          "type": "class"
        },
        "index": {
          "description": "Provides access to the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "Field9",
          "package": "lens",
          "partial": "Field",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#t:Field9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 1st field of a tuple (and possibly change its type).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2)^._1\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_1 .~ \"hello\" $ (1,2)\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",2)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2) & _1 .~ \"hello\"\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",2)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_1 putStrLn (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003ehello\n((),\"world\")\n\u003c/pre\u003e\u003cp\u003eThis can also be used on larger tuples as well:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2,3,4,5) & _1 +~ 41\n\u003c/code\u003e\u003c/strong\u003e(42,2,3,4,5)\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_1\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (a,b) (a',b) a a'\n \u003ccode\u003e\u003ca\u003e_1\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (a,b,c) (a',b,c) a a'\n \u003ccode\u003e\u003ca\u003e_1\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (a,b,c,d) (a',b,c,d) a a'\n ...\n \u003ccode\u003e\u003ca\u003e_1\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (a,b,c,d,e,f,g,h,i) (a',b,c,d,e,f,g,h,i) a a'\n\u003c/pre\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_1",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_1",
          "type": "method"
        },
        "index": {
          "description": "Access the st field of tuple and possibly change its type hello hello hello hello putStrLn hello world hello world This can also be used on larger tuples as well Lens Lens Lens Lens",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_1",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 2nd field of a tuple.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 .~ \"hello\" $ (1,(),3,4)\n\u003c/code\u003e\u003c/strong\u003e(1,\"hello\",3,4)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2,3,4) & _2 *~ 3\n\u003c/code\u003e\u003c/strong\u003e(1,6,3,4)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 print (1,2)\n\u003c/code\u003e\u003c/strong\u003e2\n(1,())\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_2\u003c/a\u003e\u003c/code\u003e :: (s -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e (a, s) -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_2\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e f, \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e t) =\u003e (a -\u003e f b) -\u003e t (s, a) -\u003e f (t (s, b))\n \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_2\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e t, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e m) =\u003e (s -\u003e m) -\u003e t (b, s) -\u003e m\n\u003c/pre\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_2",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_2",
          "type": "method"
        },
        "index": {
          "description": "Access the nd field of tuple hello hello print anyOf Bool Bool traverse Applicative Traversable foldMapOf traverse Traversable Monoid",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_2",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 3rd field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_3",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_3",
          "type": "method"
        },
        "index": {
          "description": "Access the rd field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_3",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 4th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_4",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_4",
          "type": "method"
        },
        "index": {
          "description": "Access the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_4",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 5th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_5",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_5",
          "type": "method"
        },
        "index": {
          "description": "Access the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_5",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 6th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_6",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_6",
          "type": "method"
        },
        "index": {
          "description": "Access the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_6",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 7th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_7",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_7",
          "type": "method"
        },
        "index": {
          "description": "Access the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_7",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 8th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_8",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_8",
          "type": "method"
        },
        "index": {
          "description": "Access the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_8",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the 9th field of a tuple.\n\u003c/p\u003e",
          "module": "Control.Lens.Tuple",
          "name": "_9",
          "package": "lens",
          "signature": "Lens s t a b",
          "source": "src/Control-Lens-Tuple.html#_9",
          "type": "method"
        },
        "index": {
          "description": "Access the th field of tuple",
          "hierarchy": "Control Lens Tuple",
          "module": "Control.Lens.Tuple",
          "name": "_9",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Tuple.html#v:_9"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module exports the majority of the types that need to appear in user\n signatures or in documentation when talking about lenses. The remaining types\n for consuming lenses are distributed across various modules in the hierarchy.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Type",
          "name": "Type",
          "package": "lens",
          "source": "src/Control-Lens-Type.html",
          "type": "module"
        },
        "index": {
          "description": "This module exports the majority of the types that need to appear in user signatures or in documentation when talking about lenses The remaining types for consuming lenses are distributed across various modules in the hierarchy",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Type",
          "package": "lens",
          "partial": "Type",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e can be used as an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Action",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Action",
          "type": "type"
        },
        "index": {
          "description": "An Action is Getter enriched with access to Monad for side-effects Every Getter can be used as an Action You can compose an Action with another Action using from the Prelude",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Action",
          "package": "lens",
          "partial": "Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComposable \u003ccode\u003e\u003ca\u003easTypeOf\u003c/a\u003e\u003c/code\u003e. Useful for constraining excess\n polymorphism, \u003ccode\u003efoo . (id :: As Int) . bar\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "As",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#As",
          "type": "type"
        },
        "index": {
          "description": "Composable asTypeOf Useful for constraining excess polymorphism foo id As Int bar",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "As",
          "package": "lens",
          "partial": "As",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:As"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA witness that \u003ccode\u003e(a ~ s, b ~ t)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Composition with an \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e is index-preserving.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Equality",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Equality",
          "type": "type"
        },
        "index": {
          "description": "witness that Note Composition with an Equality is index-preserving",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Equality",
          "package": "lens",
          "partial": "Equality",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Equality"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Equality'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Equality%27",
          "type": "type"
        },
        "index": {
          "description": "Simple Equality",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Equality'",
          "package": "lens",
          "partial": "Equality'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Equality-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e describes how to retrieve multiple values in a way that can be composed\n with other \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e constructions.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e provides a structure with operations very similar to those of the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e\n typeclass, see \u003ccode\u003e\u003ca\u003efoldMapOf\u003c/a\u003e\u003c/code\u003e and the other \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e combinators.\n\u003c/p\u003e\u003cp\u003eBy convention, if there exists a \u003ccode\u003efoo\u003c/code\u003e method that expects a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e (f a)\u003c/code\u003e, then there should be a\n \u003ccode\u003efooOf\u003c/code\u003e method that takes a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a\u003c/code\u003e and a value of type \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e is a legal \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e that just ignores the supplied \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eUnlike a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e is read-only. Since a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e cannot be used to write back\n there are no \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws that apply.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Fold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Fold",
          "type": "type"
        },
        "index": {
          "description": "Fold describes how to retrieve multiple values in way that can be composed with other LensLike constructions Fold provides structure with operations very similar to those of the Foldable typeclass see foldMapOf and the other Fold combinators By convention if there exists foo method that expects Foldable then there should be fooOf method that takes Fold and value of type Getter is legal Fold that just ignores the supplied Monoid Unlike Traversal Fold is read-only Since Fold cannot be used to write back there are no Lens laws that apply",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Fold",
          "package": "lens",
          "partial": "Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA relevant Fold (aka \u003ccode\u003e\u003ca\u003eFold1\u003c/a\u003e\u003c/code\u003e) has one or more targets.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Fold1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Fold1",
          "type": "type"
        },
        "index": {
          "description": "relevant Fold aka Fold1 has one or more targets",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Fold1",
          "package": "lens",
          "partial": "Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Fold1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e describes how to retrieve a single value in a way that can be\n composed with other \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e constructions.\n\u003c/p\u003e\u003cp\u003eUnlike a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e is read-only. Since a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e\n cannot be used to write back there are no \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws that can be applied to\n it. In fact, it is isomorphic to an arbitrary function from \u003ccode\u003e(s -\u003e a)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMoreover, a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e can be used directly as a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e,\n since it just ignores the \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Getter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Getter",
          "type": "type"
        },
        "index": {
          "description": "Getter describes how to retrieve single value in way that can be composed with other LensLike constructions Unlike Lens Getter is read-only Since Getter cannot be used to write back there are no Lens laws that can be applied to it In fact it is isomorphic to an arbitrary function from Moreover Getter can be used directly as Fold since it just ignores the Applicative",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Getter",
          "package": "lens",
          "partial": "Getter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Getter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingAction\u003c/a\u003e\u003c/code\u003e can be used as a \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e, but when composed with an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e yields an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e respectively.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingAction",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingAction",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingAction can be used as Action but when composed with an IndexedTraversal IndexedFold or IndexedLens yields an IndexedMonadicFold IndexedMonadicFold or IndexedAction respectively",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingAction",
          "package": "lens",
          "partial": "Index Preserving Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e can be used as a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, but when composed with an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e yields an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e respectively.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingFold",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingFold can be used as Fold but when composed with an IndexedTraversal IndexedFold or IndexedLens yields an IndexedFold respectively",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingFold",
          "package": "lens",
          "partial": "Index Preserving Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexPreservingFold1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingFold1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingFold1",
          "package": "lens",
          "partial": "Index Preserving Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingFold1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingGetter\u003c/a\u003e\u003c/code\u003e can be used as a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, but when composed with an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e yields an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e respectively.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingGetter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingGetter",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingGetter can be used as Getter but when composed with an IndexedTraversal IndexedFold or IndexedLens yields an IndexedFold IndexedFold or IndexedGetter respectively",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingGetter",
          "package": "lens",
          "partial": "Index Preserving Getter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingLens\u003c/a\u003e\u003c/code\u003e leaves any index it is composed with alone.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingLens",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingLens",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingLens leaves any index it is composed with alone",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingLens",
          "package": "lens",
          "partial": "Index Preserving Lens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexPreservingLens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingLens\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingLens'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingLens%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexPreservingLens Simple IndexPreservingLens",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingLens'",
          "package": "lens",
          "partial": "Index Preserving Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingFold\u003c/a\u003e\u003c/code\u003e can be used as a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, but when composed with an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e yields an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e respectively.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingMonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingMonadicFold",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingFold can be used as Fold but when composed with an IndexedTraversal IndexedFold or IndexedLens yields an IndexedFold respectively",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingMonadicFold",
          "package": "lens",
          "partial": "Index Preserving Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingMonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexPreservingRelevantMonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingRelevantMonadicFold",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingRelevantMonadicFold",
          "package": "lens",
          "partial": "Index Preserving Relevant Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingRelevantMonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingSetter\u003c/a\u003e\u003c/code\u003e can be composed with a \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e\n and leaves the index intact, yielding an \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingSetter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingSetter",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingSetter can be composed with IndexedSetter IndexedTraversal or IndexedLens and leaves the index intact yielding an IndexedSetter",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingSetter",
          "package": "lens",
          "partial": "Index Preserving Setter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003eIndexedPreservingSetter'\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003eIndexedPreservingSetter\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingSetter'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingSetter%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedPreservingSetter Simple IndexedPreservingSetter",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingSetter'",
          "package": "lens",
          "partial": "Index Preserving Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingSetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexPreservingLens\u003c/a\u003e\u003c/code\u003e leaves any index it is composed with alone.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingTraversal",
          "type": "type"
        },
        "index": {
          "description": "An IndexPreservingLens leaves any index it is composed with alone",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal",
          "package": "lens",
          "partial": "Index Preserving Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIndexPreservingTraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingTraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexPreservingTraversal Simple IndexPreservingTraversal",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal'",
          "package": "lens",
          "partial": "Index Preserving Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingTraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingTraversal1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal1",
          "package": "lens",
          "partial": "Index Preserving Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexPreservingTraversal1%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexPreservingTraversal1'",
          "package": "lens",
          "partial": "Index Preserving Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexPreservingTraversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexedAction\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e can be used as an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose an \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eAction\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedAction",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedAction",
          "type": "type"
        },
        "index": {
          "description": "An IndexedAction is an IndexedGetter enriched with access to Monad for side-effects Every Getter can be used as an Action You can compose an Action with another Action using from the Prelude",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedAction",
          "package": "lens",
          "partial": "Indexed Action",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e and can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedFold",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedFold is valid Fold and can be used for Getting",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedFold",
          "package": "lens",
          "partial": "Indexed Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexedFold1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedFold1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedFold1",
          "package": "lens",
          "partial": "Indexed Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedFold1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedGetter\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e and can be used for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e like a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedGetter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedGetter",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedGetter is valid IndexedFold and can be used for Getting like Getter",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedGetter",
          "package": "lens",
          "partial": "Indexed Getter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedGetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and a valid \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedLens",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedLens",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedLens is valid Lens and valid IndexedTraversal",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedLens",
          "package": "lens",
          "partial": "Indexed Lens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedLens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexedLens'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedLens\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedLens'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedLens%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedLens Simple IndexedLens",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedLens'",
          "package": "lens",
          "partial": "Indexed Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedLens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient alias for constructing indexed lenses and their ilk.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedLensLike",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedLensLike",
          "type": "type"
        },
        "index": {
          "description": "Convenient alias for constructing indexed lenses and their ilk",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedLensLike",
          "package": "lens",
          "partial": "Indexed Lens Like",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedLensLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvenient alias for constructing simple indexed lenses and their ilk.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedLensLike'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedLensLike%27",
          "type": "type"
        },
        "index": {
          "description": "Convenient alias for constructing simple indexed lenses and their ilk",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedLensLike'",
          "package": "lens",
          "partial": "Indexed Lens Like'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedLensLike-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e can be used as an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e, that simply ignores the access to the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose an \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eIndexedMonadicFold\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedMonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedMonadicFold",
          "type": "type"
        },
        "index": {
          "description": "An IndexedMonadicFold is an IndexedFold enriched with access to Monad for side-effects Every IndexedFold can be used as an IndexedMonadicFold that simply ignores the access to the Monad You can compose an IndexedMonadicFold with another IndexedMonadicFold using from the Prelude",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedMonadicFold",
          "package": "lens",
          "partial": "Indexed Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedMonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexedRelevantMonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedRelevantMonadicFold",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedRelevantMonadicFold",
          "package": "lens",
          "partial": "Indexed Relevant Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedRelevantMonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e laws are still required to hold.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedSetter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedSetter",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedSetter is valid Setter The Setter laws are still required to hold",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedSetter",
          "package": "lens",
          "partial": "Indexed Setter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedSetter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexedSetter'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedSetter\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedSetter'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedSetter%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedSetter Simple IndexedSetter",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedSetter'",
          "package": "lens",
          "partial": "Indexed Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedSetter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eIndexedFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eIndexed\u003c/a\u003e\u003c/code\u003e constraint is used to allow an \u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e to be used\n directly as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws are still required to hold.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal",
          "type": "type"
        },
        "index": {
          "description": "Every IndexedTraversal is valid Traversal or IndexedFold The Indexed constraint is used to allow an IndexedTraversal to be used directly as Traversal The Traversal laws are still required to hold",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e i = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal%27",
          "type": "type"
        },
        "index": {
          "description": "type IndexedTraversal Simple IndexedTraversal",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal'",
          "package": "lens",
          "partial": "Indexed Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedTraversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal1",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedTraversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#IndexedTraversal1%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "IndexedTraversal1'",
          "package": "lens",
          "partial": "Indexed Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:IndexedTraversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIsomorphism families can be composed with another \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) and \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Composition with an \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is index- and measure- preserving.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Iso",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Iso",
          "type": "type"
        },
        "index": {
          "description": "Isomorphism families can be composed with another Lens using and id Note Composition with an Iso is index and measure preserving",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Iso",
          "package": "lens",
          "partial": "Iso",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Iso"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Iso'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Iso%27",
          "type": "type"
        },
        "index": {
          "description": "type Iso Simple Iso",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Iso'",
          "package": "lens",
          "partial": "Iso'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Iso-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is actually a lens family as described in\n \u003ca\u003ehttp://comonad.com/reader/2012/mirrored-lenses/\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eWith great power comes great responsibility and a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is subject to the\n three common sense \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws:\n\u003c/p\u003e\u003cp\u003e1) You get back what you put in:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s)  &#8801; v\n\u003c/pre\u003e\u003cp\u003e2) Putting back what you got doesn't change anything:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l s) s  &#8801; s\n\u003c/pre\u003e\u003cp\u003e3) Setting twice is the same as setting once:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v' (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v' s\n\u003c/pre\u003e\u003cp\u003eThese laws are strong enough that the 4 type parameters of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e cannot\n vary fully independently. For more on how they interact, read the \"Why is\n it a Lens Family?\" section of\n \u003ca\u003ehttp://comonad.com/reader/2012/mirrored-lenses/\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eThere are some emergent properties of these laws:\n\u003c/p\u003e\u003cp\u003e1) \u003ccode\u003e\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l s\u003c/code\u003e must be injective for every \u003ccode\u003es\u003c/code\u003e This is a consequence of law #1\n\u003c/p\u003e\u003cp\u003e2) \u003ccode\u003e\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l\u003c/code\u003e must be surjective, because of law #2, which indicates that it is possible to obtain any \u003ccode\u003ev\u003c/code\u003e from some \u003ccode\u003es\u003c/code\u003e such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e s v = s\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003e3) Given just the first two laws you can prove a weaker form of law #3 where the values \u003ccode\u003ev\u003c/code\u003e that you are setting match:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l v s\n\u003c/pre\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used directly as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can also use a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e for \u003ccode\u003e\u003ca\u003eGetting\u003c/a\u003e\u003c/code\u003e as if it were a\n \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSince every \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, the\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws are required of any \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e you create:\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e (l f) \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l g &#8801; \u003ccode\u003e\u003ca\u003egetCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a b = forall f. \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Lens",
          "type": "type"
        },
        "index": {
          "description": "Lens is actually lens family as described in http comonad.com reader mirrored-lenses With great power comes great responsibility and Lens is subject to the three common sense Lens laws You get back what you put in view set Putting back what you got doesn change anything set view Setting twice is the same as setting once set set set These laws are strong enough that the type parameters of Lens cannot vary fully independently For more on how they interact read the Why is it Lens Family section of http comonad.com reader mirrored-lenses There are some emergent properties of these laws set must be injective for every This is consequence of law set must be surjective because of law which indicates that it is possible to obtain any from some such that set Given just the first two laws you can prove weaker form of law where the values that you are setting match set set set Every Lens can be used directly as Setter or Traversal You can also use Lens for Getting as if it were Fold or Getter Since every Lens is valid Traversal the Traversal laws are required of any Lens you create pure pure fmap getCompose Compose fmap type Lens forall Functor LensLike",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Lens"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Lens'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Lens%27",
          "type": "type"
        },
        "index": {
          "description": "type Lens Simple Lens",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Lens'",
          "package": "lens",
          "partial": "Lens'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Lens-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMany combinators that accept a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can also accept a\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e in limited situations.\n\u003c/p\u003e\u003cp\u003eThey do so by specializing the type of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e that they require of the\n caller.\n\u003c/p\u003e\u003cp\u003eIf a function accepts a \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f s t a b\u003c/code\u003e for some \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ef\u003c/code\u003e,\n then they may be passed a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFurther, if \u003ccode\u003ef\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e, they may also be passed a\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "LensLike",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#LensLike",
          "type": "type"
        },
        "index": {
          "description": "Many combinators that accept Lens can also accept Traversal in limited situations They do so by specializing the type of Functor that they require of the caller If function accepts LensLike for some Functor then they may be passed Lens Further if is an Applicative they may also be passed Traversal",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "LensLike",
          "package": "lens",
          "partial": "Lens Like",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:LensLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLensLike'\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f)\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "LensLike'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#LensLike%27",
          "type": "type"
        },
        "index": {
          "description": "type LensLike Simple LensLike",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "LensLike'",
          "package": "lens",
          "partial": "Lens Like'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:LensLike-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e enriched with access to a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for side-effects.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e can be used as a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e, that simply ignores the access to the \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can compose a \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e with another \u003ccode\u003e\u003ca\u003eMonadicFold\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "MonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#MonadicFold",
          "type": "type"
        },
        "index": {
          "description": "MonadicFold is Fold enriched with access to Monad for side-effects Every Fold can be used as MonadicFold that simply ignores the access to the Monad You can compose MonadicFold with another MonadicFold using from the Prelude",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "MonadicFold",
          "package": "lens",
          "partial": "Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:MonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA valid \u003ccode\u003e\u003ca\u003eOptic\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e should satisfy the laws:\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n l (\u003ccode\u003eProcompose\u003c/code\u003e f g) = \u003ccode\u003eProcompose\u003c/code\u003e (l f) (l g)\n\u003c/pre\u003e\u003cp\u003eThis gives rise to the laws for \u003ccode\u003e\u003ca\u003eEquality\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal1\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold1\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e as well\n along with their index-preserving variants.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f s t a b = \u003ccode\u003e\u003ca\u003eOptic\u003c/a\u003e\u003c/code\u003e (-\u003e) f s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Optic",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Optic",
          "type": "type"
        },
        "index": {
          "description": "valid Optic should satisfy the laws pure pure Procompose Procompose This gives rise to the laws for Equality Iso Prism Lens Traversal Traversal1 Setter Fold Fold1 and Getter as well along with their index-preserving variants type LensLike Optic",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Optic",
          "package": "lens",
          "partial": "Optic",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Optic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eOptic'\u003c/a\u003e\u003c/code\u003e p q f s a = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eOptic\u003c/a\u003e\u003c/code\u003e p q f) s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Optic'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Optic%27",
          "type": "type"
        },
        "index": {
          "description": "type Optic Simple Optic",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Optic'",
          "package": "lens",
          "partial": "Optic'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Optic-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f s t a b = \u003ccode\u003e\u003ca\u003eOptical\u003c/a\u003e\u003c/code\u003e (-\u003e) (-\u003e) f s t a b\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Optical",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Optical",
          "type": "type"
        },
        "index": {
          "description": "type LensLike Optical",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Optical",
          "package": "lens",
          "partial": "Optical",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Optical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eOptical'\u003c/a\u003e\u003c/code\u003e p q f s a = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eOptical\u003c/a\u003e\u003c/code\u003e p q f) s a\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Optical'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Optical%27",
          "type": "type"
        },
        "index": {
          "description": "type Optical Simple Optical",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Optical'",
          "package": "lens",
          "partial": "Optical'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Optical-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient alias for use when you need to consume either indexed or non-indexed lens-likes based on context.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Over",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Over",
          "type": "type"
        },
        "index": {
          "description": "This is convenient alias for use when you need to consume either indexed or non-indexed lens-likes based on context",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Over",
          "package": "lens",
          "partial": "Over",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Over"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient alias for use when you need to consume either indexed or non-indexed lens-likes based on context.\n\u003c/p\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eOver'\u003c/a\u003e\u003c/code\u003e p f = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eOver\u003c/a\u003e\u003c/code\u003e p f)\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Over'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Over%27",
          "type": "type"
        },
        "index": {
          "description": "This is convenient alias for use when you need to consume either indexed or non-indexed lens-likes based on context type Over Simple Over",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Over'",
          "package": "lens",
          "partial": "Over'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Over-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that can also be turned\n around with \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e to obtain a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e in the\n opposite direction.\n\u003c/p\u003e\u003cp\u003eThere are two laws that a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e should satisfy:\n\u003c/p\u003e\u003cp\u003eFirst, if I \u003ccode\u003e\u003ca\u003ere\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e a value with a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e and then \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e or use (\u003ccode\u003e\u003ca\u003e^?\u003c/a\u003e\u003c/code\u003e), I will get it back:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e l b) &#8801; \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e b\n\u003c/pre\u003e\u003cp\u003eSecond, if you can extract a value \u003ccode\u003ea\u003c/code\u003e using a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e from a value \u003ccode\u003es\u003c/code\u003e, then the value \u003ccode\u003es\u003c/code\u003e is completely described my \u003ccode\u003el\u003c/code\u003e and \u003ccode\u003ea\u003c/code\u003e:\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e\u003ccode\u003e\u003ca\u003epreview\u003c/a\u003e\u003c/code\u003e l s &#8801; \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e then \u003ccode\u003e\u003ccode\u003e\u003ca\u003ereview\u003c/a\u003e\u003c/code\u003e l a &#8801; s\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThese two laws imply that the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws hold for every \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e and that we \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e at most 1 element:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003elengthOf\u003c/a\u003e\u003c/code\u003e l x \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e 1\n\u003c/pre\u003e\u003cp\u003eIt may help to think of this as a \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e that can be partial in one direction.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEvery \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is a valid \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example, you might have a \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e allows you to always\n go from a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e, and provide you with tools to check if an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e is\n a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e and/or to edit one if it is.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003enat\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003enat\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eprism\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etoInteger\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \\ i -\u003e\n    if i \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e 0\n    then \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e i\n    else \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efromInteger\u003c/a\u003e\u003c/code\u003e i)\n\u003c/pre\u003e\u003cp\u003eNow we can ask if an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e is a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^?nat\n\u003c/code\u003e\u003c/strong\u003eJust 5\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(-5)^?nat\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cp\u003eWe can update the ones that are:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(-3,4) & both.nat *~ 2\n\u003c/code\u003e\u003c/strong\u003e(-3,8)\n\u003c/pre\u003e\u003cp\u003eAnd we can then convert from a \u003ccode\u003e\u003ca\u003eNatural\u003c/a\u003e\u003c/code\u003e to an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5 ^. re nat -- :: Natural\n\u003c/code\u003e\u003c/strong\u003e5\n\u003c/pre\u003e\u003cp\u003eSimilarly we can use a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e half of an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eLeft \"hello\" & _Left %~ length\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cp\u003eor to construct an \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Left\n\u003c/code\u003e\u003c/strong\u003eLeft 5\n\u003c/pre\u003e\u003cp\u003esuch that if you query it with the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e, you will get your original input back.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5^.re _Left ^? _Left\n\u003c/code\u003e\u003c/strong\u003eJust 5\n\u003c/pre\u003e\u003cp\u003eAnother interesting way to think of a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is as the categorical dual of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e\n -- a co-\u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, so to speak. This is what permits the construction of \u003ccode\u003e\u003ca\u003eoutside\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote: Composition with a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e is index-preserving.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Prism",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Prism",
          "type": "type"
        },
        "index": {
          "description": "Prism is Traversal that can also be turned around with re to obtain Getter in the opposite direction There are two laws that Prism should satisfy First if re or review value with Prism and then preview or use will get it back preview review Just Second if you can extract value using Prism from value then the value is completely described my and If preview Just then review These two laws imply that the Traversal laws hold for every Prism and that we traverse at most element lengthOf It may help to think of this as Iso that can be partial in one direction Every Prism is valid Traversal Every Iso is valid Prism For example you might have Prism Integer Natural allows you to always go from Natural to an Integer and provide you with tools to check if an Integer is Natural and or to edit one if it is nat Prism Integer Natural nat prism toInteger if then Left else Right fromInteger Now we can ask if an Integer is Natural nat Just nat Nothing We can update the ones that are both.nat And we can then convert from Natural to an Integer re nat Natural Similarly we can use Prism to traverse the Left half of an Either Left hello Left length Left or to construct an Either re Left Left such that if you query it with the Prism you will get your original input back re Left Left Just Another interesting way to think of Prism is as the categorical dual of Lens co Lens so to speak This is what permits the construction of outside Note Composition with Prism is index-preserving",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Prism",
          "package": "lens",
          "partial": "Prism",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Prism"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Prism'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Prism%27",
          "type": "type"
        },
        "index": {
          "description": "Simple Prism",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Prism'",
          "package": "lens",
          "partial": "Prism'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Prism-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "RelevantMonadicFold",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#RelevantMonadicFold",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "RelevantMonadicFold",
          "package": "lens",
          "partial": "Relevant Monadic Fold",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:RelevantMonadicFold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe only \u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e law that can apply to a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003el\u003c/code\u003e is that\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l y (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l x a) &#8801; \u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l y a\n\u003c/pre\u003e\u003cp\u003eYou can't \u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e in general, so the other two laws are irrelevant.\n\u003c/p\u003e\u003cp\u003eHowever, two \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e laws apply to a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l g &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e l (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003eThese can be stated more directly:\n\u003c/p\u003e\u003cpre\u003e\n l \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n l f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euntainted\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e l g &#8801; l (f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euntainted\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003eYou can compose a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e with a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) from the \u003ccode\u003ePrelude\u003c/code\u003e\n and the result is always only a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e and nothing more.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover traverse f [a,b,c,d]\n\u003c/code\u003e\u003c/strong\u003e[f a,f b,f c,f d]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover _1 f (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (traverse._1) f [(a,b),(c,d)]\n\u003c/code\u003e\u003c/strong\u003e[(f a,b),(f c,d)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover both f (a,b)\n\u003c/code\u003e\u003c/strong\u003e(f a,f b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover (traverse.both) f [(a,b),(c,d)]\n\u003c/code\u003e\u003c/strong\u003e[(f a,f b),(f c,f d)]\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Setter",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Setter",
          "type": "type"
        },
        "index": {
          "description": "The only LensLike law that can apply to Setter is that set set set You can view Setter in general so the other two laws are irrelevant However two Functor laws apply to Setter over id id over over over These can be stated more directly pure pure untainted untainted You can compose Setter with Lens or Traversal using from the Prelude and the result is always only Setter and nothing more over traverse over over traverse over both over traverse.both",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Setter",
          "package": "lens",
          "partial": "Setter",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Setter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e is just a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e that doesn't change the types.\n\u003c/p\u003e\u003cp\u003eThese are particularly common when talking about monomorphic containers. \u003cem\u003ee.g.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003esets\u003c/code\u003e Data.Text.map :: \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Setter'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Setter%27",
          "type": "type"
        },
        "index": {
          "description": "Setter is just Setter that doesn change the types These are particularly common when talking about monomorphic containers e.g sets Data.Text.map Setter Text Char type Setter Setter",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Setter'",
          "package": "lens",
          "partial": "Setter'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Setter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, ... can\n be used instead of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e,\u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, ...\n whenever the type variables don't change upon setting a value.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_imagPart\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e a) a\n \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eIndexedTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e) [a] a\n\u003c/pre\u003e\u003cp\u003eNote: To use this alias in your own code with \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLensLike\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, you may have to turn on \u003ccode\u003eLiberalTypeSynonyms\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is commonly abbreviated as a \"prime\" marker, \u003cem\u003ee.g.\u003c/em\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Simple",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Simple",
          "type": "type"
        },
        "index": {
          "description": "Simple Lens Simple Traversal can be used instead of Lens Traversal whenever the type variables don change upon setting value imagPart Simple Lens Complex traversed Simple IndexedTraversal Int Note To use this alias in your own code with LensLike or Setter you may have to turn on LiberalTypeSynonyms This is commonly abbreviated as prime marker e.g Lens Simple Lens",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Simple",
          "package": "lens",
          "partial": "Simple",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Simple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e can be used directly as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e (but not as a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e) and provides\n the ability to both read and update multiple fields, subject to some relatively weak \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e\u003cp\u003eThese have also been known as multilenses, but they have the signature and spirit of\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e f =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (f a) (f b) a b\n\u003c/pre\u003e\u003cp\u003eand the more evocative name suggests their application.\n\u003c/p\u003e\u003cp\u003eMost of the time the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e you will want to use is just \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e, but you can also pass any\n \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, and composition of a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e) with a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e)\n using (\u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e) forms a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe laws for a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e \u003ccode\u003et\u003c/code\u003e follow from the laws for \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e as stated in \"The Essence of the Iterator Pattern\".\n\u003c/p\u003e\u003cpre\u003e\n t \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e (t f) \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e t g &#8801; \u003ccode\u003e\u003ca\u003egetCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e t (\u003ccode\u003e\u003ca\u003eCompose\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e g)\n\u003c/pre\u003e\u003cp\u003eOne consequence of this requirement is that a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e needs to leave the same number of elements as a\n candidate for subsequent \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that it started with. Another testament to the strength of these laws\n is that the caveat expressed in section 5.5 of the \"Essence of the Iterator Pattern\" about exotic\n \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e instances that \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e the same entry multiple times was actually already ruled out by the\n second law in that same paper!\n\u003c/p\u003e",
          "module": "Control.Lens.Type",
          "name": "Traversal",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal",
          "type": "type"
        },
        "index": {
          "description": "Traversal can be used directly as Setter or Fold but not as Lens and provides the ability to both read and update multiple fields subject to some relatively weak Traversal laws These have also been known as multilenses but they have the signature and spirit of traverse Traversable Traversal and the more evocative name suggests their application Most of the time the Traversal you will want to use is just traverse but you can also pass any Lens or Iso as Traversal and composition of Traversal or Lens or Iso with Traversal or Lens or Iso using forms valid Traversal The laws for Traversal follow from the laws for Traversable as stated in The Essence of the Iterator Pattern pure pure fmap getCompose Compose fmap One consequence of this requirement is that Traversal needs to leave the same number of elements as candidate for subsequent Traversal that it started with Another testament to the strength of these laws is that the caveat expressed in section of the Essence of the Iterator Pattern about exotic Traversable instances that traverse the same entry multiple times was actually already ruled out by the second law in that same paper",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Traversal",
          "package": "lens",
          "partial": "Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Traversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n type \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Type",
          "name": "Traversal'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal%27",
          "type": "type"
        },
        "index": {
          "description": "type Traversal Simple Traversal",
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Traversal'",
          "package": "lens",
          "partial": "Traversal'",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Traversal-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "Traversal1",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal1",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Traversal1",
          "package": "lens",
          "partial": "Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Traversal1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Type",
          "name": "Traversal1'",
          "package": "lens",
          "source": "src/Control-Lens-Type.html#Traversal1%27",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Lens Type",
          "module": "Control.Lens.Type",
          "name": "Traversal1'",
          "package": "lens",
          "partial": "Traversal",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Type.html#t:Traversal1-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eWrapped\u003c/a\u003e\u003c/code\u003e class provides similar functionality as \u003ccode\u003eControl.Newtype\u003c/code\u003e,\n from the \u003ccode\u003enewtype\u003c/code\u003e package, but in a more convenient and efficient form.\n\u003c/p\u003e\u003cp\u003eThere are a few functions from \u003ccode\u003enewtype\u003c/code\u003e that are not provided here, because\n they can be done with the \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e directly:\n\u003c/p\u003e\u003cpre\u003e\n Control.Newtype.over \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003e_Unwrapping\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n Control.Newtype.under \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003e_Wrapping\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n Control.Newtype.overF \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003emapping\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e_Unwrapping\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e) \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n Control.Newtype.underF \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003emapping\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e_Wrapping\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSum\u003c/a\u003e\u003c/code\u003e) \u003ccode\u003e\u003ca\u003e%~\u003c/a\u003e\u003c/code\u003e f\n\u003c/pre\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eunder\u003c/a\u003e\u003c/code\u003e can also be used with \u003ccode\u003e\u003ca\u003e_Unwrapping\u003c/a\u003e\u003c/code\u003e to provide the equivalent of\n \u003ccode\u003eControl.Newtype.under\u003c/code\u003e.  Also, most use cases don't need full polymorphism,\n so only the single constructor \u003ccode\u003e\u003ca\u003e_Wrapping\u003c/a\u003e\u003c/code\u003e functions would be needed.\n\u003c/p\u003e\u003cp\u003eThese equivalences aren't 100% honest, because \u003ccode\u003enewtype\u003c/code\u003e's operators\n need to rely on two \u003ccode\u003eNewtype\u003c/code\u003e constraints.  This means that the wrapper used\n for the output is not necessarily the same as the input.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "Wrapped",
          "package": "lens",
          "source": "src/Control-Lens-Wrapped.html",
          "type": "module"
        },
        "index": {
          "description": "The Wrapped class provides similar functionality as Control.Newtype from the newtype package but in more convenient and efficient form There are few functions from newtype that are not provided here because they can be done with the Iso directly Control.Newtype.over Sum Unwrapping Sum Control.Newtype.under Sum Wrapping Sum Control.Newtype.overF Sum mapping Unwrapping Sum Control.Newtype.underF Sum mapping Wrapping Sum under can also be used with Unwrapping to provide the equivalent of Control.Newtype.under Also most use cases don need full polymorphism so only the single constructor Wrapping functions would be needed These equivalences aren honest because newtype operators need to rely on two Newtype constraints This means that the wrapper used for the output is not necessarily the same as the input",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "Wrapped",
          "package": "lens",
          "partial": "Wrapped",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Wrapped",
          "name": "Rewrapped",
          "package": "lens",
          "source": "src/Control-Lens-Wrapped.html#Rewrapped",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "Rewrapped",
          "package": "lens",
          "partial": "Rewrapped",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#t:Rewrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Wrapped",
          "name": "Rewrapping",
          "package": "lens",
          "source": "src/Control-Lens-Wrapped.html#Rewrapping",
          "type": "class"
        },
        "index": {
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "Rewrapping",
          "package": "lens",
          "partial": "Rewrapping",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#t:Rewrapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eWrapped\u003c/a\u003e\u003c/code\u003e provides isomorphisms to wrap and unwrap newtypes or\n data types with one constructor.\n\u003c/p\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "Wrapped",
          "package": "lens",
          "source": "src/Control-Lens-Wrapped.html#Wrapped",
          "type": "class"
        },
        "index": {
          "description": "Wrapped provides isomorphisms to wrap and unwrap newtypes or data types with one constructor",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "Wrapped",
          "package": "lens",
          "partial": "Wrapped",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#t:Wrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapped",
          "package": "lens",
          "signature": "Iso (Unwrapped t) (Unwrapped s) t s",
          "source": "src/Control-Lens-Wrapped.html#_Unwrapped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapped",
          "package": "lens",
          "partial": "Unwrapped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Unwrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapped'",
          "package": "lens",
          "signature": "Iso' (Unwrapped s) s",
          "source": "src/Control-Lens-Wrapped.html#_Unwrapped%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapped'",
          "package": "lens",
          "partial": "Unwrapped'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Unwrapped-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient version of \u003ccode\u003e\u003ca\u003e_Unwrapped\u003c/a\u003e\u003c/code\u003e with an argument that's ignored.\n\u003c/p\u003e\u003cp\u003eThe user supplied function is \u003cem\u003eignored\u003c/em\u003e, merely its types are used.\n\u003c/p\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapping",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e Iso (Unwrapped t) (Unwrapped s) t s",
          "source": "src/Control-Lens-Wrapped.html#_Unwrapping",
          "type": "function"
        },
        "index": {
          "description": "This is convenient version of Unwrapped with an argument that ignored The user supplied function is ignored merely its types are used",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapping",
          "normalized": "(Unwrapped a-\u003ea)-\u003eIso(Unwrapped b)(Unwrapped a)b a",
          "package": "lens",
          "partial": "Unwrapping",
          "signature": "(Unwrapped s-\u003es)-\u003eIso(Unwrapped t)(Unwrapped s)t s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Unwrapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient version of \u003ccode\u003e\u003ca\u003e_Wrapped\u003c/a\u003e\u003c/code\u003e with an argument that's ignored.\n\u003c/p\u003e\u003cp\u003eThe user supplied function is \u003cem\u003eignored\u003c/em\u003e, merely its type is used.\n\u003c/p\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapping'",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e Iso' (Unwrapped s) s",
          "source": "src/Control-Lens-Wrapped.html#_Unwrapping%27",
          "type": "function"
        },
        "index": {
          "description": "This is convenient version of Wrapped with an argument that ignored The user supplied function is ignored merely its type is used",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Unwrapping'",
          "normalized": "(Unwrapped a-\u003ea)-\u003eIso'(Unwrapped a)a",
          "package": "lens",
          "partial": "Unwrapping'",
          "signature": "(Unwrapped s-\u003es)-\u003eIso'(Unwrapped s)s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Unwrapping-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWork under a newtype wrapper.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eConst \"hello\" & _Wrapped %~ length & getConst\n\u003c/code\u003e\u003c/strong\u003e5\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Wrapped\u003c/a\u003e\u003c/code\u003e   &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Unwrapped\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_Unwrapped\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_Wrapped\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapped",
          "package": "lens",
          "signature": "Iso s t (Unwrapped s) (Unwrapped t)",
          "source": "src/Control-Lens-Wrapped.html#_Wrapped",
          "type": "function"
        },
        "index": {
          "description": "Work under newtype wrapper Const hello Wrapped length getConst Wrapped from Unwrapped Unwrapped from Wrapped",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapped",
          "package": "lens",
          "partial": "Wrapped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Wrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn isomorphism between \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapped'",
          "package": "lens",
          "signature": "Iso' s (Unwrapped s)",
          "source": "src/Control-Lens-Wrapped.html#_Wrapped%27",
          "type": "method"
        },
        "index": {
          "description": "An isomorphism between and",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapped'",
          "package": "lens",
          "partial": "Wrapped'",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Wrapped-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient version of \u003ccode\u003e\u003ca\u003e_Wrapped\u003c/a\u003e\u003c/code\u003e with an argument that's ignored.\n\u003c/p\u003e\u003cp\u003eThe user supplied function is \u003cem\u003eignored\u003c/em\u003e, merely its types are used.\n\u003c/p\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapping",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e Iso s t (Unwrapped s) (Unwrapped t)",
          "source": "src/Control-Lens-Wrapped.html#_Wrapping",
          "type": "function"
        },
        "index": {
          "description": "This is convenient version of Wrapped with an argument that ignored The user supplied function is ignored merely its types are used",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapping",
          "normalized": "(Unwrapped a-\u003ea)-\u003eIso a b(Unwrapped a)(Unwrapped b)",
          "package": "lens",
          "partial": "Wrapping",
          "signature": "(Unwrapped s-\u003es)-\u003eIso s t(Unwrapped s)(Unwrapped t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Wrapping"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a convenient version of \u003ccode\u003e\u003ca\u003e_Wrapped\u003c/a\u003e\u003c/code\u003e with an argument that's ignored.\n\u003c/p\u003e\u003cp\u003eThe user supplied function is \u003cem\u003eignored\u003c/em\u003e, merely its type is used.\n\u003c/p\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapping'",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e Iso' s (Unwrapped s)",
          "source": "src/Control-Lens-Wrapped.html#_Wrapping%27",
          "type": "function"
        },
        "index": {
          "description": "This is convenient version of Wrapped with an argument that ignored The user supplied function is ignored merely its type is used",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "_Wrapping'",
          "normalized": "(Unwrapped a-\u003ea)-\u003eIso' a(Unwrapped a)",
          "package": "lens",
          "partial": "Wrapping'",
          "signature": "(Unwrapped s-\u003es)-\u003eIso' s(Unwrapped s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:_Wrapping-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator is based on \u003ccode\u003eala\u003c/code\u003e from Conor McBride's work on Epigram.\n\u003c/p\u003e\u003cp\u003eAs with \u003ccode\u003e\u003ca\u003e_Wrapping\u003c/a\u003e\u003c/code\u003e, the user supplied function for the newtype is \u003cem\u003eignored\u003c/em\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala Sum foldMap [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala All foldMap [True,True]\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala All foldMap [True,False]\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala Any foldMap [False,False]\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala Any foldMap [True,False]\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala Sum foldMap [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eala Product foldMap [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e24\n\u003c/pre\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "ala",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e ((Unwrapped t -\u003e t) -\u003e e -\u003e s) -\u003e e -\u003e Unwrapped s",
          "source": "src/Control-Lens-Wrapped.html#ala",
          "type": "function"
        },
        "index": {
          "description": "This combinator is based on ala from Conor McBride work on Epigram As with Wrapping the user supplied function for the newtype is ignored ala Sum foldMap ala All foldMap True True True ala All foldMap True False False ala Any foldMap False False False ala Any foldMap True False True ala Sum foldMap ala Product foldMap",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "ala",
          "normalized": "(Unwrapped a-\u003ea)-\u003e((Unwrapped b-\u003eb)-\u003ec-\u003ea)-\u003ec-\u003eUnwrapped a",
          "package": "lens",
          "signature": "(Unwrapped s-\u003es)-\u003e((Unwrapped t-\u003et)-\u003ee-\u003es)-\u003ee-\u003eUnwrapped s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:ala"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis combinator is based on \u003ccode\u003eala'\u003c/code\u003e from Conor McBride's work on Epigram.\n\u003c/p\u003e\u003cp\u003eAs with \u003ccode\u003e\u003ca\u003e_Wrapping\u003c/a\u003e\u003c/code\u003e, the user supplied function for the newtype is \u003cem\u003eignored\u003c/em\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ealaf Sum foldMap length [\"hello\",\"world\"]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "alaf",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e (p r t -\u003e e -\u003e s) -\u003e p r (Unwrapped t) -\u003e e -\u003e Unwrapped s",
          "source": "src/Control-Lens-Wrapped.html#alaf",
          "type": "function"
        },
        "index": {
          "description": "This combinator is based on ala from Conor McBride work on Epigram As with Wrapping the user supplied function for the newtype is ignored alaf Sum foldMap length hello world",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "alaf",
          "normalized": "(Unwrapped a-\u003ea)-\u003e(b c d-\u003ee-\u003ea)-\u003eb c(Unwrapped d)-\u003ee-\u003eUnwrapped a",
          "package": "lens",
          "signature": "(Unwrapped s-\u003es)-\u003e(p r t-\u003ee-\u003es)-\u003ep r(Unwrapped t)-\u003ee-\u003eUnwrapped s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:alaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the constructor for a \u003ccode\u003e\u003ca\u003eWrapped\u003c/a\u003e\u003c/code\u003e type, return a\n deconstructor that is its inverse.\n\u003c/p\u003e\u003cp\u003eAssuming the \u003ccode\u003e\u003ca\u003eWrapped\u003c/a\u003e\u003c/code\u003e instance is legal, these laws hold:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eop\u003c/a\u003e\u003c/code\u003e f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n f \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eop\u003c/a\u003e\u003c/code\u003e f &#8801; \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eop Identity (Identity 4)\n\u003c/code\u003e\u003c/strong\u003e4\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eop Const (Const \"hello\")\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e",
          "module": "Control.Lens.Wrapped",
          "name": "op",
          "package": "lens",
          "signature": "(Unwrapped s -\u003e s) -\u003e s -\u003e Unwrapped s",
          "source": "src/Control-Lens-Wrapped.html#op",
          "type": "function"
        },
        "index": {
          "description": "Given the constructor for Wrapped type return deconstructor that is its inverse Assuming the Wrapped instance is legal these laws hold op id op id op Identity Identity op Const Const hello hello",
          "hierarchy": "Control Lens Wrapped",
          "module": "Control.Lens.Wrapped",
          "name": "op",
          "normalized": "(Unwrapped a-\u003ea)-\u003ea-\u003eUnwrapped a",
          "package": "lens",
          "signature": "(Unwrapped s-\u003es)-\u003es-\u003eUnwrapped s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Wrapped.html#v:op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Lens.Zoom",
          "name": "Zoom",
          "package": "lens",
          "source": "src/Control-Lens-Zoom.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Lens Zoom",
          "module": "Control.Lens.Zoom",
          "name": "Zoom",
          "package": "lens",
          "partial": "Zoom",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Zoom.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class allows us to use \u003ccode\u003e\u003ca\u003emagnify\u003c/a\u003e\u003c/code\u003e part of the environment, changing the environment supplied by\n many different \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformers. Unlike \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e this can change the environment of a deeply nested \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer.\n\u003c/p\u003e\u003cp\u003eAlso, unlike \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e, this can be used with any valid \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, but cannot be used with a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Lens.Zoom",
          "name": "Magnify",
          "package": "lens",
          "source": "src/Control-Lens-Zoom.html#Magnify",
          "type": "class"
        },
        "index": {
          "description": "This class allows us to use magnify part of the environment changing the environment supplied by many different Monad transformers Unlike zoom this can change the environment of deeply nested Monad transformer Also unlike zoom this can be used with any valid Getter but cannot be used with Traversal or Fold",
          "hierarchy": "Control Lens Zoom",
          "module": "Control.Lens.Zoom",
          "name": "Magnify",
          "package": "lens",
          "partial": "Magnify",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Zoom.html#t:Magnify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis class allows us to use \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e in, changing the \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e supplied by\n many different \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformers, potentially quite\n deep in a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack.\n\u003c/p\u003e",
          "module": "Control.Lens.Zoom",
          "name": "Zoom",
          "package": "lens",
          "source": "src/Control-Lens-Zoom.html#Zoom",
          "type": "class"
        },
        "index": {
          "description": "This class allows us to use zoom in changing the State supplied by many different Monad transformers potentially quite deep in Monad transformer stack",
          "hierarchy": "Control Lens Zoom",
          "module": "Control.Lens.Zoom",
          "name": "Zoom",
          "package": "lens",
          "partial": "Zoom",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Zoom.html#t:Zoom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a monadic action in a larger environment than it was defined in, using a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis acts like \u003ccode\u003e\u003ca\u003elocal\u003c/a\u003e\u003c/code\u003e, but can in many cases change the type of the environment as well.\n\u003c/p\u003e\u003cp\u003eThis is commonly used to lift actions in a simpler \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e with a larger environment type.\n\u003c/p\u003e\u003cp\u003eThis can be used to edit pretty much any \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack with an environment in it:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(1,2) & magnify _2 (+1)\n\u003c/code\u003e\u003c/strong\u003e3\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip Reader.runReader (1,2) $ magnify _1 Reader.ask\n\u003c/code\u003e\u003c/strong\u003e1\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip Reader.runReader (1,2,[10..20]) $ magnify (_3._tail) Reader.ask\n\u003c/code\u003e\u003c/strong\u003e[11,12,13,14,15,16,17,18,19,20]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emagnify\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a -\u003e (a -\u003e r) -\u003e s -\u003e r\n \u003ccode\u003e\u003ca\u003emagnify\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e r =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a   -\u003e (a -\u003e r) -\u003e s -\u003e r\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003emagnify\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e w                 =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s t -\u003e \u003ccode\u003e\u003ca\u003eRWS\u003c/a\u003e\u003c/code\u003e t w st c -\u003e \u003ccode\u003e\u003ca\u003eRWS\u003c/a\u003e\u003c/code\u003e s w st c\n \u003ccode\u003e\u003ca\u003emagnify\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e w, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e c) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a   -\u003e \u003ccode\u003e\u003ca\u003eRWS\u003c/a\u003e\u003c/code\u003e a w st c -\u003e \u003ccode\u003e\u003ca\u003eRWS\u003c/a\u003e\u003c/code\u003e s w st c\n ...\n\u003c/pre\u003e",
          "module": "Control.Lens.Zoom",
          "name": "magnify",
          "package": "lens",
          "signature": "LensLike' (Magnified m c) a b -\u003e m c -\u003e n c",
          "source": "src/Control-Lens-Zoom.html#magnify",
          "type": "method"
        },
        "index": {
          "description": "Run monadic action in larger environment than it was defined in using Getter This acts like local but can in many cases change the type of the environment as well This is commonly used to lift actions in simpler Reader Monad into Monad with larger environment type This can be used to edit pretty much any Monad transformer stack with an environment in it magnify flip Reader.runReader magnify Reader.ask flip Reader.runReader magnify tail Reader.ask magnify Getter magnify Monoid Fold magnify Monoid Getter RWS st RWS st magnify Monoid Monoid Fold RWS st RWS st",
          "hierarchy": "Control Lens Zoom",
          "module": "Control.Lens.Zoom",
          "name": "magnify",
          "normalized": "LensLike'(Magnified a b)c d-\u003ea b-\u003ee b",
          "package": "lens",
          "signature": "LensLike'(Magnified m c)a b-\u003em c-\u003en c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Zoom.html#v:magnify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a monadic action in a larger \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e than it was defined in,\n using a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is commonly used to lift actions in a simpler \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e into a \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e with a larger \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e\u003cp\u003eWhen applied to a \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e over\n multiple values, the actions for each target are executed sequentially\n and the results are aggregated.\n\u003c/p\u003e\u003cp\u003eThis can be used to edit pretty much any \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e transformer stack with a \u003ccode\u003e\u003ca\u003eState\u003c/a\u003e\u003c/code\u003e in it!\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip State.evalState (a,b) $ zoom _1 $ use id\n\u003c/code\u003e\u003c/strong\u003ea\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip State.execState (a,b) $ zoom _1 $ id .= c\n\u003c/code\u003e\u003c/strong\u003e(c,b)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip State.execState [(a,b),(c,d)] $ zoom traverse $ _2 %= f\n\u003c/code\u003e\u003c/strong\u003e[(a,f b),(c,f d)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip State.runState [(a,b),(c,d)] $ zoom traverse $ _2 \u003c%= f\n\u003c/code\u003e\u003c/strong\u003e(f b \u003c\u003e f d \u003c\u003e mempty,[(a,f b),(c,f d)])\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eflip State.evalState (a,b) $ zoom both (use id)\n\u003c/code\u003e\u003c/strong\u003ea \u003c\u003e b\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s t      -\u003e \u003ccode\u003e\u003ca\u003eStateT\u003c/a\u003e\u003c/code\u003e t m a -\u003e \u003ccode\u003e\u003ca\u003eStateT\u003c/a\u003e\u003c/code\u003e s m a\n \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e c) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s t -\u003e \u003ccode\u003e\u003ca\u003eStateT\u003c/a\u003e\u003c/code\u003e t m c -\u003e \u003ccode\u003e\u003ca\u003eStateT\u003c/a\u003e\u003c/code\u003e s m c\n \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e w)             =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s t      -\u003e \u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w t m c -\u003e \u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w s m c\n \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e w, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e c) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s t -\u003e \u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w t m c -\u003e \u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w s m c\n \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e w, \u003ccode\u003e\u003ca\u003eError\u003c/a\u003e\u003c/code\u003e e)  =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s t      -\u003e \u003ccode\u003e\u003ca\u003eErrorT\u003c/a\u003e\u003c/code\u003e e (\u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w t m) c -\u003e \u003ccode\u003e\u003ca\u003eErrorT\u003c/a\u003e\u003c/code\u003e e (\u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w s m) c\n \u003ccode\u003e\u003ca\u003ezoom\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e m, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e w, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e c, \u003ccode\u003e\u003ca\u003eError\u003c/a\u003e\u003c/code\u003e e) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s t -\u003e \u003ccode\u003e\u003ca\u003eErrorT\u003c/a\u003e\u003c/code\u003e e (\u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w t m) c -\u003e \u003ccode\u003e\u003ca\u003eErrorT\u003c/a\u003e\u003c/code\u003e e (\u003ccode\u003e\u003ca\u003eRWST\u003c/a\u003e\u003c/code\u003e r w s m) c\n ...\n\u003c/pre\u003e",
          "module": "Control.Lens.Zoom",
          "name": "zoom",
          "package": "lens",
          "signature": "LensLike' (Zoomed m c) t s -\u003e m c -\u003e n c",
          "source": "src/Control-Lens-Zoom.html#zoom",
          "type": "method"
        },
        "index": {
          "description": "Run monadic action in larger State than it was defined in using Lens or Traversal This is commonly used to lift actions in simpler State Monad into State Monad with larger State type When applied to Simple Traversal over multiple values the actions for each target are executed sequentially and the results are aggregated This can be used to edit pretty much any Monad transformer stack with State in it flip State.evalState zoom use id flip State.execState zoom id flip State.execState zoom traverse flip State.runState zoom traverse mempty flip State.evalState zoom both use id zoom Monad Lens StateT StateT zoom Monad Monoid Traversal StateT StateT zoom Monad Monoid Lens RWST RWST zoom Monad Monoid Monoid Traversal RWST RWST zoom Monad Monoid Error Lens ErrorT RWST ErrorT RWST zoom Monad Monoid Monoid Error Traversal ErrorT RWST ErrorT RWST",
          "hierarchy": "Control Lens Zoom",
          "module": "Control.Lens.Zoom",
          "name": "zoom",
          "normalized": "LensLike'(Zoomed a b)c d-\u003ea b-\u003ee b",
          "package": "lens",
          "signature": "LensLike'(Zoomed m c)t s-\u003em c-\u003en c",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens-Zoom.html#v:zoom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUsage:\n\u003c/p\u003e\u003cp\u003eYou can derive lenses automatically for many data types:\n\u003c/p\u003e\u003cpre\u003e\n import Control.Lens\n data Foo a = Foo { _fooArgs :: [\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e], _fooValue :: a }\n \u003ccode\u003e\u003ca\u003emakeLenses\u003c/a\u003e\u003c/code\u003e ''Foo\n\u003c/pre\u003e\u003cp\u003eThis defines the following lenses:\n\u003c/p\u003e\u003cpre\u003e\n fooArgs :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e (Foo a) [\u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e]\n fooValue :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (Foo a) (Foo b) a b\n\u003c/pre\u003e\u003cp\u003eYou can then access the value with (\u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e) and set the value of the field\n with (\u003ccode\u003e\u003ca\u003e.~\u003c/a\u003e\u003c/code\u003e) and can use almost any other combinator that is re-exported\n here on those fields.\n\u003c/p\u003e\u003cp\u003eThe combinators here have unusually specific type signatures, so for\n particularly tricky ones, the simpler type signatures you might want to\n pretend the combinators have are specified as well.\n\u003c/p\u003e\u003cp\u003eMore information on how to use lenses is available on the lens wiki:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://github.com/ekmett/lens/wiki\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003e\u003cimg src=\"Hierarchy.png\"/\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Usage You can derive lenses automatically for many data types import Control.Lens data Foo Foo fooArgs String fooValue makeLenses Foo This defines the following lenses fooArgs Lens Foo String fooValue Lens Foo Foo You can then access the value with and set the value of the field with and can use almost any other combinator that is re-exported here on those fields The combinators here have unusually specific type signatures so for particularly tricky ones the simpler type signatures you might want to pretend the combinators have are specified as well More information on how to use lenses is available on the lens wiki http github.com ekmett lens wiki",
          "hierarchy": "Control Lens",
          "module": "Control.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Error.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Monad-Error-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoth \u003ccode\u003eexceptions\u003c/code\u003e and \u003ca\u003eControl.Exception\u003c/a\u003e provide a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e\u003cp\u003eThis lets us write combinators to build handlers that are agnostic about the choice of\n which of these they use.\n\u003c/p\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "Handleable",
          "package": "lens",
          "source": "src/Control-Lens-Internal-Exception.html#Handleable",
          "type": "class"
        },
        "index": {
          "description": "Both exceptions and Control.Exception provide Handler type This lets us write combinators to build handlers that are agnostic about the choice of which of these they use",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "Handleable",
          "package": "lens",
          "partial": "Handleable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#t:Handleable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYou need this when using \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "Handler",
          "package": "lens",
          "source": "src/Control-Monad-Error-Lens.html#Handler",
          "type": "data"
        },
        "index": {
          "description": "You need this when using catches",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "Handler",
          "package": "lens",
          "partial": "Handler",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#t:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Error.Lens",
          "name": "Handler",
          "package": "lens",
          "signature": "forall a . Handler (e -\u003e Maybe a) (a -\u003e m r)",
          "source": "src/Control-Monad-Error-Lens.html#Handler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "Handler",
          "normalized": "a b Handler(c-\u003eMaybe b)(b-\u003ed e)",
          "package": "lens",
          "partial": "Handler",
          "signature": "forall a Handler(e-\u003eMaybe a)(a-\u003em r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:Handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function exists to remedy a gap between the functionality of \u003ccode\u003eControl.Exception\u003c/code\u003e\n and \u003ccode\u003eControl.Monad.Error\u003c/code\u003e. \u003ccode\u003eControl.Exception\u003c/code\u003e supplies \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e and\n a notion of \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e, which we duplicate here in a form suitable for\n working with any \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e instance.\n\u003c/p\u003e\u003cp\u003eSometimes you want to catch two different sorts of error. You could\n do something like\n\u003c/p\u003e\u003cpre\u003e\n f = \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e _Foo handleFoo (\u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e _Bar handleBar expr)\n\u003c/pre\u003e\u003cp\u003eHowever, there are a couple of problems with this approach. The first is\n that having two exception handlers is inefficient. However, the more\n serious issue is that the second exception handler will catch exceptions\n in the first, e.g. in the example above, if \u003ccode\u003ehandleFoo\u003c/code\u003e uses \u003ccode\u003e\u003ca\u003ethrowError\u003c/a\u003e\u003c/code\u003e\n then the second exception handler will catch it.\n\u003c/p\u003e\u003cp\u003eInstead, we provide a function \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e, which would be used thus:\n\u003c/p\u003e\u003cpre\u003e\n f = \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e expr [ \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e _Foo handleFoo\n                  , \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e _Bar handleBar\n                  ]\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "catches",
          "package": "lens",
          "signature": "m a -\u003e [Handler e m a] -\u003e m a",
          "source": "src/Control-Monad-Error-Lens.html#catches",
          "type": "function"
        },
        "index": {
          "description": "This function exists to remedy gap between the functionality of Control.Exception and Control.Monad.Error Control.Exception supplies catches and notion of Handler which we duplicate here in form suitable for working with any MonadError instance Sometimes you want to catch two different sorts of error You could do something like handling Foo handleFoo handling Bar handleBar expr However there are couple of problems with this approach The first is that having two exception handlers is inefficient However the more serious issue is that the second exception handler will catch exceptions in the first e.g in the example above if handleFoo uses throwError then the second exception handler will catch it Instead we provide function catches which would be used thus catches expr handler Foo handleFoo handler Bar handleBar",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "catches",
          "normalized": "a b-\u003e[Handler c a b]-\u003ea b",
          "package": "lens",
          "signature": "m a-\u003e[Handler e m a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:catches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatch exceptions that match a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e e a      -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e (a -\u003e m r) -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "catching",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e (a -\u003e m r) -\u003e m r",
          "source": "src/Control-Monad-Error-Lens.html#catching",
          "type": "function"
        },
        "index": {
          "description": "Catch exceptions that match given Prism or any Getter really catching MonadError Prism catching MonadError Lens catching MonadError Traversal catching MonadError Iso catching MonadError Getter catching MonadError Fold",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "catching",
          "normalized": "Getting(First a)b a-\u003ec d-\u003e(a-\u003ec d)-\u003ec d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003e(a-\u003em r)-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:catching"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatch exceptions that match a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e), discarding\n the information about the match. This is particuarly useful when you have\n a \u003ccode\u003e\u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e ()\u003c/code\u003e where the result of the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e isn't\n particularly valuable, just the fact that it matches.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e e a      -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e m r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "catching_",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e m r -\u003e m r",
          "source": "src/Control-Monad-Error-Lens.html#catching_",
          "type": "function"
        },
        "index": {
          "description": "Catch exceptions that match given Prism or any Getter discarding the information about the match This is particuarly useful when you have Prism where the result of the Prism or Fold isn particularly valuable just the fact that it matches catching MonadError Prism catching MonadError Lens catching MonadError Traversal catching MonadError Iso catching MonadError Getter catching MonadError Fold",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "catching_",
          "normalized": "Getting(First a)b a-\u003ec d-\u003ec d-\u003ec d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003em r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:catching_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis builds a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e for just the targets of a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e ... [ \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_AssertionFailed\u003c/a\u003e\u003c/code\u003e (s -\u003e \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \"Assertion Failed\\n\" \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e s)\n             , \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_ErrorCall\u003c/a\u003e\u003c/code\u003e (s -\u003e \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e$\u003c/a\u003e\u003c/code\u003e \"Error\\n\" \u003ccode\u003e\u003ca\u003e++\u003c/a\u003e\u003c/code\u003e s)\n             ]\n\u003c/pre\u003e\u003cp\u003eThis works ith both the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Exception\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Catch\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Error.Lens\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e (a -\u003e m r) -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "handler",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e (a -\u003e m r) -\u003e h r",
          "source": "src/Control-Lens-Internal-Exception.html#handler",
          "type": "method"
        },
        "index": {
          "description": "This builds Handler for just the targets of given Prism or any Getter really catches handler AssertionFailed print Assertion Failed handler ErrorCall print Error This works ith both the Handler type provided by Control.Exception handler Getter SomeException IO Handler handler Fold SomeException IO Handler handler Prism SomeException IO Handler handler Lens SomeException IO Handler handler Traversal SomeException IO Handler and with the Handler type provided by Control.Monad.Catch handler Getter SomeException Handler handler Fold SomeException Handler handler Prism SomeException Handler handler Lens SomeException Handler handler Traversal SomeException Handler and with the Handler type provided by Control.Monad.Error.Lens handler Getter Handler handler Fold Handler handler Prism Handler handler Lens Handler handler Traversal Handler",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "handler",
          "normalized": "Getting(First a)b a-\u003e(a-\u003ec d)-\u003ee d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003e(a-\u003em r)-\u003eh r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:handler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis builds a \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e for just the targets of a given \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, really).\n that ignores its input and just recovers with the stated monadic action.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ecatches\u003c/a\u003e\u003c/code\u003e ... [ \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_NonTermination\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e \"looped\")\n             , \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e_StackOverflow\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e \"overflow\")\n             ]\n\u003c/pre\u003e\u003cp\u003eThis works with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Exception\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Catch\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e m r\n\u003c/pre\u003e\u003cp\u003eand with the \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e type provided by \u003ccode\u003eControl.Monad.Error.Lens\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e     e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e       e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e     e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e      e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n \u003ccode\u003e\u003ca\u003ehandler_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e \u003ccode\u003e\u003ca\u003eHandler\u003c/a\u003e\u003c/code\u003e e m r\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "handler_",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e h r",
          "source": "src/Control-Lens-Internal-Exception.html#handler_",
          "type": "method"
        },
        "index": {
          "description": "This builds Handler for just the targets of given Prism or any Getter really that ignores its input and just recovers with the stated monadic action catches handler NonTermination return looped handler StackOverflow return overflow This works with the Handler type provided by Control.Exception handler Getter SomeException IO Handler handler Fold SomeException IO Handler handler Prism SomeException IO Handler handler Lens SomeException IO Handler handler Traversal SomeException IO Handler and with the Handler type provided by Control.Monad.Catch handler Getter SomeException Handler handler Fold SomeException Handler handler Prism SomeException Handler handler Lens SomeException Handler handler Traversal SomeException Handler and with the Handler type provided by Control.Monad.Error.Lens handler Getter Handler handler Fold Handler handler Prism Handler handler Lens Handler handler Traversal Handler",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "handler_",
          "normalized": "Getting(First a)b a-\u003ec d-\u003ee d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003eh r",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:handler_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatching\u003c/a\u003e\u003c/code\u003e with the arguments swapped around; useful in\n situations where the code for the handler is shorter.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e a     -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e e a      -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e e a       -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e e a       -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e e a     -\u003e (a -\u003e m r) -\u003e m r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "handling",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e (a -\u003e m r) -\u003e m r -\u003e m r",
          "source": "src/Control-Monad-Error-Lens.html#handling",
          "type": "function"
        },
        "index": {
          "description": "version of catching with the arguments swapped around useful in situations where the code for the handler is shorter handling MonadError Prism handling MonadError Lens handling MonadError Traversal handling MonadError Iso handling MonadError Fold handling MonadError Getter",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "handling",
          "normalized": "Getting(First a)b a-\u003e(a-\u003ec d)-\u003ec d-\u003ec d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003e(a-\u003em r)-\u003em r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:handling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA version of \u003ccode\u003e\u003ca\u003ecatching_\u003c/a\u003e\u003c/code\u003e with the arguments swapped around; useful in\n situations where the code for the handler is shorter.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e e a      -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e m r -\u003e m r\n \u003ccode\u003e\u003ca\u003ehandling_\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e m r -\u003e m r\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "handling_",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e m r -\u003e m r",
          "source": "src/Control-Monad-Error-Lens.html#handling_",
          "type": "function"
        },
        "index": {
          "description": "version of catching with the arguments swapped around useful in situations where the code for the handler is shorter handling MonadError Prism handling MonadError Lens handling MonadError Traversal handling MonadError Iso handling MonadError Getter handling MonadError Fold",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "handling_",
          "normalized": "Getting(First a)b a-\u003ec d-\u003ec d-\u003ec d",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003em r-\u003em r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:handling_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow an \u003ccode\u003eException\u003c/code\u003e described by a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e l &#8801; \u003ccode\u003e\u003ca\u003ereviews\u003c/a\u003e\u003c/code\u003e l \u003ccode\u003e\u003ca\u003ethrowError\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e t -\u003e t -\u003e a\n \u003ccode\u003e\u003ca\u003ethrowing\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e e t   -\u003e t -\u003e a\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "throwing",
          "package": "lens",
          "signature": "AReview e e t t -\u003e t -\u003e m x",
          "source": "src/Control-Monad-Error-Lens.html#throwing",
          "type": "function"
        },
        "index": {
          "description": "Throw an Exception described by Prism throwing reviews throwError throwing MonadError Prism throwing MonadError Iso",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "throwing",
          "normalized": "AReview a a b b-\u003eb-\u003ec d",
          "package": "lens",
          "signature": "AReview e e t t-\u003et-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:throwing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e takes a \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e (or any \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e) to select which exceptions are caught\n If the \u003ccode\u003eException\u003c/code\u003e does not match the predicate, it is re-thrown.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e e a      -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e e a -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e e a     -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n \u003ccode\u003e\u003ca\u003etrying\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eMonadError\u003c/a\u003e\u003c/code\u003e e m =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e e a       -\u003e m r -\u003e m (\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a r)\n\u003c/pre\u003e",
          "module": "Control.Monad.Error.Lens",
          "name": "trying",
          "package": "lens",
          "signature": "Getting (First a) e a -\u003e m r -\u003e m (Either a r)",
          "source": "src/Control-Monad-Error-Lens.html#trying",
          "type": "function"
        },
        "index": {
          "description": "trying takes Prism or any Getter to select which exceptions are caught If the Exception does not match the predicate it is re-thrown trying MonadError Prism Either trying MonadError Lens Either trying MonadError Traversal Either trying MonadError Iso Either trying MonadError Getter Either trying MonadError Fold Either",
          "hierarchy": "Control Monad Error Lens",
          "module": "Control.Monad.Error.Lens",
          "name": "trying",
          "normalized": "Getting(First a)b a-\u003ec d-\u003ec(Either a d)",
          "package": "lens",
          "signature": "Getting(First a)e a-\u003em r-\u003em(Either a r)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Error-Lens.html#v:trying"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Primitive.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Monad-Primitive-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Monad Primitive Lens",
          "module": "Control.Monad.Primitive.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Primitive-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Monad.Primitive.Lens",
          "name": "prim",
          "package": "lens",
          "signature": "Iso' (m a) (State# (PrimState m) -\u003e (#State# (PrimState m), a#))",
          "source": "src/Control-Monad-Primitive-Lens.html#prim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Monad Primitive Lens",
          "module": "Control.Monad.Primitive.Lens",
          "name": "prim",
          "normalized": "Iso'(a b)(State #(PrimState a)-\u003e(#State #(PrimState a),b #))",
          "package": "lens",
          "signature": "Iso'(m a)(State #(PrimState m)-\u003e(#State #(PrimState m),a #))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Monad-Primitive-Lens.html#v:prim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e can be used to take the role of \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e in\n \u003ccode\u003eControl.Parallel.Strategies\u003c/code\u003e, enabling those combinators to work with\n monomorphic containers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Parallel-Strategies-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Lens or Traversal can be used to take the role of Traversable in Control.Parallel.Strategies enabling those combinators to work with monomorphic containers",
          "hierarchy": "Control Parallel Strategies Lens",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Parallel-Strategies-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to\n first evaluates its argument according to a given \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e \u003cem\u003ebefore\u003c/em\u003e proceeding.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eafter\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003erdeepseq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e t =\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e [a]\n\u003c/pre\u003e",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "after",
          "package": "lens",
          "signature": "Strategy s -\u003e LensLike f s t a b -\u003e LensLike f s t a b",
          "source": "src/Control-Parallel-Strategies-Lens.html#after",
          "type": "function"
        },
        "index": {
          "description": "Transform Lens Fold Getter Setter or Traversal to first evaluates its argument according to given Strategy before proceeding after rdeepseq traverse Traversable Strategy Strategy",
          "hierarchy": "Control Parallel Strategies Lens",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "after",
          "normalized": "Strategy a-\u003eLensLike b a c d e-\u003eLensLike b a c d e",
          "package": "lens",
          "signature": "Strategy s-\u003eLensLike f s t a b-\u003eLensLike f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Parallel-Strategies-Lens.html#v:after"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate the targets of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into a data structure\n according to the given \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eevalTraversable\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eevalOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eevalOf\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eevalOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e s\n \u003ccode\u003e\u003ca\u003eevalOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e s\n \u003ccode\u003e\u003ca\u003eevalOf\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eEval\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eEval\u003c/a\u003e\u003c/code\u003e s) -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e s\n\u003c/pre\u003e",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "evalOf",
          "package": "lens",
          "signature": "LensLike' Eval s a -\u003e Strategy a -\u003e Strategy s",
          "source": "src/Control-Parallel-Strategies-Lens.html#evalOf",
          "type": "function"
        },
        "index": {
          "description": "Evaluate the targets of Lens or Traversal into data structure according to the given Strategy evalTraversable evalOf traverse traverse evalOf id evalOf Lens Strategy Strategy evalOf Traversal Strategy Strategy evalOf Eval Eval Strategy Strategy",
          "hierarchy": "Control Parallel Strategies Lens",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "evalOf",
          "normalized": "LensLike' Eval a b-\u003eStrategy b-\u003eStrategy a",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike' Eval s a-\u003eStrategy a-\u003eStrategy s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Parallel-Strategies-Lens.html#v:evalOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate the targets of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e according into a\n data structure according to a given \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e in parallel.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eparTraversable\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eparOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eparOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e s\n \u003ccode\u003e\u003ca\u003eparOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e s\n \u003ccode\u003e\u003ca\u003eparOf\u003c/a\u003e\u003c/code\u003e :: ((a -\u003e \u003ccode\u003e\u003ca\u003eEval\u003c/a\u003e\u003c/code\u003e a) -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eEval\u003c/a\u003e\u003c/code\u003e s) -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e s\n\u003c/pre\u003e",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "parOf",
          "package": "lens",
          "signature": "LensLike' Eval s a -\u003e Strategy a -\u003e Strategy s",
          "source": "src/Control-Parallel-Strategies-Lens.html#parOf",
          "type": "function"
        },
        "index": {
          "description": "Evaluate the targets of Lens or Traversal according into data structure according to given Strategy in parallel parTraversable parOf traverse parOf Lens Strategy Strategy parOf Traversal Strategy Strategy parOf Eval Eval Strategy Strategy",
          "hierarchy": "Control Parallel Strategies Lens",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "parOf",
          "normalized": "LensLike' Eval a b-\u003eStrategy b-\u003eStrategy a",
          "package": "lens",
          "partial": "Of",
          "signature": "LensLike' Eval s a-\u003eStrategy a-\u003eStrategy s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Parallel-Strategies-Lens.html#v:parOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e to\n evaluate its argument according to a given \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e \u003cem\u003ein parallel with\u003c/em\u003e evaluating.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ethroughout\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003erdeepseq\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversable\u003c/a\u003e\u003c/code\u003e t =\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eStrategy\u003c/a\u003e\u003c/code\u003e [a]\n\u003c/pre\u003e",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "throughout",
          "package": "lens",
          "signature": "Strategy s -\u003e LensLike f s t a b -\u003e LensLike f s t a b",
          "source": "src/Control-Parallel-Strategies-Lens.html#throughout",
          "type": "function"
        },
        "index": {
          "description": "Transform Lens Fold Getter Setter or Traversal to evaluate its argument according to given Strategy in parallel with evaluating throughout rdeepseq traverse Traversable Strategy Strategy",
          "hierarchy": "Control Parallel Strategies Lens",
          "module": "Control.Parallel.Strategies.Lens",
          "name": "throughout",
          "normalized": "Strategy a-\u003eLensLike b a c d e-\u003eLensLike b a c d e",
          "package": "lens",
          "signature": "Strategy s-\u003eLensLike f s t a b-\u003eLensLike f s t a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Parallel-Strategies-Lens.html#v:throughout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e can be used to take the role of \u003ccode\u003eFoldable\u003c/code\u003e in \u003ccode\u003eControl.Seq\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Control.Seq.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Control-Seq-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Fold can be used to take the role of Foldable in Control.Seq",
          "hierarchy": "Control Seq Lens",
          "module": "Control.Seq.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Seq-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate the elements targeted by a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e according to the given strategy.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eseqFoldable\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eseqOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Control.Seq.Lens",
          "name": "seqOf",
          "package": "lens",
          "signature": "Getting (Endo [a]) s a -\u003e Strategy a -\u003e Strategy s",
          "source": "src/Control-Seq-Lens.html#seqOf",
          "type": "function"
        },
        "index": {
          "description": "Evaluate the elements targeted by Lens Traversal Iso Getter or Fold according to the given strategy seqFoldable seqOf folded",
          "hierarchy": "Control Seq Lens",
          "module": "Control.Seq.Lens",
          "name": "seqOf",
          "normalized": "Getting(Endo[a])b a-\u003eStrategy a-\u003eStrategy b",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Endo[a])s a-\u003eStrategy a-\u003eStrategy s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Control-Seq-Lens.html#v:seqOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Aeson-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "AsJSON",
          "package": "lens",
          "source": "src/Data-Aeson-Lens.html#AsJSON",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "AsJSON",
          "package": "lens",
          "partial": "As JSON",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#t:AsJSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "AsNumber",
          "package": "lens",
          "source": "src/Data-Aeson-Lens.html#AsNumber",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "AsNumber",
          "package": "lens",
          "partial": "As Number",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#t:AsNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "AsPrimitive",
          "package": "lens",
          "source": "src/Data-Aeson-Lens.html#AsPrimitive",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "AsPrimitive",
          "package": "lens",
          "partial": "As Primitive",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#t:AsPrimitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "AsValue",
          "package": "lens",
          "source": "src/Data-Aeson-Lens.html#AsValue",
          "type": "class"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "AsValue",
          "package": "lens",
          "partial": "As Value",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#t:AsValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrimitives of \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Aeson.Lens",
          "name": "Primitive",
          "package": "lens",
          "source": "src/Data-Aeson-Lens.html#Primitive",
          "type": "data"
        },
        "index": {
          "description": "Primitives of Value",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "Primitive",
          "package": "lens",
          "partial": "Primitive",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#t:Primitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "BoolPrim",
          "package": "lens",
          "signature": "BoolPrim !Bool",
          "source": "src/Data-Aeson-Lens.html#Primitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "BoolPrim",
          "package": "lens",
          "partial": "Bool Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:BoolPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "NullPrim",
          "package": "lens",
          "signature": "NullPrim",
          "source": "src/Data-Aeson-Lens.html#Primitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "NullPrim",
          "package": "lens",
          "partial": "Null Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:NullPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "NumberPrim",
          "package": "lens",
          "signature": "NumberPrim !Scientific",
          "source": "src/Data-Aeson-Lens.html#Primitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "NumberPrim",
          "package": "lens",
          "partial": "Number Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:NumberPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "StringPrim",
          "package": "lens",
          "signature": "StringPrim !Text",
          "source": "src/Data-Aeson-Lens.html#Primitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "StringPrim",
          "package": "lens",
          "partial": "String Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:StringPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" ^? _Array\n\u003c/code\u003e\u003c/strong\u003eJust (fromList [Number 1.0,Number 2.0,Number 3.0])\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Array",
          "package": "lens",
          "signature": "Prism' t (Vector Value)",
          "source": "src/Data-Aeson-Lens.html#_Array",
          "type": "method"
        },
        "index": {
          "description": "Array Just fromList Number Number Number",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Array",
          "package": "lens",
          "partial": "Array",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "_Bool",
          "package": "lens",
          "signature": "Prism' t Bool",
          "source": "src/Data-Aeson-Lens.html#_Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Bool",
          "package": "lens",
          "partial": "Bool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrism into an \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e over a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ePrimitive\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eScientific\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[10.2]\" ^? nth 0 . _Double\n\u003c/code\u003e\u003c/strong\u003eJust 10.2\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Double",
          "package": "lens",
          "signature": "Prism' t Double",
          "source": "src/Data-Aeson-Lens.html#_Double",
          "type": "method"
        },
        "index": {
          "description": "Prism into an Double over Value Primitive or Scientific nth Double Just",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Double",
          "package": "lens",
          "partial": "Double",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrism into an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e over a \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ePrimitive\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eScientific\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[10]\" ^? nth 0 . _Integer\n\u003c/code\u003e\u003c/strong\u003eJust 10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[10.5]\" ^? nth 0 . _Integer\n\u003c/code\u003e\u003c/strong\u003eJust 10\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Integer",
          "package": "lens",
          "signature": "Prism' t Integer",
          "source": "src/Data-Aeson-Lens.html#_Integer",
          "type": "method"
        },
        "index": {
          "description": "Prism into an Integer over Value Primitive or Scientific nth Integer Just nth Integer Just",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Integer",
          "package": "lens",
          "partial": "Integer",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess Integer \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003es as Integrals.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[10]\" ^? nth 0 . _Integral\n\u003c/code\u003e\u003c/strong\u003eJust 10\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[10.5]\" ^? nth 0 . _Integral\n\u003c/code\u003e\u003c/strong\u003eJust 10\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Integral",
          "package": "lens",
          "signature": "Prism' t a",
          "source": "src/Data-Aeson-Lens.html#_Integral",
          "type": "function"
        },
        "index": {
          "description": "Access Integer Value as Integrals nth Integral Just nth Integral Just",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Integral",
          "package": "lens",
          "partial": "Integral",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Prism into \u003ccode\u003e\u003ca\u003eValue\u003c/a\u003e\u003c/code\u003e on lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_JSON",
          "package": "lens",
          "signature": "Prism' t a",
          "source": "src/Data-Aeson-Lens.html#_JSON",
          "type": "method"
        },
        "index": {
          "description": "Prism into Value on lazy ByteString",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_JSON",
          "package": "lens",
          "partial": "JSON",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_JSON"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "_Null",
          "package": "lens",
          "signature": "Prism' t ()",
          "source": "src/Data-Aeson-Lens.html#_Null",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Null",
          "normalized": "Prism' a()",
          "package": "lens",
          "partial": "Null",
          "signature": "Prism' t()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\"]\" ^? nth 0 . _Number\n\u003c/code\u003e\u003c/strong\u003eJust 1.0\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\"]\" ^? nth 1 . _Number\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Number",
          "package": "lens",
          "signature": "Prism' t Scientific",
          "source": "src/Data-Aeson-Lens.html#_Number",
          "type": "method"
        },
        "index": {
          "description": "nth Number Just nth Number Nothing",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Number",
          "package": "lens",
          "partial": "Number",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": {}, \\\"b\\\": null}\" ^? key \"a\" . _Object\n\u003c/code\u003e\u003c/strong\u003eJust fromList []\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": {}, \\\"b\\\": null}\" ^? key \"b\" . _Object\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Object",
          "package": "lens",
          "signature": "Prism' t (HashMap Text Value)",
          "source": "src/Data-Aeson-Lens.html#_Object",
          "type": "method"
        },
        "index": {
          "description": "null key Object Just fromList null key Object Nothing",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Object",
          "package": "lens",
          "partial": "Object",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Object"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\", null, true, false]\" ^? nth 0 . _Primitive\n\u003c/code\u003e\u003c/strong\u003eJust (NumberPrim 1.0)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\", null, true, false]\" ^? nth 1 . _Primitive\n\u003c/code\u003e\u003c/strong\u003eJust (StringPrim \"x\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\", null, true, false]\" ^? nth 2 . _Primitive\n\u003c/code\u003e\u003c/strong\u003eJust NullPrim\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\", null, true, false]\" ^? nth 3 . _Primitive\n\u003c/code\u003e\u003c/strong\u003eJust (BoolPrim True)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1, \\\"x\\\", null, true, false]\" ^? nth 4 . _Primitive\n\u003c/code\u003e\u003c/strong\u003eJust (BoolPrim False)\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Primitive",
          "package": "lens",
          "signature": "Prism' t Primitive",
          "source": "src/Data-Aeson-Lens.html#_Primitive",
          "type": "method"
        },
        "index": {
          "description": "null true false nth Primitive Just NumberPrim null true false nth Primitive Just StringPrim null true false nth Primitive Just NullPrim null true false nth Primitive Just BoolPrim True null true false nth Primitive Just BoolPrim False",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Primitive",
          "package": "lens",
          "partial": "Primitive",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Primitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Aeson.Lens",
          "name": "_String",
          "package": "lens",
          "signature": "Prism' t Text",
          "source": "src/Data-Aeson-Lens.html#_String",
          "type": "method"
        },
        "index": {
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_String",
          "package": "lens",
          "partial": "String",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" ^? _Value\n\u003c/code\u003e\u003c/strong\u003eJust (Array (fromList [Number 1.0,Number 2.0,Number 3.0]))\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "_Value",
          "package": "lens",
          "signature": "Prism' t Value",
          "source": "src/Data-Aeson-Lens.html#_Value",
          "type": "method"
        },
        "index": {
          "description": "Value Just Array fromList Number Number Number",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "_Value",
          "package": "lens",
          "partial": "Value",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:_Value"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e, but for \u003ccode\u003e\u003ca\u003eObject\u003c/a\u003e\u003c/code\u003e with Text indices. This often has better\n inference than \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e when used with OverloadedStrings.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": 100, \\\"b\\\": 200}\" ^? key \"a\"\n\u003c/code\u003e\u003c/strong\u003eJust (Number 100.0)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" ^? key \"a\"\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "key",
          "package": "lens",
          "signature": "Text -\u003e Traversal' t Value",
          "source": "src/Data-Aeson-Lens.html#key",
          "type": "function"
        },
        "index": {
          "description": "Like ix but for Object with Text indices This often has better inference than ix when used with OverloadedStrings key Just Number key Nothing",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "key",
          "normalized": "Text-\u003eTraversal' a Value",
          "package": "lens",
          "signature": "Text-\u003eTraversal' t Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn indexed Traversal into Object properties\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": 4, \\\"b\\\": 7}\" ^@.. members\n\u003c/code\u003e\u003c/strong\u003e[(\"a\",Number 4.0),(\"b\",Number 7.0)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": 4, \\\"b\\\": 7}\" & members . _Number *~ 10\n\u003c/code\u003e\u003c/strong\u003e\"{\\\"a\\\":40,\\\"b\\\":70}\"\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "members",
          "package": "lens",
          "signature": "IndexedTraversal' Text t Value",
          "source": "src/Data-Aeson-Lens.html#members",
          "type": "function"
        },
        "index": {
          "description": "An indexed Traversal into Object properties members Number Number members Number",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "members",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:members"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrism into non-\u003ccode\u003e\u003ca\u003eNull\u003c/a\u003e\u003c/code\u003e values\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": \\\"xyz\\\", \\\"b\\\": null}\" ^? key \"a\" . nonNull\n\u003c/code\u003e\u003c/strong\u003eJust (String \"xyz\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": {}, \\\"b\\\": null}\" ^? key \"a\" . nonNull\n\u003c/code\u003e\u003c/strong\u003eJust (Object fromList [])\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"{\\\"a\\\": \\\"xyz\\\", \\\"b\\\": null}\" ^? key \"b\" . nonNull\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "nonNull",
          "package": "lens",
          "signature": "Prism' Value Value",
          "source": "src/Data-Aeson-Lens.html#nonNull",
          "type": "function"
        },
        "index": {
          "description": "Prism into non Null values xyz null key nonNull Just String xyz null key nonNull Just Object fromList xyz null key nonNull Nothing",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "nonNull",
          "package": "lens",
          "partial": "Null",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:nonNull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e, but for Arrays with Int indexes\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" ^? nth 1\n\u003c/code\u003e\u003c/strong\u003eJust (Number 2.0)\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"\\\"a\\\": 100, \\\"b\\\": 200}\" ^? nth 1\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" & nth 1 .~ Number 20\n\u003c/code\u003e\u003c/strong\u003e\"[1,20,3]\"\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "nth",
          "package": "lens",
          "signature": "Int -\u003e Traversal' t Value",
          "source": "src/Data-Aeson-Lens.html#nth",
          "type": "function"
        },
        "index": {
          "description": "Like ix but for Arrays with Int indexes nth Just Number nth Nothing nth Number",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "nth",
          "normalized": "Int-\u003eTraversal' a Value",
          "package": "lens",
          "signature": "Int-\u003eTraversal' t Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:nth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn indexed Traversal into Array elements\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" ^.. values\n\u003c/code\u003e\u003c/strong\u003e[Number 1.0,Number 2.0,Number 3.0]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"[1,2,3]\" & values . _Number *~ 10\n\u003c/code\u003e\u003c/strong\u003e\"[10,20,30]\"\n\u003c/pre\u003e",
          "module": "Data.Aeson.Lens",
          "name": "values",
          "package": "lens",
          "signature": "IndexedTraversal' Int t Value",
          "source": "src/Data-Aeson-Lens.html#values",
          "type": "function"
        },
        "index": {
          "description": "An indexed Traversal into Array elements values Number Number Number values Number",
          "hierarchy": "Data Aeson Lens",
          "module": "Data.Aeson.Lens",
          "name": "values",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Aeson-Lens.html#v:values"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Array.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Array-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Array Lens",
          "module": "Data.Array.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Array-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003esetter\u003c/code\u003e can be used to derive a new \u003ccode\u003e\u003ca\u003eIArray\u003c/a\u003e\u003c/code\u003e from an old \u003ccode\u003eIAarray\u003c/code\u003e by\n applying a function to each of the indices to look it up in the old \u003ccode\u003e\u003ca\u003eIArray\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is a \u003cem\u003econtravariant\u003c/em\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eixmap\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eixmapped\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eixmapped\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eixmap\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eixmapped\u003c/a\u003e\u003c/code\u003e b) f arr \u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e i &#8801; arr \u003ccode\u003e\u003ca\u003e!\u003c/a\u003e\u003c/code\u003e f i\n \u003ccode\u003e\u003ca\u003ebounds\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eover\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eixmapped\u003c/a\u003e\u003c/code\u003e b) f arr) &#8801; b\n\u003c/pre\u003e",
          "module": "Data.Array.Lens",
          "name": "ixmapped",
          "package": "lens",
          "signature": "(i, i) -\u003e IndexPreservingSetter (a j e) (a i e) i j",
          "source": "src/Data-Array-Lens.html#ixmapped",
          "type": "function"
        },
        "index": {
          "description": "This setter can be used to derive new IArray from an old IAarray by applying function to each of the indices to look it up in the old IArray This is contravariant Setter ixmap over ixmapped ixmapped setting ixmap over ixmapped arr arr bounds over ixmapped arr",
          "hierarchy": "Data Array Lens",
          "module": "Data.Array.Lens",
          "name": "ixmapped",
          "normalized": "(a,a)-\u003eIndexPreservingSetter(b c d)(b a d)a c",
          "package": "lens",
          "signature": "(i,i)-\u003eIndexPreservingSetter(a j e)(a i e)i j",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Array-Lens.html#v:ixmapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bits.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Bits-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.|.~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Data-Bits-Lens.html#%3C%3C.%7C.~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.|.~) \u003c\u003c.|.~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60--60-.-124-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.|.=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Data-Bits-Lens.html#%3C%3C.%7C.%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.|.=) \u003c\u003c.|.=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60--60-.-124-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.&.~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) a) s a -\u003e a -\u003e q s (a, s)",
          "source": "src/Data-Bits-Lens.html#%3C%3C.%26.~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.&.~) \u003c\u003c.&.~",
          "normalized": "Optical'(-\u003e)a((,)b)c b-\u003eb-\u003ea c(b,c)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)a)s a-\u003ea-\u003eq s(a,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60--60-.-38-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.&.=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Data-Bits-Lens.html#%3C%3C.%26.%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c\u003c.&.=) \u003c\u003c.&.=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60--60-.-38-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \u003ccode\u003e\u003ca\u003e.|.\u003c/a\u003e\u003c/code\u003e the target(s) of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e), returning the result\n (or a monoidal summary of all of the results).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 \u003c.|.~ 6 $ (\"hello\",3)\n\u003c/code\u003e\u003c/strong\u003e(7,(\"hello\",7))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.|.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a a       -\u003e a -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.|.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a      -\u003e a -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.|.~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e a -\u003e s -\u003e (a, t)\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.|.~)",
          "package": "lens",
          "signature": "LensLike ((,) a) s t a a -\u003e a -\u003e s -\u003e (a, t)",
          "source": "src/Data-Bits-Lens.html#%3C.%7C.~",
          "type": "function"
        },
        "index": {
          "description": "Bitwise the target of Lens or Traversal returning the result or monoidal summary of all of the results hello hello Bits Iso Bits Lens Bits Monoid Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.|.~) \u003c.|.~",
          "normalized": "LensLike((,)a)b c a a-\u003ea-\u003eb-\u003e(a,c)",
          "package": "lens",
          "signature": "LensLike((,)a)s t a a-\u003ea-\u003es-\u003e(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60-.-124-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, (or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e) by computing its bitwise \u003ccode\u003e\u003ca\u003e.|.\u003c/a\u003e\u003c/code\u003e with another value,\n returning the result (or a monoidal summary of all of the results traversed).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erunState (_1 \u003c.|.= 7) (28,0)\n\u003c/code\u003e\u003c/strong\u003e(31,(31,0))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.|.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a)           =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c.|.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.|.=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Data-Bits-Lens.html#%3C.%7C.%3D",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Lens or Traversal by computing its bitwise with another value returning the result or monoidal summary of all of the results traversed runState MonadState Bits Lens MonadState Bits Monoid Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.|.=) \u003c.|.=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60-.-124-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e the target(s) of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, returning the result\n (or a monoidal summary of all of the results).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 \u003c.&.~ 7 $ (\"hello\",254)\n\u003c/code\u003e\u003c/strong\u003e(6,(\"hello\",6))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.&.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e       s t a a -\u003e a -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.&.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e      s t a a -\u003e a -\u003e s -\u003e (a, t)\n (\u003ccode\u003e\u003ca\u003e\u003c.&.~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e a -\u003e s -\u003e (a, t)\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.&.~)",
          "package": "lens",
          "signature": "LensLike ((,) a) s t a a -\u003e a -\u003e s -\u003e (a, t)",
          "source": "src/Data-Bits-Lens.html#%3C.%26.~",
          "type": "function"
        },
        "index": {
          "description": "Bitwise the target of Lens or Traversal returning the result or monoidal summary of all of the results hello hello Bits Iso Bits Lens Bits Monoid Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.&.~) \u003c.&.~",
          "normalized": "LensLike((,)a)b c a a-\u003ea-\u003eb-\u003e(a,c)",
          "package": "lens",
          "signature": "LensLike((,)a)s t a a-\u003ea-\u003es-\u003e(a,t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60-.-38-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e) by computing its bitwise \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e with another value,\n returning the result (or a monoidal summary of all of the results traversed).\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003erunState (_1 \u003c.&.= 15) (31,0)\n\u003c/code\u003e\u003c/strong\u003e(15,(15,0))\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.&.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a)           =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m a\n (\u003ccode\u003e\u003ca\u003e\u003c.&.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m a\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.&.=)",
          "package": "lens",
          "signature": "LensLike' ((,) a) s a -\u003e a -\u003e m a",
          "source": "src/Data-Bits-Lens.html#%3C.%26.%3D",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Lens or Traversal by computing its bitwise with another value returning the result or monoidal summary of all of the results traversed runState MonadState Bits Lens MonadState Bits Monoid Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(\u003c.&.=) \u003c.&.=",
          "normalized": "LensLike'((,)a)b a-\u003ea-\u003ec a",
          "package": "lens",
          "signature": "LensLike'((,)a)s a-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:-60-.-38-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \u003ccode\u003e\u003ca\u003e.|.\u003c/a\u003e\u003c/code\u003e the target(s) of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 .|.~ 6 $ (\"hello\",3)\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",7)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.|.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a a    -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.|.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a a       -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.|.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a      -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.|.~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e a -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(.|.~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Data-Bits-Lens.html#.%7C.~",
          "type": "function"
        },
        "index": {
          "description": "Bitwise the target of Lens or Setter hello hello Bits Setter Bits Iso Bits Lens Monoid Bits Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(.|.~) .|.~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:.-124-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by computing its bitwise \u003ccode\u003e\u003ca\u003e.|.\u003c/a\u003e\u003c/code\u003e with another value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 .|.= 15; _2 .|.= 3) (7,7)\n\u003c/code\u003e\u003c/strong\u003e(15,7)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.|.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.|.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.|.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.|.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(.|.=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Data-Bits-Lens.html#.%7C.%3D",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Lens Setter or Traversal by computing its bitwise with another value execState do MonadState Bits Setter MonadState Bits Iso MonadState Bits Lens MonadState Bits Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(.|.=) .|.=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:.-124-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBitwise \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e the target(s) of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_2 .&.~ 7 $ (\"hello\",254)\n\u003c/code\u003e\u003c/strong\u003e(\"hello\",6)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.&.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s t a a    -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.&.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s t a a       -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.&.~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a             =\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s t a a      -\u003e a -\u003e s -\u003e t\n (\u003ccode\u003e\u003ca\u003e.&.~\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonoid\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s t a a -\u003e a -\u003e s -\u003e t\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(.&.~)",
          "package": "lens",
          "signature": "ASetter s t a a -\u003e a -\u003e s -\u003e t",
          "source": "src/Data-Bits-Lens.html#.%26.~",
          "type": "function"
        },
        "index": {
          "description": "Bitwise the target of Lens or Setter hello hello Bits Setter Bits Iso Bits Lens Monoid Bits Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(.&.~) .&.~",
          "normalized": "ASetter a b c c-\u003ec-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t a a-\u003ea-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:.-38-.-126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e by computing its bitwise \u003ccode\u003e\u003ca\u003e.&.\u003c/a\u003e\u003c/code\u003e with another value.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (do _1 .&.= 15; _2 .&.= 3) (7,7)\n\u003c/code\u003e\u003c/strong\u003e(7,3)\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e.&.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s a    -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.&.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.&.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e a -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e.&.=\u003c/a\u003e\u003c/code\u003e) :: (\u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m, \u003ccode\u003e\u003ca\u003eBits\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e a -\u003e m ()\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "(.&.=)",
          "package": "lens",
          "signature": "ASetter' s a -\u003e a -\u003e m ()",
          "source": "src/Data-Bits-Lens.html#.%26.%3D",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Lens Setter or Traversal by computing its bitwise with another value execState do MonadState Bits Setter MonadState Bits Iso MonadState Bits Lens MonadState Bits Traversal",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "(.&.=) .&.=",
          "normalized": "ASetter' a b-\u003eb-\u003ec()",
          "package": "lens",
          "signature": "ASetter' s a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:.-38-.-61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used to access the value of the nth bit in a number.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ebitAt\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e is only a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003eb\u003c/code\u003e if \u003ccode\u003e0 \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e n \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebitSize\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e :: b)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e16^.bitAt 4\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e15^.bitAt 4\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e15 & bitAt 4 .~ True\n\u003c/code\u003e\u003c/strong\u003e31\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e16 & bitAt 4 .~ False\n\u003c/code\u003e\u003c/strong\u003e0\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "bitAt",
          "package": "lens",
          "signature": "Int -\u003e IndexedLens' Int b Bool",
          "source": "src/Data-Bits-Lens.html#bitAt",
          "type": "function"
        },
        "index": {
          "description": "This Lens can be used to access the value of the nth bit in number bitAt is only legal Lens into if bitSize undefined bitAt True bitAt False bitAt True bitAt False",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "bitAt",
          "normalized": "Int-\u003eIndexedLens' Int a Bool",
          "package": "lens",
          "partial": "At",
          "signature": "Int-\u003eIndexedLens' Int b Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:bitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse over all bits in a numeric type.\n\u003c/p\u003e\u003cp\u003eThe bit position is available as the index.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoListOf bits (5 :: Word8)\n\u003c/code\u003e\u003c/strong\u003e[True,False,True,False,False,False,False,False]\n\u003c/pre\u003e\u003cp\u003eIf you supply this an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e, the result will be an infinite \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, which\n can be productively consumed, but not reassembled.\n\u003c/p\u003e",
          "module": "Data.Bits.Lens",
          "name": "bits",
          "package": "lens",
          "signature": "IndexedTraversal' Int b Bool",
          "source": "src/Data-Bits-Lens.html#bits",
          "type": "function"
        },
        "index": {
          "description": "Traverse over all bits in numeric type The bit position is available as the index toListOf bits Word8 True False True False False False False False If you supply this an Integer the result will be an infinite Traversal which can be productively consumed but not reassembled",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "bits",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:bits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the nth byte, counting from the low end.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ebyteAt\u003c/a\u003e\u003c/code\u003e n\u003c/code\u003e is a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into \u003ccode\u003eb\u003c/code\u003e iff \u003ccode\u003e0 \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e n \u003ccode\u003e\u003ca\u003e\u003c\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ebitSize\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e :: b)) 8\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(0xff00 :: Word16)^.byteAt 0\n\u003c/code\u003e\u003c/strong\u003e0\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(0xff00 :: Word16)^.byteAt 1\n\u003c/code\u003e\u003c/strong\u003e255\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebyteAt 1 .~ 0 $ 0xff00 :: Word16\n\u003c/code\u003e\u003c/strong\u003e0\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebyteAt 0 .~ 0xff $ 0 :: Word16\n\u003c/code\u003e\u003c/strong\u003e255\n\u003c/pre\u003e",
          "module": "Data.Bits.Lens",
          "name": "byteAt",
          "package": "lens",
          "signature": "Int -\u003e IndexedLens' Int b Word8",
          "source": "src/Data-Bits-Lens.html#byteAt",
          "type": "function"
        },
        "index": {
          "description": "Get the nth byte counting from the low end byteAt is legal Lens into iff div bitSize undefined xff00 Word16 byteAt xff00 Word16 byteAt byteAt xff00 Word16 byteAt xff Word16",
          "hierarchy": "Data Bits Lens",
          "module": "Data.Bits.Lens",
          "name": "byteAt",
          "normalized": "Int-\u003eIndexedLens' Int a Word",
          "package": "lens",
          "partial": "At",
          "signature": "Int-\u003eIndexedLens' Int b Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Bits-Lens.html#v:byteAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e lenses.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-ByteString-Lazy-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Lazy ByteString lenses",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual bytes in a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e walks each strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e chunk in a tree-like fashion\n enable zippers to seek to locations more quickly and accelerate\n many monoidal queries, but up to associativity (and constant factors) it is\n equivalent to the much slower:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf bytes (== 0x80) (Char8.pack \"hello\")\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cp\u003eNote that when just using this as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n can be more efficient.\n\u003c/p\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "bytes",
          "package": "lens",
          "signature": "IndexedTraversal' Int64 ByteString Word8",
          "source": "src/Data-ByteString-Lazy-Lens.html#bytes",
          "type": "function"
        },
        "index": {
          "description": "Traverse the individual bytes in ByteString This Traversal walks each strict ByteString chunk in tree-like fashion enable zippers to seek to locations more quickly and accelerate many monoidal queries but up to associativity and constant factors it is equivalent to the much slower bytes unpackedBytes traversed anyOf bytes x80 Char8.pack hello False Note that when just using this as Setter setting map can be more efficient",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "bytes",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#v:bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual bytes in a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e as characters.\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e walks each strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e chunk in a tree-like fashion\n enable zippers to seek to locations more quickly and accelerate\n many monoidal queries, but up to associativity (and constant factors) it is\n equivalent to:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echars\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf chars (== 'h') \"hello\"\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "chars",
          "package": "lens",
          "signature": "IndexedTraversal' Int64 ByteString Char",
          "source": "src/Data-ByteString-Lazy-Lens.html#chars",
          "type": "function"
        },
        "index": {
          "description": "Traverse the individual bytes in ByteString as characters When writing back to the ByteString it is assumed that every Char lies between x00 and xff This Traversal walks each strict ByteString chunk in tree-like fashion enable zippers to seek to locations more quickly and accelerate many monoidal queries but up to associativity and constant factors it is equivalent to chars unpackedChars traversed anyOf chars hello True",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "chars",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#v:chars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) a list of bytes into a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801;  x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[104,101,108,108,111]^.packedBytes == Char8.pack \"hello\"\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "packedBytes",
          "package": "lens",
          "signature": "Iso' [Word8] ByteString",
          "source": "src/Data-ByteString-Lazy-Lens.html#packedBytes",
          "type": "function"
        },
        "index": {
          "description": "pack or unpack list of bytes into ByteString packedBytes from unpackedBytes pack packedBytes unpack from packedBytes packedBytes Char8.pack hello True",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "packedBytes",
          "normalized": "Iso'[Word]ByteString",
          "package": "lens",
          "partial": "Bytes",
          "signature": "Iso'[Word]ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#v:packedBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) a list of characters into a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.packedChars.each.re (base 16 . enum).to (\\x -\u003e if Prelude.length x == 1 then '0':x else x)\n\u003c/code\u003e\u003c/strong\u003e\"68656c6c6f\"\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "packedChars",
          "package": "lens",
          "signature": "Iso' String ByteString",
          "source": "src/Data-ByteString-Lazy-Lens.html#packedChars",
          "type": "function"
        },
        "index": {
          "description": "pack or unpack list of characters into ByteString When writing back to the ByteString it is assumed that every Char lies between x00 and xff packedChars from unpackedChars pack packedChars unpack from packedChars hello packedChars.each.re base enum to if Prelude.length then else c6c6f",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "packedChars",
          "package": "lens",
          "partial": "Chars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#v:packedChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a list of bytes\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801;  x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.packedChars.unpackedBytes\n\u003c/code\u003e\u003c/strong\u003e[104,101,108,108,111]\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "unpackedBytes",
          "package": "lens",
          "signature": "Iso' ByteString [Word8]",
          "source": "src/Data-ByteString-Lazy-Lens.html#unpackedBytes",
          "type": "function"
        },
        "index": {
          "description": "unpack or pack ByteString into list of bytes unpackedBytes from packedBytes unpack unpackedBytes pack from unpackedBytes hello packedChars.unpackedBytes",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "unpackedBytes",
          "normalized": "Iso' ByteString[Word]",
          "package": "lens",
          "partial": "Bytes",
          "signature": "Iso' ByteString[Word]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#v:unpackedBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) a list of characters into a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[104,101,108,108,111]^.packedBytes.unpackedChars\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "unpackedChars",
          "package": "lens",
          "signature": "Iso' ByteString String",
          "source": "src/Data-ByteString-Lazy-Lens.html#unpackedChars",
          "type": "function"
        },
        "index": {
          "description": "unpack or pack list of characters into ByteString When writing back to the ByteString it is assumed that every Char lies between x00 and xff unpackedChars from packedChars unpack unpackedChars pack from unpackedChars packedBytes.unpackedChars hello",
          "hierarchy": "Data ByteString Lazy Lens",
          "module": "Data.ByteString.Lazy.Lens",
          "name": "unpackedChars",
          "package": "lens",
          "partial": "Chars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lazy-Lens.html#v:unpackedChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.ByteString.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-ByteString-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraversals for ByteStrings.\n\u003c/p\u003e",
          "module": "Data.ByteString.Lens",
          "name": "IsByteString",
          "package": "lens",
          "source": "src/Data-ByteString-Lens.html#IsByteString",
          "type": "class"
        },
        "index": {
          "description": "Traversals for ByteStrings",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "IsByteString",
          "package": "lens",
          "partial": "Is Byte String",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#t:IsByteString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse each \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e in a strict or lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e walks each strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e chunk in a tree-like fashion\n enable zippers to seek to locations more quickly and accelerate\n many monoidal queries, but up to associativity (and constant factors) it is\n equivalent to the much slower:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebytes\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e 0x80) :: \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lens",
          "name": "bytes",
          "package": "lens",
          "signature": "IndexedTraversal' Int t Word8",
          "source": "src/Data-ByteString-Lens.html#bytes",
          "type": "method"
        },
        "index": {
          "description": "Traverse each Word8 in strict or lazy ByteString This Traversal walks each strict ByteString chunk in tree-like fashion enable zippers to seek to locations more quickly and accelerate many monoidal queries but up to associativity and constant factors it is equivalent to the much slower bytes unpackedBytes traversed anyOf bytes x80 ByteString Bool",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "bytes",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#v:bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual bytes in a strict or lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e as characters.\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e walks each strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e chunk in a tree-like fashion\n enable zippers to seek to locations more quickly and accelerate\n many monoidal queries, but up to associativity (and constant factors) it is\n equivalent to the much slower:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eanyOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003echars\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e 'c') :: \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lens",
          "name": "chars",
          "package": "lens",
          "signature": "IndexedTraversal' Int t Char",
          "source": "src/Data-ByteString-Lens.html#chars",
          "type": "method"
        },
        "index": {
          "description": "Traverse the individual bytes in strict or lazy ByteString as characters When writing back to the ByteString it is assumed that every Char lies between x00 and xff This Traversal walks each strict ByteString chunk in tree-like fashion enable zippers to seek to locations more quickly and accelerate many monoidal queries but up to associativity and constant factors it is equivalent to the much slower chars unpackedChars traversed anyOf chars ByteString Bool",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "chars",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#v:chars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) a list of bytes into a strict or lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lens",
          "name": "packedBytes",
          "package": "lens",
          "signature": "Iso' [Word8] t",
          "source": "src/Data-ByteString-Lens.html#packedBytes",
          "type": "method"
        },
        "index": {
          "description": "pack or unpack list of bytes into strict or lazy ByteString pack packedBytes unpack from packedBytes packedBytes from unpackedBytes",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "packedBytes",
          "normalized": "Iso'[Word]a",
          "package": "lens",
          "partial": "Bytes",
          "signature": "Iso'[Word]t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#v:packedBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) a list of characters into a strict or lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lens",
          "name": "packedChars",
          "package": "lens",
          "signature": "Iso' String t",
          "source": "src/Data-ByteString-Lens.html#packedChars",
          "type": "method"
        },
        "index": {
          "description": "pack or unpack list of characters into strict or lazy ByteString When writing back to the ByteString it is assumed that every Char lies between x00 and xff pack packedChars unpack from packedChars packedChars from unpackedChars",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "packedChars",
          "package": "lens",
          "partial": "Chars",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#v:packedChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a list of bytes\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801;  x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e [\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e]\n \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e [\u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e]\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lens",
          "name": "unpackedBytes",
          "package": "lens",
          "signature": "Iso' t [Word8]",
          "source": "src/Data-ByteString-Lens.html#unpackedBytes",
          "type": "function"
        },
        "index": {
          "description": "unpack or pack ByteString into list of bytes unpackedBytes from packedBytes unpack unpackedBytes pack from unpackedBytes unpackedBytes Iso ByteString Word8 unpackedBytes Iso ByteString Word8",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "unpackedBytes",
          "normalized": "Iso' a[Word]",
          "package": "lens",
          "partial": "Bytes",
          "signature": "Iso' t[Word]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#v:unpackedBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) a list of characters into a strict (or lazy) \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.ByteString.Lens",
          "name": "unpackedChars",
          "package": "lens",
          "signature": "Iso' t String",
          "source": "src/Data-ByteString-Lens.html#unpackedChars",
          "type": "function"
        },
        "index": {
          "description": "unpack or pack list of characters into strict or lazy ByteString When writing back to the ByteString it is assumed that every Char lies between x00 and xff unpackedChars from packedChars unpack unpackedChars pack from unpackedChars unpackedChars Iso ByteString String unpackedChars Iso ByteString String",
          "hierarchy": "Data ByteString Lens",
          "module": "Data.ByteString.Lens",
          "name": "unpackedChars",
          "package": "lens",
          "partial": "Chars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Lens.html#v:unpackedChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.ByteString.Strict.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-ByteString-Strict-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse each \u003ccode\u003e\u003ca\u003eWord8\u003c/a\u003e\u003c/code\u003e in a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e walks the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e in a tree-like fashion\n enable zippers to seek to locations in logarithmic time and accelerating\n many monoidal queries, but up to associativity (and constant factors)\n it is equivalent to the much slower:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ebytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf bytes (== 0x80) (Char8.pack \"hello\")\n\u003c/code\u003e\u003c/strong\u003eFalse\n\u003c/pre\u003e\u003cp\u003eNote that when just using this as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n can be more efficient.\n\u003c/p\u003e",
          "module": "Data.ByteString.Strict.Lens",
          "name": "bytes",
          "package": "lens",
          "signature": "IndexedTraversal' Int ByteString Word8",
          "source": "src/Data-ByteString-Strict-Lens.html#bytes",
          "type": "function"
        },
        "index": {
          "description": "Traverse each Word8 in ByteString This Traversal walks the ByteString in tree-like fashion enable zippers to seek to locations in logarithmic time and accelerating many monoidal queries but up to associativity and constant factors it is equivalent to the much slower bytes unpackedBytes traversed anyOf bytes x80 Char8.pack hello False Note that when just using this as Setter setting map can be more efficient",
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "bytes",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#v:bytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual bytes in a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e as characters.\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e walks the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e in a tree-like fashion\n enable zippers to seek to locations in logarithmic time and accelerating\n many monoidal queries, but up to associativity (and constant factors)\n it is equivalent to the much slower:\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echars\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf chars (== 'h') \"hello\"\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Data.ByteString.Strict.Lens",
          "name": "chars",
          "package": "lens",
          "signature": "IndexedTraversal' Int ByteString Char",
          "source": "src/Data-ByteString-Strict-Lens.html#chars",
          "type": "function"
        },
        "index": {
          "description": "Traverse the individual bytes in ByteString as characters When writing back to the ByteString it is assumed that every Char lies between x00 and xff This Traversal walks the ByteString in tree-like fashion enable zippers to seek to locations in logarithmic time and accelerating many monoidal queries but up to associativity and constant factors it is equivalent to the much slower chars unpackedChars traverse anyOf chars hello True",
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "chars",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#v:chars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) a list of bytes into a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801;  x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[104,101,108,108,111]^.packedBytes\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e",
          "module": "Data.ByteString.Strict.Lens",
          "name": "packedBytes",
          "package": "lens",
          "signature": "Iso' [Word8] ByteString",
          "source": "src/Data-ByteString-Strict-Lens.html#packedBytes",
          "type": "function"
        },
        "index": {
          "description": "pack or unpack list of bytes into ByteString packedBytes from unpackedBytes pack packedBytes unpack from packedBytes packedBytes hello",
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "packedBytes",
          "normalized": "Iso'[Word]ByteString",
          "package": "lens",
          "partial": "Bytes",
          "signature": "Iso'[Word]ByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#v:packedBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) a list of characters into a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.packedChars.each.re (base 16 . enum).to (\\x -\u003e if Prelude.length x == 1 then '0':x else x)\n\u003c/code\u003e\u003c/strong\u003e\"68656c6c6f\"\n\u003c/pre\u003e",
          "module": "Data.ByteString.Strict.Lens",
          "name": "packedChars",
          "package": "lens",
          "signature": "Iso' String ByteString",
          "source": "src/Data-ByteString-Strict-Lens.html#packedChars",
          "type": "function"
        },
        "index": {
          "description": "pack or unpack list of characters into ByteString When writing back to the ByteString it is assumed that every Char lies between x00 and xff packedChars from unpackedChars pack packedChars unpack from packedChars hello packedChars.each.re base enum to if Prelude.length then else c6c6f",
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "packedChars",
          "package": "lens",
          "partial": "Chars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#v:packedChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e into a list of bytes\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801;  x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedBytes\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.packedChars.unpackedBytes\n\u003c/code\u003e\u003c/strong\u003e[104,101,108,108,111]\n\u003c/pre\u003e",
          "module": "Data.ByteString.Strict.Lens",
          "name": "unpackedBytes",
          "package": "lens",
          "signature": "Iso' ByteString [Word8]",
          "source": "src/Data-ByteString-Strict-Lens.html#unpackedBytes",
          "type": "function"
        },
        "index": {
          "description": "unpack or pack ByteString into list of bytes unpackedBytes from packedBytes unpack unpackedBytes pack from unpackedBytes hello packedChars.unpackedBytes",
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "unpackedBytes",
          "normalized": "Iso' ByteString[Word]",
          "package": "lens",
          "partial": "Bytes",
          "signature": "Iso' ByteString[Word]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#v:unpackedBytes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) a list of characters into a \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eWhen writing back to the \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e it is assumed that every \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e\n lies between \u003ccode\u003e'\\x00'\u003c/code\u003e and \u003ccode\u003e'\\xff'\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpackedChars\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[104,101,108,108,111]^.packedBytes.unpackedChars\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e",
          "module": "Data.ByteString.Strict.Lens",
          "name": "unpackedChars",
          "package": "lens",
          "signature": "Iso' ByteString String",
          "source": "src/Data-ByteString-Strict-Lens.html#unpackedChars",
          "type": "function"
        },
        "index": {
          "description": "unpack or pack list of characters into ByteString When writing back to the ByteString it is assumed that every Char lies between x00 and xff unpackedChars from packedChars unpack unpackedChars pack from unpackedChars packedBytes.unpackedChars hello",
          "hierarchy": "Data ByteString Strict Lens",
          "module": "Data.ByteString.Strict.Lens",
          "name": "unpackedChars",
          "package": "lens",
          "partial": "Chars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-ByteString-Strict-Lens.html#v:unpackedChars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLenses and traversals for complex numbers\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Complex.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Complex-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Lenses and traversals for complex numbers",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the \u003ccode\u003e\u003ca\u003econjugate\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e number.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(2.0 :+ 3.0) & _conjugate . _imagPart -~ 1\n\u003c/code\u003e\u003c/strong\u003e2.0 :+ 4.0\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(mkPolar 10.0 2.0 ^. _conjugate . _phase) &#8776; (-2.0)\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e",
          "module": "Data.Complex.Lens",
          "name": "_conjugate",
          "package": "lens",
          "signature": "Iso' (Complex a) (Complex a)",
          "source": "src/Data-Complex-Lens.html#_conjugate",
          "type": "function"
        },
        "index": {
          "description": "Access the conjugate of Complex number conjugate imagPart mkPolar conjugate phase True",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "_conjugate",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#v:_conjugate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the \u003ccode\u003e\u003ca\u003eimagPart\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e number.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a :+ b)^._imagPart\n\u003c/code\u003e\u003c/strong\u003eb\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea :+ b & _imagPart *~ 2\n\u003c/code\u003e\u003c/strong\u003ea :+ b * 2\n\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003e_imagPart\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f a) -\u003e \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e a -\u003e f (\u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e a)\u003c/pre\u003e",
          "module": "Data.Complex.Lens",
          "name": "_imagPart",
          "package": "lens",
          "signature": "Lens' (Complex a) a",
          "source": "src/Data-Complex-Lens.html#_imagPart",
          "type": "function"
        },
        "index": {
          "description": "Access the imagPart of Complex number imagPart imagPart imagPart Functor Complex Complex",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "_imagPart",
          "package": "lens",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#v:_imagPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e number.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(10.0 :+ 20.0) & _magnitude *~ 2\n\u003c/code\u003e\u003c/strong\u003e20.0 :+ 40.0\n\u003c/pre\u003e\u003cp\u003eThis isn't \u003cem\u003equite\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e. Notably the\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l b a) = b\u003c/pre\u003e\u003cp\u003elaw is violated when you set a negative \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e. This flips the \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e\n and retains a positive \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e. So don't do that!\n\u003c/p\u003e\u003cp\u003eOtherwise, this is a perfectly cromulent \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSetting the \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e of a zero \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e number assumes the \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e is 0.\n\u003c/p\u003e",
          "module": "Data.Complex.Lens",
          "name": "_magnitude",
          "package": "lens",
          "signature": "Lens' (Complex a) a",
          "source": "src/Data-Complex-Lens.html#_magnitude",
          "type": "function"
        },
        "index": {
          "description": "Access the magnitude of Complex number magnitude This isn quite legal Lens Notably the view set law is violated when you set negative magnitude This flips the phase and retains positive magnitude So don do that Otherwise this is perfectly cromulent Lens Setting the magnitude of zero Complex number assumes the phase is",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "_magnitude",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#v:_magnitude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e number.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(mkPolar 10 (2-pi) & _phase +~ pi & view _phase) &#8776; 2\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cp\u003eThis isn't \u003cem\u003equite\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e. Notably the\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l b a) = b\u003c/pre\u003e\u003cp\u003elaw is violated when you set a \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e outside the range \u003ccode\u003e(-\u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003epi\u003c/a\u003e\u003c/code\u003e]\u003c/code\u003e.\n The phase is always in that range when queried. So don't do that!\n\u003c/p\u003e\u003cp\u003eOtherwise, this is a perfectly cromulent \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Complex.Lens",
          "name": "_phase",
          "package": "lens",
          "signature": "Lens' (Complex a) a",
          "source": "src/Data-Complex-Lens.html#_phase",
          "type": "function"
        },
        "index": {
          "description": "Access the phase of Complex number mkPolar pi phase pi view phase True This isn quite legal Lens Notably the view set law is violated when you set phase outside the range pi pi The phase is always in that range when queried So don do that Otherwise this is perfectly cromulent Lens",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "_phase",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#v:_phase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isn't \u003cem\u003equite\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e. Notably the\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e l (\u003ccode\u003e\u003ca\u003eset\u003c/a\u003e\u003c/code\u003e l b a) = b\u003c/pre\u003e\u003cp\u003elaw is violated when you set a \u003ccode\u003e\u003ca\u003epolar\u003c/a\u003e\u003c/code\u003e value with 0 \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e and non-zero\n \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e as the \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e information is lost, or with a negative \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e\n which flips the \u003ccode\u003e\u003ca\u003ephase\u003c/a\u003e\u003c/code\u003e and retains a positive \u003ccode\u003e\u003ca\u003emagnitude\u003c/a\u003e\u003c/code\u003e. So don't do\n that!\n\u003c/p\u003e\u003cp\u003eOtherwise, this is a perfectly cromulent \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Complex.Lens",
          "name": "_polar",
          "package": "lens",
          "signature": "Iso' (Complex a) (a, a)",
          "source": "src/Data-Complex-Lens.html#_polar",
          "type": "function"
        },
        "index": {
          "description": "This isn quite legal Lens Notably the view set law is violated when you set polar value with magnitude and non-zero phase as the phase information is lost or with negative magnitude which flips the phase and retains positive magnitude So don do that Otherwise this is perfectly cromulent Lens",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "_polar",
          "normalized": "Iso'(Complex a)(a,a)",
          "package": "lens",
          "signature": "Iso'(Complex a)(a,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#v:_polar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess the \u003ccode\u003e\u003ca\u003erealPart\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e number.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(a :+ b)^._realPart\n\u003c/code\u003e\u003c/strong\u003ea\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ea :+ b & _realPart *~ 2\n\u003c/code\u003e\u003c/strong\u003ea * 2 :+ b\n\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003e_realPart\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e f =\u003e (a -\u003e f a) -\u003e \u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e a -\u003e f (\u003ccode\u003e\u003ca\u003eComplex\u003c/a\u003e\u003c/code\u003e a)\u003c/pre\u003e",
          "module": "Data.Complex.Lens",
          "name": "_realPart",
          "package": "lens",
          "signature": "Lens' (Complex a) a",
          "source": "src/Data-Complex-Lens.html#_realPart",
          "type": "function"
        },
        "index": {
          "description": "Access the realPart of Complex number realPart realPart realPart Functor Complex Complex",
          "hierarchy": "Data Complex Lens",
          "module": "Data.Complex.Lens",
          "name": "_realPart",
          "package": "lens",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Complex-Lens.html#v:_realPart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSmart and na&#239;ve generic traversals given \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e each build up information about what\n types can be contained within another type to speed up \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Data.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Data-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Smart and na ve generic traversals given Data instances template uniplate and biplate each build up information about what types can be contained within another type to speed up Traversal",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ebiplate\u003c/a\u003e\u003c/code\u003e performs like \u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e, except when \u003ccode\u003es ~ a\u003c/code\u003e, it returns itself and nothing else.\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "biplate",
          "package": "lens",
          "signature": "Traversal' s a",
          "source": "src/Data-Data-Lens.html#biplate",
          "type": "function"
        },
        "index": {
          "description": "biplate performs like template except when it returns itself and nothing else",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "biplate",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:biplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generic applicative transformation that maps over the immediate subterms.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003egtraverse\u003c/a\u003e\u003c/code\u003e is to \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e what \u003ccode\u003e\u003ca\u003egmapM\u003c/a\u003e\u003c/code\u003e is to \u003ccode\u003e\u003ca\u003emapM\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eThis really belongs in \u003ccode\u003eData.Data\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "gtraverse",
          "package": "lens",
          "signature": "d -\u003e f d) -\u003e a -\u003e f a",
          "source": "src/Data-Data-Lens.html#gtraverse",
          "type": "function"
        },
        "index": {
          "description": "generic applicative transformation that maps over the immediate subterms gtraverse is to traverse what gmapM is to mapM This really belongs in Data.Data",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "gtraverse",
          "normalized": "a-\u003eb a)-\u003ec-\u003eb c",
          "package": "lens",
          "signature": "d-\u003ef d)-\u003ea-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:gtraverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis automatically constructs a \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e from a field accessor.\n\u003c/p\u003e\u003cp\u003eThe index of the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e can be used as an offset into \u003ccode\u003e\u003ccode\u003e\u003ca\u003eelementOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eindexing\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e or into the list\n returned by \u003ccode\u003e\u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe design of \u003ccode\u003e\u003ca\u003eonceUpon\u003c/a\u003e\u003c/code\u003e doesn't allow it to search inside of values of type \u003ccode\u003ea\u003c/code\u003e for other values of type \u003ccode\u003ea\u003c/code\u003e.\n \u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e provides this additional recursion, but at the expense of performance.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eonceUpon (tail.tail) .~ [10,20] $ [1,2,3,4] -- BAD\n\u003c/code\u003e\u003c/strong\u003e[1,10,20]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eupon (tail.tail) .~ [10,20] $ [1,2,3,4] -- GOOD\n\u003c/code\u003e\u003c/strong\u003e[1,2,10,20]\n\u003c/pre\u003e\u003cp\u003eWhen in doubt, use \u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "onceUpon",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e IndexedTraversal' Int s a",
          "source": "src/Data-Data-Lens.html#onceUpon",
          "type": "function"
        },
        "index": {
          "description": "This automatically constructs Traversal from field accessor The index of the Traversal can be used as an offset into elementOf indexing template or into the list returned by holesOf template The design of onceUpon doesn allow it to search inside of values of type for other values of type upon provides this additional recursion but at the expense of performance onceUpon tail.tail BAD upon tail.tail GOOD When in doubt use upon instead",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "onceUpon",
          "normalized": "(a-\u003eb)-\u003eIndexedTraversal' Int a b",
          "package": "lens",
          "partial": "Upon",
          "signature": "(s-\u003ea)-\u003eIndexedTraversal' Int s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:onceUpon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis more trusting version of \u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e uses your function directly as the getter for a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis means that reading from \u003ccode\u003e\u003ca\u003eupon'\u003c/a\u003e\u003c/code\u003e is considerably faster than \u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eHowever, you pay for faster access in two ways:\n\u003c/p\u003e\u003col\u003e\u003cli\u003e When passed an illegal field accessor, \u003ccode\u003e\u003ca\u003eupon'\u003c/a\u003e\u003c/code\u003e will give you a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that quietly violates\n    the laws, unlike \u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e, which will give you a legal \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that avoids modifying the target.\n\u003c/li\u003e\u003cli\u003e Modifying with the lens is slightly slower, since it has to go back and calculate the index after the fact.\n\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eWhen given a legal field accessor, the index of the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e can be used as an offset into\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eelementOf\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eindexed\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e or into the list returned by \u003ccode\u003e\u003ccode\u003e\u003ca\u003eholesOf\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eWhen in doubt, use \u003ccode\u003e\u003ca\u003eupon'\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "onceUpon'",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e IndexedLens' Int s a",
          "source": "src/Data-Data-Lens.html#onceUpon%27",
          "type": "function"
        },
        "index": {
          "description": "This more trusting version of upon uses your function directly as the getter for Lens This means that reading from upon is considerably faster than upon However you pay for faster access in two ways When passed an illegal field accessor upon will give you Lens that quietly violates the laws unlike upon which will give you legal Traversal that avoids modifying the target Modifying with the lens is slightly slower since it has to go back and calculate the index after the fact When given legal field accessor the index of the Lens can be used as an offset into elementOf indexed template or into the list returned by holesOf template When in doubt use upon instead",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "onceUpon'",
          "normalized": "(a-\u003eb)-\u003eIndexedLens' Int a b",
          "package": "lens",
          "partial": "Upon'",
          "signature": "(s-\u003ea)-\u003eIndexedLens' Int s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:onceUpon-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind every occurrence of a given type \u003ccode\u003ea\u003c/code\u003e recursively that doesn't require\n passing through something of type \u003ccode\u003ea\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e, while avoiding traversal\n of areas that cannot contain a value of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e with a more liberal signature.\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "template",
          "package": "lens",
          "signature": "Traversal' s a",
          "source": "src/Data-Data-Lens.html#template",
          "type": "function"
        },
        "index": {
          "description": "Find every occurrence of given type recursively that doesn require passing through something of type using Data while avoiding traversal of areas that cannot contain value of type This is uniplate with more liberal signature",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "template",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:template"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNa&#239;ve \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e. This does not attempt to optimize the traversal.\n\u003c/p\u003e\u003cp\u003eThis is primarily useful when the children are immediately obvious, and for benchmarking.\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "tinplate",
          "package": "lens",
          "signature": "Traversal' s a",
          "source": "src/Data-Data-Lens.html#tinplate",
          "type": "function"
        },
        "index": {
          "description": "Na ve Traversal using Data This does not attempt to optimize the traversal This is primarily useful when the children are immediately obvious and for benchmarking",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "tinplate",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:tinplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind descendants of type \u003ccode\u003ea\u003c/code\u003e non-transitively, while avoiding computation of areas that cannot contain values of\n type \u003ccode\u003ea\u003c/code\u003e using \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e is a useful default definition for \u003ccode\u003e\u003ca\u003eplate\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Data.Lens",
          "name": "uniplate",
          "package": "lens",
          "signature": "Traversal' a a",
          "source": "src/Data-Data-Lens.html#uniplate",
          "type": "function"
        },
        "index": {
          "description": "Find descendants of type non-transitively while avoiding computation of areas that cannot contain values of type using Data uniplate is useful default definition for plate",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "uniplate",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:uniplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis automatically constructs a \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e from an function.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e(2,4) & upon fst *~ 5\n\u003c/code\u003e\u003c/strong\u003e(10,4)\n\u003c/pre\u003e\u003cp\u003eThere are however, caveats on how this function can be used!\n\u003c/p\u003e\u003cp\u003eFirst, the user supplied function must access only one field of the specified type. That is to say the target\n must be a single element that would be visited by \u003ccode\u003e\u003ccode\u003eholesOnOf\u003c/code\u003e \u003ccode\u003e\u003ca\u003etemplate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003euniplate\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eNote: this even permits a number of functions to be used directly.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3,4] & upon head .~ 0\n\u003c/code\u003e\u003c/strong\u003e[0,2,3,4]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3,4] & upon last .~ 5\n\u003c/code\u003e\u003c/strong\u003e[1,2,3,5]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3,4] ^? upon tail\n\u003c/code\u003e\u003c/strong\u003eJust [2,3,4]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"\" ^? upon tail\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cp\u003eAccessing parents on the way down to children is okay:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3,4] & upon (tail.tail) .~ [10,20]\n\u003c/code\u003e\u003c/strong\u003e[1,2,10,20]\n\u003c/pre\u003e\u003cp\u003eSecond, the structure must not contain strict or unboxed fields of the same type that will be visited by \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e s, \u003ccode\u003e\u003ca\u003eData\u003c/a\u003e\u003c/code\u003e a) =\u003e (s -\u003e a) -\u003e \u003ccode\u003e\u003ca\u003eIndexedTraversal'\u003c/a\u003e\u003c/code\u003e [Int] s a\u003c/pre\u003e",
          "module": "Data.Data.Lens",
          "name": "upon",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e p a (f a) -\u003e s -\u003e f s",
          "source": "src/Data-Data-Lens.html#upon",
          "type": "function"
        },
        "index": {
          "description": "This automatically constructs Traversal from an function upon fst There are however caveats on how this function can be used First the user supplied function must access only one field of the specified type That is to say the target must be single element that would be visited by holesOnOf template uniplate Note this even permits number of functions to be used directly upon head upon last upon tail Just upon tail Nothing Accessing parents on the way down to children is okay upon tail.tail Second the structure must not contain strict or unboxed fields of the same type that will be visited by Data upon Data Data IndexedTraversal Int",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "upon",
          "normalized": "(a-\u003eb)-\u003ec b(d b)-\u003ea-\u003ed a",
          "package": "lens",
          "signature": "(s-\u003ea)-\u003ep a(f a)-\u003es-\u003ef s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:upon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe design of \u003ccode\u003e\u003ca\u003eonceUpon'\u003c/a\u003e\u003c/code\u003e doesn't allow it to search inside of values of type \u003ccode\u003ea\u003c/code\u003e for other values of type \u003ccode\u003ea\u003c/code\u003e.\n \u003ccode\u003e\u003ca\u003eupon'\u003c/a\u003e\u003c/code\u003e provides this additional recursion.\n\u003c/p\u003e\u003cp\u003eLike \u003ccode\u003e\u003ca\u003eonceUpon'\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eupon'\u003c/a\u003e\u003c/code\u003e trusts the user supplied function more than \u003ccode\u003e\u003ca\u003eupon\u003c/a\u003e\u003c/code\u003e using it directly\n as the accessor. This enables reading from the resulting \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e to be considerably faster at the risk of\n generating an illegal lens.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eupon' (tail.tail) .~ [10,20] $ [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e[1,2,10,20]\n\u003c/pre\u003e",
          "module": "Data.Data.Lens",
          "name": "upon'",
          "package": "lens",
          "signature": "(s -\u003e a) -\u003e IndexedLens' [Int] s a",
          "source": "src/Data-Data-Lens.html#upon%27",
          "type": "function"
        },
        "index": {
          "description": "The design of onceUpon doesn allow it to search inside of values of type for other values of type upon provides this additional recursion Like onceUpon upon trusts the user supplied function more than upon using it directly as the accessor This enables reading from the resulting Lens to be considerably faster at the risk of generating an illegal lens upon tail.tail",
          "hierarchy": "Data Data Lens",
          "module": "Data.Data.Lens",
          "name": "upon'",
          "normalized": "(a-\u003eb)-\u003eIndexedLens'[Int]a b",
          "package": "lens",
          "signature": "(s-\u003ea)-\u003eIndexedLens'[Int]s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Data-Lens.html#v:upon-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Dynamic.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Dynamic-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Dynamic Lens",
          "module": "Data.Dynamic.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Dynamic-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e can be thrown as an \u003ccode\u003e\u003ca\u003eException\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Dynamic.Lens",
          "name": "AsDynamic",
          "package": "lens",
          "source": "src/Data-Dynamic-Lens.html#AsDynamic",
          "type": "class"
        },
        "index": {
          "description": "Any Dynamic can be thrown as an Exception",
          "hierarchy": "Data Dynamic Lens",
          "module": "Data.Dynamic.Lens",
          "name": "AsDynamic",
          "package": "lens",
          "partial": "As Dynamic",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Dynamic-Lens.html#t:AsDynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e allows you to traverse the typed value contained in a\n \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e where the type required by your function matches that\n of the contents of the \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e, or construct a \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e value\n out of whole cloth. It can also be used to catch or throw a \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e\n value as \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_Dynamic\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eDynamic\u003c/a\u003e\u003c/code\u003e       a\n \u003ccode\u003e\u003ca\u003e_Dynamic\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Data.Dynamic.Lens",
          "name": "_Dynamic",
          "package": "lens",
          "signature": "Prism' t a",
          "source": "src/Data-Dynamic-Lens.html#_Dynamic",
          "type": "method"
        },
        "index": {
          "description": "This Prism allows you to traverse the typed value contained in Dynamic where the type required by your function matches that of the contents of the Dynamic or construct Dynamic value out of whole cloth It can also be used to catch or throw Dynamic value as SomeException Dynamic Typeable Prism Dynamic Dynamic Typeable Prism SomeException",
          "hierarchy": "Data Dynamic Lens",
          "module": "Data.Dynamic.Lens",
          "name": "_Dynamic",
          "package": "lens",
          "partial": "Dynamic",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Dynamic-Lens.html#v:_Dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.HashSet.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-HashSet-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data HashSet Lens",
          "module": "Data.HashSet.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-HashSet-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a set from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e a         =\u003e \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eHashSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eHashSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e a         =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eHashSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e a         =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eHashSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: (\u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a, \u003ccode\u003e\u003ca\u003eHashable\u003c/a\u003e\u003c/code\u003e a) =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eHashSet\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Data.HashSet.Lens",
          "name": "setOf",
          "package": "lens",
          "signature": "Getting (HashSet a) s a -\u003e s -\u003e HashSet a",
          "source": "src/Data-HashSet-Lens.html#setOf",
          "type": "function"
        },
        "index": {
          "description": "Construct set from Getter Fold Traversal Lens or Iso setOf Hashable Getter HashSet setOf Eq Hashable Fold HashSet setOf Hashable Iso HashSet setOf Hashable Lens HashSet setOf Eq Hashable Traversal HashSet",
          "hierarchy": "Data HashSet Lens",
          "module": "Data.HashSet.Lens",
          "name": "setOf",
          "normalized": "Getting(HashSet a)b a-\u003eb-\u003eHashSet a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(HashSet a)s a-\u003es-\u003eHashSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-HashSet-Lens.html#v:setOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to change the type of a \u003ccode\u003e\u003ca\u003eHashSet\u003c/a\u003e\u003c/code\u003e by mapping\n the elements to new values.\n\u003c/p\u003e\u003cp\u003eSadly, you can't create a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003eSet\u003c/code\u003e, but you can\n manipulate it by reading using \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e and reindexing it via \u003ccode\u003e\u003ca\u003esetmapped\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.HashSet.Lens",
          "name": "setmapped",
          "package": "lens",
          "signature": "IndexPreservingSetter (HashSet i) (HashSet j) i j",
          "source": "src/Data-HashSet-Lens.html#setmapped",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to change the type of HashSet by mapping the elements to new values Sadly you can create valid Traversal for Set but you can manipulate it by reading using folded and reindexing it via setmapped",
          "hierarchy": "Data HashSet Lens",
          "module": "Data.HashSet.Lens",
          "name": "setmapped",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-HashSet-Lens.html#v:setmapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-IntSet-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data IntSet Lens",
          "module": "Data.IntSet.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-IntSet-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntSet isn't Foldable, but this \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e can be used to access the members of an \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esumOf members $ setOf folded [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003e10\n\u003c/pre\u003e",
          "module": "Data.IntSet.Lens",
          "name": "members",
          "package": "lens",
          "signature": "Fold IntSet Int",
          "source": "src/Data-IntSet-Lens.html#members",
          "type": "function"
        },
        "index": {
          "description": "IntSet isn Foldable but this Fold can be used to access the members of an IntSet sumOf members setOf folded",
          "hierarchy": "Data IntSet Lens",
          "module": "Data.IntSet.Lens",
          "name": "members",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-IntSet-Lens.html#v:members"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct an \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esetOf folded [1,2,3,4]\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,3,4]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esetOf (folded._2) [(\"hello\",1),(\"world\",2),(\"!!!\",3)]\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,3]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.IntSet.Lens",
          "name": "setOf",
          "package": "lens",
          "signature": "Getting IntSet s Int -\u003e s -\u003e IntSet",
          "source": "src/Data-IntSet-Lens.html#setOf",
          "type": "function"
        },
        "index": {
          "description": "Construct an IntSet from Getter Fold Traversal Lens or Iso setOf folded fromList setOf folded hello world fromList setOf Getter Int IntSet setOf Fold Int IntSet setOf Iso Int IntSet setOf Lens Int IntSet setOf Traversal Int IntSet",
          "hierarchy": "Data IntSet Lens",
          "module": "Data.IntSet.Lens",
          "name": "setOf",
          "normalized": "Getting IntSet a Int-\u003ea-\u003eIntSet",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting IntSet s Int-\u003es-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-IntSet-Lens.html#v:setOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to change the contents of an \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e by mapping\n the elements to new values.\n\u003c/p\u003e\u003cp\u003eSadly, you can't create a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003eSet\u003c/code\u003e, because the number of\n elements might change but you can manipulate it by reading using \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e and\n reindexing it via \u003ccode\u003e\u003ca\u003esetmapped\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover setmapped (+1) (fromList [1,2,3,4])\n\u003c/code\u003e\u003c/strong\u003efromList [2,3,4,5]\n\u003c/pre\u003e",
          "module": "Data.IntSet.Lens",
          "name": "setmapped",
          "package": "lens",
          "signature": "IndexPreservingSetter' IntSet Int",
          "source": "src/Data-IntSet-Lens.html#setmapped",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to change the contents of an IntSet by mapping the elements to new values Sadly you can create valid Traversal for Set because the number of elements might change but you can manipulate it by reading using folded and reindexing it via setmapped over setmapped fromList fromList",
          "hierarchy": "Data IntSet Lens",
          "module": "Data.IntSet.Lens",
          "name": "setmapped",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-IntSet-Lens.html#v:setmapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eTraversals for manipulating parts of a list.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.List.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-List-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Traversals for manipulating parts of list",
          "hierarchy": "Data List Lens",
          "module": "Data.List.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e stripping a prefix from a list when used as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, or\n prepending that prefix when run backwards:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"preview\" ^? prefixed \"pre\"\n\u003c/code\u003e\u003c/strong\u003eJust \"view\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"review\" ^? prefixed \"pre\"\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eprefixed \"pre\" # \"amble\"\n\u003c/code\u003e\u003c/strong\u003e\"preamble\"\n\u003c/pre\u003e",
          "module": "Data.List.Lens",
          "name": "prefixed",
          "package": "lens",
          "signature": "[a] -\u003e Prism' [a] [a]",
          "source": "src/Data-List-Lens.html#prefixed",
          "type": "function"
        },
        "index": {
          "description": "Prism stripping prefix from list when used as Traversal or prepending that prefix when run backwards preview prefixed pre Just view review prefixed pre Nothing prefixed pre amble preamble",
          "hierarchy": "Data List Lens",
          "module": "Data.List.Lens",
          "name": "prefixed",
          "normalized": "[a]-\u003ePrism'[a][a]",
          "package": "lens",
          "signature": "[a]-\u003ePrism'[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Lens.html#v:prefixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.List.Lens",
          "name": "stripSuffix",
          "package": "lens",
          "signature": "[a] -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Data-List-Lens.html#stripSuffix",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data List Lens",
          "module": "Data.List.Lens",
          "name": "stripSuffix",
          "normalized": "[a]-\u003e[a]-\u003eMaybe[a]",
          "package": "lens",
          "partial": "Suffix",
          "signature": "[a]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Lens.html#v:stripSuffix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use \u003ccode\u003e\u003ca\u003eprefixed\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis is a deprecated alias for \u003ccode\u003e\u003ca\u003eprefixed\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.Lens",
          "name": "strippingPrefix",
          "package": "lens",
          "signature": "[a] -\u003e Prism' [a] [a]",
          "source": "src/Data-List-Lens.html#strippingPrefix",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use prefixed This is deprecated alias for prefixed",
          "hierarchy": "Data List Lens",
          "module": "Data.List.Lens",
          "name": "strippingPrefix",
          "normalized": "[a]-\u003ePrism'[a][a]",
          "package": "lens",
          "partial": "Prefix",
          "signature": "[a]-\u003ePrism'[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Lens.html#v:strippingPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: Use \u003ccode\u003e\u003ca\u003esuffixed\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThis is a deprecated alias for \u003ccode\u003e\u003ca\u003esuffixed\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.Lens",
          "name": "strippingSuffix",
          "package": "lens",
          "signature": "[a] -\u003e Prism' [a] [a]",
          "source": "src/Data-List-Lens.html#strippingSuffix",
          "type": "function"
        },
        "index": {
          "description": "Deprecated Use suffixed This is deprecated alias for suffixed",
          "hierarchy": "Data List Lens",
          "module": "Data.List.Lens",
          "name": "strippingSuffix",
          "normalized": "[a]-\u003ePrism'[a][a]",
          "package": "lens",
          "partial": "Suffix",
          "signature": "[a]-\u003ePrism'[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Lens.html#v:strippingSuffix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e stripping a suffix from a list when used as a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, or\n prepending that prefix when run backwards:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"review\" ^? suffixed \"view\"\n\u003c/code\u003e\u003c/strong\u003eJust \"re\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"review\" ^? suffixed \"tire\"\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esuffixed \".o\" # \"hello\"\n\u003c/code\u003e\u003c/strong\u003e\"hello.o\"\n\u003c/pre\u003e",
          "module": "Data.List.Lens",
          "name": "suffixed",
          "package": "lens",
          "signature": "[a] -\u003e Prism' [a] [a]",
          "source": "src/Data-List-Lens.html#suffixed",
          "type": "function"
        },
        "index": {
          "description": "Prism stripping suffix from list when used as Traversal or prepending that prefix when run backwards review suffixed view Just re review suffixed tire Nothing suffixed hello hello.o",
          "hierarchy": "Data List Lens",
          "module": "Data.List.Lens",
          "name": "suffixed",
          "normalized": "[a]-\u003ePrism'[a][a]",
          "package": "lens",
          "signature": "[a]-\u003ePrism'[a][a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Lens.html#v:suffixed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLenses for working with Data.List.Split\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.List.Split.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-List-Split-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Lenses for working with Data.List.Split",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into length-\u003ccode\u003en\u003c/code\u003e pieces.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"48656c6c6f20776f726c64\"^..chunking 2 folded.hex.to chr\n\u003c/code\u003e\u003c/strong\u003e\"Hello world\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003echunking\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "chunking",
          "package": "lens",
          "signature": "Int-\u003e Getting (Endo [a]) s a-\u003e Fold s [a]",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into length pieces c6c6f20776f726c64 chunking folded.hex.to chr Hello world chunking Int Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "chunking",
          "normalized": "Int-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "signature": "Int-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:chunking"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify or retrieve the policy for what a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e should about consecutive delimiters.\n\u003c/p\u003e",
          "module": "Data.List.Split.Lens",
          "name": "condensing",
          "package": "lens",
          "signature": "Lens' (Splitter a) CondensePolicy",
          "source": "src/Data-List-Split-Lens.html#condensing",
          "type": "function"
        },
        "index": {
          "description": "Modify or retrieve the policy for what Splitter should about consecutive delimiters",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "condensing",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:condensing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify or retrieve the list of delimiters for a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.List.Split.Lens",
          "name": "delimiters",
          "package": "lens",
          "signature": "Lens (Splitter a) (Splitter b) [a -\u003e Bool] [b -\u003e Bool]",
          "source": "src/Data-List-Split-Lens.html#delimiters",
          "type": "function"
        },
        "index": {
          "description": "Modify or retrieve the list of delimiters for Splitter",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "delimiters",
          "normalized": "Lens(Splitter a)(Splitter b)[a-\u003eBool][b-\u003eBool]",
          "package": "lens",
          "signature": "Lens(Splitter a)(Splitter b)[a-\u003eBool][b-\u003eBool]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:delimiters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify or retrieve the policy for what a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e to do with delimiters.\n\u003c/p\u003e",
          "module": "Data.List.Split.Lens",
          "name": "delimiting",
          "package": "lens",
          "signature": "Lens' (Splitter a) DelimPolicy",
          "source": "src/Data-List-Split-Lens.html#delimiting",
          "type": "function"
        },
        "index": {
          "description": "Modify or retrieve the policy for what Splitter to do with delimiters",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "delimiting",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:delimiting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into chunks terminated by the given delimiter.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eendingBy\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e [a] -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "endingBy",
          "package": "lens",
          "signature": "[a] -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#endingBy",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into chunks terminated by the given delimiter Equivalent to splitting dropDelims onSublist endingBy Eq Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "endingBy",
          "normalized": "[a]-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "By",
          "signature": "[a]-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:endingBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into chunks terminated by any of the given elements.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eendingByOneOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e [a] -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "endingByOneOf",
          "package": "lens",
          "signature": "[a] -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#endingByOneOf",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into chunks terminated by any of the given elements Equivalent to splitting dropFinalBlank dropDelims oneOf endingByOneOf Eq Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "endingByOneOf",
          "normalized": "[a]-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "By One Of",
          "signature": "[a]-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:endingByOneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify or retrieve the policy for whether a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e should drop a final blank.\n\u003c/p\u003e",
          "module": "Data.List.Split.Lens",
          "name": "keepFinalBlanks",
          "package": "lens",
          "signature": "Lens' (Splitter a) Bool",
          "source": "src/Data-List-Split-Lens.html#keepFinalBlanks",
          "type": "function"
        },
        "index": {
          "description": "Modify or retrieve the policy for whether Splitter should drop final blank",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "keepFinalBlanks",
          "package": "lens",
          "partial": "Final Blanks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:keepFinalBlanks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify or retrieve the policy for whether a \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e should drop an initial blank.\n\u003c/p\u003e",
          "module": "Data.List.Split.Lens",
          "name": "keepInitialBlanks",
          "package": "lens",
          "signature": "Lens' (Splitter a) Bool",
          "source": "src/Data-List-Split-Lens.html#keepInitialBlanks",
          "type": "function"
        },
        "index": {
          "description": "Modify or retrieve the policy for whether Splitter should drop an initial blank",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "keepInitialBlanks",
          "package": "lens",
          "partial": "Initial Blanks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:keepInitialBlanks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into \u003ca\u003elines\u003c/a\u003e, with line boundaries indicated by the given predicate.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropFinalBlank\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eliningBy\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "liningBy",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#liningBy",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into lines with line boundaries indicated by the given predicate Equivalent to splitting dropFinalBlank dropDelims whenElt liningBy Bool Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "liningBy",
          "normalized": "(a-\u003eBool)-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "By",
          "signature": "(a-\u003eBool)-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:liningBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e according to the given splitting strategy.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eSplitter\u003c/a\u003e\u003c/code\u003e a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "splitting",
          "package": "lens",
          "signature": "Splitter a -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#splitting",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal according to the given splitting strategy splitting Splitter Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "splitting",
          "normalized": "Splitter a-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "signature": "Splitter a-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:splitting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e on the given delimiter.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eonSublist\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esplittingOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e [a] -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "splittingOn",
          "package": "lens",
          "signature": "[a] -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#splittingOn",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal on the given delimiter Equivalent to splitting dropDelims onSublist splittingOn Eq Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "splittingOn",
          "normalized": "[a]-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "On",
          "signature": "[a]-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:splittingOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e on any of the given elements.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eoneOf\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esplittingOn\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e a =\u003e [a] -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "splittingOneOf",
          "package": "lens",
          "signature": "[a] -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#splittingOneOf",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal on any of the given elements Equivalent to splitting dropDelims oneOf splittingOn Eq Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "splittingOneOf",
          "normalized": "[a]-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "One Of",
          "signature": "[a]-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:splittingOneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into chunks of the given lengths, .\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esplittingPlaces\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e n =\u003e [n] -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "splittingPlaces",
          "package": "lens",
          "signature": "[n] -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#splittingPlaces",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into chunks of the given lengths splittingPlaces Integral Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "splittingPlaces",
          "normalized": "[a]-\u003eGetting(Endo[b])c b-\u003eFold c[b]",
          "package": "lens",
          "partial": "Places",
          "signature": "[n]-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:splittingPlaces"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into chunks of the given lengths.  Unlike \u003ccode\u003e\u003ca\u003esplittingPlaces\u003c/a\u003e\u003c/code\u003e, the output \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e will always be the same length as the first input argument.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esplittingPlacesBlanks\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e n =\u003e [n] -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "splittingPlacesBlanks",
          "package": "lens",
          "signature": "[n] -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#splittingPlacesBlanks",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into chunks of the given lengths Unlike splittingPlaces the output Fold will always be the same length as the first input argument splittingPlacesBlanks Integral Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "splittingPlacesBlanks",
          "normalized": "[a]-\u003eGetting(Endo[b])c b-\u003eFold c[b]",
          "package": "lens",
          "partial": "Places Blanks",
          "signature": "[n]-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:splittingPlacesBlanks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e on elements satisfying the given predicate.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esplittingWhen\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "splittingWhen",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#splittingWhen",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal on elements satisfying the given predicate Equivalent to splitting dropDelims whenElt splittingWhen Bool Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "splittingWhen",
          "normalized": "(a-\u003eBool)-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "When",
          "signature": "(a-\u003eBool)-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:splittingWhen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain a \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e by splitting another \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e into \u003ca\u003ewords\u003c/a\u003e, with word boundaries indicated by the given predicate.\n\u003c/p\u003e\u003cp\u003eEquivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropBlanks\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003edropDelims\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ewhenElt\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003ewordingBy\u003c/a\u003e\u003c/code\u003e :: (a -\u003e \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e) -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a -\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s [a]\n\u003c/pre\u003e",
          "module": "Data.List.Split.Lens",
          "name": "wordingBy",
          "package": "lens",
          "signature": "(a -\u003e Bool) -\u003e Getting (Endo [a]) s a -\u003e Fold s [a]",
          "source": "src/Data-List-Split-Lens.html#wordingBy",
          "type": "function"
        },
        "index": {
          "description": "Obtain Fold by splitting another Fold Lens Getter or Traversal into words with word boundaries indicated by the given predicate Equivalent to splitting dropBlanks dropDelims whenElt wordingBy Bool Fold Fold",
          "hierarchy": "Data List Split Lens",
          "module": "Data.List.Split.Lens",
          "name": "wordingBy",
          "normalized": "(a-\u003eBool)-\u003eGetting(Endo[a])b a-\u003eFold b[a]",
          "package": "lens",
          "partial": "By",
          "signature": "(a-\u003eBool)-\u003eGetting(Endo[a])s a-\u003eFold s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-List-Split-Lens.html#v:wordingBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eOne of most commonly-asked questions about this package is whether\n it provides lenses for working with \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e. It does, but their uses\n are perhaps obscured by their genericity. This module exists to provide\n documentation for them.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e is an instance of \u003ccode\u003e\u003ca\u003eAt\u003c/a\u003e\u003c/code\u003e, so we have a lenses\n on values at keys:\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eMap.fromList [(1, \"world\")] ^.at 1\n\u003c/code\u003e\u003c/strong\u003eJust \"world\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eat 1 .~ Just \"world\" $ Map.empty\n\u003c/code\u003e\u003c/strong\u003efromList [(1,\"world\")]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eat 0 ?~ \"hello\" $ Map.empty\n\u003c/code\u003e\u003c/strong\u003efromList [(0,\"hello\")]\n\u003c/pre\u003e\u003cp\u003eWe can traverse, fold over, and map over key-value pairs in a\n \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e, thanks to its \u003ccode\u003e\u003ca\u003eTraversableWithIndex\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003eFoldableWithIndex\u003c/a\u003e\u003c/code\u003e, and\n \u003ccode\u003e\u003ca\u003eFunctorWithIndex\u003c/a\u003e\u003c/code\u003e instances.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eimap const $ Map.fromList [(1, \"Venus\")]\n\u003c/code\u003e\u003c/strong\u003efromList [(1,1)]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eifoldMap (\\i _ -\u003e Sum i) $ Map.fromList [(2, \"Earth\"), (3, \"Mars\")]\n\u003c/code\u003e\u003c/strong\u003eSum {getSum = 5}\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eitraverse_ (curry print) $ Map.fromList [(4, \"Jupiter\")]\n\u003c/code\u003e\u003c/strong\u003e(4,\"Jupiter\")\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eitoList $ Map.fromList [(5, \"Saturn\")]\n\u003c/code\u003e\u003c/strong\u003e[(5,\"Saturn\")]\n\u003c/pre\u003e\u003cp\u003eA related class, \u003ccode\u003e\u003ca\u003eIxed\u003c/a\u003e\u003c/code\u003e, allows us to use\n \u003ccode\u003e\u003ca\u003eix\u003c/a\u003e\u003c/code\u003e to traverse a value at a particular key.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eix 2 %~ (\"New \" ++) $ Map.fromList [(2, \"Earth\")]\n\u003c/code\u003e\u003c/strong\u003efromList [(2,\"New Earth\")]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003epreview (ix 8) $ Map.empty\n\u003c/code\u003e\u003c/strong\u003eNothing\n\u003c/pre\u003e\u003cp\u003eAdditionally, \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e has \u003ccode\u003e\u003ca\u003eTraverseMin\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eTraverseMax\u003c/a\u003e\u003c/code\u003e instances, which let us traverse over\n the value at the least and greatest keys, respectively.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003epreview traverseMin $ Map.fromList [(5, \"Saturn\"), (6, \"Uranus\")]\n\u003c/code\u003e\u003c/strong\u003eJust \"Saturn\"\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003epreview traverseMax $ Map.fromList [(5, \"Saturn\"), (6, \"Uranus\")]\n\u003c/code\u003e\u003c/strong\u003eJust \"Uranus\"\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Data.Map.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Map-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "One of most commonly-asked questions about this package is whether it provides lenses for working with Map It does but their uses are perhaps obscured by their genericity This module exists to provide documentation for them Map is an instance of At so we have lenses on values at keys Map.fromList world at Just world at Just world Map.empty fromList world at hello Map.empty fromList hello We can traverse fold over and map over key-value pairs in Map thanks to its TraversableWithIndex FoldableWithIndex and FunctorWithIndex instances imap const Map.fromList Venus fromList ifoldMap Sum Map.fromList Earth Mars Sum getSum itraverse curry print Map.fromList Jupiter Jupiter itoList Map.fromList Saturn Saturn related class Ixed allows us to use ix to traverse value at particular key ix New Map.fromList Earth fromList New Earth preview ix Map.empty Nothing Additionally Map has TraverseMin and TraverseMax instances which let us traverse over the value at the least and greatest keys respectively preview traverseMin Map.fromList Saturn Uranus Just Saturn preview traverseMax Map.fromList Saturn Uranus Just Uranus",
          "hierarchy": "Data Map Lens",
          "module": "Data.Map.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Map-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Sequence.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Sequence-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eseqOf folded [\"hello\",\"world\"]\n\u003c/code\u003e\u003c/strong\u003efromList [\"hello\",\"world\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eseqOf (folded._2) [(\"hello\",1),(\"world\",2),(\"!!!\",3)]\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,3]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eseqOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eseqOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eseqOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eseqOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003eseqOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Data.Sequence.Lens",
          "name": "seqOf",
          "package": "lens",
          "signature": "Getting (Seq a) s a -\u003e s -\u003e Seq a",
          "source": "src/Data-Sequence-Lens.html#seqOf",
          "type": "function"
        },
        "index": {
          "description": "Construct Seq from Getter Fold Traversal Lens or Iso seqOf folded hello world fromList hello world seqOf folded hello world fromList seqOf Getter Seq seqOf Fold Seq seqOf Iso Seq seqOf Lens Seq seqOf Traversal Seq",
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "seqOf",
          "normalized": "Getting(Seq a)b a-\u003eb-\u003eSeq a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Seq a)s a-\u003es-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#v:seqOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse all the elements numbered from \u003ccode\u003ei\u003c/code\u003e to \u003ccode\u003ej\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] & sliced 1 3 %~ f\n\u003c/code\u003e\u003c/strong\u003efromList [a,f b,f c,d,e]\n\u003c/pre\u003e",
          "module": "Data.Sequence.Lens",
          "name": "sliced",
          "package": "lens",
          "signature": "Int -\u003e Int -\u003e IndexedTraversal' Int (Seq a) a",
          "source": "src/Data-Sequence-Lens.html#sliced",
          "type": "function"
        },
        "index": {
          "description": "Traverse all the elements numbered from to of Seq fromList sliced fromList",
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "sliced",
          "normalized": "Int-\u003eInt-\u003eIndexedTraversal' Int(Seq a)a",
          "package": "lens",
          "signature": "Int-\u003eInt-\u003eIndexedTraversal' Int(Seq a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#v:sliced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse all but the first \u003ccode\u003en\u003c/code\u003e elements of a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] ^.. slicedFrom 2\n\u003c/code\u003e\u003c/strong\u003e[c,d,e]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] & slicedFrom 2 %~ f\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,f c,f d,f e]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] & slicedFrom 10 .~ x\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,c,d,e]\n\u003c/pre\u003e",
          "module": "Data.Sequence.Lens",
          "name": "slicedFrom",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int (Seq a) a",
          "source": "src/Data-Sequence-Lens.html#slicedFrom",
          "type": "function"
        },
        "index": {
          "description": "Traverse all but the first elements of Seq fromList slicedFrom fromList slicedFrom fromList fromList slicedFrom fromList",
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "slicedFrom",
          "normalized": "Int-\u003eIndexedTraversal' Int(Seq a)a",
          "package": "lens",
          "partial": "From",
          "signature": "Int-\u003eIndexedTraversal' Int(Seq a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#v:slicedFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the first \u003ccode\u003en\u003c/code\u003e elements of a \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] ^.. slicedTo 2\n\u003c/code\u003e\u003c/strong\u003e[a,b]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] & slicedTo 2 %~ f\n\u003c/code\u003e\u003c/strong\u003efromList [f a,f b,c,d,e]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efromList [a,b,c,d,e] & slicedTo 10 .~ x\n\u003c/code\u003e\u003c/strong\u003efromList [x,x,x,x,x]\n\u003c/pre\u003e",
          "module": "Data.Sequence.Lens",
          "name": "slicedTo",
          "package": "lens",
          "signature": "Int -\u003e IndexedTraversal' Int (Seq a) a",
          "source": "src/Data-Sequence-Lens.html#slicedTo",
          "type": "function"
        },
        "index": {
          "description": "Traverse the first elements of Seq fromList slicedTo fromList slicedTo fromList fromList slicedTo fromList",
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "slicedTo",
          "normalized": "Int-\u003eIndexedTraversal' Int(Seq a)a",
          "package": "lens",
          "partial": "To",
          "signature": "Int-\u003eIndexedTraversal' Int(Seq a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#v:slicedTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e is isomorphic to a \u003ccode\u003e\u003ca\u003eViewL\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eviewl\u003c/a\u003e\u003c/code\u003e m &#8801; m \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eviewL\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c] ^. viewL\n\u003c/code\u003e\u003c/strong\u003ea :\u003c fromList [b,c]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.empty ^. viewL\n\u003c/code\u003e\u003c/strong\u003eEmptyL\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eEmptyL ^. from viewL\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereview viewL $ a :\u003c fromList [b,c]\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,c]\n\u003c/pre\u003e",
          "module": "Data.Sequence.Lens",
          "name": "viewL",
          "package": "lens",
          "signature": "Iso (Seq a) (Seq b) (ViewL a) (ViewL b)",
          "source": "src/Data-Sequence-Lens.html#viewL",
          "type": "function"
        },
        "index": {
          "description": "Seq is isomorphic to ViewL viewl viewL Seq.fromList viewL fromList Seq.empty viewL EmptyL EmptyL from viewL fromList review viewL fromList fromList",
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "viewL",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#v:viewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e is isomorphic to a \u003ccode\u003e\u003ca\u003eViewR\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eviewr\u003c/a\u003e\u003c/code\u003e m &#8801; m \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eviewR\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.fromList [a,b,c] ^. viewR\n\u003c/code\u003e\u003c/strong\u003efromList [a,b] :\u003e c\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eSeq.empty ^. viewR\n\u003c/code\u003e\u003c/strong\u003eEmptyR\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eEmptyR ^. from viewR\n\u003c/code\u003e\u003c/strong\u003efromList []\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ereview viewR $ fromList [a,b] :\u003e c\n\u003c/code\u003e\u003c/strong\u003efromList [a,b,c]\n\u003c/pre\u003e",
          "module": "Data.Sequence.Lens",
          "name": "viewR",
          "package": "lens",
          "signature": "Iso (Seq a) (Seq b) (ViewR a) (ViewR b)",
          "source": "src/Data-Sequence-Lens.html#viewR",
          "type": "function"
        },
        "index": {
          "description": "Seq is isomorphic to ViewR viewr viewR Seq.fromList viewR fromList Seq.empty viewR EmptyR EmptyR from viewR fromList review viewR fromList fromList",
          "hierarchy": "Data Sequence Lens",
          "module": "Data.Sequence.Lens",
          "name": "viewR",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Sequence-Lens.html#v:viewR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Set.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Set-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Set Lens",
          "module": "Data.Set.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Set-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a set from a \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esetOf folded [\"hello\",\"world\"]\n\u003c/code\u003e\u003c/strong\u003efromList [\"hello\",\"world\"]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003esetOf (folded._2) [(\"hello\",1),(\"world\",2),(\"!!!\",3)]\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,3]\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e ::          \u003ccode\u003e\u003ca\u003eGetter\u003c/a\u003e\u003c/code\u003e s a     -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eFold\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e ::          \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s a       -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e ::          \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s a      -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e a\n \u003ccode\u003e\u003ca\u003esetOf\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e a =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s a -\u003e s -\u003e \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e a\n\u003c/pre\u003e",
          "module": "Data.Set.Lens",
          "name": "setOf",
          "package": "lens",
          "signature": "Getting (Set a) s a -\u003e s -\u003e Set a",
          "source": "src/Data-Set-Lens.html#setOf",
          "type": "function"
        },
        "index": {
          "description": "Construct set from Getter Fold Traversal Lens or Iso setOf folded hello world fromList hello world setOf folded hello world fromList setOf Getter Set setOf Ord Fold Set setOf Iso Set setOf Lens Set setOf Ord Traversal Set",
          "hierarchy": "Data Set Lens",
          "module": "Data.Set.Lens",
          "name": "setOf",
          "normalized": "Getting(Set a)b a-\u003eb-\u003eSet a",
          "package": "lens",
          "partial": "Of",
          "signature": "Getting(Set a)s a-\u003es-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Set-Lens.html#v:setOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e can be used to change the type of a \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e by mapping\n the elements to new values.\n\u003c/p\u003e\u003cp\u003eSadly, you can't create a valid \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e for a \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e, but you can\n manipulate it by reading using \u003ccode\u003e\u003ca\u003efolded\u003c/a\u003e\u003c/code\u003e and reindexing it via \u003ccode\u003e\u003ca\u003esetmapped\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eover setmapped (+1) (fromList [1,2,3,4])\n\u003c/code\u003e\u003c/strong\u003efromList [2,3,4,5]\n\u003c/pre\u003e",
          "module": "Data.Set.Lens",
          "name": "setmapped",
          "package": "lens",
          "signature": "IndexPreservingSetter (Set i) (Set j) i j",
          "source": "src/Data-Set-Lens.html#setmapped",
          "type": "function"
        },
        "index": {
          "description": "This Setter can be used to change the type of Set by mapping the elements to new values Sadly you can create valid Traversal for Set but you can manipulate it by reading using folded and reindexing it via setmapped over setmapped fromList fromList",
          "hierarchy": "Data Set Lens",
          "module": "Data.Set.Lens",
          "name": "setmapped",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Set-Lens.html#v:setmapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Text.Lazy.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Text-Lazy-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Text Lazy Lens",
          "module": "Data.Text.Lazy.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lazy-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert between lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e .\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efromLazyText\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebuilder\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003etoLazyText\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebuilder\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lazy.Lens",
          "name": "builder",
          "package": "lens",
          "signature": "Iso' Text Builder",
          "source": "src/Data-Text-Lazy-Lens.html#builder",
          "type": "function"
        },
        "index": {
          "description": "Convert between lazy Text and Builder fromLazyText builder toLazyText from builder",
          "hierarchy": "Data Text Lazy Lens",
          "module": "Data.Text.Lazy.Lens",
          "name": "builder",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lazy-Lens.html#v:builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.packed -- :: Text\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lazy.Lens",
          "name": "packed",
          "package": "lens",
          "signature": "Iso' String Text",
          "source": "src/Data-Text-Lazy-Lens.html#packed",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to pack or unpack lazy Text hello packed Text hello pack packed unpack from packed packed from unpacked",
          "hierarchy": "Data Text Lazy Lens",
          "module": "Data.Text.Lazy.Lens",
          "name": "packed",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lazy-Lens.html#v:packed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual characters in a \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf text (=='c') \"chello\"\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eWhen the type is unambiguous, you can also use the more general \u003ccode\u003e\u003ca\u003eeach\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eeach\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNote that when just using this as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e\n can be more efficient.\n\u003c/p\u003e",
          "module": "Data.Text.Lazy.Lens",
          "name": "text",
          "package": "lens",
          "signature": "IndexedTraversal' Int Text Char",
          "source": "src/Data-Text-Lazy-Lens.html#text",
          "type": "function"
        },
        "index": {
          "description": "Traverse the individual characters in Text anyOf text chello True text unpacked traversed When the type is unambiguous you can also use the more general each text each Note that when just using this as Setter setting map can be more efficient",
          "hierarchy": "Data Text Lazy Lens",
          "module": "Data.Text.Lazy.Lens",
          "name": "text",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lazy-Lens.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.unpacked -- :: String\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is provided for notational convenience rather than out of great need, since\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lazy.Lens",
          "name": "unpacked",
          "package": "lens",
          "signature": "Iso' Text String",
          "source": "src/Data-Text-Lazy-Lens.html#unpacked",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to unpack or pack lazy Text hello unpacked String hello pack from unpacked unpack packed This Iso is provided for notational convenience rather than out of great need since unpacked from packed",
          "hierarchy": "Data Text Lazy Lens",
          "module": "Data.Text.Lazy.Lens",
          "name": "unpacked",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lazy-Lens.html#v:unpacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncode\u003cem\u003eDecode a lazy 'Text' to\u003c/em\u003efrom lazy \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e, via UTF-8.\n\u003c/p\u003e\u003cp\u003eNote: This function does not decode lazily, as it must consume the entire\n input before deciding whether or not it fails.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eByteString.unpack (utf8 # \"&#9731;\")\n\u003c/code\u003e\u003c/strong\u003e[226,152,131]\n\u003c/pre\u003e",
          "module": "Data.Text.Lazy.Lens",
          "name": "utf8",
          "package": "lens",
          "signature": "Prism' ByteString Text",
          "source": "src/Data-Text-Lazy-Lens.html#utf8",
          "type": "function"
        },
        "index": {
          "description": "Encode Decode lazy Text to from lazy ByteString via UTF-8 Note This function does not decode lazily as it must consume the entire input before deciding whether or not it fails ByteString.unpack utf8",
          "hierarchy": "Data Text Lazy Lens",
          "module": "Data.Text.Lazy.Lens",
          "name": "utf8",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lazy-Lens.html#v:utf8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Text.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Text-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Text Lens",
          "module": "Data.Text.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraversals for strict or lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Text.Lens",
          "name": "IsText",
          "package": "lens",
          "source": "src/Data-Text-Lens.html#IsText",
          "type": "class"
        },
        "index": {
          "description": "Traversals for strict or lazy Text",
          "hierarchy": "Data Text Lens",
          "module": "Data.Text.Lens",
          "name": "IsText",
          "package": "lens",
          "partial": "Is Text",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lens.html#t:IsText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert between strict or lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e and a \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efromText\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebuilder\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lens",
          "name": "builder",
          "package": "lens",
          "signature": "Iso' t Builder",
          "source": "src/Data-Text-Lens.html#builder",
          "type": "method"
        },
        "index": {
          "description": "Convert between strict or lazy Text and Builder fromText builder",
          "hierarchy": "Data Text Lens",
          "module": "Data.Text.Lens",
          "name": "builder",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lens.html#v:builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) strict or lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lens",
          "name": "packed",
          "package": "lens",
          "signature": "Iso' String t",
          "source": "src/Data-Text-Lens.html#packed",
          "type": "method"
        },
        "index": {
          "description": "This isomorphism can be used to pack or unpack strict or lazy Text pack packed unpack from packed packed from unpacked",
          "hierarchy": "Data Text Lens",
          "module": "Data.Text.Lens",
          "name": "packed",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lens.html#v:packed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual characters in strict or lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lens",
          "name": "text",
          "package": "lens",
          "signature": "IndexedTraversal' Int t Char",
          "source": "src/Data-Text-Lens.html#text",
          "type": "method"
        },
        "index": {
          "description": "Traverse the individual characters in strict or lazy Text text unpacked traversed",
          "hierarchy": "Data Text Lens",
          "module": "Data.Text.Lens",
          "name": "text",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lens.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) both strict or lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is provided for notational convenience rather than out of great need, since\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Lens",
          "name": "unpacked",
          "package": "lens",
          "signature": "Iso' t String",
          "source": "src/Data-Text-Lens.html#unpacked",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to unpack or pack both strict or lazy Text unpack unpacked pack from unpacked This Iso is provided for notational convenience rather than out of great need since unpacked from packed",
          "hierarchy": "Data Text Lens",
          "module": "Data.Text.Lens",
          "name": "unpacked",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Lens.html#v:unpacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Text.Strict.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Text-Strict-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Text Strict Lens",
          "module": "Data.Text.Strict.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Strict-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert between strict \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eBuilder\u003c/a\u003e\u003c/code\u003e .\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003efromText\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebuilder\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003etoStrict\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etoLazyText\u003c/a\u003e\u003c/code\u003e x) &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebuilder\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Strict.Lens",
          "name": "builder",
          "package": "lens",
          "signature": "Iso' Text Builder",
          "source": "src/Data-Text-Strict-Lens.html#builder",
          "type": "function"
        },
        "index": {
          "description": "Convert between strict Text and Builder fromText builder toStrict toLazyText from builder",
          "hierarchy": "Data Text Strict Lens",
          "module": "Data.Text.Strict.Lens",
          "name": "builder",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Strict-Lens.html#v:builder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e) strict \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.packed -- :: Text\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Strict.Lens",
          "name": "packed",
          "package": "lens",
          "signature": "Iso' String Text",
          "source": "src/Data-Text-Strict-Lens.html#packed",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to pack or unpack strict Text hello packed Text hello pack packed unpack from packed packed from unpacked packed iso pack unpack",
          "hierarchy": "Data Text Strict Lens",
          "module": "Data.Text.Strict.Lens",
          "name": "packed",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Strict-Lens.html#v:packed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse the individual characters in strict \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eanyOf text (=='o') \"hello\"\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cp\u003eWhen the type is unambiguous, you can also use the more general \u003ccode\u003e\u003ca\u003eeach\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003etraversed\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003etext\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eeach\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eNote that when just using this as a \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ccode\u003e\u003ca\u003esetting\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e can\n be more efficient.\n\u003c/p\u003e",
          "module": "Data.Text.Strict.Lens",
          "name": "text",
          "package": "lens",
          "signature": "IndexedTraversal' Int Text Char",
          "source": "src/Data-Text-Strict-Lens.html#text",
          "type": "function"
        },
        "index": {
          "description": "Traverse the individual characters in strict Text anyOf text hello True When the type is unambiguous you can also use the more general each text unpacked traversed text each Note that when just using this as Setter setting map can be more efficient",
          "hierarchy": "Data Text Strict Lens",
          "module": "Data.Text.Strict.Lens",
          "name": "text",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Strict-Lens.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis isomorphism can be used to \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e (or \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e) lazy \u003ccode\u003e\u003ca\u003eText\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.unpacked -- :: String\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e is provided for notational convenience rather than out of great need, since\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e x &#8801; x \u003ccode\u003e\u003ca\u003e^.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epacked\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003eunpacked\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunpack\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003epack\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "Data.Text.Strict.Lens",
          "name": "unpacked",
          "package": "lens",
          "signature": "Iso' Text String",
          "source": "src/Data-Text-Strict-Lens.html#unpacked",
          "type": "function"
        },
        "index": {
          "description": "This isomorphism can be used to unpack or pack lazy Text hello unpacked String hello This Iso is provided for notational convenience rather than out of great need since unpacked from packed pack from unpacked unpack packed unpacked iso unpack pack",
          "hierarchy": "Data Text Strict Lens",
          "module": "Data.Text.Strict.Lens",
          "name": "unpacked",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Strict-Lens.html#v:unpacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEncode\u003cem\u003eDecode a strict 'Text' to\u003c/em\u003efrom strict \u003ccode\u003e\u003ca\u003eByteString\u003c/a\u003e\u003c/code\u003e, via UTF-8.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eutf8 # \"&#9731;\"\n\u003c/code\u003e\u003c/strong\u003e\"\\226\\152\\131\"\n\u003c/pre\u003e",
          "module": "Data.Text.Strict.Lens",
          "name": "utf8",
          "package": "lens",
          "signature": "Prism' ByteString Text",
          "source": "src/Data-Text-Strict-Lens.html#utf8",
          "type": "function"
        },
        "index": {
          "description": "Encode Decode strict Text to from strict ByteString via UTF-8 utf8",
          "hierarchy": "Data Text Strict Lens",
          "module": "Data.Text.Strict.Lens",
          "name": "utf8",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Text-Strict-Lens.html#v:utf8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Tree-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Tree Lens",
          "module": "Data.Tree.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Tree-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e returning the direct descendants of the root of a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eview\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ebranches\u003c/a\u003e\u003c/code\u003e &#8801; \u003ccode\u003e\u003ca\u003esubForest\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e",
          "module": "Data.Tree.Lens",
          "name": "branches",
          "package": "lens",
          "signature": "Lens' (Tree a) [Tree a]",
          "source": "src/Data-Tree-Lens.html#branches",
          "type": "function"
        },
        "index": {
          "description": "Lens returning the direct descendants of the root of Tree view branches subForest",
          "hierarchy": "Data Tree Lens",
          "module": "Data.Tree.Lens",
          "name": "branches",
          "normalized": "Lens'(Tree a)[Tree a]",
          "package": "lens",
          "signature": "Lens'(Tree a)[Tree a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Tree-Lens.html#v:branches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that focuses on the root of a \u003ccode\u003e\u003ca\u003eTree\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eview root $ Node 42 []\n\u003c/code\u003e\u003c/strong\u003e42\n\u003c/pre\u003e",
          "module": "Data.Tree.Lens",
          "name": "root",
          "package": "lens",
          "signature": "Lens' (Tree a) a",
          "source": "src/Data-Tree-Lens.html#root",
          "type": "function"
        },
        "index": {
          "description": "Lens that focuses on the root of Tree view root Node",
          "hierarchy": "Data Tree Lens",
          "module": "Data.Tree.Lens",
          "name": "root",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Tree-Lens.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Typeable.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Typeable-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Data Typeable Lens",
          "module": "Data.Typeable.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Typeable-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e for working with a \u003ccode\u003e\u003ca\u003ecast\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "Data.Typeable.Lens",
          "name": "_cast",
          "package": "lens",
          "signature": "Traversal' s a",
          "source": "src/Data-Typeable-Lens.html#_cast",
          "type": "function"
        },
        "index": {
          "description": "Traversal for working with cast of Typeable value",
          "hierarchy": "Data Typeable Lens",
          "module": "Data.Typeable.Lens",
          "name": "_cast",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Typeable-Lens.html#v:_cast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e for working with a \u003ccode\u003e\u003ca\u003egcast\u003c/a\u003e\u003c/code\u003e of a \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e value.\n\u003c/p\u003e",
          "module": "Data.Typeable.Lens",
          "name": "_gcast",
          "package": "lens",
          "signature": "Traversal' (c s) (c a)",
          "source": "src/Data-Typeable-Lens.html#_gcast",
          "type": "function"
        },
        "index": {
          "description": "Traversal for working with gcast of Typeable value",
          "hierarchy": "Data Typeable Lens",
          "module": "Data.Typeable.Lens",
          "name": "_gcast",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Typeable-Lens.html#v:_gcast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides lenses and traversals for working with generic\n vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Vector-Generic-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides lenses and traversals for working with generic vectors",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e to a finite \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e (or back.)\n\u003c/p\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "asStream",
          "package": "lens",
          "signature": "Iso' (v a) (Stream a)",
          "source": "src/Data-Vector-Generic-Lens.html#asStream",
          "type": "function"
        },
        "index": {
          "description": "Convert Vector to finite Stream or back",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "asStream",
          "package": "lens",
          "partial": "Stream",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:asStream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e to a finite \u003ccode\u003e\u003ca\u003eStream\u003c/a\u003e\u003c/code\u003e from right to left (or\n back.)\n\u003c/p\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "asStreamR",
          "package": "lens",
          "signature": "Iso' (v a) (Stream a)",
          "source": "src/Data-Vector-Generic-Lens.html#asStreamR",
          "type": "function"
        },
        "index": {
          "description": "Convert Vector to finite Stream from right to left or back",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "asStreamR",
          "package": "lens",
          "partial": "Stream",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:asStreamR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e back and forth to an initializer that when run\n produces a copy of the \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "cloned",
          "package": "lens",
          "signature": "Iso' (v a) (New v a)",
          "source": "src/Data-Vector-Generic-Lens.html#cloned",
          "type": "function"
        },
        "index": {
          "description": "Convert Vector back and forth to an initializer that when run produces copy of the Vector",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "cloned",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:cloned"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e to a version that doesn't retain any extra\n memory.\n\u003c/p\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "forced",
          "package": "lens",
          "signature": "Iso' (v a) (v a)",
          "source": "src/Data-Vector-Generic-Lens.html#forced",
          "type": "function"
        },
        "index": {
          "description": "Convert Vector to version that doesn retain any extra memory",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "forced",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:forced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e will ignore any duplicates in the supplied list\n of indices.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]\n\u003c/code\u003e\u003c/strong\u003e[4,8,6,12,20,22]\n\u003c/pre\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "ordinals",
          "package": "lens",
          "signature": "[Int] -\u003e IndexedTraversal' Int (v a) a",
          "source": "src/Data-Vector-Generic-Lens.html#ordinals",
          "type": "function"
        },
        "index": {
          "description": "This Traversal will ignore any duplicates in the supplied list of indices toListOf ordinals Vector.fromList",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "ordinals",
          "normalized": "[Int]-\u003eIndexedTraversal' Int(a b)b",
          "package": "lens",
          "signature": "[Int]-\u003eIndexedTraversal' Int(v a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:ordinals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esliced i n\u003c/code\u003e provides a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that edits the \u003ccode\u003en\u003c/code\u003e elements starting\n at index \u003ccode\u003ei\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is only a valid \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e if you do not change the length of the\n resulting \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAttempting to return a longer or shorter vector will result in\n violations of the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList [1..10] ^. sliced 2 5\n\u003c/code\u003e\u003c/strong\u003efromList [3,4,5,6,7]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList [1..10] & sliced 2 5 . mapped .~ 0\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,0,0,0,0,0,8,9,10]\n\u003c/pre\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "sliced",
          "package": "lens",
          "signature": "Int-\u003e Int-\u003e Lens' (v a) (v a)",
          "type": "function"
        },
        "index": {
          "description": "sliced provides Lens that edits the elements starting at index from Lens This is only valid Lens if you do not change the length of the resulting Vector Attempting to return longer or shorter vector will result in violations of the Lens laws Vector.fromList sliced fromList Vector.fromList sliced mapped fromList",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "sliced",
          "normalized": "Int-\u003eInt-\u003eLens'(a b)(a b)",
          "package": "lens",
          "signature": "Int-\u003eInt-\u003eLens'(v a)(v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:sliced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e, but returning a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoVectorOf both (8,15) :: Vector.Vector Int\n\u003c/code\u003e\u003c/strong\u003efromList [8,15]\n\u003c/pre\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "toVectorOf",
          "package": "lens",
          "signature": "Getting (Endo [a]) s a -\u003e s -\u003e v a",
          "source": "src/Data-Vector-Generic-Lens.html#toVectorOf",
          "type": "function"
        },
        "index": {
          "description": "Similar to toListOf but returning Vector toVectorOf both Vector.Vector Int fromList",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "toVectorOf",
          "normalized": "Getting(Endo[a])b a-\u003eb-\u003ec a",
          "package": "lens",
          "partial": "Vector Of",
          "signature": "Getting(Endo[a])s a-\u003es-\u003ev a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:toVectorOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list to a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e (or back.)\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3] ^. vector :: Vector.Vector Int\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList [0,8,15] ^. from vector\n\u003c/code\u003e\u003c/strong\u003e[0,8,15]\n\u003c/pre\u003e",
          "module": "Data.Vector.Generic.Lens",
          "name": "vector",
          "package": "lens",
          "signature": "Iso' [a] (v a)",
          "source": "src/Data-Vector-Generic-Lens.html#vector",
          "type": "function"
        },
        "index": {
          "description": "Convert list to Vector or back vector Vector.Vector Int fromList Vector.fromList from vector",
          "hierarchy": "Data Vector Generic Lens",
          "module": "Data.Vector.Generic.Lens",
          "name": "vector",
          "normalized": "Iso'[a](b a)",
          "package": "lens",
          "signature": "Iso'[a](v a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Generic-Lens.html#v:vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides lenses and traversals for working with generic\n vectors.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Vector.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Data-Vector-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides lenses and traversals for working with generic vectors",
          "hierarchy": "Data Vector Lens",
          "module": "Data.Vector.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e to a version that doesn't retain any extra\n memory.\n\u003c/p\u003e",
          "module": "Data.Vector.Lens",
          "name": "forced",
          "package": "lens",
          "signature": "Iso (Vector a) (Vector b) (Vector a) (Vector b)",
          "source": "src/Data-Vector-Lens.html#forced",
          "type": "function"
        },
        "index": {
          "description": "Convert Vector to version that doesn retain any extra memory",
          "hierarchy": "Data Vector Lens",
          "module": "Data.Vector.Lens",
          "name": "forced",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Lens.html#v:forced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e will ignore any duplicates in the supplied list\n of indices.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoListOf (ordinals [1,3,2,5,9,10]) $ Vector.fromList [2,4..40]\n\u003c/code\u003e\u003c/strong\u003e[4,8,6,12,20,22]\n\u003c/pre\u003e",
          "module": "Data.Vector.Lens",
          "name": "ordinals",
          "package": "lens",
          "signature": "[Int] -\u003e IndexedTraversal' Int (Vector a) a",
          "source": "src/Data-Vector-Lens.html#ordinals",
          "type": "function"
        },
        "index": {
          "description": "This Traversal will ignore any duplicates in the supplied list of indices toListOf ordinals Vector.fromList",
          "hierarchy": "Data Vector Lens",
          "module": "Data.Vector.Lens",
          "name": "ordinals",
          "normalized": "[Int]-\u003eIndexedTraversal' Int(Vector a)a",
          "package": "lens",
          "signature": "[Int]-\u003eIndexedTraversal' Int(Vector a)a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Lens.html#v:ordinals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003esliced i n\u003c/code\u003e provides a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e that edits the \u003ccode\u003en\u003c/code\u003e elements starting\n at index \u003ccode\u003ei\u003c/code\u003e from a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis is only a valid \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e if you do not change the length of the\n resulting \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAttempting to return a longer or shorter vector will result in\n violations of the \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e laws.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList [1..10] ^. sliced 2 5\n\u003c/code\u003e\u003c/strong\u003efromList [3,4,5,6,7]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList [1..10] & sliced 2 5 . mapped .~ 0\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,0,0,0,0,0,8,9,10]\n\u003c/pre\u003e",
          "module": "Data.Vector.Lens",
          "name": "sliced",
          "package": "lens",
          "signature": "Int-\u003e Int-\u003e Lens' (Vector a) (Vector a)",
          "type": "function"
        },
        "index": {
          "description": "sliced provides Lens that edits the elements starting at index from Lens This is only valid Lens if you do not change the length of the resulting Vector Attempting to return longer or shorter vector will result in violations of the Lens laws Vector.fromList sliced fromList Vector.fromList sliced mapped fromList",
          "hierarchy": "Data Vector Lens",
          "module": "Data.Vector.Lens",
          "name": "sliced",
          "normalized": "Int-\u003eInt-\u003eLens'(Vector a)(Vector a)",
          "package": "lens",
          "signature": "Int-\u003eInt-\u003eLens'(Vector a)(Vector a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Lens.html#v:sliced"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSimilar to \u003ccode\u003e\u003ca\u003etoListOf\u003c/a\u003e\u003c/code\u003e, but returning a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003etoVectorOf both (8,15)\n\u003c/code\u003e\u003c/strong\u003efromList [8,15]\n\u003c/pre\u003e",
          "module": "Data.Vector.Lens",
          "name": "toVectorOf",
          "package": "lens",
          "signature": "Getting (Endo [a]) s a -\u003e s -\u003e Vector a",
          "source": "src/Data-Vector-Lens.html#toVectorOf",
          "type": "function"
        },
        "index": {
          "description": "Similar to toListOf but returning Vector toVectorOf both fromList",
          "hierarchy": "Data Vector Lens",
          "module": "Data.Vector.Lens",
          "name": "toVectorOf",
          "normalized": "Getting(Endo[a])b a-\u003eb-\u003eVector a",
          "package": "lens",
          "partial": "Vector Of",
          "signature": "Getting(Endo[a])s a-\u003es-\u003eVector a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Lens.html#v:toVectorOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a list to a \u003ccode\u003e\u003ca\u003eVector\u003c/a\u003e\u003c/code\u003e (or back)\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3] ^. vector\n\u003c/code\u003e\u003c/strong\u003efromList [1,2,3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1,2,3] ^. vector . from vector\n\u003c/code\u003e\u003c/strong\u003e[1,2,3]\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eVector.fromList [0,8,15] ^. from vector . vector\n\u003c/code\u003e\u003c/strong\u003efromList [0,8,15]\n\u003c/pre\u003e",
          "module": "Data.Vector.Lens",
          "name": "vector",
          "package": "lens",
          "signature": "Iso [a] [b] (Vector a) (Vector b)",
          "source": "src/Data-Vector-Lens.html#vector",
          "type": "function"
        },
        "index": {
          "description": "Convert list to Vector or back vector fromList vector from vector Vector.fromList from vector vector fromList",
          "hierarchy": "Data Vector Lens",
          "module": "Data.Vector.Lens",
          "name": "vector",
          "normalized": "Iso[a][b](Vector a)(Vector b)",
          "package": "lens",
          "signature": "Iso[a][b](Vector a)(Vector b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Data-Vector-Lens.html#v:vector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNote: \u003ccode\u003eGHC.Generics\u003c/code\u003e exports a number of names that collide with \u003ccode\u003eControl.Lens\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can use hiding or imports to mitigate this to an extent, and the following imports,\n represent a fair compromise for user code:\n\u003c/p\u003e\u003cpre\u003e import Control.Lens hiding (Rep)\n import GHC.Generics hiding (from, to)\n\u003c/pre\u003e\u003cp\u003eYou can use \u003ccode\u003e\u003ca\u003egeneric\u003c/a\u003e\u003c/code\u003e to replace \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003eGHC.Generics\u003c/code\u003e,\n and probably won't be explicitly referencing \u003ccode\u003e\u003ca\u003eRep\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003eControl.Lens\u003c/code\u003e\n in code that uses generics.\n\u003c/p\u003e\u003cp\u003eThis module provides compatibility with older GHC versions by using the\n \u003ca\u003egeneric-deriving\u003c/a\u003e\n package.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "GHC.Generics.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/GHC-Generics-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Note GHC.Generics exports number of names that collide with Control.Lens You can use hiding or imports to mitigate this to an extent and the following imports represent fair compromise for user code import Control.Lens hiding Rep import GHC.Generics hiding from to You can use generic to replace from and to from GHC.Generics and probably won be explicitly referencing Rep from Control.Lens in code that uses generics This module provides compatibility with older GHC versions by using the generic-deriving package",
          "hierarchy": "GHC Generics Lens",
          "module": "GHC.Generics.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/GHC-Generics-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eNote: \u003ccode\u003eGenerics.Deriving\u003c/code\u003e exports a number of names that collide with \u003ccode\u003eControl.Lens\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eYou can use hiding to mitigate this to an extent, and the following import\n represents a fair compromise for user code:\n\u003c/p\u003e\u003cpre\u003e import Generics.Deriving hiding (from, to)\n\u003c/pre\u003e\u003cp\u003eYou can use \u003ccode\u003e\u003ca\u003egeneric\u003c/a\u003e\u003c/code\u003e to replace \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003eto\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003eGenerics.Deriving\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Generics.Deriving.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Generics-Deriving-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Note Generics.Deriving exports number of names that collide with Control.Lens You can use hiding to mitigate this to an extent and the following import represents fair compromise for user code import Generics.Deriving hiding from to You can use generic to replace from and to from Generics.Deriving",
          "hierarchy": "Generics Deriving Lens",
          "module": "Generics.Deriving.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Generics-Deriving-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to traverse \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e data by \u003ccode\u003euniplate\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Generics.Deriving.Lens",
          "name": "GTraversal",
          "package": "lens",
          "source": "src/Generics-Deriving-Lens.html#GTraversal",
          "type": "class"
        },
        "index": {
          "description": "Used to traverse Generic data by uniplate",
          "hierarchy": "Generics Deriving Lens",
          "module": "Generics.Deriving.Lens",
          "name": "GTraversal",
          "package": "lens",
          "partial": "GTraversal",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Generics-Deriving-Lens.html#t:GTraversal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the data type to its representation (or back)\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"hello\"^.generic.from generic :: String\n\u003c/code\u003e\u003c/strong\u003e\"hello\"\n\u003c/pre\u003e",
          "module": "Generics.Deriving.Lens",
          "name": "generic",
          "package": "lens",
          "signature": "Iso' a (Rep a b)",
          "source": "src/Generics-Deriving-Lens.html#generic",
          "type": "function"
        },
        "index": {
          "description": "Convert from the data type to its representation or back hello generic.from generic String hello",
          "hierarchy": "Generics Deriving Lens",
          "module": "Generics.Deriving.Lens",
          "name": "generic",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Generics-Deriving-Lens.html#v:generic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from the data type to its representation (or back)\n\u003c/p\u003e",
          "module": "Generics.Deriving.Lens",
          "name": "generic1",
          "package": "lens",
          "signature": "Iso' (f a) (Rep1 f a)",
          "source": "src/Generics-Deriving-Lens.html#generic1",
          "type": "function"
        },
        "index": {
          "description": "Convert from the data type to its representation or back",
          "hierarchy": "Generics Deriving Lens",
          "module": "Generics.Deriving.Lens",
          "name": "generic1",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Generics-Deriving-Lens.html#v:generic1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eGeneric\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e that visits every occurrence\n of something \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e anywhere in a container.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eallOf tinplate (==\"Hello\") (1::Int,2::Double,(),\"Hello\",[\"Hello\"])\n\u003c/code\u003e\u003c/strong\u003eTrue\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003emapMOf_ tinplate putStrLn (\"hello\",[(2 :: Int, \"world!\")])\n\u003c/code\u003e\u003c/strong\u003ehello\nworld!\n\u003c/pre\u003e",
          "module": "Generics.Deriving.Lens",
          "name": "tinplate",
          "package": "lens",
          "signature": "Traversal' a b",
          "source": "src/Generics-Deriving-Lens.html#tinplate",
          "type": "function"
        },
        "index": {
          "description": "Generic Traversal that visits every occurrence of something Typeable anywhere in container allOf tinplate Hello Int Double Hello Hello True mapMOf tinplate putStrLn hello Int world hello world",
          "hierarchy": "Generics Deriving Lens",
          "module": "Generics.Deriving.Lens",
          "name": "tinplate",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Generics-Deriving-Lens.html#v:tinplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLenses, Prisms, and Traversals for working with Template Haskell\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Language-Haskell-TH-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "Lenses Prisms and Traversals for working with Template Haskell",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHas a \u003ccode\u003e\u003ca\u003eName\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "HasName",
          "package": "lens",
          "source": "src/Language-Haskell-TH-Lens.html#HasName",
          "type": "class"
        },
        "index": {
          "description": "Has Name",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "HasName",
          "package": "lens",
          "partial": "Has Name",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#t:HasName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides for the extraction of free type variables, and alpha renaming.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "HasTypeVars",
          "package": "lens",
          "source": "src/Language-Haskell-TH-Lens.html#HasTypeVars",
          "type": "class"
        },
        "index": {
          "description": "Provides for the extraction of free type variables and alpha renaming",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "HasTypeVars",
          "package": "lens",
          "partial": "Has Type Vars",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#t:HasTypeVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides substitution for types\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "SubstType",
          "package": "lens",
          "source": "src/Language-Haskell-TH-Lens.html#SubstType",
          "type": "class"
        },
        "index": {
          "description": "Provides substitution for types",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "SubstType",
          "package": "lens",
          "partial": "Subst Type",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#t:SubstType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_AllPhases",
          "package": "lens",
          "signature": "Prism' Phases ()",
          "source": "src/Language-Haskell-TH-Lens.html#_AllPhases",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_AllPhases",
          "normalized": "Prism' Phases()",
          "package": "lens",
          "partial": "All Phases",
          "signature": "Prism' Phases()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_AllPhases"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_AppE",
          "package": "lens",
          "signature": "Prism' Exp (Exp, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_AppE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_AppE",
          "normalized": "Prism' Exp(Exp,Exp)",
          "package": "lens",
          "partial": "App",
          "signature": "Prism' Exp(Exp,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_AppE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_AppT",
          "package": "lens",
          "signature": "Prism' Type (Type, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_AppT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_AppT",
          "normalized": "Prism' Type(Type,Type)",
          "package": "lens",
          "partial": "App",
          "signature": "Prism' Type(Type,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_AppT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ArithSeqE",
          "package": "lens",
          "signature": "Prism' Exp Range",
          "source": "src/Language-Haskell-TH-Lens.html#_ArithSeqE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ArithSeqE",
          "package": "lens",
          "partial": "Arith Seq",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ArithSeqE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ArrowT",
          "package": "lens",
          "signature": "Prism' Type ()",
          "source": "src/Language-Haskell-TH-Lens.html#_ArrowT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ArrowT",
          "normalized": "Prism' Type()",
          "package": "lens",
          "partial": "Arrow",
          "signature": "Prism' Type()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ArrowT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_AsP",
          "package": "lens",
          "signature": "Prism' Pat (Name, Pat)",
          "source": "src/Language-Haskell-TH-Lens.html#_AsP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_AsP",
          "normalized": "Prism' Pat(Name,Pat)",
          "package": "lens",
          "partial": "As",
          "signature": "Prism' Pat(Name,Pat)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_AsP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_BangP",
          "package": "lens",
          "signature": "Prism' Pat Pat",
          "source": "src/Language-Haskell-TH-Lens.html#_BangP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_BangP",
          "package": "lens",
          "partial": "Bang",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_BangP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_BeforePhase",
          "package": "lens",
          "signature": "Prism' Phases Int",
          "source": "src/Language-Haskell-TH-Lens.html#_BeforePhase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_BeforePhase",
          "package": "lens",
          "partial": "Before Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_BeforePhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_BindS",
          "package": "lens",
          "signature": "Prism' Stmt (Pat, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_BindS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_BindS",
          "normalized": "Prism' Stmt(Pat,Exp)",
          "package": "lens",
          "partial": "Bind",
          "signature": "Prism' Stmt(Pat,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_BindS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_CCall",
          "package": "lens",
          "signature": "Prism' Callconv ()",
          "source": "src/Language-Haskell-TH-Lens.html#_CCall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_CCall",
          "normalized": "Prism' Callconv()",
          "package": "lens",
          "partial": "CCall",
          "signature": "Prism' Callconv()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_CCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_CaseE",
          "package": "lens",
          "signature": "Prism' Exp (Exp, [Match])",
          "source": "src/Language-Haskell-TH-Lens.html#_CaseE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_CaseE",
          "normalized": "Prism' Exp(Exp,[Match])",
          "package": "lens",
          "partial": "Case",
          "signature": "Prism' Exp(Exp,[Match])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_CaseE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_CharL",
          "package": "lens",
          "signature": "Prism' Lit Char",
          "source": "src/Language-Haskell-TH-Lens.html#_CharL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_CharL",
          "package": "lens",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_CharL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassD",
          "package": "lens",
          "signature": "Prism' Dec (Cxt, Name, [TyVarBndr], [FunDep], [Dec])",
          "source": "src/Language-Haskell-TH-Lens.html#_ClassD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassD",
          "normalized": "Prism' Dec(Cxt,Name,[TyVarBndr],[FunDep],[Dec])",
          "package": "lens",
          "partial": "Class",
          "signature": "Prism' Dec(Cxt,Name,[TyVarBndr],[FunDep],[Dec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ClassD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassI",
          "package": "lens",
          "signature": "Prism' Info (Dec, [InstanceDec])",
          "source": "src/Language-Haskell-TH-Lens.html#_ClassI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassI",
          "normalized": "Prism' Info(Dec,[InstanceDec])",
          "package": "lens",
          "partial": "Class",
          "signature": "Prism' Info(Dec,[InstanceDec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ClassI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassOpI",
          "package": "lens",
          "signature": "Prism' Info (Name, Type, ParentName, Fixity)",
          "source": "src/Language-Haskell-TH-Lens.html#_ClassOpI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassOpI",
          "normalized": "Prism' Info(Name,Type,ParentName,Fixity)",
          "package": "lens",
          "partial": "Class Op",
          "signature": "Prism' Info(Name,Type,ParentName,Fixity)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ClassOpI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassP",
          "package": "lens",
          "signature": "Prism' Pred (Name, [Type])",
          "source": "src/Language-Haskell-TH-Lens.html#_ClassP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ClassP",
          "normalized": "Prism' Pred(Name,[Type])",
          "package": "lens",
          "partial": "Class",
          "signature": "Prism' Pred(Name,[Type])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ClassP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_CompE",
          "package": "lens",
          "signature": "Prism' Exp [Stmt]",
          "source": "src/Language-Haskell-TH-Lens.html#_CompE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_CompE",
          "normalized": "Prism' Exp[Stmt]",
          "package": "lens",
          "partial": "Comp",
          "signature": "Prism' Exp[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_CompE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConE",
          "package": "lens",
          "signature": "Prism' Exp Name",
          "source": "src/Language-Haskell-TH-Lens.html#_ConE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConE",
          "package": "lens",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ConE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConLike",
          "package": "lens",
          "signature": "Prism' RuleMatch ()",
          "source": "src/Language-Haskell-TH-Lens.html#_ConLike",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConLike",
          "normalized": "Prism' RuleMatch()",
          "package": "lens",
          "partial": "Con Like",
          "signature": "Prism' RuleMatch()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ConLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConP",
          "package": "lens",
          "signature": "Prism' Pat (Name, [Pat])",
          "source": "src/Language-Haskell-TH-Lens.html#_ConP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConP",
          "normalized": "Prism' Pat(Name,[Pat])",
          "package": "lens",
          "partial": "Con",
          "signature": "Prism' Pat(Name,[Pat])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ConP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConT",
          "package": "lens",
          "signature": "Prism' Type Name",
          "source": "src/Language-Haskell-TH-Lens.html#_ConT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConT",
          "package": "lens",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ConT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_CondE",
          "package": "lens",
          "signature": "Prism' Exp (Exp, Exp, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_CondE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_CondE",
          "normalized": "Prism' Exp(Exp,Exp,Exp)",
          "package": "lens",
          "partial": "Cond",
          "signature": "Prism' Exp(Exp,Exp,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_CondE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConstraintT",
          "package": "lens",
          "signature": "Prism' Type ()",
          "source": "src/Language-Haskell-TH-Lens.html#_ConstraintT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ConstraintT",
          "normalized": "Prism' Type()",
          "package": "lens",
          "partial": "Constraint",
          "signature": "Prism' Type()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ConstraintT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataConI",
          "package": "lens",
          "signature": "Prism' Info (Name, Type, ParentName, Fixity)",
          "source": "src/Language-Haskell-TH-Lens.html#_DataConI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataConI",
          "normalized": "Prism' Info(Name,Type,ParentName,Fixity)",
          "package": "lens",
          "partial": "Data Con",
          "signature": "Prism' Info(Name,Type,ParentName,Fixity)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_DataConI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataD",
          "package": "lens",
          "signature": "Prism' Dec (Cxt, Name, [TyVarBndr], [Con], [Name])",
          "source": "src/Language-Haskell-TH-Lens.html#_DataD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataD",
          "normalized": "Prism' Dec(Cxt,Name,[TyVarBndr],[Con],[Name])",
          "package": "lens",
          "partial": "Data",
          "signature": "Prism' Dec(Cxt,Name,[TyVarBndr],[Con],[Name])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_DataD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataFam",
          "package": "lens",
          "signature": "Prism' FamFlavour ()",
          "source": "src/Language-Haskell-TH-Lens.html#_DataFam",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataFam",
          "normalized": "Prism' FamFlavour()",
          "package": "lens",
          "partial": "Data Fam",
          "signature": "Prism' FamFlavour()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_DataFam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataInstD",
          "package": "lens",
          "signature": "Prism' Dec (Cxt, Name, [Type], [Con], [Name])",
          "source": "src/Language-Haskell-TH-Lens.html#_DataInstD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_DataInstD",
          "normalized": "Prism' Dec(Cxt,Name,[Type],[Con],[Name])",
          "package": "lens",
          "partial": "Data Inst",
          "signature": "Prism' Dec(Cxt,Name,[Type],[Con],[Name])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_DataInstD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_DoE",
          "package": "lens",
          "signature": "Prism' Exp [Stmt]",
          "source": "src/Language-Haskell-TH-Lens.html#_DoE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_DoE",
          "normalized": "Prism' Exp[Stmt]",
          "package": "lens",
          "partial": "Do",
          "signature": "Prism' Exp[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_DoE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_DoublePrimL",
          "package": "lens",
          "signature": "Prism' Lit Rational",
          "source": "src/Language-Haskell-TH-Lens.html#_DoublePrimL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_DoublePrimL",
          "package": "lens",
          "partial": "Double Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_DoublePrimL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_EqualP",
          "package": "lens",
          "signature": "Prism' Pred (Type, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_EqualP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_EqualP",
          "normalized": "Prism' Pred(Type,Type)",
          "package": "lens",
          "partial": "Equal",
          "signature": "Prism' Pred(Type,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_EqualP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ExportF",
          "package": "lens",
          "signature": "Prism' Foreign (Callconv, String, Name, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_ExportF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ExportF",
          "normalized": "Prism' Foreign(Callconv,String,Name,Type)",
          "package": "lens",
          "partial": "Export",
          "signature": "Prism' Foreign(Callconv,String,Name,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ExportF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FamilyD",
          "package": "lens",
          "signature": "Prism' Dec (FamFlavour, Name, [TyVarBndr], Maybe Kind)",
          "source": "src/Language-Haskell-TH-Lens.html#_FamilyD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FamilyD",
          "normalized": "Prism' Dec(FamFlavour,Name,[TyVarBndr],Maybe Kind)",
          "package": "lens",
          "partial": "Family",
          "signature": "Prism' Dec(FamFlavour,Name,[TyVarBndr],Maybe Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FamilyD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FamilyI",
          "package": "lens",
          "signature": "Prism' Info (Dec, [InstanceDec])",
          "source": "src/Language-Haskell-TH-Lens.html#_FamilyI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FamilyI",
          "normalized": "Prism' Info(Dec,[InstanceDec])",
          "package": "lens",
          "partial": "Family",
          "signature": "Prism' Info(Dec,[InstanceDec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FamilyI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FloatPrimL",
          "package": "lens",
          "signature": "Prism' Lit Rational",
          "source": "src/Language-Haskell-TH-Lens.html#_FloatPrimL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FloatPrimL",
          "package": "lens",
          "partial": "Float Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FloatPrimL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ForallC",
          "package": "lens",
          "signature": "Prism' Con ([TyVarBndr], Cxt, Con)",
          "source": "src/Language-Haskell-TH-Lens.html#_ForallC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ForallC",
          "normalized": "Prism' Con([TyVarBndr],Cxt,Con)",
          "package": "lens",
          "partial": "Forall",
          "signature": "Prism' Con([TyVarBndr],Cxt,Con)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ForallC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ForallT",
          "package": "lens",
          "signature": "Prism' Type ([TyVarBndr], Cxt, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_ForallT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ForallT",
          "normalized": "Prism' Type([TyVarBndr],Cxt,Type)",
          "package": "lens",
          "partial": "Forall",
          "signature": "Prism' Type([TyVarBndr],Cxt,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ForallT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ForeignD",
          "package": "lens",
          "signature": "Prism' Dec Foreign",
          "source": "src/Language-Haskell-TH-Lens.html#_ForeignD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ForeignD",
          "package": "lens",
          "partial": "Foreign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ForeignD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromPhase",
          "package": "lens",
          "signature": "Prism' Phases Int",
          "source": "src/Language-Haskell-TH-Lens.html#_FromPhase",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromPhase",
          "package": "lens",
          "partial": "From Phase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FromPhase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromR",
          "package": "lens",
          "signature": "Prism' Range Exp",
          "source": "src/Language-Haskell-TH-Lens.html#_FromR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromR",
          "package": "lens",
          "partial": "From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FromR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromThenR",
          "package": "lens",
          "signature": "Prism' Range (Exp, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_FromThenR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromThenR",
          "normalized": "Prism' Range(Exp,Exp)",
          "package": "lens",
          "partial": "From Then",
          "signature": "Prism' Range(Exp,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FromThenR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromThenToR",
          "package": "lens",
          "signature": "Prism' Range (Exp, Exp, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_FromThenToR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromThenToR",
          "normalized": "Prism' Range(Exp,Exp,Exp)",
          "package": "lens",
          "partial": "From Then To",
          "signature": "Prism' Range(Exp,Exp,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FromThenToR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromToR",
          "package": "lens",
          "signature": "Prism' Range (Exp, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_FromToR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FromToR",
          "normalized": "Prism' Range(Exp,Exp)",
          "package": "lens",
          "partial": "From To",
          "signature": "Prism' Range(Exp,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FromToR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FunD",
          "package": "lens",
          "signature": "Prism' Dec (Name, [Clause])",
          "source": "src/Language-Haskell-TH-Lens.html#_FunD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FunD",
          "normalized": "Prism' Dec(Name,[Clause])",
          "package": "lens",
          "partial": "Fun",
          "signature": "Prism' Dec(Name,[Clause])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FunD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FunDep",
          "package": "lens",
          "signature": "Prism' FunDep ([Name], [Name])",
          "source": "src/Language-Haskell-TH-Lens.html#_FunDep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FunDep",
          "normalized": "Prism' FunDep([Name],[Name])",
          "package": "lens",
          "partial": "Fun Dep",
          "signature": "Prism' FunDep([Name],[Name])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FunDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_FunLike",
          "package": "lens",
          "signature": "Prism' RuleMatch ()",
          "source": "src/Language-Haskell-TH-Lens.html#_FunLike",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_FunLike",
          "normalized": "Prism' RuleMatch()",
          "package": "lens",
          "partial": "Fun Like",
          "signature": "Prism' RuleMatch()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_FunLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_GuardedB",
          "package": "lens",
          "signature": "Prism' Body [(Guard, Exp)]",
          "source": "src/Language-Haskell-TH-Lens.html#_GuardedB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_GuardedB",
          "normalized": "Prism' Body[(Guard,Exp)]",
          "package": "lens",
          "partial": "Guarded",
          "signature": "Prism' Body[(Guard,Exp)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_GuardedB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ImportF",
          "package": "lens",
          "signature": "Prism' Foreign (Callconv, Safety, String, Name, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_ImportF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ImportF",
          "normalized": "Prism' Foreign(Callconv,Safety,String,Name,Type)",
          "package": "lens",
          "partial": "Import",
          "signature": "Prism' Foreign(Callconv,Safety,String,Name,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ImportF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixC",
          "package": "lens",
          "signature": "Prism' Con (StrictType, Name, StrictType)",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixC",
          "normalized": "Prism' Con(StrictType,Name,StrictType)",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' Con(StrictType,Name,StrictType)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixD",
          "package": "lens",
          "signature": "Prism' Dec (Fixity, Name)",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixD",
          "normalized": "Prism' Dec(Fixity,Name)",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' Dec(Fixity,Name)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixE",
          "package": "lens",
          "signature": "Prism' Exp (Maybe Exp, Exp, Maybe Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixE",
          "normalized": "Prism' Exp(Maybe Exp,Exp,Maybe Exp)",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' Exp(Maybe Exp,Exp,Maybe Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixL",
          "package": "lens",
          "signature": "Prism' FixityDirection ()",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixL",
          "normalized": "Prism' FixityDirection()",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' FixityDirection()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixN",
          "package": "lens",
          "signature": "Prism' FixityDirection ()",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixN",
          "normalized": "Prism' FixityDirection()",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' FixityDirection()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixP",
          "package": "lens",
          "signature": "Prism' Pat (Pat, Name, Pat)",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixP",
          "normalized": "Prism' Pat(Pat,Name,Pat)",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' Pat(Pat,Name,Pat)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixR",
          "package": "lens",
          "signature": "Prism' FixityDirection ()",
          "source": "src/Language-Haskell-TH-Lens.html#_InfixR",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InfixR",
          "normalized": "Prism' FixityDirection()",
          "package": "lens",
          "partial": "Infix",
          "signature": "Prism' FixityDirection()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InfixR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_Inlinable",
          "package": "lens",
          "signature": "Prism' Inline ()",
          "source": "src/Language-Haskell-TH-Lens.html#_Inlinable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_Inlinable",
          "normalized": "Prism' Inline()",
          "package": "lens",
          "partial": "Inlinable",
          "signature": "Prism' Inline()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_Inlinable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_Inline",
          "package": "lens",
          "signature": "Prism' Inline ()",
          "source": "src/Language-Haskell-TH-Lens.html#_Inline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_Inline",
          "normalized": "Prism' Inline()",
          "package": "lens",
          "partial": "Inline",
          "signature": "Prism' Inline()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_Inline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InlineP",
          "package": "lens",
          "signature": "Prism' Pragma (Name, Inline, RuleMatch, Phases)",
          "source": "src/Language-Haskell-TH-Lens.html#_InlineP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InlineP",
          "normalized": "Prism' Pragma(Name,Inline,RuleMatch,Phases)",
          "package": "lens",
          "partial": "Inline",
          "signature": "Prism' Pragma(Name,Inline,RuleMatch,Phases)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InlineP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_InstanceD",
          "package": "lens",
          "signature": "Prism' Dec (Cxt, Type, [Dec])",
          "source": "src/Language-Haskell-TH-Lens.html#_InstanceD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_InstanceD",
          "normalized": "Prism' Dec(Cxt,Type,[Dec])",
          "package": "lens",
          "partial": "Instance",
          "signature": "Prism' Dec(Cxt,Type,[Dec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_InstanceD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_IntPrimL",
          "package": "lens",
          "signature": "Prism' Lit Integer",
          "source": "src/Language-Haskell-TH-Lens.html#_IntPrimL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_IntPrimL",
          "package": "lens",
          "partial": "Int Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_IntPrimL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_IntegerL",
          "package": "lens",
          "signature": "Prism' Lit Integer",
          "source": "src/Language-Haskell-TH-Lens.html#_IntegerL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_IntegerL",
          "package": "lens",
          "partial": "Integer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_IntegerL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_Interruptible",
          "package": "lens",
          "signature": "Prism' Safety ()",
          "source": "src/Language-Haskell-TH-Lens.html#_Interruptible",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_Interruptible",
          "normalized": "Prism' Safety()",
          "package": "lens",
          "partial": "Interruptible",
          "signature": "Prism' Safety()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_Interruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_IsStrict",
          "package": "lens",
          "signature": "Prism' Strict ()",
          "source": "src/Language-Haskell-TH-Lens.html#_IsStrict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_IsStrict",
          "normalized": "Prism' Strict()",
          "package": "lens",
          "partial": "Is Strict",
          "signature": "Prism' Strict()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_IsStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_KindedTV",
          "package": "lens",
          "signature": "Prism' TyVarBndr (Name, Kind)",
          "source": "src/Language-Haskell-TH-Lens.html#_KindedTV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_KindedTV",
          "normalized": "Prism' TyVarBndr(Name,Kind)",
          "package": "lens",
          "partial": "Kinded TV",
          "signature": "Prism' TyVarBndr(Name,Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_KindedTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LamCaseE",
          "package": "lens",
          "signature": "Prism' Exp [Match]",
          "source": "src/Language-Haskell-TH-Lens.html#_LamCaseE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LamCaseE",
          "normalized": "Prism' Exp[Match]",
          "package": "lens",
          "partial": "Lam Case",
          "signature": "Prism' Exp[Match]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LamCaseE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LamE",
          "package": "lens",
          "signature": "Prism' Exp ([Pat], Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_LamE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LamE",
          "normalized": "Prism' Exp([Pat],Exp)",
          "package": "lens",
          "partial": "Lam",
          "signature": "Prism' Exp([Pat],Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LamE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LetE",
          "package": "lens",
          "signature": "Prism' Exp ([Dec], Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_LetE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LetE",
          "normalized": "Prism' Exp([Dec],Exp)",
          "package": "lens",
          "partial": "Let",
          "signature": "Prism' Exp([Dec],Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LetE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LetS",
          "package": "lens",
          "signature": "Prism' Stmt [Dec]",
          "source": "src/Language-Haskell-TH-Lens.html#_LetS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LetS",
          "normalized": "Prism' Stmt[Dec]",
          "package": "lens",
          "partial": "Let",
          "signature": "Prism' Stmt[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LetS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ListE",
          "package": "lens",
          "signature": "Prism' Exp [Exp]",
          "source": "src/Language-Haskell-TH-Lens.html#_ListE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ListE",
          "normalized": "Prism' Exp[Exp]",
          "package": "lens",
          "partial": "List",
          "signature": "Prism' Exp[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ListE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ListP",
          "package": "lens",
          "signature": "Prism' Pat [Pat]",
          "source": "src/Language-Haskell-TH-Lens.html#_ListP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ListP",
          "normalized": "Prism' Pat[Pat]",
          "package": "lens",
          "partial": "List",
          "signature": "Prism' Pat[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ListP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ListT",
          "package": "lens",
          "signature": "Prism' Type ()",
          "source": "src/Language-Haskell-TH-Lens.html#_ListT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ListT",
          "normalized": "Prism' Type()",
          "package": "lens",
          "partial": "List",
          "signature": "Prism' Type()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ListT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LitE",
          "package": "lens",
          "signature": "Prism' Exp Lit",
          "source": "src/Language-Haskell-TH-Lens.html#_LitE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LitE",
          "package": "lens",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LitE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LitP",
          "package": "lens",
          "signature": "Prism' Pat Lit",
          "source": "src/Language-Haskell-TH-Lens.html#_LitP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LitP",
          "package": "lens",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LitP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_LitT",
          "package": "lens",
          "signature": "Prism' Type TyLit",
          "source": "src/Language-Haskell-TH-Lens.html#_LitT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_LitT",
          "package": "lens",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_LitT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_MultiIfE",
          "package": "lens",
          "signature": "Prism' Exp [(Guard, Exp)]",
          "source": "src/Language-Haskell-TH-Lens.html#_MultiIfE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_MultiIfE",
          "normalized": "Prism' Exp[(Guard,Exp)]",
          "package": "lens",
          "partial": "Multi If",
          "signature": "Prism' Exp[(Guard,Exp)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_MultiIfE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NewtypeD",
          "package": "lens",
          "signature": "Prism' Dec (Cxt, Name, [TyVarBndr], Con, [Name])",
          "source": "src/Language-Haskell-TH-Lens.html#_NewtypeD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NewtypeD",
          "normalized": "Prism' Dec(Cxt,Name,[TyVarBndr],Con,[Name])",
          "package": "lens",
          "partial": "Newtype",
          "signature": "Prism' Dec(Cxt,Name,[TyVarBndr],Con,[Name])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NewtypeD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NewtypeInstD",
          "package": "lens",
          "signature": "Prism' Dec (Cxt, Name, [Type], Con, [Name])",
          "source": "src/Language-Haskell-TH-Lens.html#_NewtypeInstD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NewtypeInstD",
          "normalized": "Prism' Dec(Cxt,Name,[Type],Con,[Name])",
          "package": "lens",
          "partial": "Newtype Inst",
          "signature": "Prism' Dec(Cxt,Name,[Type],Con,[Name])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NewtypeInstD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NoBindS",
          "package": "lens",
          "signature": "Prism' Stmt Exp",
          "source": "src/Language-Haskell-TH-Lens.html#_NoBindS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NoBindS",
          "package": "lens",
          "partial": "No Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NoBindS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NoInline",
          "package": "lens",
          "signature": "Prism' Inline ()",
          "source": "src/Language-Haskell-TH-Lens.html#_NoInline",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NoInline",
          "normalized": "Prism' Inline()",
          "package": "lens",
          "partial": "No Inline",
          "signature": "Prism' Inline()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NoInline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NormalB",
          "package": "lens",
          "signature": "Prism' Body Exp",
          "source": "src/Language-Haskell-TH-Lens.html#_NormalB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NormalB",
          "package": "lens",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NormalB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NormalC",
          "package": "lens",
          "signature": "Prism' Con (Name, [StrictType])",
          "source": "src/Language-Haskell-TH-Lens.html#_NormalC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NormalC",
          "normalized": "Prism' Con(Name,[StrictType])",
          "package": "lens",
          "partial": "Normal",
          "signature": "Prism' Con(Name,[StrictType])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NormalC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NormalG",
          "package": "lens",
          "signature": "Prism' Guard Exp",
          "source": "src/Language-Haskell-TH-Lens.html#_NormalG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NormalG",
          "package": "lens",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NormalG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NotStrict",
          "package": "lens",
          "signature": "Prism' Strict ()",
          "source": "src/Language-Haskell-TH-Lens.html#_NotStrict",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NotStrict",
          "normalized": "Prism' Strict()",
          "package": "lens",
          "partial": "Not Strict",
          "signature": "Prism' Strict()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NotStrict"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_NumTyLit",
          "package": "lens",
          "signature": "Prism' TyLit Integer",
          "source": "src/Language-Haskell-TH-Lens.html#_NumTyLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_NumTyLit",
          "package": "lens",
          "partial": "Num Ty Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_NumTyLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ParS",
          "package": "lens",
          "signature": "Prism' Stmt [[Stmt]]",
          "source": "src/Language-Haskell-TH-Lens.html#_ParS",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ParS",
          "normalized": "Prism' Stmt[[Stmt]]",
          "package": "lens",
          "partial": "Par",
          "signature": "Prism' Stmt[[Stmt]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ParS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ParensE",
          "package": "lens",
          "signature": "Prism' Exp Exp",
          "source": "src/Language-Haskell-TH-Lens.html#_ParensE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ParensE",
          "package": "lens",
          "partial": "Parens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ParensE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ParensP",
          "package": "lens",
          "signature": "Prism' Pat Pat",
          "source": "src/Language-Haskell-TH-Lens.html#_ParensP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ParensP",
          "package": "lens",
          "partial": "Parens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ParensP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PatG",
          "package": "lens",
          "signature": "Prism' Guard [Stmt]",
          "source": "src/Language-Haskell-TH-Lens.html#_PatG",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PatG",
          "normalized": "Prism' Guard[Stmt]",
          "package": "lens",
          "partial": "Pat",
          "signature": "Prism' Guard[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PatG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PlainTV",
          "package": "lens",
          "signature": "Prism' TyVarBndr Name",
          "source": "src/Language-Haskell-TH-Lens.html#_PlainTV",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PlainTV",
          "package": "lens",
          "partial": "Plain TV",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PlainTV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PragmaD",
          "package": "lens",
          "signature": "Prism' Dec Pragma",
          "source": "src/Language-Haskell-TH-Lens.html#_PragmaD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PragmaD",
          "package": "lens",
          "partial": "Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PragmaD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PrimTyConI",
          "package": "lens",
          "signature": "Prism' Info (Name, Arity, Unlifted)",
          "source": "src/Language-Haskell-TH-Lens.html#_PrimTyConI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PrimTyConI",
          "normalized": "Prism' Info(Name,Arity,Unlifted)",
          "package": "lens",
          "partial": "Prim Ty Con",
          "signature": "Prism' Info(Name,Arity,Unlifted)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PrimTyConI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedConsT",
          "package": "lens",
          "signature": "Prism' Type ()",
          "source": "src/Language-Haskell-TH-Lens.html#_PromotedConsT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedConsT",
          "normalized": "Prism' Type()",
          "package": "lens",
          "partial": "Promoted Cons",
          "signature": "Prism' Type()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PromotedConsT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedNilT",
          "package": "lens",
          "signature": "Prism' Type ()",
          "source": "src/Language-Haskell-TH-Lens.html#_PromotedNilT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedNilT",
          "normalized": "Prism' Type()",
          "package": "lens",
          "partial": "Promoted Nil",
          "signature": "Prism' Type()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PromotedNilT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedT",
          "package": "lens",
          "signature": "Prism' Type Name",
          "source": "src/Language-Haskell-TH-Lens.html#_PromotedT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedT",
          "package": "lens",
          "partial": "Promoted",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PromotedT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedTupleT",
          "package": "lens",
          "signature": "Prism' Type Int",
          "source": "src/Language-Haskell-TH-Lens.html#_PromotedTupleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_PromotedTupleT",
          "package": "lens",
          "partial": "Promoted Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_PromotedTupleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RationalL",
          "package": "lens",
          "signature": "Prism' Lit Rational",
          "source": "src/Language-Haskell-TH-Lens.html#_RationalL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RationalL",
          "package": "lens",
          "partial": "Rational",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RationalL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecC",
          "package": "lens",
          "signature": "Prism' Con (Name, [VarStrictType])",
          "source": "src/Language-Haskell-TH-Lens.html#_RecC",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecC",
          "normalized": "Prism' Con(Name,[VarStrictType])",
          "package": "lens",
          "partial": "Rec",
          "signature": "Prism' Con(Name,[VarStrictType])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RecC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecConE",
          "package": "lens",
          "signature": "Prism' Exp (Name, [FieldExp])",
          "source": "src/Language-Haskell-TH-Lens.html#_RecConE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecConE",
          "normalized": "Prism' Exp(Name,[FieldExp])",
          "package": "lens",
          "partial": "Rec Con",
          "signature": "Prism' Exp(Name,[FieldExp])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RecConE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecP",
          "package": "lens",
          "signature": "Prism' Pat (Name, [FieldPat])",
          "source": "src/Language-Haskell-TH-Lens.html#_RecP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecP",
          "normalized": "Prism' Pat(Name,[FieldPat])",
          "package": "lens",
          "partial": "Rec",
          "signature": "Prism' Pat(Name,[FieldPat])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RecP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecUpdE",
          "package": "lens",
          "signature": "Prism' Exp (Exp, [FieldExp])",
          "source": "src/Language-Haskell-TH-Lens.html#_RecUpdE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RecUpdE",
          "normalized": "Prism' Exp(Exp,[FieldExp])",
          "package": "lens",
          "partial": "Rec Upd",
          "signature": "Prism' Exp(Exp,[FieldExp])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RecUpdE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RuleP",
          "package": "lens",
          "signature": "Prism' Pragma (String, [RuleBndr], Exp, Exp, Phases)",
          "source": "src/Language-Haskell-TH-Lens.html#_RuleP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RuleP",
          "normalized": "Prism' Pragma(String,[RuleBndr],Exp,Exp,Phases)",
          "package": "lens",
          "partial": "Rule",
          "signature": "Prism' Pragma(String,[RuleBndr],Exp,Exp,Phases)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RuleP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_RuleVar",
          "package": "lens",
          "signature": "Prism' RuleBndr Name",
          "source": "src/Language-Haskell-TH-Lens.html#_RuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_RuleVar",
          "package": "lens",
          "partial": "Rule Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_RuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_Safe",
          "package": "lens",
          "signature": "Prism' Safety ()",
          "source": "src/Language-Haskell-TH-Lens.html#_Safe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_Safe",
          "normalized": "Prism' Safety()",
          "package": "lens",
          "partial": "Safe",
          "signature": "Prism' Safety()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_Safe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigD",
          "package": "lens",
          "signature": "Prism' Dec (Name, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_SigD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigD",
          "normalized": "Prism' Dec(Name,Type)",
          "package": "lens",
          "partial": "Sig",
          "signature": "Prism' Dec(Name,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_SigD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigE",
          "package": "lens",
          "signature": "Prism' Exp (Exp, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_SigE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigE",
          "normalized": "Prism' Exp(Exp,Type)",
          "package": "lens",
          "partial": "Sig",
          "signature": "Prism' Exp(Exp,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_SigE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigP",
          "package": "lens",
          "signature": "Prism' Pat (Pat, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_SigP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigP",
          "normalized": "Prism' Pat(Pat,Type)",
          "package": "lens",
          "partial": "Sig",
          "signature": "Prism' Pat(Pat,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_SigP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigT",
          "package": "lens",
          "signature": "Prism' Type (Type, Kind)",
          "source": "src/Language-Haskell-TH-Lens.html#_SigT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_SigT",
          "normalized": "Prism' Type(Type,Kind)",
          "package": "lens",
          "partial": "Sig",
          "signature": "Prism' Type(Type,Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_SigT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_SpecialiseInstP",
          "package": "lens",
          "signature": "Prism' Pragma Type",
          "source": "src/Language-Haskell-TH-Lens.html#_SpecialiseInstP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_SpecialiseInstP",
          "package": "lens",
          "partial": "Specialise Inst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_SpecialiseInstP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_SpecialiseP",
          "package": "lens",
          "signature": "Prism' Pragma (Name, Type, Maybe Inline, Phases)",
          "source": "src/Language-Haskell-TH-Lens.html#_SpecialiseP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_SpecialiseP",
          "normalized": "Prism' Pragma(Name,Type,Maybe Inline,Phases)",
          "package": "lens",
          "partial": "Specialise",
          "signature": "Prism' Pragma(Name,Type,Maybe Inline,Phases)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_SpecialiseP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_StarT",
          "package": "lens",
          "signature": "Prism' Type ()",
          "source": "src/Language-Haskell-TH-Lens.html#_StarT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_StarT",
          "normalized": "Prism' Type()",
          "package": "lens",
          "partial": "Star",
          "signature": "Prism' Type()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_StarT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_StdCall",
          "package": "lens",
          "signature": "Prism' Callconv ()",
          "source": "src/Language-Haskell-TH-Lens.html#_StdCall",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_StdCall",
          "normalized": "Prism' Callconv()",
          "package": "lens",
          "partial": "Std Call",
          "signature": "Prism' Callconv()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_StdCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_StrTyLit",
          "package": "lens",
          "signature": "Prism' TyLit String",
          "source": "src/Language-Haskell-TH-Lens.html#_StrTyLit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_StrTyLit",
          "package": "lens",
          "partial": "Str Ty Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_StrTyLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_StringL",
          "package": "lens",
          "signature": "Prism' Lit String",
          "source": "src/Language-Haskell-TH-Lens.html#_StringL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_StringL",
          "package": "lens",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_StringL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_StringPrimL",
          "package": "lens",
          "signature": "Prism' Lit [Word8]",
          "source": "src/Language-Haskell-TH-Lens.html#_StringPrimL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_StringPrimL",
          "normalized": "Prism' Lit[Word]",
          "package": "lens",
          "partial": "String Prim",
          "signature": "Prism' Lit[Word]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_StringPrimL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TildeP",
          "package": "lens",
          "signature": "Prism' Pat Pat",
          "source": "src/Language-Haskell-TH-Lens.html#_TildeP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TildeP",
          "package": "lens",
          "partial": "Tilde",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TildeP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TupE",
          "package": "lens",
          "signature": "Prism' Exp [Exp]",
          "source": "src/Language-Haskell-TH-Lens.html#_TupE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TupE",
          "normalized": "Prism' Exp[Exp]",
          "package": "lens",
          "partial": "Tup",
          "signature": "Prism' Exp[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TupE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TupP",
          "package": "lens",
          "signature": "Prism' Pat [Pat]",
          "source": "src/Language-Haskell-TH-Lens.html#_TupP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TupP",
          "normalized": "Prism' Pat[Pat]",
          "package": "lens",
          "partial": "Tup",
          "signature": "Prism' Pat[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TupP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TupleT",
          "package": "lens",
          "signature": "Prism' Type Int",
          "source": "src/Language-Haskell-TH-Lens.html#_TupleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TupleT",
          "package": "lens",
          "partial": "Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TupleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TyConI",
          "package": "lens",
          "signature": "Prism' Info Dec",
          "source": "src/Language-Haskell-TH-Lens.html#_TyConI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TyConI",
          "package": "lens",
          "partial": "Ty Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TyConI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TySynD",
          "package": "lens",
          "signature": "Prism' Dec (Name, [TyVarBndr], Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_TySynD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TySynD",
          "normalized": "Prism' Dec(Name,[TyVarBndr],Type)",
          "package": "lens",
          "partial": "Ty Syn",
          "signature": "Prism' Dec(Name,[TyVarBndr],Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TySynD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TySynInstD",
          "package": "lens",
          "signature": "Prism' Dec (Name, [Type], Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_TySynInstD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TySynInstD",
          "normalized": "Prism' Dec(Name,[Type],Type)",
          "package": "lens",
          "partial": "Ty Syn Inst",
          "signature": "Prism' Dec(Name,[Type],Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TySynInstD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TyVarI",
          "package": "lens",
          "signature": "Prism' Info (Name, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_TyVarI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TyVarI",
          "normalized": "Prism' Info(Name,Type)",
          "package": "lens",
          "partial": "Ty Var",
          "signature": "Prism' Info(Name,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TyVarI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TypeFam",
          "package": "lens",
          "signature": "Prism' FamFlavour ()",
          "source": "src/Language-Haskell-TH-Lens.html#_TypeFam",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TypeFam",
          "normalized": "Prism' FamFlavour()",
          "package": "lens",
          "partial": "Type Fam",
          "signature": "Prism' FamFlavour()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TypeFam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_TypedRuleVar",
          "package": "lens",
          "signature": "Prism' RuleBndr (Name, Type)",
          "source": "src/Language-Haskell-TH-Lens.html#_TypedRuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_TypedRuleVar",
          "normalized": "Prism' RuleBndr(Name,Type)",
          "package": "lens",
          "partial": "Typed Rule Var",
          "signature": "Prism' RuleBndr(Name,Type)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_TypedRuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_UInfixE",
          "package": "lens",
          "signature": "Prism' Exp (Exp, Exp, Exp)",
          "source": "src/Language-Haskell-TH-Lens.html#_UInfixE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_UInfixE",
          "normalized": "Prism' Exp(Exp,Exp,Exp)",
          "package": "lens",
          "partial": "UInfix",
          "signature": "Prism' Exp(Exp,Exp,Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_UInfixE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_UInfixP",
          "package": "lens",
          "signature": "Prism' Pat (Pat, Name, Pat)",
          "source": "src/Language-Haskell-TH-Lens.html#_UInfixP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_UInfixP",
          "normalized": "Prism' Pat(Pat,Name,Pat)",
          "package": "lens",
          "partial": "UInfix",
          "signature": "Prism' Pat(Pat,Name,Pat)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_UInfixP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_UnboxedTupE",
          "package": "lens",
          "signature": "Prism' Exp [Exp]",
          "source": "src/Language-Haskell-TH-Lens.html#_UnboxedTupE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_UnboxedTupE",
          "normalized": "Prism' Exp[Exp]",
          "package": "lens",
          "partial": "Unboxed Tup",
          "signature": "Prism' Exp[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_UnboxedTupE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_UnboxedTupP",
          "package": "lens",
          "signature": "Prism' Pat [Pat]",
          "source": "src/Language-Haskell-TH-Lens.html#_UnboxedTupP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_UnboxedTupP",
          "normalized": "Prism' Pat[Pat]",
          "package": "lens",
          "partial": "Unboxed Tup",
          "signature": "Prism' Pat[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_UnboxedTupP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_UnboxedTupleT",
          "package": "lens",
          "signature": "Prism' Type Int",
          "source": "src/Language-Haskell-TH-Lens.html#_UnboxedTupleT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_UnboxedTupleT",
          "package": "lens",
          "partial": "Unboxed Tuple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_UnboxedTupleT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_Unpacked",
          "package": "lens",
          "signature": "Prism' Strict ()",
          "source": "src/Language-Haskell-TH-Lens.html#_Unpacked",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_Unpacked",
          "normalized": "Prism' Strict()",
          "package": "lens",
          "partial": "Unpacked",
          "signature": "Prism' Strict()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_Unpacked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_Unsafe",
          "package": "lens",
          "signature": "Prism' Safety ()",
          "source": "src/Language-Haskell-TH-Lens.html#_Unsafe",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_Unsafe",
          "normalized": "Prism' Safety()",
          "package": "lens",
          "partial": "Unsafe",
          "signature": "Prism' Safety()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_Unsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ValD",
          "package": "lens",
          "signature": "Prism' Dec (Pat, Body, [Dec])",
          "source": "src/Language-Haskell-TH-Lens.html#_ValD",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ValD",
          "normalized": "Prism' Dec(Pat,Body,[Dec])",
          "package": "lens",
          "partial": "Val",
          "signature": "Prism' Dec(Pat,Body,[Dec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ValD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarE",
          "package": "lens",
          "signature": "Prism' Exp Name",
          "source": "src/Language-Haskell-TH-Lens.html#_VarE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarE",
          "package": "lens",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_VarE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarI",
          "package": "lens",
          "signature": "Prism' Info (Name, Type, Maybe Dec, Fixity)",
          "source": "src/Language-Haskell-TH-Lens.html#_VarI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarI",
          "normalized": "Prism' Info(Name,Type,Maybe Dec,Fixity)",
          "package": "lens",
          "partial": "Var",
          "signature": "Prism' Info(Name,Type,Maybe Dec,Fixity)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_VarI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarP",
          "package": "lens",
          "signature": "Prism' Pat Name",
          "source": "src/Language-Haskell-TH-Lens.html#_VarP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarP",
          "package": "lens",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_VarP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarT",
          "package": "lens",
          "signature": "Prism' Type Name",
          "source": "src/Language-Haskell-TH-Lens.html#_VarT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_VarT",
          "package": "lens",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_VarT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_ViewP",
          "package": "lens",
          "signature": "Prism' Pat (Exp, Pat)",
          "source": "src/Language-Haskell-TH-Lens.html#_ViewP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_ViewP",
          "normalized": "Prism' Pat(Exp,Pat)",
          "package": "lens",
          "partial": "View",
          "signature": "Prism' Pat(Exp,Pat)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_ViewP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_WildP",
          "package": "lens",
          "signature": "Prism' Pat ()",
          "source": "src/Language-Haskell-TH-Lens.html#_WildP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_WildP",
          "normalized": "Prism' Pat()",
          "package": "lens",
          "partial": "Wild",
          "signature": "Prism' Pat()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_WildP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "_WordPrimL",
          "package": "lens",
          "signature": "Prism' Lit Integer",
          "source": "src/Language-Haskell-TH-Lens.html#_WordPrimL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "_WordPrimL",
          "package": "lens",
          "partial": "Word Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:_WordPrimL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "clauseBody",
          "package": "lens",
          "signature": "Lens' Clause Body",
          "source": "src/Language-Haskell-TH-Lens.html#clauseBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "clauseBody",
          "package": "lens",
          "partial": "Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:clauseBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "clauseDecs",
          "package": "lens",
          "signature": "Lens' Clause [Dec]",
          "source": "src/Language-Haskell-TH-Lens.html#clauseDecs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "clauseDecs",
          "normalized": "Lens' Clause[Dec]",
          "package": "lens",
          "partial": "Decs",
          "signature": "Lens' Clause[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:clauseDecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "clausePattern",
          "package": "lens",
          "signature": "Lens' Clause [Pat]",
          "source": "src/Language-Haskell-TH-Lens.html#clausePattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "clausePattern",
          "normalized": "Lens' Clause[Pat]",
          "package": "lens",
          "partial": "Pattern",
          "signature": "Lens' Clause[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:clausePattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProvides a \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the types of each field of a constructor.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "conFields",
          "package": "lens",
          "signature": "Traversal' Con StrictType",
          "source": "src/Language-Haskell-TH-Lens.html#conFields",
          "type": "function"
        },
        "index": {
          "description": "Provides Traversal of the types of each field of constructor",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "conFields",
          "package": "lens",
          "partial": "Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:conFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e of the types of the \u003cem\u003enamed\u003c/em\u003e fields of a constructor.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "conNamedFields",
          "package": "lens",
          "signature": "Traversal' Con VarStrictType",
          "source": "src/Language-Haskell-TH-Lens.html#conNamedFields",
          "type": "function"
        },
        "index": {
          "description": "Traversal of the types of the named fields of constructor",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "conNamedFields",
          "package": "lens",
          "partial": "Named Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:conNamedFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldExpExpression",
          "package": "lens",
          "signature": "Lens' FieldExp Exp",
          "source": "src/Language-Haskell-TH-Lens.html#fieldExpExpression",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldExpExpression",
          "package": "lens",
          "partial": "Exp Expression",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:fieldExpExpression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldExpName",
          "package": "lens",
          "signature": "Lens' FieldExp Name",
          "source": "src/Language-Haskell-TH-Lens.html#fieldExpName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldExpName",
          "package": "lens",
          "partial": "Exp Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:fieldExpName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldPatName",
          "package": "lens",
          "signature": "Lens' FieldPat Name",
          "source": "src/Language-Haskell-TH-Lens.html#fieldPatName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldPatName",
          "package": "lens",
          "partial": "Pat Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:fieldPatName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldPatPattern",
          "package": "lens",
          "signature": "Lens' FieldPat Pat",
          "source": "src/Language-Haskell-TH-Lens.html#fieldPatPattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "fieldPatPattern",
          "package": "lens",
          "partial": "Pat Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:fieldPatPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "fixityDirection",
          "package": "lens",
          "signature": "Lens' Fixity FixityDirection",
          "source": "src/Language-Haskell-TH-Lens.html#fixityDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "fixityDirection",
          "package": "lens",
          "partial": "Direction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:fixityDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "fixityPrecedence",
          "package": "lens",
          "signature": "Lens' Fixity Int",
          "source": "src/Language-Haskell-TH-Lens.html#fixityPrecedence",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "fixityPrecedence",
          "package": "lens",
          "partial": "Precedence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:fixityPrecedence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "funDepInputs",
          "package": "lens",
          "signature": "Lens' FunDep [Name]",
          "source": "src/Language-Haskell-TH-Lens.html#funDepInputs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "funDepInputs",
          "normalized": "Lens' FunDep[Name]",
          "package": "lens",
          "partial": "Dep Inputs",
          "signature": "Lens' FunDep[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:funDepInputs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "funDepOutputs",
          "package": "lens",
          "signature": "Lens' FunDep [Name]",
          "source": "src/Language-Haskell-TH-Lens.html#funDepOutputs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "funDepOutputs",
          "normalized": "Lens' FunDep[Name]",
          "package": "lens",
          "partial": "Dep Outputs",
          "signature": "Lens' FunDep[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:funDepOutputs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "locEnd",
          "package": "lens",
          "signature": "Lens' Loc CharPos",
          "source": "src/Language-Haskell-TH-Lens.html#locEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "locEnd",
          "package": "lens",
          "partial": "End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:locEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "locFileName",
          "package": "lens",
          "signature": "Lens' Loc String",
          "source": "src/Language-Haskell-TH-Lens.html#locFileName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "locFileName",
          "package": "lens",
          "partial": "File Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:locFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "locModule",
          "package": "lens",
          "signature": "Lens' Loc String",
          "source": "src/Language-Haskell-TH-Lens.html#locModule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "locModule",
          "package": "lens",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:locModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "locPackage",
          "package": "lens",
          "signature": "Lens' Loc String",
          "source": "src/Language-Haskell-TH-Lens.html#locPackage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "locPackage",
          "package": "lens",
          "partial": "Package",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:locPackage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "locStart",
          "package": "lens",
          "signature": "Lens' Loc CharPos",
          "source": "src/Language-Haskell-TH-Lens.html#locStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "locStart",
          "package": "lens",
          "partial": "Start",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:locStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "matchBody",
          "package": "lens",
          "signature": "Lens' Match Body",
          "source": "src/Language-Haskell-TH-Lens.html#matchBody",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "matchBody",
          "package": "lens",
          "partial": "Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:matchBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "matchDeclarations",
          "package": "lens",
          "signature": "Lens' Match [Dec]",
          "source": "src/Language-Haskell-TH-Lens.html#matchDeclarations",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "matchDeclarations",
          "normalized": "Lens' Match[Dec]",
          "package": "lens",
          "partial": "Declarations",
          "signature": "Lens' Match[Dec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:matchDeclarations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.TH.Lens",
          "name": "matchPattern",
          "package": "lens",
          "signature": "Lens' Match Pat",
          "source": "src/Language-Haskell-TH-Lens.html#matchPattern",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "matchPattern",
          "package": "lens",
          "partial": "Pattern",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:matchPattern"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract (or modify) the \u003ccode\u003e\u003ca\u003eName\u003c/a\u003e\u003c/code\u003e of something\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "name",
          "package": "lens",
          "signature": "Lens' t Name",
          "source": "src/Language-Haskell-TH-Lens.html#name",
          "type": "method"
        },
        "index": {
          "description": "Extract or modify the Name of something",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "name",
          "package": "lens",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform substitution for types\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "substType",
          "package": "lens",
          "signature": "Map Name Type -\u003e t -\u003e t",
          "source": "src/Language-Haskell-TH-Lens.html#substType",
          "type": "method"
        },
        "index": {
          "description": "Perform substitution for types",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "substType",
          "normalized": "Map Name Type-\u003ea-\u003ea",
          "package": "lens",
          "partial": "Type",
          "signature": "Map Name Type-\u003et-\u003et",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:substType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSubstitute using a map of names in for \u003cem\u003efree\u003c/em\u003e type variables\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "substTypeVars",
          "package": "lens",
          "signature": "Map Name Name -\u003e t -\u003e t",
          "source": "src/Language-Haskell-TH-Lens.html#substTypeVars",
          "type": "function"
        },
        "index": {
          "description": "Substitute using map of names in for free type variables",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "substTypeVars",
          "normalized": "Map Name Name-\u003ea-\u003ea",
          "package": "lens",
          "partial": "Type Vars",
          "signature": "Map Name Name-\u003et-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:substTypeVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraverse \u003cem\u003efree\u003c/em\u003e type variables\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "typeVars",
          "package": "lens",
          "signature": "Traversal' t Name",
          "source": "src/Language-Haskell-TH-Lens.html#typeVars",
          "type": "function"
        },
        "index": {
          "description": "Traverse free type variables",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "typeVars",
          "package": "lens",
          "partial": "Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:typeVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen performing substitution into this traversal you're not allowed\n to substitute in a name that is bound internally or you'll violate\n the \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e laws, when in doubt generate your names with \u003ccode\u003e\u003ca\u003enewName\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.TH.Lens",
          "name": "typeVarsEx",
          "package": "lens",
          "signature": "Set Name -\u003e Traversal' t Name",
          "source": "src/Language-Haskell-TH-Lens.html#typeVarsEx",
          "type": "method"
        },
        "index": {
          "description": "When performing substitution into this traversal you re not allowed to substitute in name that is bound internally or you ll violate the Traversal laws when in doubt generate your names with newName",
          "hierarchy": "Language Haskell TH Lens",
          "module": "Language.Haskell.TH.Lens",
          "name": "typeVarsEx",
          "normalized": "Set Name-\u003eTraversal' a Name",
          "package": "lens",
          "partial": "Vars Ex",
          "signature": "Set Name-\u003eTraversal' t Name",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Language-Haskell-TH-Lens.html#v:typeVarsEx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/Numeric-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003eadding\u003c/a\u003e\u003c/code\u003e n = \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e (+n) (subtract n)\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e[1..3]^..traverse.adding 1000\n\u003c/code\u003e\u003c/strong\u003e[1001,1002,1003]\n\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "adding",
          "package": "lens",
          "signature": "a -\u003e Iso' a a",
          "source": "src/Numeric-Lens.html#adding",
          "type": "function"
        },
        "index": {
          "description": "adding iso subtract traverse.adding",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "adding",
          "normalized": "a-\u003eIso' a a",
          "package": "lens",
          "signature": "a-\u003eIso' a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:adding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA prism that shows and reads integers in base-2 through base-36\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"100\" ^? base 16\n\u003c/code\u003e\u003c/strong\u003eJust 256\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e1767707668033969 ^. re (base 36)\n\u003c/code\u003e\u003c/strong\u003e\"helloworld\"\n\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "base",
          "package": "lens",
          "signature": "Int -\u003e Prism' String a",
          "source": "src/Numeric-Lens.html#base",
          "type": "function"
        },
        "index": {
          "description": "prism that shows and reads integers in base-2 through base-36 base Just re base helloworld",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "base",
          "normalized": "Int-\u003ePrism' String a",
          "package": "lens",
          "signature": "Int-\u003ePrism' String a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003ebinary\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebase\u003c/a\u003e\u003c/code\u003e 2\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "binary",
          "package": "lens",
          "signature": "Prism' String a",
          "source": "src/Numeric-Lens.html#binary",
          "type": "function"
        },
        "index": {
          "description": "binary base",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "binary",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:binary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003edecimal\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebase\u003c/a\u003e\u003c/code\u003e 10\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "decimal",
          "package": "lens",
          "signature": "Prism' String a",
          "source": "src/Numeric-Lens.html#decimal",
          "type": "function"
        },
        "index": {
          "description": "decimal base",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "decimal",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:decimal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003edividing\u003c/a\u003e\u003c/code\u003e n = \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e (/n) (*n)\n \u003ccode\u003e\u003ca\u003edividing\u003c/a\u003e\u003c/code\u003e n = \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003emultiplying\u003c/a\u003e\u003c/code\u003e n)\u003c/pre\u003e\u003cp\u003eNote: This errors for n = 0\n\u003c/p\u003e",
          "module": "Numeric.Lens",
          "name": "dividing",
          "package": "lens",
          "signature": "a -\u003e Iso' a a",
          "source": "src/Numeric-Lens.html#dividing",
          "type": "function"
        },
        "index": {
          "description": "dividing iso dividing from multiplying Note This errors for",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "dividing",
          "normalized": "a-\u003eIso' a a",
          "package": "lens",
          "signature": "a-\u003eIso' a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:dividing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003eexponentiating\u003c/a\u003e\u003c/code\u003e n = \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e (**n) (**recip n)\u003c/pre\u003e\u003cp\u003eNote: This errors for n = 0\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eau (exponentiating 2._Unwrapping Sum) (foldMapOf each) (3,4)\n\u003c/code\u003e\u003c/strong\u003e5.0\n\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "exponentiating",
          "package": "lens",
          "signature": "a -\u003e Iso' a a",
          "source": "src/Numeric-Lens.html#exponentiating",
          "type": "function"
        },
        "index": {
          "description": "exponentiating iso recip Note This errors for au exponentiating Unwrapping Sum foldMapOf each",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "exponentiating",
          "normalized": "a-\u003eIso' a a",
          "package": "lens",
          "signature": "a-\u003eIso' a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:exponentiating"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003ehex\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebase\u003c/a\u003e\u003c/code\u003e 16\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "hex",
          "package": "lens",
          "signature": "Prism' String a",
          "source": "src/Numeric-Lens.html#hex",
          "type": "function"
        },
        "index": {
          "description": "hex base",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "hex",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:hex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e extracts can be used to model the fact that every \u003ccode\u003e\u003ca\u003eIntegral\u003c/a\u003e\u003c/code\u003e\n type is a subset of \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eEmbedding through the \u003ccode\u003e\u003ca\u003ePrism\u003c/a\u003e\u003c/code\u003e only succeeds if the \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e would pass\n through unmodified when re-extracted.\n\u003c/p\u003e",
          "module": "Numeric.Lens",
          "name": "integral",
          "package": "lens",
          "signature": "Prism Integer Integer a b",
          "source": "src/Numeric-Lens.html#integral",
          "type": "function"
        },
        "index": {
          "description": "This Prism extracts can be used to model the fact that every Integral type is subset of Integer Embedding through the Prism only succeeds if the Integer would pass through unmodified when re-extracted",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "integral",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003emultiplying\u003c/a\u003e\u003c/code\u003e n = iso (*n) (/n)\u003c/pre\u003e\u003cp\u003eNote: This errors for n = 0\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e5 & multiplying 1000 +~ 3\n\u003c/code\u003e\u003c/strong\u003e5.003\n\u003c/pre\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003elet fahrenheit = multiplying (9/5).adding 32 in 230^.from fahrenheit\n\u003c/code\u003e\u003c/strong\u003e110.0\n\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "multiplying",
          "package": "lens",
          "signature": "a -\u003e Iso' a a",
          "source": "src/Numeric-Lens.html#multiplying",
          "type": "function"
        },
        "index": {
          "description": "multiplying iso Note This errors for multiplying let fahrenheit multiplying adding in from fahrenheit",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "multiplying",
          "normalized": "a-\u003eIso' a a",
          "package": "lens",
          "signature": "a-\u003eIso' a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:multiplying"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\u003ccode\u003e\u003ca\u003eoctal\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003ebase\u003c/a\u003e\u003c/code\u003e 8\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "octal",
          "package": "lens",
          "signature": "Prism' String a",
          "source": "src/Numeric-Lens.html#octal",
          "type": "function"
        },
        "index": {
          "description": "octal base",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "octal",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:octal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003esubtracting\u003c/a\u003e\u003c/code\u003e n = \u003ccode\u003e\u003ca\u003eiso\u003c/a\u003e\u003c/code\u003e (subtract n) ((+n)\n \u003ccode\u003e\u003ca\u003esubtracting\u003c/a\u003e\u003c/code\u003e n = \u003ccode\u003e\u003ca\u003efrom\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eadding\u003c/a\u003e\u003c/code\u003e n)\n\u003c/pre\u003e",
          "module": "Numeric.Lens",
          "name": "subtracting",
          "package": "lens",
          "signature": "a -\u003e Iso' a a",
          "source": "src/Numeric-Lens.html#subtracting",
          "type": "function"
        },
        "index": {
          "description": "subtracting iso subtract subtracting from adding",
          "hierarchy": "Numeric Lens",
          "module": "Numeric.Lens",
          "name": "subtracting",
          "normalized": "a-\u003eIso' a a",
          "package": "lens",
          "signature": "a-\u003eIso' a a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/Numeric-Lens.html#v:subtracting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThese prisms can be used with the combinators in \u003ca\u003eControl.Exception.Lens\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "System.Exit.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/System-Exit-Lens.html",
          "type": "module"
        },
        "index": {
          "description": "These prisms can be used with the combinators in Control.Exception.Lens",
          "hierarchy": "System Exit Lens",
          "module": "System.Exit.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-Exit-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExit codes that a program can return with:\n\u003c/p\u003e",
          "module": "System.Exit.Lens",
          "name": "AsExitCode",
          "package": "lens",
          "source": "src/System-Exit-Lens.html#AsExitCode",
          "type": "class"
        },
        "index": {
          "description": "Exit codes that program can return with",
          "hierarchy": "System Exit Lens",
          "module": "System.Exit.Lens",
          "name": "AsExitCode",
          "package": "lens",
          "partial": "As Exit Code",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-Exit-Lens.html#t:AsExitCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_ExitCode\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003eEquality'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_ExitCode\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e    \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "System.Exit.Lens",
          "name": "_ExitCode",
          "package": "lens",
          "signature": "Optic' p f t ExitCode",
          "source": "src/System-Exit-Lens.html#_ExitCode",
          "type": "method"
        },
        "index": {
          "description": "ExitCode Equality ExitCode ExitCode ExitCode Prism SomeException ExitCode",
          "hierarchy": "System Exit Lens",
          "module": "System.Exit.Lens",
          "name": "_ExitCode",
          "package": "lens",
          "partial": "Exit Code",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-Exit-Lens.html#v:_ExitCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindicates program failure with an exit code. The exact interpretation of the code is operating-system dependent. In particular, some values may be prohibited (e.g. 0 on a POSIX-compliant system).\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_ExitFailure\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e      \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n \u003ccode\u003e\u003ca\u003e_ExitFailure\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n\u003c/pre\u003e",
          "module": "System.Exit.Lens",
          "name": "_ExitFailure",
          "package": "lens",
          "signature": "Optic' p f t Int",
          "source": "src/System-Exit-Lens.html#_ExitFailure",
          "type": "function"
        },
        "index": {
          "description": "indicates program failure with an exit code The exact interpretation of the code is operating-system dependent In particular some values may be prohibited e.g on POSIX-compliant system ExitFailure Prism ExitCode Int ExitFailure Prism SomeException Int",
          "hierarchy": "System Exit Lens",
          "module": "System.Exit.Lens",
          "name": "_ExitFailure",
          "package": "lens",
          "partial": "Exit Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-Exit-Lens.html#v:_ExitFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindicates successful termination;\n\u003c/p\u003e\u003cpre\u003e\n \u003ccode\u003e\u003ca\u003e_ExitSuccess\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eExitCode\u003c/a\u003e\u003c/code\u003e      ()\n \u003ccode\u003e\u003ca\u003e_ExitSuccess\u003c/a\u003e\u003c/code\u003e :: \u003ccode\u003e\u003ca\u003ePrism'\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eSomeException\u003c/a\u003e\u003c/code\u003e ()\n\u003c/pre\u003e",
          "module": "System.Exit.Lens",
          "name": "_ExitSuccess",
          "package": "lens",
          "signature": "Optic' p f t ()",
          "source": "src/System-Exit-Lens.html#_ExitSuccess",
          "type": "function"
        },
        "index": {
          "description": "indicates successful termination ExitSuccess Prism ExitCode ExitSuccess Prism SomeException",
          "hierarchy": "System Exit Lens",
          "module": "System.Exit.Lens",
          "name": "_ExitSuccess",
          "normalized": "Optic' a b c()",
          "package": "lens",
          "partial": "Exit Success",
          "signature": "Optic' p f t()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-Exit-Lens.html#v:_ExitSuccess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.FilePath.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/System-FilePath-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the path by adding another path.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth \u003c/\u003e~ \"bin\" $ (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello/bin\",\"world/bin\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c/\u003e~)",
          "package": "lens",
          "signature": "ASetter s t FilePath FilePath -\u003e FilePath -\u003e s -\u003e t",
          "source": "src/System-FilePath-Lens.html#%3C%2F%3E~",
          "type": "function"
        },
        "index": {
          "description": "Modify the path by adding another path both bin hello world hello bin world bin Setter FilePath FilePath FilePath Iso FilePath FilePath FilePath Lens FilePath FilePath FilePath Traversal FilePath FilePath FilePath",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c/\u003e~) \u003c/\u003e~",
          "normalized": "ASetter a b FilePath FilePath-\u003eFilePath-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s t FilePath FilePath-\u003eFilePath-\u003es-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--47--62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by adding a path.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (both \u003c/\u003e= \"bin\") (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello/bin\",\"world/bin\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c/\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c/\u003e=)",
          "package": "lens",
          "signature": "ASetter' s FilePath -\u003e FilePath -\u003e m ()",
          "source": "src/System-FilePath-Lens.html#%3C%2F%3E%3D",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Simple Lens Iso Setter or Traversal by adding path execState both bin hello world hello bin world bin MonadState Setter FilePath FilePath MonadState Iso FilePath FilePath MonadState Lens FilePath FilePath MonadState Traversal FilePath FilePath",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c/\u003e=) \u003c/\u003e=",
          "normalized": "ASetter' a FilePath-\u003eFilePath-\u003eb()",
          "package": "lens",
          "signature": "ASetter' s FilePath-\u003eFilePath-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--47--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a path onto the end of the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e\u003c/\u003e~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c/\u003e~)",
          "package": "lens",
          "signature": "LensLike ((,) FilePath) s a FilePath FilePath -\u003e FilePath -\u003e s -\u003e (FilePath, a)",
          "source": "src/System-FilePath-Lens.html#%3C%3C%2F%3E~",
          "type": "function"
        },
        "index": {
          "description": "Add path onto the end of the target of Lens and return the result When you do not need the result of the operation is more flexible",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c/\u003e~) \u003c\u003c/\u003e~",
          "normalized": "LensLike((,)FilePath)a b FilePath FilePath-\u003eFilePath-\u003ea-\u003e(FilePath,b)",
          "package": "lens",
          "signature": "LensLike((,)FilePath)s a FilePath FilePath-\u003eFilePath-\u003es-\u003e(FilePath,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60--47--62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a path onto the end of the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into\n your monad's state and return the result.\n\u003c/p\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e\u003c/\u003e=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c/\u003e=)",
          "package": "lens",
          "signature": "LensLike' ((,) FilePath) s FilePath -\u003e FilePath -\u003e m FilePath",
          "source": "src/System-FilePath-Lens.html#%3C%3C%2F%3E%3D",
          "type": "function"
        },
        "index": {
          "description": "Add path onto the end of the target of Lens into your monad state and return the result When you do not need the result of the operation is more flexible",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c/\u003e=) \u003c\u003c/\u003e=",
          "normalized": "LensLike'((,)FilePath)a FilePath-\u003eFilePath-\u003eb FilePath",
          "package": "lens",
          "signature": "LensLike'((,)FilePath)s FilePath-\u003eFilePath-\u003em FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60--47--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c/\u003e~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) FilePath) s FilePath -\u003e FilePath -\u003e q s (FilePath, s)",
          "source": "src/System-FilePath-Lens.html#%3C%3C%3C%2F%3E~",
          "type": "function"
        },
        "index": {
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c/\u003e~) \u003c\u003c\u003c/\u003e~",
          "normalized": "Optical'(-\u003e)a((,)FilePath)b FilePath-\u003eFilePath-\u003ea b(FilePath,b)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)FilePath)s FilePath-\u003eFilePath-\u003eq s(FilePath,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60--60--47--62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c/\u003e=)",
          "package": "lens",
          "signature": "LensLike' ((,) FilePath) s FilePath -\u003e FilePath -\u003e m FilePath",
          "source": "src/System-FilePath-Lens.html#%3C%3C%3C%2F%3E%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c/\u003e=) \u003c\u003c\u003c/\u003e=",
          "normalized": "LensLike'((,)FilePath)a FilePath-\u003eFilePath-\u003eb FilePath",
          "package": "lens",
          "signature": "LensLike'((,)FilePath)s FilePath-\u003eFilePath-\u003em FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60--60--47--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c.\u003e~)",
          "package": "lens",
          "signature": "Optical' (-\u003e) q ((,) FilePath) s FilePath -\u003e String -\u003e q s (FilePath, s)",
          "source": "src/System-FilePath-Lens.html#%3C%3C%3C.%3E~",
          "type": "function"
        },
        "index": {
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c.\u003e~) \u003c\u003c\u003c.\u003e~",
          "normalized": "Optical'(-\u003e)a((,)FilePath)b FilePath-\u003eString-\u003ea b(FilePath,b)",
          "package": "lens",
          "signature": "Optical'(-\u003e)q((,)FilePath)s FilePath-\u003eString-\u003eq s(FilePath,s)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60--60-.-62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c.\u003e=)",
          "package": "lens",
          "signature": "LensLike' ((,) FilePath) s FilePath -\u003e String -\u003e m FilePath",
          "source": "src/System-FilePath-Lens.html#%3C%3C%3C.%3E%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c\u003c.\u003e=) \u003c\u003c\u003c.\u003e=",
          "normalized": "LensLike'((,)FilePath)a FilePath-\u003eString-\u003eb FilePath",
          "package": "lens",
          "signature": "LensLike'((,)FilePath)s FilePath-\u003eString-\u003em FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60--60-.-62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an extension onto the end of the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e and return the result\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e_1 \u003c\u003c.\u003e~ \"txt\" $ (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello.txt\",(\"hello.txt\",\"world\"))\n\u003c/pre\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e\u003c.\u003e~\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c.\u003e~)",
          "package": "lens",
          "signature": "LensLike ((,) FilePath) s a FilePath FilePath -\u003e String -\u003e s -\u003e (FilePath, a)",
          "source": "src/System-FilePath-Lens.html#%3C%3C.%3E~",
          "type": "function"
        },
        "index": {
          "description": "Add an extension onto the end of the target of Lens and return the result txt hello world hello.txt hello.txt world When you do not need the result of the operation is more flexible",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c.\u003e~) \u003c\u003c.\u003e~",
          "normalized": "LensLike((,)FilePath)a b FilePath FilePath-\u003eString-\u003ea-\u003e(FilePath,b)",
          "package": "lens",
          "signature": "LensLike((,)FilePath)s a FilePath FilePath-\u003eString-\u003es-\u003e(FilePath,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60-.-62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an extension onto the end of the target of a \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e into\n your monad's state and return the result.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eevalState (_1 \u003c\u003c.\u003e= \"txt\") (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e\"hello.txt\"\n\u003c/pre\u003e\u003cp\u003eWhen you do not need the result of the operation, (\u003ccode\u003e\u003ca\u003e\u003c.\u003e=\u003c/a\u003e\u003c/code\u003e) is more flexible.\n\u003c/p\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c.\u003e=)",
          "package": "lens",
          "signature": "LensLike' ((,) FilePath) s FilePath -\u003e String -\u003e m FilePath",
          "source": "src/System-FilePath-Lens.html#%3C%3C.%3E%3D",
          "type": "function"
        },
        "index": {
          "description": "Add an extension onto the end of the target of Lens into your monad state and return the result evalState txt hello world hello.txt When you do not need the result of the operation is more flexible",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c\u003c.\u003e=) \u003c\u003c.\u003e=",
          "normalized": "LensLike'((,)FilePath)a FilePath-\u003eString-\u003eb FilePath",
          "package": "lens",
          "signature": "LensLike'((,)FilePath)s FilePath-\u003eString-\u003em FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60--60-.-62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the path by adding extension.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eboth \u003c.\u003e~ \"txt\" $ (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello.txt\",\"world.txt\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e~\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e s a \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e s -\u003e a\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c.\u003e~)",
          "package": "lens",
          "signature": "ASetter s a FilePath FilePath -\u003e String -\u003e s -\u003e a",
          "source": "src/System-FilePath-Lens.html#%3C.%3E~",
          "type": "function"
        },
        "index": {
          "description": "Modify the path by adding extension both txt hello world hello.txt world.txt Setter FilePath FilePath String Iso FilePath FilePath String Lens FilePath FilePath String Traversal FilePath FilePath String",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c.\u003e~) \u003c.\u003e~",
          "normalized": "ASetter a b FilePath FilePath-\u003eString-\u003ea-\u003eb",
          "package": "lens",
          "signature": "ASetter s a FilePath FilePath-\u003eString-\u003es-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60-.-62--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the target(s) of a \u003ccode\u003e\u003ca\u003eSimple\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eIso\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eSetter\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eTraversal\u003c/a\u003e\u003c/code\u003e by adding an extension.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eexecState (both \u003c.\u003e= \"txt\") (\"hello\",\"world\")\n\u003c/code\u003e\u003c/strong\u003e(\"hello.txt\",\"world.txt\")\n\u003c/pre\u003e\u003cpre\u003e\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eSetter'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eIso'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eLens'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n (\u003ccode\u003e\u003ca\u003e\u003c.\u003e=\u003c/a\u003e\u003c/code\u003e) :: \u003ccode\u003e\u003ca\u003eMonadState\u003c/a\u003e\u003c/code\u003e s m =\u003e \u003ccode\u003e\u003ca\u003eTraversal'\u003c/a\u003e\u003c/code\u003e s \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e -\u003e m ()\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "(\u003c.\u003e=)",
          "package": "lens",
          "signature": "ASetter' s FilePath -\u003e String -\u003e m ()",
          "source": "src/System-FilePath-Lens.html#%3C.%3E%3D",
          "type": "function"
        },
        "index": {
          "description": "Modify the target of Simple Lens Iso Setter or Traversal by adding an extension execState both txt hello world hello.txt world.txt MonadState Setter FilePath String MonadState Iso FilePath String MonadState Lens FilePath String MonadState Traversal FilePath String",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "(\u003c.\u003e=) \u003c.\u003e=",
          "normalized": "ASetter' a FilePath-\u003eString-\u003eb()",
          "package": "lens",
          "signature": "ASetter' s FilePath-\u003eString-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:-60-.-62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e for reading and writing to the basename\n\u003c/p\u003e\u003cp\u003eNote: This is \u003ccode\u003e\u003ca\u003enot\u003c/a\u003e\u003c/code\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e unless the outer \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e has both a directory\n and filename component and the generated basenames are not null and contain no directory\n separators.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003ebasename .~ \"filename\" $ \"path/name.png\"\n\u003c/code\u003e\u003c/strong\u003e\"path/filename.png\"\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "basename",
          "package": "lens",
          "signature": "Lens' FilePath FilePath",
          "source": "src/System-FilePath-Lens.html#basename",
          "type": "function"
        },
        "index": {
          "description": "Lens for reading and writing to the basename Note This is not legal Lens unless the outer FilePath has both directory and filename component and the generated basenames are not null and contain no directory separators basename filename path name.png path filename.png",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "basename",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:basename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e for reading and writing to the directory\n\u003c/p\u003e\u003cp\u003eNote: this is \u003cem\u003enot\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e unless the outer \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e already has a directory component,\n and generated directories are not null.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003e\"long/path/name.txt\" ^. directory\n\u003c/code\u003e\u003c/strong\u003e\"long/path\"\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "directory",
          "package": "lens",
          "signature": "Lens' FilePath FilePath",
          "source": "src/System-FilePath-Lens.html#directory",
          "type": "function"
        },
        "index": {
          "description": "Lens for reading and writing to the directory Note this is not legal Lens unless the outer FilePath already has directory component and generated directories are not null long path name.txt directory long path",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "directory",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:directory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e for reading and writing to the extension\n\u003c/p\u003e\u003cp\u003eNote: This is \u003cem\u003enot\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, unless you are careful to ensure that generated\n extension \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e components are either null or start with \u003ccode\u003e\u003ca\u003eextSeparator\u003c/a\u003e\u003c/code\u003e\n and do not contain any internal \u003ccode\u003e\u003ca\u003eextSeparator\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003eextension .~ \".png\" $ \"path/name.txt\"\n\u003c/code\u003e\u003c/strong\u003e\"path/name.png\"\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "extension",
          "package": "lens",
          "signature": "Lens' FilePath FilePath",
          "source": "src/System-FilePath-Lens.html#extension",
          "type": "function"
        },
        "index": {
          "description": "Lens for reading and writing to the extension Note This is not legal Lens unless you are careful to ensure that generated extension FilePath components are either null or start with extSeparator and do not contain any internal extSeparator extension png path name.txt path name.png",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "extension",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:extension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e for reading and writing to the full filename\n\u003c/p\u003e\u003cp\u003eNote: This is \u003cem\u003enot\u003c/em\u003e a legal \u003ccode\u003e\u003ca\u003eLens\u003c/a\u003e\u003c/code\u003e, unless you are careful to ensure that generated\n filename \u003ccode\u003e\u003ca\u003eFilePath\u003c/a\u003e\u003c/code\u003e components are not null and do not contain any\n elements of \u003ccode\u003e\u003ca\u003epathSeparators\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e\u003cpre class=\"screen\"\u003e\u003ccode class=\"prompt\"\u003e\u003e\u003e\u003e \u003c/code\u003e\u003cstrong class=\"userinput\"\u003e\u003ccode\u003efilename .~ \"name.txt\" $ \"path/name.png\"\n\u003c/code\u003e\u003c/strong\u003e\"path/name.txt\"\n\u003c/pre\u003e",
          "module": "System.FilePath.Lens",
          "name": "filename",
          "package": "lens",
          "signature": "Lens' FilePath FilePath",
          "source": "src/System-FilePath-Lens.html#filename",
          "type": "function"
        },
        "index": {
          "description": "Lens for reading and writing to the full filename Note This is not legal Lens unless you are careful to ensure that generated filename FilePath components are not null and do not contain any elements of pathSeparators filename name.txt path name.png path name.txt",
          "hierarchy": "System FilePath Lens",
          "module": "System.FilePath.Lens",
          "name": "filename",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-FilePath-Lens.html#v:filename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "Lens",
          "package": "lens",
          "source": "src/System-IO-Error-Lens.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "Lens",
          "package": "lens",
          "partial": "Lens",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_AlreadyExists",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_AlreadyExists",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_AlreadyExists",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Already Exists",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_AlreadyExists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_EOF",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_EOF",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_EOF",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "EOF",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_EOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_HardwareFault",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_HardwareFault",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_HardwareFault",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Hardware Fault",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_HardwareFault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_IllegalOperation",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_IllegalOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_IllegalOperation",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Illegal Operation",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_IllegalOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_InappropriateType",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_InappropriateType",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_InappropriateType",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Inappropriate Type",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_InappropriateType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_Interrupted",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_Interrupted",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_Interrupted",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Interrupted",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_Interrupted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_InvalidArgument",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_InvalidArgument",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_InvalidArgument",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Invalid Argument",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_InvalidArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_NoSuchThing",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_NoSuchThing",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_NoSuchThing",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "No Such Thing",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_NoSuchThing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_OtherError",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_OtherError",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_OtherError",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Other Error",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_OtherError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_PermissionDenied",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_PermissionDenied",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_PermissionDenied",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Permission Denied",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_PermissionDenied"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_ProtocolError",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_ProtocolError",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_ProtocolError",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Protocol Error",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_ProtocolError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_ResourceBusy",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_ResourceBusy",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_ResourceBusy",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Resource Busy",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_ResourceBusy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_ResourceExhausted",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_ResourceExhausted",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_ResourceExhausted",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Resource Exhausted",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_ResourceExhausted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_ResourceVanished",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_ResourceVanished",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_ResourceVanished",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Resource Vanished",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_ResourceVanished"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_SystemError",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_SystemError",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_SystemError",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "System Error",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_SystemError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_TimeExpired",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_TimeExpired",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_TimeExpired",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Time Expired",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_TimeExpired"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_UnsatisfiedConstraints",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_UnsatisfiedConstraints",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_UnsatisfiedConstraints",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Unsatisfied Constraints",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_UnsatisfiedConstraints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_UnsupportedOperation",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_UnsupportedOperation",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_UnsupportedOperation",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "Unsupported Operation",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_UnsupportedOperation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "System.IO.Error.Lens",
          "name": "_UserError",
          "package": "lens",
          "signature": "Prism' IOErrorType ()",
          "source": "src/System-IO-Error-Lens.html#_UserError",
          "type": "function"
        },
        "index": {
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "_UserError",
          "normalized": "Prism' IOErrorType()",
          "package": "lens",
          "partial": "User Error",
          "signature": "Prism' IOErrorType()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:_UserError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError type specific information.\n\u003c/p\u003e",
          "module": "System.IO.Error.Lens",
          "name": "description",
          "package": "lens",
          "signature": "Lens' IOException String",
          "source": "src/System-IO-Error-Lens.html#description",
          "type": "function"
        },
        "index": {
          "description": "Error type specific information",
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "description",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:description"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eerrno\u003c/a\u003e\u003c/code\u003e leading to this error, if any.\n\u003c/p\u003e",
          "module": "System.IO.Error.Lens",
          "name": "errno",
          "package": "lens",
          "signature": "Lens' IOException (Maybe CInt)",
          "source": "src/System-IO-Error-Lens.html#errno",
          "type": "function"
        },
        "index": {
          "description": "errno leading to this error if any",
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "errno",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:errno"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat type of error it is\n\u003c/p\u003e",
          "module": "System.IO.Error.Lens",
          "name": "errorType",
          "package": "lens",
          "signature": "Lens' IOException IOErrorType",
          "source": "src/System-IO-Error-Lens.html#errorType",
          "type": "function"
        },
        "index": {
          "description": "What type of error it is",
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "errorType",
          "package": "lens",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:errorType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efileName\u003c/a\u003e\u003c/code\u003e the error is related to.\n\u003c/p\u003e",
          "module": "System.IO.Error.Lens",
          "name": "fileName",
          "package": "lens",
          "signature": "Lens' IOException (Maybe FilePath)",
          "source": "src/System-IO-Error-Lens.html#fileName",
          "type": "function"
        },
        "index": {
          "description": "fileName the error is related to",
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "fileName",
          "package": "lens",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:fileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe handle used by the action flagging this error.\n\u003c/p\u003e",
          "module": "System.IO.Error.Lens",
          "name": "handle",
          "package": "lens",
          "signature": "Lens' IOException (Maybe Handle)",
          "source": "src/System-IO-Error-Lens.html#handle",
          "type": "function"
        },
        "index": {
          "description": "The handle used by the action flagging this error",
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "handle",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:handle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhere the error happened.\n\u003c/p\u003e",
          "module": "System.IO.Error.Lens",
          "name": "location",
          "package": "lens",
          "signature": "Lens' IOException String",
          "source": "src/System-IO-Error-Lens.html#location",
          "type": "function"
        },
        "index": {
          "description": "Where the error happened",
          "hierarchy": "System IO Error Lens",
          "module": "System.IO.Error.Lens",
          "name": "location",
          "package": "lens",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lens/docs/System-IO-Error-Lens.html#v:location"
      }
    }
  ]
]