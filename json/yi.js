[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "yi"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBoot process of Yi.\n Uses Dyre to implement the XMonad-style dynamic reconfiguration.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Boot",
          "name": "Boot",
          "package": "yi",
          "source": "src/Yi-Boot.html",
          "type": "module"
        },
        "index": {
          "description": "Boot process of Yi Uses Dyre to implement the XMonad-style dynamic reconfiguration",
          "hierarchy": "Yi Boot",
          "module": "Yi.Boot",
          "name": "Boot",
          "package": "yi",
          "partial": "Boot",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Boot.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003ereloads\u003c/a\u003e the configuration\n\u003c/p\u003e\u003cp\u003eSerializes the editor state and relaunches Yi using the serialized state.\n The launch of Yi will result in recompilation of the user's custom yi. This, in effect, \u003ca\u003ereloads\u003c/a\u003e\n the configuration.\n\u003c/p\u003e",
          "module": "Yi.Boot",
          "name": "reload",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Boot.html#reload",
          "type": "function"
        },
        "index": {
          "description": "reloads the configuration Serializes the editor state and relaunches Yi using the serialized state The launch of Yi will result in recompilation of the user custom yi This in effect reloads the configuration",
          "hierarchy": "Yi Boot",
          "module": "Yi.Boot",
          "name": "reload",
          "normalized": "YiM()",
          "package": "yi",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Boot.html#v:reload"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Boot",
          "name": "yi",
          "package": "yi",
          "signature": "Config -\u003e IO ()",
          "source": "src/Yi-Boot.html#yi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Boot",
          "module": "Yi.Boot",
          "name": "yi",
          "normalized": "Config-\u003eIO()",
          "package": "yi",
          "signature": "Config-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Boot.html#v:yi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed by both the yi executable and the custom yi that is built from the user's configuration.\n The yi executable uses a default config.\n\u003c/p\u003e",
          "module": "Yi.Boot",
          "name": "yiDriver",
          "package": "yi",
          "signature": "Config -\u003e IO ()",
          "source": "src/Yi-Boot.html#yiDriver",
          "type": "function"
        },
        "index": {
          "description": "Used by both the yi executable and the custom yi that is built from the user configuration The yi executable uses default config",
          "hierarchy": "Yi Boot",
          "module": "Yi.Boot",
          "name": "yiDriver",
          "normalized": "Config-\u003eIO()",
          "package": "yi",
          "partial": "Driver",
          "signature": "Config-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Boot.html#v:yiDriver"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eBasic types useful everywhere we play with buffers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "Basic",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html",
          "type": "module"
        },
        "index": {
          "description": "Basic types useful everywhere we play with buffers",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Basic",
          "package": "yi",
          "partial": "Basic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReference to a buffer.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "BufferRef",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#BufferRef",
          "type": "newtype"
        },
        "index": {
          "description": "Reference to buffer",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "BufferRef",
          "package": "yi",
          "partial": "Buffer Ref",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#t:BufferRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirection of movement inside a buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "Direction",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Direction",
          "type": "data"
        },
        "index": {
          "description": "Direction of movement inside buffer",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Direction",
          "package": "yi",
          "partial": "Direction",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#t:Direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA mark in a buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "Mark",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Mark",
          "type": "newtype"
        },
        "index": {
          "description": "mark in buffer",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Mark",
          "package": "yi",
          "partial": "Mark",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#t:Mark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA point in a buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "Point",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Point",
          "type": "newtype"
        },
        "index": {
          "description": "point in buffer",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Point",
          "package": "yi",
          "partial": "Point",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#t:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of a buffer region\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "Size",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Size",
          "type": "newtype"
        },
        "index": {
          "description": "Size of buffer region",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Size",
          "package": "yi",
          "partial": "Size",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#t:Size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWindow references\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "WindowRef",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#WindowRef",
          "type": "newtype"
        },
        "index": {
          "description": "Window references",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "WindowRef",
          "package": "yi",
          "partial": "Window Ref",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#t:WindowRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "Backward",
          "package": "yi",
          "signature": "Backward",
          "source": "src/Yi-Buffer-Basic.html#Direction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Backward",
          "package": "yi",
          "partial": "Backward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Backward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "BufferRef",
          "package": "yi",
          "signature": "BufferRef Int",
          "source": "src/Yi-Buffer-Basic.html#BufferRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "BufferRef",
          "package": "yi",
          "partial": "Buffer Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:BufferRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "Forward",
          "package": "yi",
          "signature": "Forward",
          "source": "src/Yi-Buffer-Basic.html#Direction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Forward",
          "package": "yi",
          "partial": "Forward",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Forward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "Mark",
          "package": "yi",
          "signature": "Mark",
          "source": "src/Yi-Buffer-Basic.html#Mark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Mark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Mark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Basic\",\"Yi.Syntax\"]",
          "name": "Point",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Buffer-Basic.html#Point",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Point\",\"http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:Point\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Point",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Basic\",\"Yi.Lexer.Alex\",\"Yi.Syntax\"]",
          "name": "Size",
          "package": "yi",
          "signature": "Size",
          "source": "src/Yi-Buffer-Basic.html#Size",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Size\",\"http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:Size\",\"http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:Size\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "Size",
          "package": "yi",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:Size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "WindowRef",
          "package": "yi",
          "signature": "WindowRef",
          "source": "src/Yi-Buffer-Basic.html#WindowRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "WindowRef",
          "package": "yi",
          "partial": "Window Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:WindowRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edirection\u003c/code\u003e is in the same style of \u003ccode\u003emaybe\u003c/code\u003e or \u003ccode\u003eeither\u003c/code\u003e functions,\n It takes one argument per direction (backward, then forward) and a\n direction to select the output.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "directionElim",
          "package": "yi",
          "signature": "Direction -\u003e a -\u003e a -\u003e a",
          "source": "src/Yi-Buffer-Basic.html#directionElim",
          "type": "function"
        },
        "index": {
          "description": "direction is in the same style of maybe or either functions It takes one argument per direction backward then forward and direction to select the output",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "directionElim",
          "normalized": "Direction-\u003ea-\u003ea-\u003ea",
          "package": "yi",
          "partial": "Elim",
          "signature": "Direction-\u003ea-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:directionElim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Basic\",\"Yi.Syntax\"]",
          "name": "fromPoint",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-Basic.html#Point",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:fromPoint\",\"http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:fromPoint\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "fromPoint",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:fromPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Basic\",\"Yi.Lexer.Alex\",\"Yi.Syntax\"]",
          "name": "fromSize",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-Basic.html#Size",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:fromSize\",\"http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:fromSize\",\"http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:fromSize\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "fromSize",
          "package": "yi",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:fromSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "fromString",
          "package": "yi",
          "signature": "String -\u003e Rope",
          "source": "src/Yi-Buffer-Basic.html#fromString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "fromString",
          "normalized": "String-\u003eRope",
          "package": "yi",
          "partial": "String",
          "signature": "String-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:fromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "markId",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-Basic.html#Mark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "markId",
          "package": "yi",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:markId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereverse if Backward\n\u003c/p\u003e",
          "module": "Yi.Buffer.Basic",
          "name": "mayReverse",
          "package": "yi",
          "signature": "Direction -\u003e [a] -\u003e [a]",
          "source": "src/Yi-Buffer-Basic.html#mayReverse",
          "type": "function"
        },
        "index": {
          "description": "reverse if Backward",
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "mayReverse",
          "normalized": "Direction-\u003e[a]-\u003e[a]",
          "package": "yi",
          "partial": "Reverse",
          "signature": "Direction-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:mayReverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "reverseDir",
          "package": "yi",
          "signature": "Direction -\u003e Direction",
          "source": "src/Yi-Buffer-Basic.html#reverseDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "reverseDir",
          "normalized": "Direction-\u003eDirection",
          "package": "yi",
          "partial": "Dir",
          "signature": "Direction-\u003eDirection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:reverseDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Basic",
          "name": "unWindowRef",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-Basic.html#WindowRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Basic",
          "module": "Yi.Buffer.Basic",
          "name": "unWindowRef",
          "package": "yi",
          "partial": "Window Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Basic.html#v:unWindowRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "HighLevel",
          "package": "yi",
          "source": "src/Yi-Buffer-HighLevel.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "HighLevel",
          "package": "yi",
          "partial": "High Level",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "BufferFileInfo",
          "package": "yi",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "BufferFileInfo",
          "package": "yi",
          "partial": "Buffer File Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#t:BufferFileInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "RelPosition",
          "package": "yi",
          "source": "src/Yi-Buffer-HighLevel.html#RelPosition",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "RelPosition",
          "package": "yi",
          "partial": "Rel Position",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#t:RelPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "Above",
          "package": "yi",
          "signature": "Above",
          "source": "src/Yi-Buffer-HighLevel.html#RelPosition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "Above",
          "package": "yi",
          "partial": "Above",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:Above"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "Below",
          "package": "yi",
          "signature": "Below",
          "source": "src/Yi-Buffer-HighLevel.html#RelPosition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "Below",
          "package": "yi",
          "partial": "Below",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:Below"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "BufferFileInfo",
          "package": "yi",
          "signature": "BufferFileInfo",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "BufferFileInfo",
          "package": "yi",
          "partial": "Buffer File Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:BufferFileInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "Within",
          "package": "yi",
          "signature": "Within",
          "source": "src/Yi-Buffer-HighLevel.html#RelPosition",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "Within",
          "package": "yi",
          "partial": "Within",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:Within"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if point at end of file\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "atEof",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#atEof",
          "type": "function"
        },
        "index": {
          "description": "True if point at end of file",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "atEof",
          "package": "yi",
          "partial": "Eof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:atEof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn true if the current point is the end of a line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "atEol",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#atEol",
          "type": "function"
        },
        "index": {
          "description": "Return true if the current point is the end of line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "atEol",
          "package": "yi",
          "partial": "Eol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:atEol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if point at the last line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "atLastLine",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#atLastLine",
          "type": "function"
        },
        "index": {
          "description": "True if point at the last line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "atLastLine",
          "package": "yi",
          "partial": "Last Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:atLastLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if point at start of file\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "atSof",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#atSof",
          "type": "function"
        },
        "index": {
          "description": "True if point at start of file",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "atSof",
          "package": "yi",
          "partial": "Sof",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:atSof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn true if the current point is the start of a line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "atSol",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#atSol",
          "type": "function"
        },
        "index": {
          "description": "Return true if the current point is the start of line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "atSol",
          "package": "yi",
          "partial": "Sol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:atSol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete one character backward\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "bdeleteB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#bdeleteB",
          "type": "function"
        },
        "index": {
          "description": "Delete one character backward",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bdeleteB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bdeleteB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete backward whitespace or non-whitespace depending on\n the character before point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "bkillWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#bkillWordB",
          "type": "function"
        },
        "index": {
          "description": "Delete backward whitespace or non-whitespace depending on the character before point",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bkillWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bkillWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor to end of buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "botB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#botB",
          "type": "function"
        },
        "index": {
          "description": "Move cursor to end of buffer",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "botB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:botB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFile info, size in chars, line no, col num, char num, percent\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoB",
          "package": "yi",
          "signature": "BufferM BufferFileInfo",
          "source": "src/Yi-Buffer-HighLevel.html#bufInfoB",
          "type": "function"
        },
        "index": {
          "description": "File info size in chars line no col num char num percent",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoB",
          "package": "yi",
          "partial": "Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoCharNo",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoCharNo",
          "package": "yi",
          "partial": "Info Char No",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoCharNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoColNo",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoColNo",
          "package": "yi",
          "partial": "Info Col No",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoColNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoFileName",
          "package": "yi",
          "signature": "FilePath",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoFileName",
          "package": "yi",
          "partial": "Info File Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoLineNo",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoLineNo",
          "package": "yi",
          "partial": "Info Line No",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoLineNo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoModified",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoModified",
          "package": "yi",
          "partial": "Info Modified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoModified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoPercent",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoPercent",
          "package": "yi",
          "partial": "Info Percent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoPercent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoSize",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-HighLevel.html#BufferFileInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "bufInfoSize",
          "package": "yi",
          "partial": "Info Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:bufInfoSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecapitalise the first letter of this word\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "capitaliseWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#capitaliseWordB",
          "type": "function"
        },
        "index": {
          "description": "capitalise the first letter of this word",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "capitaliseWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:capitaliseWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteBlankLinesB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#deleteBlankLinesB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteBlankLinesB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Blank Lines",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:deleteBlankLinesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete whole line moving to the next line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteLineForward",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#deleteLineForward",
          "type": "function"
        },
        "index": {
          "description": "Delete whole line moving to the next line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteLineForward",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Line Forward",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:deleteLineForward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteRegionWithStyleB",
          "package": "yi",
          "signature": "Region -\u003e RegionStyle -\u003e BufferM Point",
          "source": "src/Yi-Buffer-HighLevel.html#deleteRegionWithStyleB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteRegionWithStyleB",
          "normalized": "Region-\u003eRegionStyle-\u003eBufferM Point",
          "package": "yi",
          "partial": "Region With Style",
          "signature": "Region-\u003eRegionStyle-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:deleteRegionWithStyleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete to the end of line, excluding it.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteToEol",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#deleteToEol",
          "type": "function"
        },
        "index": {
          "description": "Delete to the end of line excluding it",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteToEol",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "To Eol",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:deleteToEol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete trailing whitespace from all lines\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteTrailingSpaceB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#deleteTrailingSpaceB",
          "type": "function"
        },
        "index": {
          "description": "Delete trailing whitespace from all lines",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "deleteTrailingSpaceB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Trailing Space",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:deleteTrailingSpaceB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to \u003ccode\u003en\u003c/code\u003e lines down from top of screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "downFromTosB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#downFromTosB",
          "type": "function"
        },
        "index": {
          "description": "Move to lines down from top of screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "downFromTosB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "From Tos",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:downFromTosB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScroll down 1 screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "downScreenB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#downScreenB",
          "type": "function"
        },
        "index": {
          "description": "Scroll down screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "downScreenB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Screen",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:downScreenB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "downScreensB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#downScreensB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "downScreensB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Screens",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:downScreensB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExchange point & mark.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "exchangePointAndMarkB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#exchangePointAndMarkB",
          "type": "function"
        },
        "index": {
          "description": "Exchange point mark",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "exchangePointAndMarkB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Point And Mark",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:exchangePointAndMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend the selection mark using the given region.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "extendSelectRegionB",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#extendSelectRegionB",
          "type": "function"
        },
        "index": {
          "description": "Extend the selection mark using the given region",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "extendSelectRegionB",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Select Region",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:extendSelectRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "fillParagraph",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#fillParagraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "fillParagraph",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Paragraph",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:fillParagraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFill the text in the region so it fits nicely 80 columns.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "fillRegion",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#fillRegion",
          "type": "function"
        },
        "index": {
          "description": "Fill the text in the region so it fits nicely columns",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "fillRegion",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:fillRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "findMatchingPairB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#findMatchingPairB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "findMatchingPairB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Matching Pair",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:findMatchingPairB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to first non-space character in this line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "firstNonSpaceB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#firstNonSpaceB",
          "type": "function"
        },
        "index": {
          "description": "Move to first non-space character in this line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "firstNonSpaceB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Non Space",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:firstNonSpaceB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "flipRectangleB",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e BufferM (Point, Point)",
          "source": "src/Yi-Buffer-HighLevel.html#flipRectangleB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "flipRectangleB",
          "normalized": "Point-\u003ePoint-\u003eBufferM(Point,Point)",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "Point-\u003ePoint-\u003eBufferM(Point,Point)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:flipRectangleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "getBookmarkB",
          "package": "yi",
          "signature": "String -\u003e BufferM Mark",
          "source": "src/Yi-Buffer-HighLevel.html#getBookmarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getBookmarkB",
          "normalized": "String-\u003eBufferM Mark",
          "package": "yi",
          "partial": "Bookmark",
          "signature": "String-\u003eBufferM Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getBookmarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current line and column number\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "getLineAndCol",
          "package": "yi",
          "signature": "BufferM (Int, Int)",
          "source": "src/Yi-Buffer-HighLevel.html#getLineAndCol",
          "type": "function"
        },
        "index": {
          "description": "Get the current line and column number",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getLineAndCol",
          "normalized": "BufferM(Int,Int)",
          "package": "yi",
          "partial": "Line And Col",
          "signature": "BufferM(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getLineAndCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "getLineAndColOfPoint",
          "package": "yi",
          "signature": "Point -\u003e BufferM (Int, Int)",
          "source": "src/Yi-Buffer-HighLevel.html#getLineAndColOfPoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getLineAndColOfPoint",
          "normalized": "Point-\u003eBufferM(Int,Int)",
          "package": "yi",
          "partial": "Line And Col Of Point",
          "signature": "Point-\u003eBufferM(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getLineAndColOfPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "getMaybeNextLineB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM (Maybe String)",
          "source": "src/Yi-Buffer-HighLevel.html#getMaybeNextLineB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getMaybeNextLineB",
          "normalized": "Direction-\u003eBufferM(Maybe String)",
          "package": "yi",
          "partial": "Maybe Next Line",
          "signature": "Direction-\u003eBufferM(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getMaybeNextLineB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "getNextLineB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#getNextLineB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getNextLineB",
          "normalized": "Direction-\u003eBufferM String",
          "package": "yi",
          "partial": "Next Line",
          "signature": "Direction-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getNextLineB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "getNextLineWhichB",
          "package": "yi",
          "signature": "Direction -\u003e (String -\u003e Bool) -\u003e BufferM (Maybe String)",
          "source": "src/Yi-Buffer-HighLevel.html#getNextLineWhichB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getNextLineWhichB",
          "normalized": "Direction-\u003e(String-\u003eBool)-\u003eBufferM(Maybe String)",
          "package": "yi",
          "partial": "Next Line Which",
          "signature": "Direction-\u003e(String-\u003eBool)-\u003eBufferM(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getNextLineWhichB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "getNextNonBlankLineB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#getNextNonBlankLineB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getNextNonBlankLineB",
          "normalized": "Direction-\u003eBufferM String",
          "package": "yi",
          "partial": "Next Non Blank Line",
          "signature": "Direction-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getNextNonBlankLineB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the empty region if the selection is not visible.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "getRawSelectRegionB",
          "package": "yi",
          "signature": "BufferM Region",
          "source": "src/Yi-Buffer-HighLevel.html#getRawSelectRegionB",
          "type": "function"
        },
        "index": {
          "description": "Return the empty region if the selection is not visible",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getRawSelectRegionB",
          "package": "yi",
          "partial": "Raw Select Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getRawSelectRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the region between point and mark\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "getRawestSelectRegionB",
          "package": "yi",
          "signature": "BufferM Region",
          "source": "src/Yi-Buffer-HighLevel.html#getRawestSelectRegionB",
          "type": "function"
        },
        "index": {
          "description": "Return the region between point and mark",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getRawestSelectRegionB",
          "package": "yi",
          "partial": "Rawest Select Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getRawestSelectRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current region boundaries. Extended to the current selection unit.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "getSelectRegionB",
          "package": "yi",
          "signature": "BufferM Region",
          "source": "src/Yi-Buffer-HighLevel.html#getSelectRegionB",
          "type": "function"
        },
        "index": {
          "description": "Get the current region boundaries Extended to the current selection unit",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getSelectRegionB",
          "package": "yi",
          "partial": "Select Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getSelectRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the current buffer selection mark\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "getSelectionMarkPointB",
          "package": "yi",
          "signature": "BufferM Point",
          "source": "src/Yi-Buffer-HighLevel.html#getSelectionMarkPointB",
          "type": "function"
        },
        "index": {
          "description": "Get the current buffer selection mark",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "getSelectionMarkPointB",
          "package": "yi",
          "partial": "Selection Mark Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:getSelectionMarkPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "goUnmatchedB",
          "package": "yi",
          "signature": "Direction -\u003e Char -\u003e Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#goUnmatchedB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "goUnmatchedB",
          "normalized": "Direction-\u003eChar-\u003eChar-\u003eBufferM()",
          "package": "yi",
          "partial": "Unmatched",
          "signature": "Direction-\u003eChar-\u003eChar-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:goUnmatchedB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "gotoCharacterB",
          "package": "yi",
          "signature": "Char -\u003e Direction -\u003e RegionStyle -\u003e Bool -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#gotoCharacterB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "gotoCharacterB",
          "normalized": "Char-\u003eDirection-\u003eRegionStyle-\u003eBool-\u003eBufferM()",
          "package": "yi",
          "partial": "Character",
          "signature": "Char-\u003eDirection-\u003eRegionStyle-\u003eBool-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:gotoCharacterB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "hasWhiteSpaceBefore",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#hasWhiteSpaceBefore",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "hasWhiteSpaceBefore",
          "package": "yi",
          "partial": "White Space Before",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:hasWhiteSpaceBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn index of Sol on line \u003ccode\u003en\u003c/code\u003e above current line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "indexOfSolAbove",
          "package": "yi",
          "signature": "Int -\u003e BufferM Point",
          "source": "src/Yi-Buffer-HighLevel.html#indexOfSolAbove",
          "type": "function"
        },
        "index": {
          "description": "return index of Sol on line above current line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "indexOfSolAbove",
          "normalized": "Int-\u003eBufferM Point",
          "package": "yi",
          "partial": "Of Sol Above",
          "signature": "Int-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:indexOfSolAbove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "insertRopeWithStyleB",
          "package": "yi",
          "signature": "Rope -\u003e RegionStyle -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#insertRopeWithStyleB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "insertRopeWithStyleB",
          "normalized": "Rope-\u003eRegionStyle-\u003eBufferM()",
          "package": "yi",
          "partial": "Rope With Style",
          "signature": "Rope-\u003eRegionStyle-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:insertRopeWithStyleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNote: Returns False if line doesn't have any characters besides a newline\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "isCurrentLineAllWhiteSpaceB",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#isCurrentLineAllWhiteSpaceB",
          "type": "function"
        },
        "index": {
          "description": "Note Returns False if line doesn have any characters besides newline",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "isCurrentLineAllWhiteSpaceB",
          "package": "yi",
          "partial": "Current Line All White Space",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:isCurrentLineAllWhiteSpaceB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if current line consists of just a newline (no whitespace)\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "isCurrentLineEmptyB",
          "package": "yi",
          "signature": "BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#isCurrentLineEmptyB",
          "type": "function"
        },
        "index": {
          "description": "True if current line consists of just newline no whitespace",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "isCurrentLineEmptyB",
          "package": "yi",
          "partial": "Current Line Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:isCurrentLineEmptyB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJustifies all the lines of the selection to be the same as\n the top line.\n NOTE: if the selection begins part way along a line, the other\n lines will be justified only with respect to the part of the indentation\n which is selected.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "justifySelectionWithTopB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#justifySelectionWithTopB",
          "type": "function"
        },
        "index": {
          "description": "Justifies all the lines of the selection to be the same as the top line NOTE if the selection begins part way along line the other lines will be justified only with respect to the part of the indentation which is selected",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "justifySelectionWithTopB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Selection With Top",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:justifySelectionWithTopB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete forward whitespace or non-whitespace depending on\n the character under point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "killWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#killWordB",
          "type": "function"
        },
        "index": {
          "description": "Delete forward whitespace or non-whitespace depending on the character under point",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "killWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:killWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the last non-space character in this line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "lastNonSpaceB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#lastNonSpaceB",
          "type": "function"
        },
        "index": {
          "description": "Move to the last non-space character in this line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "lastNonSpaceB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Non Space",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:lastNonSpaceB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "leftEdgesOfRegionB",
          "package": "yi",
          "signature": "RegionStyle -\u003e Region -\u003e BufferM [Point]",
          "source": "src/Yi-Buffer-HighLevel.html#leftEdgesOfRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "leftEdgesOfRegionB",
          "normalized": "RegionStyle-\u003eRegion-\u003eBufferM[Point]",
          "package": "yi",
          "partial": "Edges Of Region",
          "signature": "RegionStyle-\u003eRegion-\u003eBufferM[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:leftEdgesOfRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove left if on eol, but not on blank line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "leftOnEol",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#leftOnEol",
          "type": "function"
        },
        "index": {
          "description": "Move left if on eol but not on blank line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "leftOnEol",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "On Eol",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:leftOnEol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrefix each line in the selection using\n the given string.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "linePrefixSelectionB",
          "package": "yi",
          "signature": "String-\u003e BufferM ()",
          "type": "function"
        },
        "index": {
          "description": "Prefix each line in the selection using the given string",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "linePrefixSelectionB",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Prefix Selection",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:linePrefixSelectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a (lazy) stream of lines in the buffer, starting at the \u003cem\u003enext\u003c/em\u003e line\n in the given direction.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "lineStreamB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM [String]",
          "source": "src/Yi-Buffer-HighLevel.html#lineStreamB",
          "type": "function"
        },
        "index": {
          "description": "Get lazy stream of lines in the buffer starting at the next line in the given direction",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "lineStreamB",
          "normalized": "Direction-\u003eBufferM[String]",
          "package": "yi",
          "partial": "Stream",
          "signature": "Direction-\u003eBufferM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:lineStreamB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elowerise word under the cursor\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "lowercaseWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#lowercaseWordB",
          "type": "function"
        },
        "index": {
          "description": "lowerise word under the cursor",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "lowercaseWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:lowercaseWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to middle line in screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "middleB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#middleB",
          "type": "function"
        },
        "index": {
          "description": "Move to middle line in screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "middleB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:middleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "modifyExtendedSelectionB",
          "package": "yi",
          "signature": "TextUnit -\u003e (String -\u003e String) -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#modifyExtendedSelectionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "modifyExtendedSelectionB",
          "normalized": "TextUnit-\u003e(String-\u003eString)-\u003eBufferM()",
          "package": "yi",
          "partial": "Extended Selection",
          "signature": "TextUnit-\u003e(String-\u003eString)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:modifyExtendedSelectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUses a string modifying function to modify the current selection\n Currently unsets the mark such that we have no selection, arguably\n we could instead work out where the new positions should be\n and move the mark and point accordingly.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "modifySelectionB",
          "package": "yi",
          "signature": "(String -\u003e String) -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#modifySelectionB",
          "type": "function"
        },
        "index": {
          "description": "Uses string modifying function to modify the current selection Currently unsets the mark such that we have no selection arguably we could instead work out where the new positions should be and move the mark and point accordingly",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "modifySelectionB",
          "normalized": "(String-\u003eString)-\u003eBufferM()",
          "package": "yi",
          "partial": "Selection",
          "signature": "(String-\u003eString)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:modifySelectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGo to the first non space character in the line;\n if already there, then go to the beginning of the line.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveNonspaceOrSol",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#moveNonspaceOrSol",
          "type": "function"
        },
        "index": {
          "description": "Go to the first non space character in the line if already there then go to the beginning of the line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveNonspaceOrSol",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Nonspace Or Sol",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:moveNonspaceOrSol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "movePercentageFileB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#movePercentageFileB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "movePercentageFileB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Percentage File",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:movePercentageFileB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point to end of line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveToEol",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#moveToEol",
          "type": "function"
        },
        "index": {
          "description": "Move point to end of line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveToEol",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "To Eol",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:moveToEol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point to start of line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveToSol",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#moveToSol",
          "type": "function"
        },
        "index": {
          "description": "Move point to start of line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveToSol",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "To Sol",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:moveToSol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove \u003ccode\u003ex\u003c/code\u003e chars forward, or to the eol, whichever is less\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveXorEol",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#moveXorEol",
          "type": "function"
        },
        "index": {
          "description": "Move chars forward or to the eol whichever is less",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveXorEol",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Xor Eol",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:moveXorEol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove \u003ccode\u003ex\u003c/code\u003e chars back, or to the sol, whichever is less\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveXorSol",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#moveXorSol",
          "type": "function"
        },
        "index": {
          "description": "Move chars back or to the sol whichever is less",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "moveXorSol",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Xor Sol",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:moveXorSol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the character before the next occurence of \u003ccode\u003ec\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCExc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#nextCExc",
          "type": "function"
        },
        "index": {
          "description": "Move to the character before the next occurence of",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCExc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CExc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextCExc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCInLineExc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#nextCInLineExc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCInLineExc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CIn Line Exc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextCInLineExc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCInLineInc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#nextCInLineInc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCInLineInc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CIn Line Inc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextCInLineInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the next occurence of \u003ccode\u003ec\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCInc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#nextCInc",
          "type": "function"
        },
        "index": {
          "description": "Move to the next occurence of",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextCInc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CInc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextCInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove down next \u003ccode\u003en\u003c/code\u003e paragraphs\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextNParagraphs",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#nextNParagraphs",
          "type": "function"
        },
        "index": {
          "description": "Move down next paragraphs",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextNParagraphs",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "NParagraphs",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextNParagraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the next point, unless at the end of the file\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextPointB",
          "package": "yi",
          "signature": "BufferM Point",
          "source": "src/Yi-Buffer-HighLevel.html#nextPointB",
          "type": "function"
        },
        "index": {
          "description": "Get the next point unless at the end of the file",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextPointB",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to first char of next word forwards\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#nextWordB",
          "type": "function"
        },
        "index": {
          "description": "Move to first char of next word forwards",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "nextWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:nextWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "pointInWindowB",
          "package": "yi",
          "signature": "Point -\u003e BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#pointInWindowB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "pointInWindowB",
          "normalized": "Point-\u003eBufferM Bool",
          "package": "yi",
          "partial": "In Window",
          "signature": "Point-\u003eBufferM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:pointInWindowB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereturn relative position of the point \u003ccode\u003ep\u003c/code\u003e\n relative to the region defined by the points \u003ccode\u003ers\u003c/code\u003e and \u003ccode\u003ere\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "pointScreenRelPosition",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e Point -\u003e RelPosition",
          "source": "src/Yi-Buffer-HighLevel.html#pointScreenRelPosition",
          "type": "function"
        },
        "index": {
          "description": "return relative position of the point relative to the region defined by the points rs and re",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "pointScreenRelPosition",
          "normalized": "Point-\u003ePoint-\u003ePoint-\u003eRelPosition",
          "package": "yi",
          "partial": "Screen Rel Position",
          "signature": "Point-\u003ePoint-\u003ePoint-\u003eRelPosition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:pointScreenRelPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the character after the previous occurence of \u003ccode\u003ec\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCExc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#prevCExc",
          "type": "function"
        },
        "index": {
          "description": "Move to the character after the previous occurence of",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCExc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CExc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevCExc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCInLineExc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#prevCInLineExc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCInLineExc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CIn Line Exc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevCInLineExc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCInLineInc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#prevCInLineInc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCInLineInc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CIn Line Inc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevCInLineInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the previous occurence of \u003ccode\u003ec\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCInc",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#prevCInc",
          "type": "function"
        },
        "index": {
          "description": "Move to the previous occurence of",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevCInc",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "CInc",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevCInc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove up prev \u003ccode\u003en\u003c/code\u003e paragraphs\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevNParagraphs",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#prevNParagraphs",
          "type": "function"
        },
        "index": {
          "description": "Move up prev paragraphs",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevNParagraphs",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "NParagraphs",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevNParagraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the previous point, unless at the beginning of the file\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevPointB",
          "package": "yi",
          "signature": "BufferM Point",
          "source": "src/Yi-Buffer-HighLevel.html#prevPointB",
          "type": "function"
        },
        "index": {
          "description": "Get the previous point unless at the beginning of the file",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevPointB",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to first char of next word backwards\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#prevWordB",
          "type": "function"
        },
        "index": {
          "description": "Move to first char of next word backwards",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "prevWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:prevWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "readCharB",
          "package": "yi",
          "signature": "BufferM (Maybe Char)",
          "source": "src/Yi-Buffer-HighLevel.html#readCharB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readCharB",
          "package": "yi",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readCharB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "readCurrentWordB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#readCurrentWordB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readCurrentWordB",
          "package": "yi",
          "partial": "Current Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readCurrentWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the line the point is on\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "readLnB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#readLnB",
          "type": "function"
        },
        "index": {
          "description": "Read the line the point is on",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readLnB",
          "package": "yi",
          "partial": "Ln",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readLnB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "readPrevWordB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#readPrevWordB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readPrevWordB",
          "package": "yi",
          "partial": "Prev Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readPrevWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead from point to beginning of line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "readPreviousOfLnB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#readPreviousOfLnB",
          "type": "function"
        },
        "index": {
          "description": "Read from point to beginning of line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readPreviousOfLnB",
          "package": "yi",
          "partial": "Previous Of Ln",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readPreviousOfLnB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "readRegionRopeWithStyleB",
          "package": "yi",
          "signature": "Region -\u003e RegionStyle -\u003e BufferM Rope",
          "source": "src/Yi-Buffer-HighLevel.html#readRegionRopeWithStyleB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readRegionRopeWithStyleB",
          "normalized": "Region-\u003eRegionStyle-\u003eBufferM Rope",
          "package": "yi",
          "partial": "Region Rope With Style",
          "signature": "Region-\u003eRegionStyle-\u003eBufferM Rope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readRegionRopeWithStyleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead from point to end of line\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "readRestOfLnB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-HighLevel.html#readRestOfLnB",
          "type": "function"
        },
        "index": {
          "description": "Read from point to end of line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "readRestOfLnB",
          "package": "yi",
          "partial": "Rest Of Ln",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:readRestOfLnB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace the contents of the buffer with some string\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "replaceBufferContent",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#replaceBufferContent",
          "type": "function"
        },
        "index": {
          "description": "Replace the contents of the buffer with some string",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "replaceBufferContent",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Buffer Content",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:replaceBufferContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper function: revert the buffer contents to its on-disk version\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "revertB",
          "package": "yi",
          "signature": "Rope -\u003e UTCTime -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#revertB",
          "type": "function"
        },
        "index": {
          "description": "Helper function revert the buffer contents to its on-disk version",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "revertB",
          "normalized": "Rope-\u003eUTCTime-\u003eBufferM()",
          "package": "yi",
          "signature": "Rope-\u003eUTCTime-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:revertB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "rightEdgesOfRegionB",
          "package": "yi",
          "signature": "RegionStyle -\u003e Region -\u003e BufferM [Point]",
          "source": "src/Yi-Buffer-HighLevel.html#rightEdgesOfRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "rightEdgesOfRegionB",
          "normalized": "RegionStyle-\u003eRegion-\u003eBufferM[Point]",
          "package": "yi",
          "partial": "Edges Of Region",
          "signature": "RegionStyle-\u003eRegion-\u003eBufferM[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:rightEdgesOfRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScroll by n lines.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#scrollB",
          "type": "function"
        },
        "index": {
          "description": "Scroll by lines",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:scrollB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScroll according to function passed. The function takes the\n | Window height in lines, its result is passed to scrollB\n | (negative for up)\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollByB",
          "package": "yi",
          "signature": "(Int -\u003e Int) -\u003e Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#scrollByB",
          "type": "function"
        },
        "index": {
          "description": "Scroll according to function passed The function takes the Window height in lines its result is passed to scrollB negative for up",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollByB",
          "normalized": "(Int-\u003eInt)-\u003eInt-\u003eBufferM()",
          "package": "yi",
          "partial": "By",
          "signature": "(Int-\u003eInt)-\u003eInt-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:scrollByB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor to the bottom of the screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollCursorToBottomB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#scrollCursorToBottomB",
          "type": "function"
        },
        "index": {
          "description": "Move cursor to the bottom of the screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollCursorToBottomB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Cursor To Bottom",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:scrollCursorToBottomB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor to the top of the screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollCursorToTopB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#scrollCursorToTopB",
          "type": "function"
        },
        "index": {
          "description": "Move cursor to the top of the screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollCursorToTopB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Cursor To Top",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:scrollCursorToTopB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScroll by n screens (negative for up)\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollScreensB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#scrollScreensB",
          "type": "function"
        },
        "index": {
          "description": "Scroll by screens negative for up",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollScreensB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Screens",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:scrollScreensB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to middle line in screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollToCursorB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#scrollToCursorB",
          "type": "function"
        },
        "index": {
          "description": "Move to middle line in screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "scrollToCursorB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "To Cursor",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:scrollToCursorB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSelect the given region: set the selection mark at the \u003ccode\u003e\u003ca\u003eregionStart\u003c/a\u003e\u003c/code\u003e\n and the current point at the \u003ccode\u003e\u003ca\u003eregionEnd\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "setSelectRegionB",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#setSelectRegionB",
          "type": "function"
        },
        "index": {
          "description": "Select the given region set the selection mark at the regionStart and the current point at the regionEnd",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "setSelectRegionB",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Select Region",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:setSelectRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMarks\n\u003c/p\u003e\u003cp\u003eSet the current buffer selection mark\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "setSelectionMarkPointB",
          "package": "yi",
          "signature": "Point -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#setSelectionMarkPointB",
          "type": "function"
        },
        "index": {
          "description": "Marks Set the current buffer selection mark",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "setSelectionMarkPointB",
          "normalized": "Point-\u003eBufferM()",
          "package": "yi",
          "partial": "Selection Mark Point",
          "signature": "Point-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:setSelectionMarkPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "shapeOfBlockRegionB",
          "package": "yi",
          "signature": "Region -\u003e BufferM (Point, [Int])",
          "source": "src/Yi-Buffer-HighLevel.html#shapeOfBlockRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "shapeOfBlockRegionB",
          "normalized": "Region-\u003eBufferM(Point,[Int])",
          "package": "yi",
          "partial": "Of Block Region",
          "signature": "Region-\u003eBufferM(Point,[Int])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:shapeOfBlockRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "smallBufferSize",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-HighLevel.html#smallBufferSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "smallBufferSize",
          "package": "yi",
          "partial": "Buffer Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:smallBufferSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove the point to inside the viewable region\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "snapInsB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#snapInsB",
          "type": "function"
        },
        "index": {
          "description": "Move the point to inside the viewable region",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "snapInsB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Ins",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:snapInsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove the visible region to include the point\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "snapScreenB",
          "package": "yi",
          "signature": "Maybe ScrollStyle -\u003e BufferM Bool",
          "source": "src/Yi-Buffer-HighLevel.html#snapScreenB",
          "type": "function"
        },
        "index": {
          "description": "Move the visible region to include the point",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "snapScreenB",
          "normalized": "Maybe ScrollStyle-\u003eBufferM Bool",
          "package": "yi",
          "partial": "Screen",
          "signature": "Maybe ScrollStyle-\u003eBufferM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:snapScreenB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSort the lines of the region.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "sortLines",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#sortLines",
          "type": "function"
        },
        "index": {
          "description": "Sort the lines of the region",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "sortLines",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Lines",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:sortLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "splitBlockRegionToContiguousSubRegionsB",
          "package": "yi",
          "signature": "Region -\u003e BufferM [Region]",
          "source": "src/Yi-Buffer-HighLevel.html#splitBlockRegionToContiguousSubRegionsB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "splitBlockRegionToContiguousSubRegionsB",
          "normalized": "Region-\u003eBufferM[Region]",
          "package": "yi",
          "partial": "Block Region To Contiguous Sub Regions",
          "signature": "Region-\u003eBufferM[Region]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:splitBlockRegionToContiguousSubRegionsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranspose two characters, (the Emacs C-t action)\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "swapB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#swapB",
          "type": "function"
        },
        "index": {
          "description": "Transpose two characters the Emacs C-t action",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "swapB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:swapB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "switchCaseChar",
          "package": "yi",
          "signature": "Char -\u003e Char",
          "source": "src/Yi-Buffer-HighLevel.html#switchCaseChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "switchCaseChar",
          "normalized": "Char-\u003eChar",
          "package": "yi",
          "partial": "Case Char",
          "signature": "Char-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:switchCaseChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eswitch the case of the letter under the cursor\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "switchCaseCharB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#switchCaseCharB",
          "type": "function"
        },
        "index": {
          "description": "switch the case of the letter under the cursor",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "switchCaseCharB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Case Char",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:switchCaseCharB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eToggle line comments in the selection by adding or removing a prefix to each\n line.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "toggleCommentSelectionB",
          "package": "yi",
          "signature": "String -\u003e String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#toggleCommentSelectionB",
          "type": "function"
        },
        "index": {
          "description": "Toggle line comments in the selection by adding or removing prefix to each line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "toggleCommentSelectionB",
          "normalized": "String-\u003eString-\u003eBufferM()",
          "package": "yi",
          "partial": "Comment Selection",
          "signature": "String-\u003eString-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:toggleCommentSelectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor to origin\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "topB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#topB",
          "type": "function"
        },
        "index": {
          "description": "Move cursor to origin",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "topB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:topB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUncomments the selection using the given line comment\n starting string. This only works for the comments which\n begin at the start of the line.\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "unLineCommentSelectionB",
          "package": "yi",
          "signature": "String-\u003e String-\u003e BufferM ()",
          "type": "function"
        },
        "index": {
          "description": "Uncomments the selection using the given line comment starting string This only works for the comments which begin at the start of the line",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "unLineCommentSelectionB",
          "normalized": "String-\u003eString-\u003eBufferM()",
          "package": "yi",
          "partial": "Line Comment Selection",
          "signature": "String-\u003eString-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:unLineCommentSelectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to \u003ccode\u003en\u003c/code\u003e lines up from the bottom of the screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "upFromBosB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#upFromBosB",
          "type": "function"
        },
        "index": {
          "description": "Move to lines up from the bottom of the screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "upFromBosB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "From Bos",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:upFromBosB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScroll up 1 screen\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "upScreenB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#upScreenB",
          "type": "function"
        },
        "index": {
          "description": "Scroll up screen",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "upScreenB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Screen",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:upScreenB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.HighLevel",
          "name": "upScreensB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#upScreensB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "upScreensB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Screens",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:upScreensB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecapitalise the word under the cursor\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "uppercaseWordB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#uppercaseWordB",
          "type": "function"
        },
        "index": {
          "description": "capitalise the word under the cursor",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "uppercaseWordB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Word",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:uppercaseWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as scrollB, but also moves the cursor\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "vimScrollB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#vimScrollB",
          "type": "function"
        },
        "index": {
          "description": "Same as scrollB but also moves the cursor",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "vimScrollB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Scroll",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:vimScrollB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as scrollByB, but also moves the cursor\n\u003c/p\u003e",
          "module": "Yi.Buffer.HighLevel",
          "name": "vimScrollByB",
          "package": "yi",
          "signature": "(Int -\u003e Int) -\u003e Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-HighLevel.html#vimScrollByB",
          "type": "function"
        },
        "index": {
          "description": "Same as scrollByB but also moves the cursor",
          "hierarchy": "Yi Buffer HighLevel",
          "module": "Yi.Buffer.HighLevel",
          "name": "vimScrollByB",
          "normalized": "(Int-\u003eInt)-\u003eInt-\u003eBufferM()",
          "package": "yi",
          "partial": "Scroll By",
          "signature": "(Int-\u003eInt)-\u003eInt-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-HighLevel.html#v:vimScrollByB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Indent",
          "name": "Indent",
          "package": "yi",
          "source": "src/Yi-Buffer-Indent.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "Indent",
          "package": "yi",
          "partial": "Indent",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialisation of \u003ccode\u003e\u003ca\u003eautoIndentHelperB\u003c/a\u003e\u003c/code\u003e.\n  This is the most basic and the user is encouraged to\n  specialise \u003ccode\u003e\u003ca\u003eautoIndentHelperB\u003c/a\u003e\u003c/code\u003e on their own.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "autoIndentB",
          "package": "yi",
          "signature": "IndentBehaviour -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#autoIndentB",
          "type": "function"
        },
        "index": {
          "description": "specialisation of autoIndentHelperB This is the most basic and the user is encouraged to specialise autoIndentHelperB on their own",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "autoIndentB",
          "normalized": "IndentBehaviour-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent",
          "signature": "IndentBehaviour-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:autoIndentB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis takes two arguments the first is a function to\n  obtain indentation hints from lines above the current one.\n  The second is a function to obtain a set of indentation hints\n  from the previous line. Both of these are in the \u003ccode\u003e\u003ca\u003eBufferM\u003c/a\u003e\u003c/code\u003e\n  monad although the second seems like it is unnecessary.\n  However we must take into account the length of tabs which come\n  from the the tab settings and hence we must be in the \u003ccode\u003e\u003ca\u003eBufferM\u003c/a\u003e\u003c/code\u003e\n  monad.\n\u003c/p\u003e\u003cp\u003eTo get the straightforward behaviour of the indents of all previous\n  lines until one of them has zero indent call this with:\n  \u003ccode\u003eautoIndentHelperB fetchPreviousIndentsB (fmap (: []) indentOfB)\u003c/code\u003e\n  However commonly we wish to have something more interesting for\n  the second argument, in particular we commonly wish to have the\n  last opening bracket of the previous line as well as its indent.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "autoIndentHelperB",
          "package": "yi",
          "signature": "BufferM [Int]-\u003e (String -\u003e BufferM [Int])-\u003e IndentBehaviour-\u003e BufferM ()",
          "type": "function"
        },
        "index": {
          "description": "This takes two arguments the first is function to obtain indentation hints from lines above the current one The second is function to obtain set of indentation hints from the previous line Both of these are in the BufferM monad although the second seems like it is unnecessary However we must take into account the length of tabs which come from the the tab settings and hence we must be in the BufferM monad To get the straightforward behaviour of the indents of all previous lines until one of them has zero indent call this with autoIndentHelperB fetchPreviousIndentsB fmap indentOfB However commonly we wish to have something more interesting for the second argument in particular we commonly wish to have the last opening bracket of the previous line as well as its indent",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "autoIndentHelperB",
          "normalized": "BufferM[Int]-\u003e(String-\u003eBufferM[Int])-\u003eIndentBehaviour-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent Helper",
          "signature": "BufferM[Int]-\u003e(String-\u003eBufferM[Int])-\u003eIndentBehaviour-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:autoIndentHelperB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn application of \u003ccode\u003e\u003ca\u003eautoIndentHelperB\u003c/a\u003e\u003c/code\u003e which adds more\n    indentation hints using the given keywords.\n    The offsets of the first set of keywords are used as hints.\n    For the second set of keywords it is not the offsets of the\n    keywords themselves but the offset of the first non-white\n    characters after the keywords.\n\u003c/p\u003e\u003cp\u003eIn addition to the keyword hints we also do the same as the\n    default (\u003ccode\u003e\u003ca\u003eautoIndentB\u003c/a\u003e\u003c/code\u003e) which is to use any non-closed\n    opening brackets as hints.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "autoIndentWithKeywordsB",
          "package": "yi",
          "signature": "[String]-\u003e [String]-\u003e IndentBehaviour-\u003e BufferM ()",
          "type": "function"
        },
        "index": {
          "description": "An application of autoIndentHelperB which adds more indentation hints using the given keywords The offsets of the first set of keywords are used as hints For the second set of keywords it is not the offsets of the keywords themselves but the offset of the first non-white characters after the keywords In addition to the keyword hints we also do the same as the default autoIndentB which is to use any non-closed opening brackets as hints",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "autoIndentWithKeywordsB",
          "normalized": "[String]-\u003e[String]-\u003eIndentBehaviour-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent With Keywords",
          "signature": "[String]-\u003e[String]-\u003eIndentBehaviour-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:autoIndentWithKeywordsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycles through the indentation hints. It does this without\n requiring to set/get any state. We just look at the current\n indentation of the current line and moving to the largest\n indent that is \n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "cycleIndentsB",
          "package": "yi",
          "signature": "IndentBehaviour -\u003e [Int] -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#cycleIndentsB",
          "type": "function"
        },
        "index": {
          "description": "Cycles through the indentation hints It does this without requiring to set get any state We just look at the current indentation of the current line and moving to the largest indent that is",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "cycleIndentsB",
          "normalized": "IndentBehaviour-\u003e[Int]-\u003eBufferM()",
          "package": "yi",
          "partial": "Indents",
          "signature": "IndentBehaviour-\u003e[Int]-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:cycleIndentsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Indent",
          "name": "deleteIndentOfRegion",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#deleteIndentOfRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "deleteIndentOfRegion",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent Of Region",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:deleteIndentOfRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function generally useful as the first argument to\n  \u003ccode\u003e\u003ca\u003eautoIndentHelperB\u003c/a\u003e\u003c/code\u003e. This searches the lines above\n  the current line for the indentations of each line\n  until we get to a line which has no indentation\n  *and* is not empty. Indicating that we have reached\n  the outer scope.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "fetchPreviousIndentsB",
          "package": "yi",
          "signature": "BufferM [Int]",
          "source": "src/Yi-Buffer-Indent.html#fetchPreviousIndentsB",
          "type": "function"
        },
        "index": {
          "description": "function generally useful as the first argument to autoIndentHelperB This searches the lines above the current line for the indentations of each line until we get to line which has no indentation and is not empty Indicating that we have reached the outer scope",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "fetchPreviousIndentsB",
          "normalized": "BufferM[Int]",
          "package": "yi",
          "partial": "Previous Indents",
          "signature": "BufferM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:fetchPreviousIndentsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Indent",
          "name": "indentAsNeighborLineB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#indentAsNeighborLineB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentAsNeighborLineB",
          "normalized": "Direction-\u003eBufferM()",
          "package": "yi",
          "partial": "As Neighbor Line",
          "signature": "Direction-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentAsNeighborLineB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndent as much as the previous line\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentAsNextB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#indentAsNextB",
          "type": "function"
        },
        "index": {
          "description": "Indent as much as the previous line",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentAsNextB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "As Next",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentAsNextB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndent as much as the previous line\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentAsPreviousB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#indentAsPreviousB",
          "type": "function"
        },
        "index": {
          "description": "Indent as much as the previous line",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentAsPreviousB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "As Previous",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentAsPreviousB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the indentation of a given string. Note that this depends\n  on the current indentation settings.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentOfB",
          "package": "yi",
          "signature": "String -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Indent.html#indentOfB",
          "type": "function"
        },
        "index": {
          "description": "Returns the indentation of given string Note that this depends on the current indentation settings",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentOfB",
          "normalized": "String-\u003eBufferM Int",
          "package": "yi",
          "partial": "Of",
          "signature": "String-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentOfB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of spaces at the beginning of the line, up to the point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentOfCurrentPosB",
          "package": "yi",
          "signature": "BufferM Int",
          "source": "src/Yi-Buffer-Indent.html#indentOfCurrentPosB",
          "type": "function"
        },
        "index": {
          "description": "Return the number of spaces at the beginning of the line up to the point",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentOfCurrentPosB",
          "package": "yi",
          "partial": "Of Current Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentOfCurrentPosB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the current indentation settings for the buffer.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentSettingsB",
          "package": "yi",
          "signature": "BufferM IndentSettings",
          "source": "src/Yi-Buffer-Indent.html#indentSettingsB",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the current indentation settings for the buffer",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentSettingsB",
          "package": "yi",
          "partial": "Settings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentSettingsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshifts right (or left if num is negative) num times, filling in tabs if\n expandTabs is set in the buffers IndentSettings\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentString",
          "package": "yi",
          "signature": "IndentSettings -\u003e Int -\u003e String -\u003e String",
          "source": "src/Yi-Buffer-Indent.html#indentString",
          "type": "function"
        },
        "index": {
          "description": "shifts right or left if num is negative num times filling in tabs if expandTabs is set in the buffers IndentSettings",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentString",
          "normalized": "IndentSettings-\u003eInt-\u003eString-\u003eString",
          "package": "yi",
          "partial": "String",
          "signature": "IndentSettings-\u003eInt-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndents the current line to the given indentation level.\n    In addition moves the point according to where it was on the\n    line originally. If we were somewhere within the indentation\n    (ie at the start of the line or on an empty line) then we want\n    to just go to the end of the (new) indentation.\n    However if we are currently pointing somewhere within the text\n    of the line then we wish to remain pointing to the same character.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "indentToB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#indentToB",
          "type": "function"
        },
        "index": {
          "description": "Indents the current line to the given indentation level In addition moves the point according to where it was on the line originally If we were somewhere within the indentation ie at the start of the line or on an empty line then we want to just go to the end of the new indentation However if we are currently pointing somewhere within the text of the line then we wish to remain pointing to the same character",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "indentToB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "To",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:indentToB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the offsets of anything that isn't white space \u003ccode\u003eafter\u003c/code\u003e\n a keyword on the given line.\n This is essentially then the same as \u003ccode\u003e\u003ca\u003ekeywordHints\u003c/a\u003e\u003c/code\u003e except that\n for each keyword on the input rather than return the offset at\n the start of the keyword we return the offset of the first non-white\n character after the keyword.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "keywordAfterHints",
          "package": "yi",
          "signature": "[String] -\u003e String -\u003e BufferM [Int]",
          "source": "src/Yi-Buffer-Indent.html#keywordAfterHints",
          "type": "function"
        },
        "index": {
          "description": "Returns the offsets of anything that isn white space after keyword on the given line This is essentially then the same as keywordHints except that for each keyword on the input rather than return the offset at the start of the keyword we return the offset of the first non-white character after the keyword",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "keywordAfterHints",
          "normalized": "[String]-\u003eString-\u003eBufferM[Int]",
          "package": "yi",
          "partial": "After Hints",
          "signature": "[String]-\u003eString-\u003eBufferM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:keywordAfterHints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the offsets of all the given keywords\n within the given string. This is potentially useful\n as providing indentation hints.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "keywordHints",
          "package": "yi",
          "signature": "[String] -\u003e String -\u003e BufferM [Int]",
          "source": "src/Yi-Buffer-Indent.html#keywordHints",
          "type": "function"
        },
        "index": {
          "description": "Returns the offsets of all the given keywords within the given string This is potentially useful as providing indentation hints",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "keywordHints",
          "normalized": "[String]-\u003eString-\u003eBufferM[Int]",
          "package": "yi",
          "partial": "Hints",
          "signature": "[String]-\u003eString-\u003eBufferM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:keywordHints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the position of the last opening bracket on the\n line which is not closed on the same line.\n Note that if we have unmatched parentheses such as \u003ca\u003e( ]\u003c/a\u003e\n then we may not get the correct answer, but in that case\n then arguably we don't really care if we get the correct\n answer (at least if we get it wrong the user may notice\n their error).\n We return a list here as it's a convenient way of returning\n no hint in the case of there being no non-closed bracket\n and normally such a hint will be part of a list of hints\n anyway.\n NOTE: this could be easily modified to return the indentations\n of *all* the non-closed opening brackets. But I think this is\n not what you generally want.\n TODO: we also do not care whether or not the bracket is within\n a string or escaped. If someone feels up to caring about that\n by all means please fix this.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "lastOpenBracketHint",
          "package": "yi",
          "signature": "String -\u003e BufferM [Int]",
          "source": "src/Yi-Buffer-Indent.html#lastOpenBracketHint",
          "type": "function"
        },
        "index": {
          "description": "Returns the position of the last opening bracket on the line which is not closed on the same line Note that if we have unmatched parentheses such as then we may not get the correct answer but in that case then arguably we don really care if we get the correct answer at least if we get it wrong the user may notice their error We return list here as it convenient way of returning no hint in the case of there being no non-closed bracket and normally such hint will be part of list of hints anyway NOTE this could be easily modified to return the indentations of all the non-closed opening brackets But think this is not what you generally want TODO we also do not care whether or not the bracket is within string or escaped If someone feels up to caring about that by all means please fix this",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "lastOpenBracketHint",
          "normalized": "String-\u003eBufferM[Int]",
          "package": "yi",
          "partial": "Open Bracket Hint",
          "signature": "String-\u003eBufferM[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:lastOpenBracketHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert a newline at point and indent the new line as the previous one.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "newlineAndIndentB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#newlineAndIndentB",
          "type": "function"
        },
        "index": {
          "description": "Insert newline at point and indent the new line as the previous one",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "newlineAndIndentB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "And Indent",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:newlineAndIndentB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the padding of the string to newCount, filling in tabs if\n expandTabs is set in the buffers IndentSettings\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "rePadString",
          "package": "yi",
          "signature": "IndentSettings -\u003e Int -\u003e String -\u003e String",
          "source": "src/Yi-Buffer-Indent.html#rePadString",
          "type": "function"
        },
        "index": {
          "description": "Set the padding of the string to newCount filling in tabs if expandTabs is set in the buffers IndentSettings",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "rePadString",
          "normalized": "IndentSettings-\u003eInt-\u003eString-\u003eString",
          "package": "yi",
          "partial": "Pad String",
          "signature": "IndentSettings-\u003eInt-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:rePadString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncreases the indentation on the region by the given amount of shiftWidth\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "shiftIndentOfRegion",
          "package": "yi",
          "signature": "Int -\u003e Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Indent.html#shiftIndentOfRegion",
          "type": "function"
        },
        "index": {
          "description": "Increases the indentation on the region by the given amount of shiftWidth",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "shiftIndentOfRegion",
          "normalized": "Int-\u003eRegion-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent Of Region",
          "signature": "Int-\u003eRegion-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:shiftIndentOfRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the length of a given string taking into account the\n    white space and the indentation settings.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "spacingOfB",
          "package": "yi",
          "signature": "String -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Indent.html#spacingOfB",
          "type": "function"
        },
        "index": {
          "description": "Returns the length of given string taking into account the white space and the indentation settings",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "spacingOfB",
          "normalized": "String-\u003eBufferM Int",
          "package": "yi",
          "partial": "Of",
          "signature": "String-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:spacingOfB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn either a t or the number of spaces specified by tabSize in the\n  IndentSettings. Note that if you actually want to insert a tab character\n  (for example when editing makefiles) then you should use: \u003ccode\u003einsertB '\\t'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Indent",
          "name": "tabB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-Indent.html#tabB",
          "type": "function"
        },
        "index": {
          "description": "Return either or the number of spaces specified by tabSize in the IndentSettings Note that if you actually want to insert tab character for example when editing makefiles then you should use insertB",
          "hierarchy": "Yi Buffer Indent",
          "module": "Yi.Buffer.Indent",
          "name": "tabB",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Indent.html#v:tabB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003eBuffer\u003c/code\u003e module defines monadic editing operations over one-dimensional\n buffers, maintaining a current \u003cem\u003epoint\u003c/em\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "Misc",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html",
          "type": "module"
        },
        "index": {
          "description": "The Buffer module defines monadic editing operations over one-dimensional buffers maintaining current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "Misc",
          "package": "yi",
          "partial": "Misc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "AnyMode",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#AnyMode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "AnyMode",
          "package": "yi",
          "partial": "Any Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:AnyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emaybe a filename associated with this buffer. Filename is canonicalized.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "BufferId",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#BufferId",
          "type": "type"
        },
        "index": {
          "description": "maybe filename associated with this buffer Filename is canonicalized",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "BufferId",
          "package": "yi",
          "partial": "Buffer Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:BufferId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe BufferM monad writes the updates performed.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "BufferM",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#BufferM",
          "type": "newtype"
        },
        "index": {
          "description": "The BufferM monad writes the updates performed",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "BufferM",
          "package": "yi",
          "partial": "Buffer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:BufferM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "FBuffer",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#FBuffer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "FBuffer",
          "package": "yi",
          "partial": "FBuffer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:FBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to specify the behaviour of the automatic indent command.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "IndentBehaviour",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#IndentBehaviour",
          "type": "data"
        },
        "index": {
          "description": "Used to specify the behaviour of the automatic indent command",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "IndentBehaviour",
          "package": "yi",
          "partial": "Indent Behaviour",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:IndentBehaviour"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrently duplicates some of Vim's indent settings. Allowing a buffer to\n - specify settings that are more dynamic, perhaps via closures, could be\n - useful.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "IndentSettings",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#IndentSettings",
          "type": "data"
        },
        "index": {
          "description": "Currently duplicates some of Vim indent settings Allowing buffer to specify settings that are more dynamic perhaps via closures could be useful",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "IndentSettings",
          "package": "yi",
          "partial": "Indent Settings",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:IndentSettings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "MarkSet",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#MarkSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "MarkSet",
          "package": "yi",
          "partial": "Mark Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:MarkSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "MarkValue",
          "package": "yi",
          "source": "src/Yi-Buffer-Implementation.html#MarkValue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "MarkValue",
          "package": "yi",
          "partial": "Mark Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:MarkValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Mode customizes the Yi interface for editing a particular data\n   format.  It specifies when the mode should be used and\n   controls file-specific syntax highlighting and command input, among\n   other things.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "Mode",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "data"
        },
        "index": {
          "description": "Mode customizes the Yi interface for editing particular data format It specifies when the mode should be used and controls file-specific syntax highlighting and command input among other things",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "Mode",
          "package": "yi",
          "partial": "Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "Overlay",
          "package": "yi",
          "source": "src/Yi-Buffer-Implementation.html#Overlay",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "Overlay",
          "package": "yi",
          "partial": "Overlay",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:Overlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "OvlLayer",
          "package": "yi",
          "source": "src/Yi-Buffer-Implementation.html#OvlLayer",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "OvlLayer",
          "package": "yi",
          "partial": "Ovl Layer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:OvlLayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "SearchExp",
          "package": "yi",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "SearchExp",
          "package": "yi",
          "partial": "Search Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:SearchExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "WinMarks",
          "package": "yi",
          "source": "src/Yi-Buffer-Misc.html#WinMarks",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "WinMarks",
          "package": "yi",
          "partial": "Win Marks",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#t:WinMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "AnyMode",
          "package": "yi",
          "signature": "forall syntax . AnyMode (Mode syntax)",
          "source": "src/Yi-Buffer-Misc.html#AnyMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "AnyMode",
          "package": "yi",
          "partial": "Any Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:AnyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "BufferM",
          "package": "yi",
          "signature": "BufferM",
          "source": "src/Yi-Buffer-Misc.html#BufferM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "BufferM",
          "package": "yi",
          "partial": "Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:BufferM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrease the indentation to the next smaller indentation\n   hint. If we are currently at the smallest level then\n   cycle back to the largest\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "DecreaseCycle",
          "package": "yi",
          "signature": "DecreaseCycle",
          "source": "src/Yi-Buffer-Misc.html#IndentBehaviour",
          "type": "function"
        },
        "index": {
          "description": "Decrease the indentation to the next smaller indentation hint If we are currently at the smallest level then cycle back to the largest",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "DecreaseCycle",
          "package": "yi",
          "partial": "Decrease Cycle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:DecreaseCycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrease the indentation to the next smaller indentation\n   hint, if no such hint exists do nothing.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "DecreaseOnly",
          "package": "yi",
          "signature": "DecreaseOnly",
          "source": "src/Yi-Buffer-Misc.html#IndentBehaviour",
          "type": "function"
        },
        "index": {
          "description": "Decrease the indentation to the next smaller indentation hint if no such hint exists do nothing",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "DecreaseOnly",
          "package": "yi",
          "partial": "Decrease Only",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:DecreaseOnly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "FBuffer",
          "package": "yi",
          "signature": "forall syntax . FBuffer !(Mode syntax) !(BufferImpl syntax) !Attributes",
          "source": "src/Yi-Buffer-Misc.html#FBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "FBuffer",
          "package": "yi",
          "partial": "FBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:FBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "HintLayer",
          "package": "yi",
          "signature": "HintLayer",
          "source": "src/Yi-Buffer-Implementation.html#OvlLayer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "HintLayer",
          "package": "yi",
          "partial": "Hint Layer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:HintLayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrease the indentation to the next higher indentation\n   hint. If we are currently at the highest level of\n   indentation then cycle back to the lowest.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "IncreaseCycle",
          "package": "yi",
          "signature": "IncreaseCycle",
          "source": "src/Yi-Buffer-Misc.html#IndentBehaviour",
          "type": "function"
        },
        "index": {
          "description": "Increase the indentation to the next higher indentation hint If we are currently at the highest level of indentation then cycle back to the lowest",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "IncreaseCycle",
          "package": "yi",
          "partial": "Increase Cycle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:IncreaseCycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrease the indentation to the next higher hint\n   if no such hint exists do nothing.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "IncreaseOnly",
          "package": "yi",
          "signature": "IncreaseOnly",
          "source": "src/Yi-Buffer-Misc.html#IndentBehaviour",
          "type": "function"
        },
        "index": {
          "description": "Increase the indentation to the next higher hint if no such hint exists do nothing",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "IncreaseOnly",
          "package": "yi",
          "partial": "Increase Only",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:IncreaseOnly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "IndentSettings",
          "package": "yi",
          "signature": "IndentSettings",
          "source": "src/Yi-Buffer-Misc.html#IndentSettings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "IndentSettings",
          "package": "yi",
          "partial": "Indent Settings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:IndentSettings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "MarkSet",
          "package": "yi",
          "signature": "MarkSet",
          "source": "src/Yi-Buffer-Misc.html#MarkSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "MarkSet",
          "package": "yi",
          "partial": "Mark Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:MarkSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "MarkValue",
          "package": "yi",
          "signature": "MarkValue",
          "source": "src/Yi-Buffer-Implementation.html#MarkValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "MarkValue",
          "package": "yi",
          "partial": "Mark Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:MarkValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "Mode",
          "package": "yi",
          "signature": "Mode",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "Mode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "UserLayer",
          "package": "yi",
          "signature": "UserLayer",
          "source": "src/Yi-Buffer-Implementation.html#OvlLayer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "UserLayer",
          "package": "yi",
          "partial": "User Layer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:UserLayer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds an \u003ca\u003eoverlay\u003c/a\u003e to the buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "addOverlayB",
          "package": "yi",
          "signature": "Overlay -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#addOverlayB",
          "type": "function"
        },
        "index": {
          "description": "Adds an overlay to the buffer",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "addOverlayB",
          "normalized": "Overlay-\u003eBufferM()",
          "package": "yi",
          "partial": "Overlay",
          "signature": "Overlay-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:addOverlayB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "askMarks",
          "package": "yi",
          "signature": "BufferM WinMarks",
          "source": "src/Yi-Buffer-Misc.html#askMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "askMarks",
          "package": "yi",
          "partial": "Marks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:askMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "askWindow",
          "package": "yi",
          "signature": "(Window -\u003e a) -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#askWindow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "askWindow",
          "normalized": "(Window-\u003ea)-\u003eBufferM a",
          "package": "yi",
          "partial": "Window",
          "signature": "(Window-\u003ea)-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:askWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "bkey",
          "package": "yi",
          "signature": "FBuffer -\u003e BufferRef",
          "source": "src/Yi-Buffer-Misc.html#bkey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "bkey",
          "normalized": "FBuffer-\u003eBufferRef",
          "package": "yi",
          "signature": "FBuffer-\u003eBufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:bkey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccess to a value into the extensible state, keyed by its type.\n   This allows you to save or retrieve inside a \u003ccode\u003e\u003ca\u003eBufferM\u003c/a\u003e\u003c/code\u003e monad, ie:\n\u003c/p\u003e\u003cpre\u003e putA bufferDynamicValueA updatedvalue\n value \u003c- getA bufferDynamicValueA\n\u003c/pre\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "bufferDynamicValueA",
          "package": "yi",
          "signature": "Accessor FBuffer a",
          "source": "src/Yi-Buffer-Misc.html#bufferDynamicValueA",
          "type": "function"
        },
        "index": {
          "description": "Access to value into the extensible state keyed by its type This allows you to save or retrieve inside BufferM monad ie putA bufferDynamicValueA updatedvalue value getA bufferDynamicValueA",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "bufferDynamicValueA",
          "package": "yi",
          "partial": "Dynamic Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:bufferDynamicValueA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eudpate the syntax information (clear the dirty \u003ca\u003eflag\u003c/a\u003e)\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "clearSyntax",
          "package": "yi",
          "signature": "FBuffer -\u003e FBuffer",
          "source": "src/Yi-Buffer-Misc.html#clearSyntax",
          "type": "function"
        },
        "index": {
          "description": "udpate the syntax information clear the dirty flag",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "clearSyntax",
          "normalized": "FBuffer-\u003eFBuffer",
          "package": "yi",
          "partial": "Syntax",
          "signature": "FBuffer-\u003eFBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:clearSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "colOf",
          "package": "yi",
          "signature": "Point -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#colOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "colOf",
          "normalized": "Point-\u003eBufferM Int",
          "package": "yi",
          "partial": "Of",
          "signature": "Point-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:colOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "commitUpdateTransactionB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#commitUpdateTransactionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "commitUpdateTransactionB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Update Transaction",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:commitUpdateTransactionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent column.\n Note that this is different from offset or number of chars from sol.\n (This takes into account tabs, unicode chars, etc.)\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "curCol",
          "package": "yi",
          "signature": "BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#curCol",
          "type": "function"
        },
        "index": {
          "description": "Current column Note that this is different from offset or number of chars from sol This takes into account tabs unicode chars etc",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "curCol",
          "package": "yi",
          "partial": "Col",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:curCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current line number\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "curLn",
          "package": "yi",
          "signature": "BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#curLn",
          "type": "function"
        },
        "index": {
          "description": "Return the current line number",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "curLn",
          "package": "yi",
          "partial": "Ln",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:curLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove an existing \u003ca\u003eoverlay\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "delOverlayB",
          "package": "yi",
          "signature": "Overlay -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#delOverlayB",
          "type": "function"
        },
        "index": {
          "description": "Remove an existing overlay",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "delOverlayB",
          "normalized": "Overlay-\u003eBufferM()",
          "package": "yi",
          "partial": "Overlay",
          "signature": "Overlay-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:delOverlayB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "delOverlayLayerB",
          "package": "yi",
          "signature": "OvlLayer -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#delOverlayLayerB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "delOverlayLayerB",
          "normalized": "OvlLayer-\u003eBufferM()",
          "package": "yi",
          "partial": "Overlay Layer",
          "signature": "OvlLayer-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:delOverlayLayerB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "deleteMarkB",
          "package": "yi",
          "signature": "Mark -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#deleteMarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "deleteMarkB",
          "normalized": "Mark-\u003eBufferM()",
          "package": "yi",
          "partial": "Mark",
          "signature": "Mark-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:deleteMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete \u003ccode\u003en\u003c/code\u003e characters forward from the current point\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "deleteN",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#deleteN",
          "type": "function"
        },
        "index": {
          "description": "Delete characters forward from the current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "deleteN",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:deleteN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edeleteNAt n p\u003c/code\u003e deletes \u003ccode\u003en\u003c/code\u003e characters forwards from position \u003ccode\u003ep\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "deleteNAt",
          "package": "yi",
          "signature": "Direction -\u003e Int -\u003e Point -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#deleteNAt",
          "type": "function"
        },
        "index": {
          "description": "deleteNAt deletes characters forwards from position",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "deleteNAt",
          "normalized": "Direction-\u003eInt-\u003ePoint-\u003eBufferM()",
          "package": "yi",
          "partial": "NAt",
          "signature": "Direction-\u003eInt-\u003ePoint-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:deleteNAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat would be the point after doing the given action?\n The argument must not modify the buffer.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "destinationOfMoveB",
          "package": "yi",
          "signature": "BufferM a -\u003e BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#destinationOfMoveB",
          "type": "function"
        },
        "index": {
          "description": "What would be the point after doing the given action The argument must not modify the buffer",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "destinationOfMoveB",
          "normalized": "BufferM a-\u003eBufferM Point",
          "package": "yi",
          "partial": "Of Move",
          "signature": "BufferM a-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:destinationOfMoveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the contents of the buffer as a list\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "elemsB",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Buffer-Misc.html#elemsB",
          "type": "function"
        },
        "index": {
          "description": "Return the contents of the buffer as list",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "elemsB",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:elemsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "emptyMode",
          "package": "yi",
          "signature": "Mode syntax",
          "source": "src/Yi-Buffer-Misc.html#emptyMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "emptyMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:emptyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert spaces instead of tabs as possible\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "expandTabs",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Buffer-Misc.html#IndentSettings",
          "type": "function"
        },
        "index": {
          "description": "Insert spaces instead of tabs as possible",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "expandTabs",
          "package": "yi",
          "partial": "Tabs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:expandTabs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "file",
          "package": "yi",
          "signature": "FBuffer -\u003e Maybe FilePath",
          "source": "src/Yi-Buffer-Misc.html#file",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "file",
          "normalized": "FBuffer-\u003eMaybe FilePath",
          "package": "yi",
          "signature": "FBuffer-\u003eMaybe FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:file"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "focusSyntax",
          "package": "yi",
          "signature": "Map WindowRef Region -\u003e FBuffer -\u003e FBuffer",
          "source": "src/Yi-Buffer-Misc.html#focusSyntax",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "focusSyntax",
          "normalized": "Map WindowRef Region-\u003eFBuffer-\u003eFBuffer",
          "package": "yi",
          "partial": "Syntax",
          "signature": "Map WindowRef Region-\u003eFBuffer-\u003eFBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:focusSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "forgetPreferCol",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#forgetPreferCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "forgetPreferCol",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Prefer Col",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:forgetPreferCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "fromBufferM",
          "package": "yi",
          "signature": "RWS Window [Update] FBuffer a",
          "source": "src/Yi-Buffer-Misc.html#BufferM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "fromBufferM",
          "normalized": "RWS Window[Update]FBuffer a",
          "package": "yi",
          "partial": "Buffer",
          "signature": "RWS Window[Update]FBuffer a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:fromBufferM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "fromMark",
          "package": "yi",
          "signature": "a",
          "source": "src/Yi-Buffer-Misc.html#MarkSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "fromMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:fromMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "getMarkB",
          "package": "yi",
          "signature": "Maybe String -\u003e BufferM Mark",
          "source": "src/Yi-Buffer-Misc.html#getMarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getMarkB",
          "normalized": "Maybe String-\u003eBufferM Mark",
          "package": "yi",
          "partial": "Mark",
          "signature": "Maybe String-\u003eBufferM Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "getMarkPointB",
          "package": "yi",
          "signature": "Mark -\u003e BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#getMarkPointB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getMarkPointB",
          "normalized": "Mark-\u003eBufferM Point",
          "package": "yi",
          "partial": "Mark Point",
          "signature": "Mark-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getMarkPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "getMarkValueB",
          "package": "yi",
          "signature": "Mark -\u003e BufferM MarkValue",
          "source": "src/Yi-Buffer-Misc.html#getMarkValueB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getMarkValueB",
          "normalized": "Mark-\u003eBufferM MarkValue",
          "package": "yi",
          "partial": "Mark Value",
          "signature": "Mark-\u003eBufferM MarkValue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getMarkValueB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "getMarks",
          "package": "yi",
          "signature": "Window -\u003e BufferM (Maybe WinMarks)",
          "source": "src/Yi-Buffer-Misc.html#getMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getMarks",
          "normalized": "Window-\u003eBufferM(Maybe WinMarks)",
          "package": "yi",
          "partial": "Marks",
          "signature": "Window-\u003eBufferM(Maybe WinMarks)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a buffer, and some information update the modeline\n\u003c/p\u003e\u003cp\u003eN.B. the contents of modelines should be specified by user, and\n not hardcoded.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "getModeLine",
          "package": "yi",
          "signature": "[String] -\u003e BufferM String",
          "source": "src/Yi-Buffer-Misc.html#getModeLine",
          "type": "function"
        },
        "index": {
          "description": "Given buffer and some information update the modeline N.B the contents of modelines should be specified by user and not hardcoded",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getModeLine",
          "normalized": "[String]-\u003eBufferM String",
          "package": "yi",
          "partial": "Mode Line",
          "signature": "[String]-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getModeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a point, and the file size, gives us a percent string\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "getPercent",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e String",
          "source": "src/Yi-Buffer-Misc.html#getPercent",
          "type": "function"
        },
        "index": {
          "description": "Given point and the file size gives us percent string",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getPercent",
          "normalized": "Point-\u003ePoint-\u003eString",
          "package": "yi",
          "partial": "Percent",
          "signature": "Point-\u003ePoint-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getPercent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "getPrefCol",
          "package": "yi",
          "signature": "BufferM (Maybe Int)",
          "source": "src/Yi-Buffer-Misc.html#getPrefCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "getPrefCol",
          "package": "yi",
          "partial": "Pref Col",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:getPrefCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGo to line number \u003ccode\u003en\u003c/code\u003e. \u003ccode\u003en\u003c/code\u003e is indexed from 1. Returns the\n actual line we went to (which may be not be the requested line,\n if it was out of range)\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "gotoLn",
          "package": "yi",
          "signature": "Int -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#gotoLn",
          "type": "function"
        },
        "index": {
          "description": "Go to line number is indexed from Returns the actual line we went to which may be not be the requested line if it was out of range",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "gotoLn",
          "normalized": "Int-\u003eBufferM Int",
          "package": "yi",
          "partial": "Ln",
          "signature": "Int-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:gotoLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGo to line indexed from current point\n Returns the actual moved difference which of course\n may be negative if the requested difference was negative.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "gotoLnFrom",
          "package": "yi",
          "signature": "Int -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#gotoLnFrom",
          "type": "function"
        },
        "index": {
          "description": "Go to line indexed from current point Returns the actual moved difference which of course may be negative if the requested difference was negative",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "gotoLnFrom",
          "normalized": "Int-\u003eBufferM Int",
          "package": "yi",
          "partial": "Ln From",
          "signature": "Int-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:gotoLnFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "highlightSelectionA",
          "package": "yi",
          "signature": "Accessor FBuffer Bool",
          "source": "src/Yi-Buffer-Misc.html#highlightSelectionA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "highlightSelectionA",
          "package": "yi",
          "partial": "Selection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:highlightSelectionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "identA",
          "package": "yi",
          "signature": "Accessor FBuffer BufferId",
          "source": "src/Yi-Buffer-Misc.html#identA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "identA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:identA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "identString",
          "package": "yi",
          "signature": "FBuffer -\u003e [Char]",
          "source": "src/Yi-Buffer-Misc.html#identString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "identString",
          "normalized": "FBuffer-\u003e[Char]",
          "package": "yi",
          "partial": "String",
          "signature": "FBuffer-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:identString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "indexedStreamB",
          "package": "yi",
          "signature": "Direction -\u003e Point -\u003e BufferM [(Point, Char)]",
          "source": "src/Yi-Buffer-Misc.html#indexedStreamB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "indexedStreamB",
          "normalized": "Direction-\u003ePoint-\u003eBufferM[(Point,Char)]",
          "package": "yi",
          "partial": "Stream",
          "signature": "Direction-\u003ePoint-\u003eBufferM[(Point,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:indexedStreamB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "insMark",
          "package": "yi",
          "signature": "a",
          "source": "src/Yi-Buffer-Misc.html#MarkSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert the char at current point, extending size of buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "insertB",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertB",
          "type": "function"
        },
        "index": {
          "description": "Insert the char at current point extending size of buffer",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertB",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "insertCharWithAboveB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertCharWithAboveB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertCharWithAboveB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Char With Above",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertCharWithAboveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "insertCharWithBelowB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertCharWithBelowB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertCharWithBelowB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Char With Below",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertCharWithBelowB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert the list at current point, extending size of buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "insertN",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertN",
          "type": "function"
        },
        "index": {
          "description": "Insert the list at current point extending size of buffer",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertN",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "insertN'",
          "package": "yi",
          "signature": "Rope -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertN%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertN'",
          "normalized": "Rope-\u003eBufferM()",
          "package": "yi",
          "partial": "N'",
          "signature": "Rope-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertN-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert the list at specified point, extending size of buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "insertNAt",
          "package": "yi",
          "signature": "String -\u003e Point -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertNAt",
          "type": "function"
        },
        "index": {
          "description": "Insert the list at specified point extending size of buffer",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertNAt",
          "normalized": "String-\u003ePoint-\u003eBufferM()",
          "package": "yi",
          "partial": "NAt",
          "signature": "String-\u003ePoint-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertNAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "insertNAt'",
          "package": "yi",
          "signature": "Rope -\u003e Point -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#insertNAt%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertNAt'",
          "normalized": "Rope-\u003ePoint-\u003eBufferM()",
          "package": "yi",
          "partial": "NAt'",
          "signature": "Rope-\u003ePoint-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertNAt-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "insertingA",
          "package": "yi",
          "signature": "Accessor FBuffer Bool",
          "source": "src/Yi-Buffer-Misc.html#insertingA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "insertingA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:insertingA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "isUnchangedBuffer",
          "package": "yi",
          "signature": "FBuffer -\u003e Bool",
          "source": "src/Yi-Buffer-Misc.html#isUnchangedBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "isUnchangedBuffer",
          "normalized": "FBuffer-\u003eBool",
          "package": "yi",
          "partial": "Unchanged Buffer",
          "signature": "FBuffer-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:isUnchangedBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "keymapProcessA",
          "package": "yi",
          "signature": "Accessor FBuffer KeymapProcess",
          "source": "src/Yi-Buffer-Misc.html#keymapProcessA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "keymapProcessA",
          "package": "yi",
          "partial": "Process",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:keymapProcessA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse in readonly!\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "lastActiveWindowA",
          "package": "yi",
          "signature": "Accessor FBuffer Window",
          "source": "src/Yi-Buffer-Misc.html#lastActiveWindowA",
          "type": "function"
        },
        "index": {
          "description": "Use in readonly",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lastActiveWindowA",
          "package": "yi",
          "partial": "Active Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lastActiveWindowA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "lastSyncTimeA",
          "package": "yi",
          "signature": "Accessor FBuffer UTCTime",
          "source": "src/Yi-Buffer-Misc.html#lastSyncTimeA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lastSyncTimeA",
          "package": "yi",
          "partial": "Sync Time",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lastSyncTimeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point -1\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "leftB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#leftB",
          "type": "function"
        },
        "index": {
          "description": "Move point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "leftB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:leftB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor -n\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "leftN",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#leftN",
          "type": "function"
        },
        "index": {
          "description": "Move cursor",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "leftN",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:leftN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "lineCountB",
          "package": "yi",
          "signature": "BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#lineCountB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lineCountB",
          "package": "yi",
          "partial": "Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lineCountB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point down one line\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "lineDown",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#lineDown",
          "type": "function"
        },
        "index": {
          "description": "Move point down one line",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lineDown",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Down",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lineDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point down by \u003ccode\u003en\u003c/code\u003e lines. \u003ccode\u003en\u003c/code\u003e can be negative.\n Returns the actual difference in lines which we moved which\n may be negative if the requested line difference is negative.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "lineMoveRel",
          "package": "yi",
          "signature": "Int -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#lineMoveRel",
          "type": "function"
        },
        "index": {
          "description": "Move point down by lines can be negative Returns the actual difference in lines which we moved which may be negative if the requested line difference is negative",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lineMoveRel",
          "normalized": "Int-\u003eBufferM Int",
          "package": "yi",
          "partial": "Move Rel",
          "signature": "Int-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lineMoveRel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "lineOf",
          "package": "yi",
          "signature": "Point -\u003e BufferM Int",
          "source": "src/Yi-Buffer-Misc.html#lineOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lineOf",
          "normalized": "Point-\u003eBufferM Int",
          "package": "yi",
          "partial": "Of",
          "signature": "Point-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lineOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point up one line\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "lineUp",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#lineUp",
          "type": "function"
        },
        "index": {
          "description": "Move point up one line",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "lineUp",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Up",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:lineUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "markGravity",
          "package": "yi",
          "signature": "Direction",
          "source": "src/Yi-Buffer-Implementation.html#MarkValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "markGravity",
          "package": "yi",
          "partial": "Gravity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:markGravity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn line numbers of marks\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "markLines",
          "package": "yi",
          "signature": "BufferM (MarkSet Int)",
          "source": "src/Yi-Buffer-Misc.html#markLines",
          "type": "function"
        },
        "index": {
          "description": "Return line numbers of marks",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "markLines",
          "package": "yi",
          "partial": "Lines",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:markLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "markPoint",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Buffer-Implementation.html#MarkValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "markPoint",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:markPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMark the current point in the undo list as a saved state.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "markSavedB",
          "package": "yi",
          "signature": "UTCTime -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#markSavedB",
          "type": "function"
        },
        "index": {
          "description": "Mark the current point in the undo list as saved state",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "markSavedB",
          "normalized": "UTCTime-\u003eBufferM()",
          "package": "yi",
          "partial": "Saved",
          "signature": "UTCTime-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:markSavedB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "mayGetMarkB",
          "package": "yi",
          "signature": "String -\u003e BufferM (Maybe Mark)",
          "source": "src/Yi-Buffer-Misc.html#mayGetMarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "mayGetMarkB",
          "normalized": "String-\u003eBufferM(Maybe Mark)",
          "package": "yi",
          "partial": "Get Mark",
          "signature": "String-\u003eBufferM(Maybe Mark)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:mayGetMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "miniIdentString",
          "package": "yi",
          "signature": "FBuffer -\u003e [Char]",
          "source": "src/Yi-Buffer-Misc.html#miniIdentString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "miniIdentString",
          "normalized": "FBuffer-\u003e[Char]",
          "package": "yi",
          "partial": "Ident String",
          "signature": "FBuffer-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:miniIdentString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an \u003ca\u003eoverlay\u003c/a\u003e for the style \u003ccode\u003esty\u003c/code\u003e between points \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003ee\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "mkOverlay",
          "package": "yi",
          "signature": "OvlLayer -\u003e Region -\u003e StyleName -\u003e Overlay",
          "source": "src/Yi-Buffer-Implementation.html#mkOverlay",
          "type": "function"
        },
        "index": {
          "description": "Create an overlay for the style sty between points and",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "mkOverlay",
          "normalized": "OvlLayer-\u003eRegion-\u003eStyleName-\u003eOverlay",
          "package": "yi",
          "partial": "Overlay",
          "signature": "OvlLayer-\u003eRegion-\u003eStyleName-\u003eOverlay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:mkOverlay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadjust the indentation after modification\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeAdjustBlock",
          "package": "yi",
          "signature": "syntax -\u003e Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "adjust the indentation after modification",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeAdjustBlock",
          "normalized": "a-\u003eInt-\u003eBufferM()",
          "package": "yi",
          "partial": "Adjust Block",
          "signature": "syntax-\u003eInt-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeAdjustBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeAdjustBlockA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e Int -\u003e BufferM ())",
          "source": "src/Yi-Buffer-Misc.html#modeAdjustBlockA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeAdjustBlockA",
          "normalized": "a b T(Mode c)(c-\u003eInt-\u003eBufferM())",
          "package": "yi",
          "partial": "Adjust Block",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003eInt-\u003eBufferM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeAdjustBlockA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMode applies function that always returns True.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeAlwaysApplies",
          "package": "yi",
          "signature": "FilePath -\u003e String -\u003e Bool",
          "source": "src/Yi-Buffer-Misc.html#modeAlwaysApplies",
          "type": "function"
        },
        "index": {
          "description": "Mode applies function that always returns True",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeAlwaysApplies",
          "normalized": "FilePath-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Always Applies",
          "signature": "FilePath-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeAlwaysApplies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhat type of files does this mode apply to?\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeApplies",
          "package": "yi",
          "signature": "FilePath -\u003e String -\u003e Bool",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "What type of files does this mode apply to",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeApplies",
          "normalized": "FilePath-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Applies",
          "signature": "FilePath-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeApplies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeAppliesA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (FilePath -\u003e String -\u003e Bool)",
          "source": "src/Yi-Buffer-Misc.html#modeAppliesA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeAppliesA",
          "normalized": "a b T(Mode c)(FilePath-\u003eString-\u003eBool)",
          "package": "yi",
          "partial": "Applies",
          "signature": "forall syntax. T(Mode syntax)(FilePath-\u003eString-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeAppliesA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFollow a \"link\" in the file. (eg. go to location of error message)\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeFollow",
          "package": "yi",
          "signature": "syntax -\u003e Action",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "Follow link in the file eg go to location of error message",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeFollow",
          "normalized": "a-\u003eAction",
          "package": "yi",
          "partial": "Follow",
          "signature": "syntax-\u003eAction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeFollow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeFollowA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e Action)",
          "source": "src/Yi-Buffer-Misc.html#modeFollowA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeFollowA",
          "normalized": "a b T(Mode c)(c-\u003eAction)",
          "package": "yi",
          "partial": "Follow",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003eAction)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeFollowA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeGetAnnotations",
          "package": "yi",
          "signature": "syntax -\u003e Point -\u003e [Span String]",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeGetAnnotations",
          "normalized": "a-\u003ePoint-\u003e[Span String]",
          "package": "yi",
          "partial": "Get Annotations",
          "signature": "syntax-\u003ePoint-\u003e[Span String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeGetAnnotations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeGetAnnotationsA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e Point -\u003e [Span String])",
          "source": "src/Yi-Buffer-Misc.html#modeGetAnnotationsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeGetAnnotationsA",
          "normalized": "a b T(Mode c)(c-\u003ePoint-\u003e[Span String])",
          "package": "yi",
          "partial": "Get Annotations",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003ePoint-\u003e[Span String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeGetAnnotationsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrokes that should be applied when displaying a syntax element\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeGetStrokes",
          "package": "yi",
          "signature": "syntax -\u003e Point -\u003e Point -\u003e Point -\u003e [Stroke]",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "Strokes that should be applied when displaying syntax element",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeGetStrokes",
          "normalized": "a-\u003ePoint-\u003ePoint-\u003ePoint-\u003e[Stroke]",
          "package": "yi",
          "partial": "Get Strokes",
          "signature": "syntax-\u003ePoint-\u003ePoint-\u003ePoint-\u003e[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeGetStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeGetStrokesA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e Point -\u003e Point -\u003e Point -\u003e [Stroke])",
          "source": "src/Yi-Buffer-Misc.html#modeGetStrokesA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeGetStrokesA",
          "normalized": "a b T(Mode c)(c-\u003ePoint-\u003ePoint-\u003ePoint-\u003e[Stroke])",
          "package": "yi",
          "partial": "Get Strokes",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003ePoint-\u003ePoint-\u003ePoint-\u003e[Stroke])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeGetStrokesA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSyntax highlighter\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeHL",
          "package": "yi",
          "signature": "ExtHL syntax",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "Syntax highlighter",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeHL",
          "package": "yi",
          "partial": "HL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeHL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeHLA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (ExtHL syntax)",
          "source": "src/Yi-Buffer-Misc.html#modeHLA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeHLA",
          "package": "yi",
          "partial": "HLA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeHLA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eemacs-style auto-indent line\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeIndent",
          "package": "yi",
          "signature": "syntax -\u003e IndentBehaviour -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "emacs-style auto-indent line",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeIndent",
          "normalized": "a-\u003eIndentBehaviour-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent",
          "signature": "syntax-\u003eIndentBehaviour-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeIndentA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e IndentBehaviour -\u003e BufferM ())",
          "source": "src/Yi-Buffer-Misc.html#modeIndentA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeIndentA",
          "normalized": "a b T(Mode c)(c-\u003eIndentBehaviour-\u003eBufferM())",
          "package": "yi",
          "partial": "Indent",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003eIndentBehaviour-\u003eBufferM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeIndentA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeIndentSettings",
          "package": "yi",
          "signature": "IndentSettings",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeIndentSettings",
          "package": "yi",
          "partial": "Indent Settings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeIndentSettings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeIndentSettingsA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) IndentSettings",
          "source": "src/Yi-Buffer-Misc.html#modeIndentSettingsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeIndentSettingsA",
          "package": "yi",
          "partial": "Indent Settings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeIndentSettingsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuffer-local keymap modification\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeKeymap",
          "package": "yi",
          "signature": "KeymapSet -\u003e KeymapSet",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "Buffer-local keymap modification",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeKeymap",
          "normalized": "KeymapSet-\u003eKeymapSet",
          "package": "yi",
          "partial": "Keymap",
          "signature": "KeymapSet-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeKeymapA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (KeymapSet -\u003e KeymapSet)",
          "source": "src/Yi-Buffer-Misc.html#modeKeymapA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeKeymapA",
          "normalized": "a b T(Mode c)(KeymapSet-\u003eKeymapSet)",
          "package": "yi",
          "partial": "Keymap",
          "signature": "forall syntax. T(Mode syntax)(KeymapSet-\u003eKeymapSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeKeymapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuffer-local modeline formatting method\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeModeLine",
          "package": "yi",
          "signature": "[String] -\u003e BufferM String",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "buffer-local modeline formatting method",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeModeLine",
          "normalized": "[String]-\u003eBufferM String",
          "package": "yi",
          "partial": "Mode Line",
          "signature": "[String]-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeModeLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeModeLineA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) ([String] -\u003e BufferM String)",
          "source": "src/Yi-Buffer-Misc.html#modeModeLineA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeModeLineA",
          "normalized": "a b T(Mode c)([String]-\u003eBufferM String)",
          "package": "yi",
          "partial": "Mode Line",
          "signature": "forall syntax. T(Mode syntax)([String]-\u003eBufferM String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeModeLineA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eso this can be serialized, debugged.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeName",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "so this can be serialized debugged",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeName",
          "package": "yi",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeNameA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) String",
          "source": "src/Yi-Buffer-Misc.html#modeNameA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeNameA",
          "package": "yi",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeNameA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMode applies function that always returns False.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeNeverApplies",
          "package": "yi",
          "signature": "FilePath -\u003e String -\u003e Bool",
          "source": "src/Yi-Buffer-Misc.html#modeNeverApplies",
          "type": "function"
        },
        "index": {
          "description": "Mode applies function that always returns False",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeNeverApplies",
          "normalized": "FilePath-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Never Applies",
          "signature": "FilePath-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeNeverApplies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn action that is to be executed when this mode is set\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modeOnLoad",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "An action that is to be executed when this mode is set",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeOnLoad",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "On Load",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeOnLoad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeOnLoadA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (BufferM ())",
          "source": "src/Yi-Buffer-Misc.html#modeOnLoadA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeOnLoadA",
          "normalized": "a b T(Mode c)(BufferM())",
          "package": "yi",
          "partial": "On Load",
          "signature": "forall syntax. T(Mode syntax)(BufferM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeOnLoadA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrettify current \"paragraph\"\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modePrettify",
          "package": "yi",
          "signature": "syntax -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "description": "Prettify current paragraph",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modePrettify",
          "normalized": "a-\u003eBufferM()",
          "package": "yi",
          "partial": "Prettify",
          "signature": "syntax-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modePrettify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modePrettifyA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e BufferM ())",
          "source": "src/Yi-Buffer-Misc.html#modePrettifyA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modePrettifyA",
          "normalized": "a b T(Mode c)(c-\u003eBufferM())",
          "package": "yi",
          "partial": "Prettify",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003eBufferM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modePrettifyA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modePrintTree",
          "package": "yi",
          "signature": "syntax -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modePrintTree",
          "normalized": "a-\u003eBufferM()",
          "package": "yi",
          "partial": "Print Tree",
          "signature": "syntax-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modePrintTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modePrintTreeA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (syntax -\u003e BufferM ())",
          "source": "src/Yi-Buffer-Misc.html#modePrintTreeA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modePrintTreeA",
          "normalized": "a b T(Mode c)(c-\u003eBufferM())",
          "package": "yi",
          "partial": "Print Tree",
          "signature": "forall syntax. T(Mode syntax)(syntax-\u003eBufferM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modePrintTreeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeToggleCommentSelection",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#Mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeToggleCommentSelection",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Toggle Comment Selection",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeToggleCommentSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modeToggleCommentSelectionA",
          "package": "yi",
          "signature": "forall syntax.  T (Mode syntax) (BufferM ())",
          "source": "src/Yi-Buffer-Misc.html#modeToggleCommentSelectionA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modeToggleCommentSelectionA",
          "normalized": "a b T(Mode c)(BufferM())",
          "package": "yi",
          "partial": "Toggle Comment Selection",
          "signature": "forall syntax. T(Mode syntax)(BufferM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modeToggleCommentSelectionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "modifyMarkB",
          "package": "yi",
          "signature": "Mark -\u003e (MarkValue -\u003e MarkValue) -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#modifyMarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modifyMarkB",
          "normalized": "Mark-\u003e(MarkValue-\u003eMarkValue)-\u003eBufferM()",
          "package": "yi",
          "partial": "Mark",
          "signature": "Mark-\u003e(MarkValue-\u003eMarkValue)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modifyMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify the mode\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "modifyMode",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e Mode syntax) -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#modifyMode",
          "type": "function"
        },
        "index": {
          "description": "Modify the mode",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "modifyMode",
          "normalized": "(a b Mode c-\u003eMode c)-\u003eBufferM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "(forall syntax. Mode syntax-\u003eMode syntax)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:modifyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point by the given number of characters.\n A negative offset moves backwards a positive one forward.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "moveN",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#moveN",
          "type": "function"
        },
        "index": {
          "description": "Move point by the given number of characters negative offset moves backwards positive one forward",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "moveN",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:moveN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove point in buffer to the given index\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "moveTo",
          "package": "yi",
          "signature": "Point -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#moveTo",
          "type": "function"
        },
        "index": {
          "description": "Move point in buffer to the given index",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "moveTo",
          "normalized": "Point-\u003eBufferM()",
          "package": "yi",
          "partial": "To",
          "signature": "Point-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:moveTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "moveToColB",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#moveToColB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "moveToColB",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "To Col",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:moveToColB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "moveToLineColB",
          "package": "yi",
          "signature": "Int -\u003e Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#moveToLineColB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "moveToLineColB",
          "normalized": "Int-\u003eInt-\u003eBufferM()",
          "package": "yi",
          "partial": "To Line Col",
          "signature": "Int-\u003eInt-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:moveToLineColB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "movingToPrefCol",
          "package": "yi",
          "signature": "BufferM a -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#movingToPrefCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "movingToPrefCol",
          "normalized": "BufferM a-\u003eBufferM a",
          "package": "yi",
          "partial": "To Pref Col",
          "signature": "BufferM a-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:movingToPrefCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn \u003ccode\u003en\u003c/code\u003e elems starting at \u003ccode\u003ei\u003c/code\u003e of the buffer as a list\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "nelemsB",
          "package": "yi",
          "signature": "Int -\u003e Point -\u003e BufferM String",
          "source": "src/Yi-Buffer-Misc.html#nelemsB",
          "type": "function"
        },
        "index": {
          "description": "Return elems starting at of the buffer as list",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "nelemsB",
          "normalized": "Int-\u003ePoint-\u003eBufferM String",
          "package": "yi",
          "signature": "Int-\u003ePoint-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:nelemsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "nelemsB'",
          "package": "yi",
          "signature": "Int -\u003e Point -\u003e BufferM Rope",
          "source": "src/Yi-Buffer-Misc.html#nelemsB%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "nelemsB'",
          "normalized": "Int-\u003ePoint-\u003eBufferM Rope",
          "package": "yi",
          "partial": "B'",
          "signature": "Int-\u003ePoint-\u003eBufferM Rope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:nelemsB-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate buffer named \u003ccode\u003enm\u003c/code\u003e with contents \u003ccode\u003es\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "newB",
          "package": "yi",
          "signature": "BufferRef -\u003e BufferId -\u003e Rope -\u003e FBuffer",
          "source": "src/Yi-Buffer-Misc.html#newB",
          "type": "function"
        },
        "index": {
          "description": "Create buffer named nm with contents",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "newB",
          "normalized": "BufferRef-\u003eBufferId-\u003eRope-\u003eFBuffer",
          "package": "yi",
          "signature": "BufferRef-\u003eBufferId-\u003eRope-\u003eFBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:newB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "newMarkB",
          "package": "yi",
          "signature": "MarkValue -\u003e BufferM Mark",
          "source": "src/Yi-Buffer-Misc.html#newMarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "newMarkB",
          "normalized": "MarkValue-\u003eBufferM Mark",
          "package": "yi",
          "partial": "Mark",
          "signature": "MarkValue-\u003eBufferM Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:newMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert newline at current point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "newlineB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#newlineB",
          "type": "function"
        },
        "index": {
          "description": "Insert newline at current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "newlineB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:newlineB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "onMode",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e Mode syntax) -\u003e AnyMode -\u003e AnyMode",
          "source": "src/Yi-Buffer-Misc.html#onMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "onMode",
          "normalized": "(a b Mode c-\u003eMode c)-\u003eAnyMode-\u003eAnyMode",
          "package": "yi",
          "partial": "Mode",
          "signature": "(forall syntax. Mode syntax-\u003eMode syntax)-\u003eAnyMode-\u003eAnyMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:onMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "pendingUpdatesA",
          "package": "yi",
          "signature": "Accessor FBuffer [UIUpdate]",
          "source": "src/Yi-Buffer-Misc.html#pendingUpdatesA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "pendingUpdatesA",
          "normalized": "Accessor FBuffer[UIUpdate]",
          "package": "yi",
          "partial": "Updates",
          "signature": "Accessor FBuffer[UIUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:pendingUpdatesA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "pointAfterCursorB",
          "package": "yi",
          "signature": "Point -\u003e BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#pointAfterCursorB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "pointAfterCursorB",
          "normalized": "Point-\u003eBufferM Point",
          "package": "yi",
          "partial": "After Cursor",
          "signature": "Point-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:pointAfterCursorB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "pointAt",
          "package": "yi",
          "signature": "forall a.  BufferM a -\u003e BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#pointAt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "pointAt",
          "normalized": "a b BufferM c-\u003eBufferM Point",
          "package": "yi",
          "partial": "At",
          "signature": "forall a. BufferM a-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:pointAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the current point\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "pointB",
          "package": "yi",
          "signature": "BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#pointB",
          "type": "function"
        },
        "index": {
          "description": "Extract the current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "pointB",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:pointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "pointFollowsWindowA",
          "package": "yi",
          "signature": "Accessor FBuffer (WindowRef -\u003e Bool)",
          "source": "src/Yi-Buffer-Misc.html#pointFollowsWindowA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "pointFollowsWindowA",
          "normalized": "Accessor FBuffer(WindowRef-\u003eBool)",
          "package": "yi",
          "partial": "Follows Window",
          "signature": "Accessor FBuffer(WindowRef-\u003eBool)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:pointFollowsWindowA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "pointOfLineColB",
          "package": "yi",
          "signature": "Int -\u003e Int -\u003e BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#pointOfLineColB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "pointOfLineColB",
          "normalized": "Int-\u003eInt-\u003eBufferM Point",
          "package": "yi",
          "partial": "Of Line Col",
          "signature": "Int-\u003eInt-\u003eBufferM Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:pointOfLineColB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the character at the given index\n This is an unsafe operation: character NUL is returned when out of bounds\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "readAtB",
          "package": "yi",
          "signature": "Point -\u003e BufferM Char",
          "source": "src/Yi-Buffer-Misc.html#readAtB",
          "type": "function"
        },
        "index": {
          "description": "Read the character at the given index This is an unsafe operation character NUL is returned when out of bounds",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "readAtB",
          "normalized": "Point-\u003eBufferM Char",
          "package": "yi",
          "partial": "At",
          "signature": "Point-\u003eBufferM Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:readAtB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead the character at the current point\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "readB",
          "package": "yi",
          "signature": "BufferM Char",
          "source": "src/Yi-Buffer-Misc.html#readB",
          "type": "function"
        },
        "index": {
          "description": "Read the character at the current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "readB",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:readB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "readOnlyA",
          "package": "yi",
          "signature": "Accessor FBuffer Bool",
          "source": "src/Yi-Buffer-Misc.html#readOnlyA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "readOnlyA",
          "package": "yi",
          "partial": "Only",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:readOnlyA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "rectangleSelectionA",
          "package": "yi",
          "signature": "Accessor FBuffer Bool",
          "source": "src/Yi-Buffer-Misc.html#rectangleSelectionA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "rectangleSelectionA",
          "package": "yi",
          "partial": "Selection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:rectangleSelectionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "redoB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#redoB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "redoB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:redoB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn indices of next string in buffer matched by regex in the\n given direction\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "regexB",
          "package": "yi",
          "signature": "Direction -\u003e SearchExp -\u003e BufferM [Region]",
          "source": "src/Yi-Buffer-Misc.html#regexB",
          "type": "function"
        },
        "index": {
          "description": "Return indices of next string in buffer matched by regex in the given direction",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "regexB",
          "normalized": "Direction-\u003eSearchExp-\u003eBufferM[Region]",
          "package": "yi",
          "signature": "Direction-\u003eSearchExp-\u003eBufferM[Region]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:regexB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn indices of strings in buffer matched by regex in the\n given region.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "regexRegionB",
          "package": "yi",
          "signature": "SearchExp -\u003e Region -\u003e BufferM [Region]",
          "source": "src/Yi-Buffer-Misc.html#regexRegionB",
          "type": "function"
        },
        "index": {
          "description": "Return indices of strings in buffer matched by regex in the given region",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "regexRegionB",
          "normalized": "SearchExp-\u003eRegion-\u003eBufferM[Region]",
          "package": "yi",
          "partial": "Region",
          "signature": "SearchExp-\u003eRegion-\u003eBufferM[Region]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:regexRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "replaceCharB",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#replaceCharB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "replaceCharB",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "Char",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:replaceCharB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "replaceCharWithAboveB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#replaceCharWithAboveB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "replaceCharWithAboveB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Char With Above",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:replaceCharWithAboveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "replaceCharWithBelowB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#replaceCharWithBelowB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "replaceCharWithBelowB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Char With Below",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:replaceCharWithBelowB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRevert all the pending updates; don't touch the point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "revertPendingUpdatesB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#revertPendingUpdatesB",
          "type": "function"
        },
        "index": {
          "description": "Revert all the pending updates don touch the point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "revertPendingUpdatesB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Pending Updates",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:revertPendingUpdatesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor +1\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "rightB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#rightB",
          "type": "function"
        },
        "index": {
          "description": "Move cursor",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "rightB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:rightB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove cursor +n\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "rightN",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#rightN",
          "type": "function"
        },
        "index": {
          "description": "Move cursor",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "rightN",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:rightN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute a \u003ccode\u003eBufferM\u003c/code\u003e value on a given buffer and window.  The new state of\n the buffer is returned alongside the result of the computation.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "runBuffer",
          "package": "yi",
          "signature": "Window -\u003e FBuffer -\u003e BufferM a -\u003e (a, FBuffer)",
          "source": "src/Yi-Buffer-Misc.html#runBuffer",
          "type": "function"
        },
        "index": {
          "description": "Execute BufferM value on given buffer and window The new state of the buffer is returned alongside the result of the computation",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "runBuffer",
          "normalized": "Window-\u003eFBuffer-\u003eBufferM a-\u003e(a,FBuffer)",
          "package": "yi",
          "partial": "Buffer",
          "signature": "Window-\u003eFBuffer-\u003eBufferM a-\u003e(a,FBuffer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:runBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute a \u003ccode\u003eBufferM\u003c/code\u003e value on a given buffer, using a dummy window.  The new state of\n the buffer is discarded.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "runBufferDummyWindow",
          "package": "yi",
          "signature": "FBuffer -\u003e BufferM a -\u003e a",
          "source": "src/Yi-Buffer-Misc.html#runBufferDummyWindow",
          "type": "function"
        },
        "index": {
          "description": "Execute BufferM value on given buffer using dummy window The new state of the buffer is discarded",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "runBufferDummyWindow",
          "normalized": "FBuffer-\u003eBufferM a-\u003ea",
          "package": "yi",
          "partial": "Buffer Dummy Window",
          "signature": "FBuffer-\u003eBufferM a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:runBufferDummyWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "runBufferFull",
          "package": "yi",
          "signature": "Window -\u003e FBuffer -\u003e BufferM a -\u003e (a, [Update], FBuffer)",
          "source": "src/Yi-Buffer-Misc.html#runBufferFull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "runBufferFull",
          "normalized": "Window-\u003eFBuffer-\u003eBufferM a-\u003e(a,[Update],FBuffer)",
          "package": "yi",
          "partial": "Buffer Full",
          "signature": "Window-\u003eFBuffer-\u003eBufferM a-\u003e(a,[Update],FBuffer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:runBufferFull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eperform a \u003ccode\u003eBufferM a\u003c/code\u003e, and return to the current point. (by using a mark)\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "savingExcursionB",
          "package": "yi",
          "signature": "BufferM a -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#savingExcursionB",
          "type": "function"
        },
        "index": {
          "description": "perform BufferM and return to the current point by using mark",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "savingExcursionB",
          "normalized": "BufferM a-\u003eBufferM a",
          "package": "yi",
          "partial": "Excursion",
          "signature": "BufferM a-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:savingExcursionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eperform an \u003ccode\u003eBufferM a\u003c/code\u003e, and return to the current point\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "savingPointB",
          "package": "yi",
          "signature": "BufferM a -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#savingPointB",
          "type": "function"
        },
        "index": {
          "description": "perform an BufferM and return to the current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "savingPointB",
          "normalized": "BufferM a-\u003eBufferM a",
          "package": "yi",
          "partial": "Point",
          "signature": "BufferM a-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:savingPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "savingPrefCol",
          "package": "yi",
          "signature": "BufferM a -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#savingPrefCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "savingPrefCol",
          "normalized": "BufferM a-\u003eBufferM a",
          "package": "yi",
          "partial": "Pref Col",
          "signature": "BufferM a-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:savingPrefCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "selMark",
          "package": "yi",
          "signature": "a",
          "source": "src/Yi-Buffer-Misc.html#MarkSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "selMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:selMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the mode\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "setAnyMode",
          "package": "yi",
          "signature": "AnyMode -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setAnyMode",
          "type": "function"
        },
        "index": {
          "description": "Set the mode",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setAnyMode",
          "normalized": "AnyMode-\u003eBufferM()",
          "package": "yi",
          "partial": "Any Mode",
          "signature": "AnyMode-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setAnyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "setInserting",
          "package": "yi",
          "signature": "Bool -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setInserting",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setInserting",
          "normalized": "Bool-\u003eBufferM()",
          "package": "yi",
          "partial": "Inserting",
          "signature": "Bool-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setInserting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "setMarkHereB",
          "package": "yi",
          "signature": "BufferM Mark",
          "source": "src/Yi-Buffer-Misc.html#setMarkHereB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setMarkHereB",
          "package": "yi",
          "partial": "Mark Here",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setMarkHereB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the given mark's point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "setMarkPointB",
          "package": "yi",
          "signature": "Mark -\u003e Point -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setMarkPointB",
          "type": "function"
        },
        "index": {
          "description": "Set the given mark point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setMarkPointB",
          "normalized": "Mark-\u003ePoint-\u003eBufferM()",
          "package": "yi",
          "partial": "Mark Point",
          "signature": "Mark-\u003ePoint-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setMarkPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "setMode",
          "package": "yi",
          "signature": "Mode syntax -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setMode",
          "normalized": "Mode a-\u003eBufferM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "Mode syntax-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "setMode0",
          "package": "yi",
          "signature": "forall syntax.  Mode syntax -\u003e FBuffer -\u003e FBuffer",
          "source": "src/Yi-Buffer-Misc.html#setMode0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setMode0",
          "normalized": "a b Mode c-\u003eFBuffer-\u003eFBuffer",
          "package": "yi",
          "partial": "Mode",
          "signature": "forall syntax. Mode syntax-\u003eFBuffer-\u003eFBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setMode0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "setNamedMarkHereB",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setNamedMarkHereB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setNamedMarkHereB",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Named Mark Here",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setNamedMarkHereB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "setPrefCol",
          "package": "yi",
          "signature": "Maybe Int -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setPrefCol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setPrefCol",
          "normalized": "Maybe Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Pref Col",
          "signature": "Maybe Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setPrefCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHighlight the selection\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "setVisibleSelection",
          "package": "yi",
          "signature": "Bool -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#setVisibleSelection",
          "type": "function"
        },
        "index": {
          "description": "Highlight the selection",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "setVisibleSelection",
          "normalized": "Bool-\u003eBufferM()",
          "package": "yi",
          "partial": "Visible Selection",
          "signature": "Bool-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:setVisibleSelection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndent by so many columns \n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "shiftWidth",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-Misc.html#IndentSettings",
          "type": "function"
        },
        "index": {
          "description": "Indent by so many columns",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "shiftWidth",
          "package": "yi",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:shiftWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "shortIdentString",
          "package": "yi",
          "signature": "[a] -\u003e FBuffer -\u003e [Char]",
          "source": "src/Yi-Buffer-Misc.html#shortIdentString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "shortIdentString",
          "normalized": "[a]-\u003eFBuffer-\u003e[Char]",
          "package": "yi",
          "partial": "Ident String",
          "signature": "[a]-\u003eFBuffer-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:shortIdentString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePoint of eof\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "sizeB",
          "package": "yi",
          "signature": "BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#sizeB",
          "type": "function"
        },
        "index": {
          "description": "Point of eof",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "sizeB",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:sizeB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "solPointB",
          "package": "yi",
          "signature": "BufferM Point",
          "source": "src/Yi-Buffer-Misc.html#solPointB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "solPointB",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:solPointB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "startUpdateTransactionB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#startUpdateTransactionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "startUpdateTransactionB",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Update Transaction",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:startUpdateTransactionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "streamB",
          "package": "yi",
          "signature": "Direction -\u003e Point -\u003e BufferM Rope",
          "source": "src/Yi-Buffer-Misc.html#streamB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "streamB",
          "normalized": "Direction-\u003ePoint-\u003eBufferM Rope",
          "package": "yi",
          "signature": "Direction-\u003ePoint-\u003eBufferM Rope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:streamB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "strokesRangesB",
          "package": "yi",
          "signature": "Maybe SearchExp -\u003e Region -\u003e BufferM [[Stroke]]",
          "source": "src/Yi-Buffer-Misc.html#strokesRangesB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "strokesRangesB",
          "normalized": "Maybe SearchExp-\u003eRegion-\u003eBufferM[[Stroke]]",
          "package": "yi",
          "partial": "Ranges",
          "signature": "Maybe SearchExp-\u003eRegion-\u003eBufferM[[Stroke]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:strokesRangesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of a Tab\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "tabSize",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Buffer-Misc.html#IndentSettings",
          "type": "function"
        },
        "index": {
          "description": "Size of Tab",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "tabSize",
          "package": "yi",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:tabSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "undoB",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#undoB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "undoB",
          "normalized": "BufferM()",
          "package": "yi",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:undoB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "undosA",
          "package": "yi",
          "signature": "Accessor FBuffer URList",
          "source": "src/Yi-Buffer-Misc.html#undosA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "undosA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:undosA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "withEveryLineB",
          "package": "yi",
          "signature": "BufferM () -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#withEveryLineB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "withEveryLineB",
          "normalized": "BufferM()-\u003eBufferM()",
          "package": "yi",
          "partial": "Every Line",
          "signature": "BufferM()-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:withEveryLineB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "withMode0",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e a) -\u003e FBuffer -\u003e a",
          "source": "src/Yi-Buffer-Misc.html#withMode0",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "withMode0",
          "normalized": "(a b Mode c-\u003ed)-\u003eFBuffer-\u003ed",
          "package": "yi",
          "partial": "Mode",
          "signature": "(forall syntax. Mode syntax-\u003ea)-\u003eFBuffer-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:withMode0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "withModeB",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e BufferM a) -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#withModeB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "withModeB",
          "normalized": "(a b Mode c-\u003eBufferM d)-\u003eBufferM d",
          "package": "yi",
          "partial": "Mode",
          "signature": "(forall syntax. Mode syntax-\u003eBufferM a)-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:withModeB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "withSyntaxB",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e syntax -\u003e a) -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#withSyntaxB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "withSyntaxB",
          "normalized": "(a b Mode c-\u003ec-\u003ed)-\u003eBufferM d",
          "package": "yi",
          "partial": "Syntax",
          "signature": "(forall syntax. Mode syntax-\u003esyntax-\u003ea)-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:withSyntaxB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Misc",
          "name": "withSyntaxB'",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e syntax -\u003e BufferM a) -\u003e BufferM a",
          "source": "src/Yi-Buffer-Misc.html#withSyntaxB%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "withSyntaxB'",
          "normalized": "(a b Mode c-\u003ec-\u003eBufferM d)-\u003eBufferM d",
          "package": "yi",
          "partial": "Syntax B'",
          "signature": "(forall syntax. Mode syntax-\u003esyntax-\u003eBufferM a)-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:withSyntaxB-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite an element into the buffer at the current point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "writeB",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#writeB",
          "type": "function"
        },
        "index": {
          "description": "Write an element into the buffer at the current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "writeB",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:writeB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite the list into the buffer at current point.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Misc",
          "name": "writeN",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Misc.html#writeN",
          "type": "function"
        },
        "index": {
          "description": "Write the list into the buffer at current point",
          "hierarchy": "Yi Buffer Misc",
          "module": "Yi.Buffer.Misc",
          "name": "writeN",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Misc.html#v:writeN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA normalized API to many buffer operations.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Buffer.Normal",
          "name": "Normal",
          "package": "yi",
          "source": "src/Yi-Buffer-Normal.html",
          "type": "module"
        },
        "index": {
          "description": "normalized API to many buffer operations",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Normal",
          "package": "yi",
          "partial": "Normal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoundary side\n\u003c/p\u003e",
          "module": "Yi.Buffer.Normal",
          "name": "BoundarySide",
          "package": "yi",
          "source": "src/Yi-Buffer-TextUnit.html#BoundarySide",
          "type": "data"
        },
        "index": {
          "description": "Boundary side",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "BoundarySide",
          "package": "yi",
          "partial": "Boundary Side",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#t:BoundarySide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "RegionStyle",
          "package": "yi",
          "source": "src/Yi-Buffer-Normal.html#RegionStyle",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "RegionStyle",
          "package": "yi",
          "partial": "Region Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#t:RegionStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesignate a given \u003ca\u003eunit\u003c/a\u003e of text.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Normal",
          "name": "TextUnit",
          "package": "yi",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "data"
        },
        "index": {
          "description": "Designate given unit of text",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "TextUnit",
          "package": "yi",
          "partial": "Text Unit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#t:TextUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "Block",
          "package": "yi",
          "signature": "Block",
          "source": "src/Yi-Buffer-Normal.html#RegionStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Block",
          "package": "yi",
          "partial": "Block",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea single character\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "Character",
          "package": "yi",
          "signature": "Character",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Character\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:Character\"]"
        },
        "index": {
          "description": "single character",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Character",
          "package": "yi",
          "partial": "Character",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Character"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe whole document\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "Document",
          "package": "yi",
          "signature": "Document",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Document\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:Document\"]"
        },
        "index": {
          "description": "the whole document",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Document",
          "package": "yi",
          "partial": "Document",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Document"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "Exclusive",
          "package": "yi",
          "signature": "Exclusive",
          "source": "src/Yi-Buffer-Normal.html#RegionStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Exclusive",
          "package": "yi",
          "partial": "Exclusive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Exclusive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "GenUnit",
          "package": "yi",
          "signature": "GenUnit",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:GenUnit\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:GenUnit\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "GenUnit",
          "package": "yi",
          "partial": "Gen Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:GenUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "Inclusive",
          "package": "yi",
          "signature": "Inclusive",
          "source": "src/Yi-Buffer-Normal.html#RegionStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Inclusive",
          "package": "yi",
          "partial": "Inclusive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Inclusive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "InsideBound",
          "package": "yi",
          "signature": "InsideBound",
          "source": "src/Yi-Buffer-TextUnit.html#BoundarySide",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:InsideBound\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:InsideBound\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "InsideBound",
          "package": "yi",
          "partial": "Inside Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:InsideBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea line of text (between newlines)\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "Line",
          "package": "yi",
          "signature": "Line",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Line\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:Line\"]"
        },
        "index": {
          "description": "line of text between newlines",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "Line",
          "package": "yi",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "LineWise",
          "package": "yi",
          "signature": "LineWise",
          "source": "src/Yi-Buffer-Normal.html#RegionStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "LineWise",
          "package": "yi",
          "partial": "Line Wise",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:LineWise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "OutsideBound",
          "package": "yi",
          "signature": "OutsideBound",
          "source": "src/Yi-Buffer-TextUnit.html#BoundarySide",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:OutsideBound\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:OutsideBound\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "OutsideBound",
          "package": "yi",
          "partial": "Outside Bound",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:OutsideBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea \u003ca\u003evertical\u003c/a\u003e line of text (area of text between two characters at the same column number)\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "VLine",
          "package": "yi",
          "signature": "VLine",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:VLine\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:VLine\"]"
        },
        "index": {
          "description": "vertical line of text area of text between two characters at the same column number",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "VLine",
          "package": "yi",
          "partial": "VLine",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:VLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "atBoundaryB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM Bool",
          "source": "src/Yi-Buffer-TextUnit.html#atBoundaryB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:atBoundaryB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:atBoundaryB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "atBoundaryB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM Bool",
          "package": "yi",
          "partial": "Boundary",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:atBoundaryB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "checkPeekB",
          "package": "yi",
          "signature": "Int -\u003e [Char -\u003e Bool] -\u003e Direction -\u003e BufferM Bool",
          "source": "src/Yi-Buffer-TextUnit.html#checkPeekB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:checkPeekB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:checkPeekB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "checkPeekB",
          "normalized": "Int-\u003e[Char-\u003eBool]-\u003eDirection-\u003eBufferM Bool",
          "package": "yi",
          "partial": "Peek",
          "signature": "Int-\u003e[Char-\u003eBool]-\u003eDirection-\u003eBufferM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:checkPeekB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "convertRegionToStyleB",
          "package": "yi",
          "signature": "Region -\u003e RegionStyle -\u003e BufferM Region",
          "source": "src/Yi-Buffer-Normal.html#convertRegionToStyleB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "convertRegionToStyleB",
          "normalized": "Region-\u003eRegionStyle-\u003eBufferM Region",
          "package": "yi",
          "partial": "Region To Style",
          "signature": "Region-\u003eRegionStyle-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:convertRegionToStyleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete between point and next unit boundary, return the deleted region.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "deleteB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#deleteB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:deleteB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:deleteB\"]"
        },
        "index": {
          "description": "Delete between point and next unit boundary return the deleted region",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "deleteB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:deleteB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo an action if the current buffer character passes the predicate\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "doIfCharB",
          "package": "yi",
          "signature": "(Char -\u003e Bool) -\u003e BufferM a -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#doIfCharB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:doIfCharB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:doIfCharB\"]"
        },
        "index": {
          "description": "Do an action if the current buffer character passes the predicate",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "doIfCharB",
          "normalized": "(Char-\u003eBool)-\u003eBufferM a-\u003eBufferM()",
          "package": "yi",
          "partial": "If Char",
          "signature": "(Char-\u003eBool)-\u003eBufferM a-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:doIfCharB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "doUntilB_",
          "package": "yi",
          "signature": "BufferM Bool -\u003e BufferM a -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#doUntilB_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:doUntilB_\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:doUntilB_\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "doUntilB_",
          "normalized": "BufferM Bool-\u003eBufferM a-\u003eBufferM()",
          "package": "yi",
          "partial": "Until",
          "signature": "BufferM Bool-\u003eBufferM a-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:doUntilB_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend the given region to boundaries of the text unit.\n For instance one can extend the selection to complete lines, or\n paragraphs.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Normal",
          "name": "extendRegionToBoundaries",
          "package": "yi",
          "signature": "TextUnit -\u003e BoundarySide -\u003e BoundarySide -\u003e Region -\u003e BufferM Region",
          "source": "src/Yi-Buffer-Normal.html#extendRegionToBoundaries",
          "type": "function"
        },
        "index": {
          "description": "Extend the given region to boundaries of the text unit For instance one can extend the selection to complete lines or paragraphs",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "extendRegionToBoundaries",
          "normalized": "TextUnit-\u003eBoundarySide-\u003eBoundarySide-\u003eRegion-\u003eBufferM Region",
          "package": "yi",
          "partial": "Region To Boundaries",
          "signature": "TextUnit-\u003eBoundarySide-\u003eBoundarySide-\u003eRegion-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:extendRegionToBoundaries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003egenAtBoundaryB u d s\u003c/code\u003e returns whether the point is at a given boundary \u003ccode\u003e(d,s)\u003c/code\u003e .\n Boundary \u003ccode\u003e(d,s)\u003c/code\u003e , taking Word as example, means:\n      Word \n     ^^  ^^\n     12  34\n 1: (Backward,OutsideBound)\n 2: (Backward,InsideBound)\n 3: (Forward,InsideBound)\n 4: (Forward,OutsideBound)\n\u003c/p\u003e\u003cp\u003erules:\n genAtBoundaryB u Backward InsideBound  = atBoundaryB u Backward\n genAtBoundaryB u Forward  OutsideBound = atBoundaryB u Forward\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "genAtBoundaryB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BoundarySide -\u003e BufferM Bool",
          "source": "src/Yi-Buffer-TextUnit.html#genAtBoundaryB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genAtBoundaryB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:genAtBoundaryB\"]"
        },
        "index": {
          "description": "genAtBoundaryB returns whether the point is at given boundary Boundary taking Word as example means Word Backward OutsideBound Backward InsideBound Forward InsideBound Forward OutsideBound rules genAtBoundaryB Backward InsideBound atBoundaryB Backward genAtBoundaryB Forward OutsideBound atBoundaryB Forward",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "genAtBoundaryB",
          "normalized": "TextUnit-\u003eDirection-\u003eBoundarySide-\u003eBufferM Bool",
          "package": "yi",
          "partial": "At Boundary",
          "signature": "TextUnit-\u003eDirection-\u003eBoundarySide-\u003eBufferM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genAtBoundaryB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "genEnclosingUnit",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genEnclosingUnit\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:genEnclosingUnit\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "genEnclosingUnit",
          "package": "yi",
          "partial": "Enclosing Unit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genEnclosingUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric maybe move operation.\n As genMoveB, but don't move if we are at boundary already.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "genMaybeMoveB",
          "package": "yi",
          "signature": "TextUnit -\u003e (Direction, BoundarySide) -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#genMaybeMoveB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genMaybeMoveB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:genMaybeMoveB\"]"
        },
        "index": {
          "description": "Generic maybe move operation As genMoveB but don move if we are at boundary already",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "genMaybeMoveB",
          "normalized": "TextUnit-\u003e(Direction,BoundarySide)-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "partial": "Maybe Move",
          "signature": "TextUnit-\u003e(Direction,BoundarySide)-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genMaybeMoveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric move operation\n Warning: moving To the (OutsideBound, Backward) bound of Document is impossible (offset -1!)\n \u003ccode\u003egenMoveB u b d\u003c/code\u003e: move in direction d until encountering boundary b or unit u. See \u003ccode\u003e\u003ca\u003egenAtBoundaryB\u003c/a\u003e\u003c/code\u003e for boundary explanation.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "genMoveB",
          "package": "yi",
          "signature": "TextUnit -\u003e (Direction, BoundarySide) -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#genMoveB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genMoveB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:genMoveB\"]"
        },
        "index": {
          "description": "Generic move operation Warning moving To the OutsideBound Backward bound of Document is impossible offset genMoveB move in direction until encountering boundary or unit See genAtBoundaryB for boundary explanation",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "genMoveB",
          "normalized": "TextUnit-\u003e(Direction,BoundarySide)-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "partial": "Move",
          "signature": "TextUnit-\u003e(Direction,BoundarySide)-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genMoveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "genUnitBoundary",
          "package": "yi",
          "signature": "Direction -\u003e BufferM Bool",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genUnitBoundary\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:genUnitBoundary\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "genUnitBoundary",
          "normalized": "Direction-\u003eBufferM Bool",
          "package": "yi",
          "partial": "Unit Boundary",
          "signature": "Direction-\u003eBufferM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:genUnitBoundary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSeparator characters (space, tab, unicode separators). Most of the units\n above attempt to identify \u003ca\u003ewords\u003c/a\u003e with various punctuation and symbols included\n or excluded. This set of units is a simple inverse: it is true for \u003ca\u003ewhitespace\u003c/a\u003e\n or \u003ca\u003eseparators\u003c/a\u003e and false for anything that is not (letters, numbers, symbols,\n punctuation, whatever).\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "isAnySep",
          "package": "yi",
          "signature": "Char -\u003e Bool",
          "source": "src/Yi-Buffer-TextUnit.html#isAnySep",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:isAnySep\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:isAnySep\"]"
        },
        "index": {
          "description": "Separator characters space tab unicode separators Most of the units above attempt to identify words with various punctuation and symbols included or excluded This set of units is simple inverse it is true for whitespace or separators and false for anything that is not letters numbers symbols punctuation whatever",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "isAnySep",
          "normalized": "Char-\u003eBool",
          "package": "yi",
          "partial": "Any Sep",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:isAnySep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "isWordChar",
          "package": "yi",
          "signature": "Char -\u003e Bool",
          "source": "src/Yi-Buffer-TextUnit.html#isWordChar",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:isWordChar\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:isWordChar\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "isWordChar",
          "normalized": "Char-\u003eBool",
          "package": "yi",
          "partial": "Word Char",
          "signature": "Char-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:isWordChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnit that have its left and right boundaries at the left boundary of the argument unit.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "leftBoundaryUnit",
          "package": "yi",
          "signature": "TextUnit -\u003e TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#leftBoundaryUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:leftBoundaryUnit\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:leftBoundaryUnit\"]"
        },
        "index": {
          "description": "Unit that have its left and right boundaries at the left boundary of the argument unit",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "leftBoundaryUnit",
          "normalized": "TextUnit-\u003eTextUnit",
          "package": "yi",
          "partial": "Boundary Unit",
          "signature": "TextUnit-\u003eTextUnit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:leftBoundaryUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003emoveB\u003c/a\u003e\u003c/code\u003e, unless the point is at a unit boundary\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "maybeMoveB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#maybeMoveB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:maybeMoveB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:maybeMoveB\"]"
        },
        "index": {
          "description": "As moveB unless the point is at unit boundary",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "maybeMoveB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "partial": "Move",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:maybeMoveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "mkRegionOfStyleB",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e RegionStyle -\u003e BufferM Region",
          "source": "src/Yi-Buffer-Normal.html#mkRegionOfStyleB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "mkRegionOfStyleB",
          "normalized": "Point-\u003ePoint-\u003eRegionStyle-\u003eBufferM Region",
          "package": "yi",
          "partial": "Region Of Style",
          "signature": "Point-\u003ePoint-\u003eRegionStyle-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:mkRegionOfStyleB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMove to the next unit boundary\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "moveB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#moveB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:moveB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:moveB\"]"
        },
        "index": {
          "description": "Move to the next unit boundary",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "moveB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:moveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "numberOfB",
          "package": "yi",
          "signature": "TextUnit -\u003e TextUnit -\u003e BufferM Int",
          "source": "src/Yi-Buffer-TextUnit.html#numberOfB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:numberOfB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:numberOfB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "numberOfB",
          "normalized": "TextUnit-\u003eTextUnit-\u003eBufferM Int",
          "package": "yi",
          "partial": "Of",
          "signature": "TextUnit-\u003eTextUnit-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:numberOfB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurns a unit into its \u003ca\u003enegative\u003c/a\u003e by inverting the boundaries. For example,\n \u003ccode\u003eoutsideUnit unitViWord\u003c/code\u003e will be the unit of spaces between words. For units\n without boundaries (\u003ccode\u003e\u003ca\u003eCharacter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eDocument\u003c/a\u003e\u003c/code\u003e, ...), this is the identity\n function.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "outsideUnit",
          "package": "yi",
          "signature": "TextUnit -\u003e TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#outsideUnit",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:outsideUnit\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:outsideUnit\"]"
        },
        "index": {
          "description": "Turns unit into its negative by inverting the boundaries For example outsideUnit unitViWord will be the unit of spaces between words For units without boundaries Character Document this is the identity function",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "outsideUnit",
          "normalized": "TextUnit-\u003eTextUnit",
          "package": "yi",
          "partial": "Unit",
          "signature": "TextUnit-\u003eTextUnit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:outsideUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "readPrevUnitB",
          "package": "yi",
          "signature": "TextUnit -\u003e BufferM String",
          "source": "src/Yi-Buffer-TextUnit.html#readPrevUnitB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:readPrevUnitB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:readPrevUnitB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "readPrevUnitB",
          "normalized": "TextUnit-\u003eBufferM String",
          "package": "yi",
          "partial": "Prev Unit",
          "signature": "TextUnit-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:readPrevUnitB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "readUnitB",
          "package": "yi",
          "signature": "TextUnit -\u003e BufferM String",
          "source": "src/Yi-Buffer-TextUnit.html#readUnitB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:readUnitB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:readUnitB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "readUnitB",
          "normalized": "TextUnit-\u003eBufferM String",
          "package": "yi",
          "partial": "Unit",
          "signature": "TextUnit-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:readUnitB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegion of the whole textunit where the current point is.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "regionOfB",
          "package": "yi",
          "signature": "TextUnit -\u003e BufferM Region",
          "source": "src/Yi-Buffer-TextUnit.html#regionOfB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:regionOfB\"]"
        },
        "index": {
          "description": "Region of the whole textunit where the current point is",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "regionOfB",
          "normalized": "TextUnit-\u003eBufferM Region",
          "package": "yi",
          "partial": "Of",
          "signature": "TextUnit-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon empty region of the whole textunit where the current point is.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "regionOfNonEmptyB",
          "package": "yi",
          "signature": "TextUnit -\u003e BufferM Region",
          "source": "src/Yi-Buffer-TextUnit.html#regionOfNonEmptyB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfNonEmptyB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:regionOfNonEmptyB\"]"
        },
        "index": {
          "description": "Non empty region of the whole textunit where the current point is",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "regionOfNonEmptyB",
          "normalized": "TextUnit-\u003eBufferM Region",
          "package": "yi",
          "partial": "Of Non Empty",
          "signature": "TextUnit-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfNonEmptyB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegion between the point and the next boundary.\n The region is empty if the point is at the boundary.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "regionOfPartB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM Region",
          "source": "src/Yi-Buffer-TextUnit.html#regionOfPartB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfPartB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:regionOfPartB\"]"
        },
        "index": {
          "description": "Region between the point and the next boundary The region is empty if the point is at the boundary",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "regionOfPartB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM Region",
          "package": "yi",
          "partial": "Of Part",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfPartB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon empty region at given point and the next boundary,\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "regionOfPartNonEmptyAtB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e Point -\u003e BufferM Region",
          "source": "src/Yi-Buffer-TextUnit.html#regionOfPartNonEmptyAtB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfPartNonEmptyAtB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:regionOfPartNonEmptyAtB\"]"
        },
        "index": {
          "description": "Non empty region at given point and the next boundary",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "regionOfPartNonEmptyAtB",
          "normalized": "TextUnit-\u003eDirection-\u003ePoint-\u003eBufferM Region",
          "package": "yi",
          "partial": "Of Part Non Empty At",
          "signature": "TextUnit-\u003eDirection-\u003ePoint-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfPartNonEmptyAtB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNon empty region between the point and the next boundary,\n In fact the region can be empty if we are at the end of file.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "regionOfPartNonEmptyB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM Region",
          "source": "src/Yi-Buffer-TextUnit.html#regionOfPartNonEmptyB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfPartNonEmptyB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:regionOfPartNonEmptyB\"]"
        },
        "index": {
          "description": "Non empty region between the point and the next boundary In fact the region can be empty if we are at the end of file",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "regionOfPartNonEmptyB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM Region",
          "package": "yi",
          "partial": "Of Part Non Empty",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionOfPartNonEmptyB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "regionStyleA",
          "package": "yi",
          "signature": "Accessor FBuffer RegionStyle",
          "source": "src/Yi-Buffer-Normal.html#regionStyleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "regionStyleA",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:regionStyleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "transformB",
          "package": "yi",
          "signature": "(String -\u003e String) -\u003e TextUnit -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#transformB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:transformB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:transformB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "transformB",
          "normalized": "(String-\u003eString)-\u003eTextUnit-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "signature": "(String-\u003eString)-\u003eTextUnit-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:transformB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "transposeB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#transposeB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:transposeB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:transposeB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "transposeB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:transposeB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitDelimited",
          "package": "yi",
          "signature": "Char -\u003e Char -\u003e Bool -\u003e TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitDelimited",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitDelimited\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitDelimited\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitDelimited",
          "normalized": "Char-\u003eChar-\u003eBool-\u003eTextUnit",
          "package": "yi",
          "partial": "Delimited",
          "signature": "Char-\u003eChar-\u003eBool-\u003eTextUnit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitDelimited"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParagraph to implement emacs-like forward-paragraph/backward-paragraph\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitEmacsParagraph",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitEmacsParagraph",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitEmacsParagraph\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitEmacsParagraph\"]"
        },
        "index": {
          "description": "Paragraph to implement emacs-like forward-paragraph backward-paragraph",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitEmacsParagraph",
          "package": "yi",
          "partial": "Emacs Paragraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitEmacsParagraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParagraph that begins and ends in the paragraph, not the empty lines surrounding it.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitParagraph",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitParagraph",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitParagraph\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitParagraph\"]"
        },
        "index": {
          "description": "Paragraph that begins and ends in the paragraph not the empty lines surrounding it",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitParagraph",
          "package": "yi",
          "partial": "Paragraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitParagraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitSentence",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitSentence",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitSentence\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitSentence\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitSentence",
          "package": "yi",
          "partial": "Sentence",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitSentence"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunitSep is true for any kind of whitespace/separator\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitSep",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitSep",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitSep\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitSep\"]"
        },
        "index": {
          "description": "unitSep is true for any kind of whitespace separator",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitSep",
          "package": "yi",
          "partial": "Sep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunitSepThisLine is true for any kind of whitespace/separator on this line only\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitSepThisLine",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitSepThisLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitSepThisLine\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitSepThisLine\"]"
        },
        "index": {
          "description": "unitSepThisLine is true for any kind of whitespace separator on this line only",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitSepThisLine",
          "package": "yi",
          "partial": "Sep This Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitSepThisLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitViWORD",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitViWORD",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWORD\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitViWORD\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitViWORD",
          "package": "yi",
          "partial": "Vi WORD",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWORD"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitViWORDAnyBnd",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitViWORDAnyBnd",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWORDAnyBnd\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitViWORDAnyBnd\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitViWORDAnyBnd",
          "package": "yi",
          "partial": "Vi WORDAny Bnd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWORDAnyBnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitViWORDOnLine",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitViWORDOnLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWORDOnLine\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitViWORDOnLine\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitViWORDOnLine",
          "package": "yi",
          "partial": "Vi WORDOn Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWORDOnLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitViWord",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitViWord",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWord\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitViWord\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitViWord",
          "package": "yi",
          "partial": "Vi Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitViWordAnyBnd",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitViWordAnyBnd",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWordAnyBnd\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitViWordAnyBnd\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitViWordAnyBnd",
          "package": "yi",
          "partial": "Vi Word Any Bnd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWordAnyBnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitViWordOnLine",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitViWordOnLine",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWordOnLine\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitViWordOnLine\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitViWordOnLine",
          "package": "yi",
          "partial": "Vi Word On Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitViWordOnLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Normal",
          "name": "unitWiseRegion",
          "package": "yi",
          "signature": "TextUnit -\u003e Region -\u003e BufferM Region",
          "source": "src/Yi-Buffer-Normal.html#unitWiseRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitWiseRegion",
          "normalized": "TextUnit-\u003eRegion-\u003eBufferM Region",
          "package": "yi",
          "partial": "Wise Region",
          "signature": "TextUnit-\u003eRegion-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitWiseRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edelimited on the left and right by given characters, boolean argument tells if whether those are included.\n\u003c/p\u003e\u003cp\u003ea word as in use in Emacs (fundamental mode)\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "unitWord",
          "package": "yi",
          "signature": "TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#unitWord",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitWord\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:unitWord\"]"
        },
        "index": {
          "description": "delimited on the left and right by given characters boolean argument tells if whether those are included word as in use in Emacs fundamental mode",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "unitWord",
          "package": "yi",
          "partial": "Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:unitWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepeat an action until the condition is fulfilled or the cursor stops moving.\n The Action may be performed zero times.\n\u003c/p\u003e",
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "untilB",
          "package": "yi",
          "signature": "BufferM Bool -\u003e BufferM a -\u003e BufferM [a]",
          "source": "src/Yi-Buffer-TextUnit.html#untilB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:untilB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:untilB\"]"
        },
        "index": {
          "description": "Repeat an action until the condition is fulfilled or the cursor stops moving The Action may be performed zero times",
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "untilB",
          "normalized": "BufferM Bool-\u003eBufferM a-\u003eBufferM[a]",
          "package": "yi",
          "signature": "BufferM Bool-\u003eBufferM a-\u003eBufferM[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:untilB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "untilB_",
          "package": "yi",
          "signature": "BufferM Bool -\u003e BufferM a -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#untilB_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:untilB_\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:untilB_\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "untilB_",
          "normalized": "BufferM Bool-\u003eBufferM a-\u003eBufferM()",
          "package": "yi",
          "signature": "BufferM Bool-\u003eBufferM a-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:untilB_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Buffer.Normal\",\"Yi.Buffer.TextUnit\"]",
          "name": "whileB",
          "package": "yi",
          "signature": "BufferM Bool -\u003e BufferM a -\u003e BufferM [a]",
          "source": "src/Yi-Buffer-TextUnit.html#whileB",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:whileB\",\"http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:whileB\"]"
        },
        "index": {
          "hierarchy": "Yi Buffer Normal",
          "module": "Yi.Buffer.Normal",
          "name": "whileB",
          "normalized": "BufferM Bool-\u003eBufferM a-\u003eBufferM[a]",
          "package": "yi",
          "signature": "BufferM Bool-\u003eBufferM a-\u003eBufferM[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Normal.html#v:whileB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines buffer operation on regions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Buffer.Region",
          "name": "Region",
          "package": "yi",
          "source": "src/Yi-Buffer-Region.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines buffer operation on regions",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "Region",
          "package": "yi",
          "partial": "Region",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee a region as a block/rectangular region,\n since regions are represented by two point, this returns\n a list of small regions form this block region.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "blockifyRegion",
          "package": "yi",
          "signature": "Region -\u003e BufferM [Region]",
          "source": "src/Yi-Buffer-Region.html#blockifyRegion",
          "type": "function"
        },
        "index": {
          "description": "See region as block rectangular region since regions are represented by two point this returns list of small regions form this block region",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "blockifyRegion",
          "normalized": "Region-\u003eBufferM[Region]",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eBufferM[Region]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:blockifyRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Region",
          "name": "concatLinesB",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#concatLinesB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "concatLinesB",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Lines",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:concatLinesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete an arbitrary part of the buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "deleteRegionB",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#deleteRegionB",
          "type": "function"
        },
        "index": {
          "description": "Delete an arbitrary part of the buffer",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "deleteRegionB",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:deleteRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtend the right bound of a region to include it.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "inclusiveRegionB",
          "package": "yi",
          "signature": "Region -\u003e BufferM Region",
          "source": "src/Yi-Buffer-Region.html#inclusiveRegionB",
          "type": "function"
        },
        "index": {
          "description": "Extend the right bound of region to include it",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "inclusiveRegionB",
          "normalized": "Region-\u003eBufferM Region",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:inclusiveRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Region",
          "name": "joinLinesB",
          "package": "yi",
          "signature": "Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#joinLinesB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "joinLinesB",
          "normalized": "Region-\u003eBufferM()",
          "package": "yi",
          "partial": "Lines",
          "signature": "Region-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:joinLinesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Region",
          "name": "mapRegionB",
          "package": "yi",
          "signature": "Region -\u003e (Char -\u003e Char) -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#mapRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "mapRegionB",
          "normalized": "Region-\u003e(Char-\u003eChar)-\u003eBufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003e(Char-\u003eChar)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:mapRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModifies the given region according to the given\n string transformation function\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "modifyRegionB",
          "package": "yi",
          "signature": "(String -\u003e String)-\u003e Region-\u003e BufferM ()",
          "type": "function"
        },
        "index": {
          "description": "Modifies the given region according to the given string transformation function",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "modifyRegionB",
          "normalized": "(String-\u003eString)-\u003eRegion-\u003eBufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "(String-\u003eString)-\u003eRegion-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:modifyRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003emodifyRegionB\u003c/a\u003e\u003c/code\u003e, but do a minimal edition instead of deleting the whole\n region and inserting it back.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "modifyRegionClever",
          "package": "yi",
          "signature": "(String -\u003e String) -\u003e Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#modifyRegionClever",
          "type": "function"
        },
        "index": {
          "description": "As modifyRegionB but do minimal edition instead of deleting the whole region and inserting it back",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "modifyRegionClever",
          "normalized": "(String-\u003eString)-\u003eRegion-\u003eBufferM()",
          "package": "yi",
          "partial": "Region Clever",
          "signature": "(String-\u003eString)-\u003eRegion-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:modifyRegionClever"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead an arbitrary part of the buffer\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "readRegionB",
          "package": "yi",
          "signature": "Region -\u003e BufferM String",
          "source": "src/Yi-Buffer-Region.html#readRegionB",
          "type": "function"
        },
        "index": {
          "description": "Read an arbitrary part of the buffer",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "readRegionB",
          "normalized": "Region-\u003eBufferM String",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:readRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Region",
          "name": "readRegionB'",
          "package": "yi",
          "signature": "Region -\u003e BufferM Rope",
          "source": "src/Yi-Buffer-Region.html#readRegionB%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "readRegionB'",
          "normalized": "Region-\u003eBufferM Rope",
          "package": "yi",
          "partial": "Region B'",
          "signature": "Region-\u003eBufferM Rope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:readRegionB-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a region with a given string.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "replaceRegionB",
          "package": "yi",
          "signature": "Region -\u003e String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#replaceRegionB",
          "type": "function"
        },
        "index": {
          "description": "Replace region with given string",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "replaceRegionB",
          "normalized": "Region-\u003eString-\u003eBufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eString-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:replaceRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a region with a given rope.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "replaceRegionB'",
          "package": "yi",
          "signature": "Region -\u003e Rope -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#replaceRegionB%27",
          "type": "function"
        },
        "index": {
          "description": "Replace region with given rope",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "replaceRegionB'",
          "normalized": "Region-\u003eRope-\u003eBufferM()",
          "package": "yi",
          "partial": "Region B'",
          "signature": "Region-\u003eRope-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:replaceRegionB-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003ereplaceRegionB\u003c/a\u003e\u003c/code\u003e, but do a minimal edition instead of deleting the whole\n region and inserting it back.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "replaceRegionClever",
          "package": "yi",
          "signature": "Region -\u003e String -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#replaceRegionClever",
          "type": "function"
        },
        "index": {
          "description": "As replaceRegionB but do minimal edition instead of deleting the whole region and inserting it back",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "replaceRegionClever",
          "normalized": "Region-\u003eString-\u003eBufferM()",
          "package": "yi",
          "partial": "Region Clever",
          "signature": "Region-\u003eString-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:replaceRegionClever"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap the content of two Regions\n\u003c/p\u003e",
          "module": "Yi.Buffer.Region",
          "name": "swapRegionsB",
          "package": "yi",
          "signature": "Region -\u003e Region -\u003e BufferM ()",
          "source": "src/Yi-Buffer-Region.html#swapRegionsB",
          "type": "function"
        },
        "index": {
          "description": "Swap the content of two Regions",
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "swapRegionsB",
          "normalized": "Region-\u003eRegion-\u003eBufferM()",
          "package": "yi",
          "partial": "Regions",
          "signature": "Region-\u003eRegion-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:swapRegionsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Region",
          "name": "winRegionB",
          "package": "yi",
          "signature": "BufferM Region",
          "source": "src/Yi-Buffer-Region.html#winRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Region",
          "module": "Yi.Buffer.Region",
          "name": "winRegionB",
          "package": "yi",
          "partial": "Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Region.html#v:winRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.TextUnit",
          "name": "TextUnit",
          "package": "yi",
          "source": "src/Yi-Buffer-TextUnit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Buffer TextUnit",
          "module": "Yi.Buffer.TextUnit",
          "name": "TextUnit",
          "package": "yi",
          "partial": "Text Unit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBoundary side\n\u003c/p\u003e",
          "module": "Yi.Buffer.TextUnit",
          "name": "BoundarySide",
          "package": "yi",
          "source": "src/Yi-Buffer-TextUnit.html#BoundarySide",
          "type": "data"
        },
        "index": {
          "description": "Boundary side",
          "hierarchy": "Yi Buffer TextUnit",
          "module": "Yi.Buffer.TextUnit",
          "name": "BoundarySide",
          "package": "yi",
          "partial": "Boundary Side",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#t:BoundarySide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDesignate a given \u003ca\u003eunit\u003c/a\u003e of text.\n\u003c/p\u003e",
          "module": "Yi.Buffer.TextUnit",
          "name": "TextUnit",
          "package": "yi",
          "source": "src/Yi-Buffer-TextUnit.html#TextUnit",
          "type": "data"
        },
        "index": {
          "description": "Designate given unit of text",
          "hierarchy": "Yi Buffer TextUnit",
          "module": "Yi.Buffer.TextUnit",
          "name": "TextUnit",
          "package": "yi",
          "partial": "Text Unit",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#t:TextUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.TextUnit",
          "name": "deleteUnitB",
          "package": "yi",
          "signature": "TextUnit -\u003e Direction -\u003e BufferM ()",
          "source": "src/Yi-Buffer-TextUnit.html#deleteUnitB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer TextUnit",
          "module": "Yi.Buffer.TextUnit",
          "name": "deleteUnitB",
          "normalized": "TextUnit-\u003eDirection-\u003eBufferM()",
          "package": "yi",
          "partial": "Unit",
          "signature": "TextUnit-\u003eDirection-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:deleteUnitB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.TextUnit",
          "name": "halfUnit",
          "package": "yi",
          "signature": "Direction -\u003e TextUnit -\u003e TextUnit",
          "source": "src/Yi-Buffer-TextUnit.html#halfUnit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer TextUnit",
          "module": "Yi.Buffer.TextUnit",
          "name": "halfUnit",
          "normalized": "Direction-\u003eTextUnit-\u003eTextUnit",
          "package": "yi",
          "partial": "Unit",
          "signature": "Direction-\u003eTextUnit-\u003eTextUnit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:halfUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.TextUnit",
          "name": "regionWithTwoMovesB",
          "package": "yi",
          "signature": "BufferM a -\u003e BufferM b -\u003e BufferM Region",
          "source": "src/Yi-Buffer-TextUnit.html#regionWithTwoMovesB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer TextUnit",
          "module": "Yi.Buffer.TextUnit",
          "name": "regionWithTwoMovesB",
          "normalized": "BufferM a-\u003eBufferM b-\u003eBufferM Region",
          "package": "yi",
          "partial": "With Two Moves",
          "signature": "BufferM a-\u003eBufferM b-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-TextUnit.html#v:regionWithTwoMovesB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn implementation of restricted, linear undo, as described in:\n\u003c/p\u003e\u003cpre\u003e    T. Berlage, \"A selective undo mechanism for graphical user interfaces\n    based on command objects\", ACM Transactions on Computer-Human\n    Interaction 1(3), pp. 269-294, 1994.\n\u003c/pre\u003e\u003cp\u003eImplementation based on a proposal by sjw.\n\u003c/p\u003e\u003cp\u003eFrom Berlage:\n\u003c/p\u003e\u003cpre\u003e    All buffer-mutating commands are stored (in abstract form) in an\n    Undo list. The most recent item in this list is the action that\n    will be undone next. When it is undone, it is removed from the Undo\n    list, and its inverse is added to the Redo list. The last command\n    put into the Redo list can be redone, and again prepended to the\n    Undo list. New commands are added to the Undo list without\n    affecting the Redo list.\n\u003c/pre\u003e\u003cp\u003eNow, the above assumes that commands can be _redone_ in a state other\n than that in which it was orginally done. This is not the case in our\n text editor: a user may delete, for example, between an undo and a\n redo. Berlage addresses this in S2.3. A Yi example:\n\u003c/p\u003e\u003cpre\u003e    Delete some characters\n    Undo partialy\n    Move prior in the file, and delete another _chunk_\n    Redo some things  == corruption.\n\u003c/pre\u003e\u003cp\u003eBerlage describes the \u003cem\u003estable execution property\u003c/em\u003e:\n\u003c/p\u003e\u003cpre\u003e    A command is always redone in the same state that it was originally\n    executed in, and is always undone in the state that was reached\n    after the original execution.\n\u003c/pre\u003e\u003cpre\u003e    The only case where the linear undo model violates the stable\n    execution property is when _a new command is submitted while the\n    redo list is not empty_. The _restricted linear undo model_ ...\n    clears the redo list in this case.\n\u003c/pre\u003e\u003cp\u003eAlso some discussion of this in: \u003cem\u003eThe Text Editor Sam\u003c/em\u003e, Rob Pike, pg 19.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "Undo",
          "package": "yi",
          "source": "src/Yi-Buffer-Undo.html",
          "type": "module"
        },
        "index": {
          "description": "An implementation of restricted linear undo as described in Berlage selective undo mechanism for graphical user interfaces based on command objects ACM Transactions on Computer-Human Interaction pp Implementation based on proposal by sjw From Berlage All buffer-mutating commands are stored in abstract form in an Undo list The most recent item in this list is the action that will be undone next When it is undone it is removed from the Undo list and its inverse is added to the Redo list The last command put into the Redo list can be redone and again prepended to the Undo list New commands are added to the Undo list without affecting the Redo list Now the above assumes that commands can be redone in state other than that in which it was orginally done This is not the case in our text editor user may delete for example between an undo and redo Berlage addresses this in S2.3 Yi example Delete some characters Undo partialy Move prior in the file and delete another chunk Redo some things corruption Berlage describes the stable execution property command is always redone in the same state that it was originally executed in and is always undone in the state that was reached after the original execution The only case where the linear undo model violates the stable execution property is when new command is submitted while the redo list is not empty The restricted linear undo model clears the redo list in this case Also some discussion of this in The Text Editor Sam Rob Pike pg",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "Undo",
          "package": "yi",
          "partial": "Undo",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Undo",
          "name": "Change",
          "package": "yi",
          "source": "src/Yi-Buffer-Undo.html#Change",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "Change",
          "package": "yi",
          "partial": "Change",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#t:Change"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA URList consists of an undo and a redo list.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "URList",
          "package": "yi",
          "source": "src/Yi-Buffer-Undo.html#URList",
          "type": "data"
        },
        "index": {
          "description": "URList consists of an undo and redo list",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "URList",
          "package": "yi",
          "partial": "URList",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#t:URList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Undo",
          "name": "AtomicChange",
          "package": "yi",
          "signature": "AtomicChange !Update",
          "source": "src/Yi-Buffer-Undo.html#Change",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "AtomicChange",
          "package": "yi",
          "partial": "Atomic Change",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:AtomicChange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer.Undo",
          "name": "InteractivePoint",
          "package": "yi",
          "signature": "InteractivePoint",
          "source": "src/Yi-Buffer-Undo.html#Change",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "InteractivePoint",
          "package": "yi",
          "partial": "Interactive Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:InteractivePoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd an action to the undo list.\n According to the restricted, linear undo model, if we add a command\n whilst the redo list is not empty, we will lose our redoable changes.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "addChangeU",
          "package": "yi",
          "signature": "Change -\u003e URList -\u003e URList",
          "source": "src/Yi-Buffer-Undo.html#addChangeU",
          "type": "function"
        },
        "index": {
          "description": "Add an action to the undo list According to the restricted linear undo model if we add command whilst the redo list is not empty we will lose our redoable changes",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "addChangeU",
          "normalized": "Change-\u003eURList-\u003eURList",
          "package": "yi",
          "partial": "Change",
          "signature": "Change-\u003eURList-\u003eURList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:addChangeU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA new empty \u003ccode\u003e\u003ca\u003eURList\u003c/a\u003e\u003c/code\u003e.\n Notice we must have a saved file point as this is when we assume we are\n opening the file so it is currently the same as the one on disk\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "emptyU",
          "package": "yi",
          "signature": "URList",
          "source": "src/Yi-Buffer-Undo.html#emptyU",
          "type": "function"
        },
        "index": {
          "description": "new empty URList Notice we must have saved file point as this is when we assume we are opening the file so it is currently the same as the one on disk",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "emptyU",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:emptyU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eundoIsAtSavedFilePoint. \u003ccode\u003eTrue\u003c/code\u003e if the undo list is at a SavedFilePoint indicating\n   that the buffer has not been modified since we last saved the file.\n Note: that an empty undo list does NOT mean that the buffer is not modified since\n the last save. Because we may have saved the file and then undone actions done before\n the save.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "isAtSavedFilePointU",
          "package": "yi",
          "signature": "URList -\u003e Bool",
          "source": "src/Yi-Buffer-Undo.html#isAtSavedFilePointU",
          "type": "function"
        },
        "index": {
          "description": "undoIsAtSavedFilePoint True if the undo list is at SavedFilePoint indicating that the buffer has not been modified since we last saved the file Note that an empty undo list does NOT mean that the buffer is not modified since the last save Because we may have saved the file and then undone actions done before the save",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "isAtSavedFilePointU",
          "normalized": "URList-\u003eBool",
          "package": "yi",
          "partial": "At Saved File Point",
          "signature": "URList-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:isAtSavedFilePointU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis redoes one iteraction step.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "redoU",
          "package": "yi",
          "signature": "Mark -\u003e URList -\u003e BufferImpl syntax -\u003e (BufferImpl syntax, (URList, [Update]))",
          "source": "src/Yi-Buffer-Undo.html#redoU",
          "type": "function"
        },
        "index": {
          "description": "This redoes one iteraction step",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "redoU",
          "normalized": "Mark-\u003eURList-\u003eBufferImpl a-\u003e(BufferImpl a,(URList,[Update]))",
          "package": "yi",
          "signature": "Mark-\u003eURList-\u003eBufferImpl syntax-\u003e(BufferImpl syntax,(URList,[Update]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:redoU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a saved file point so that we can tell that the buffer has not\n been modified since the previous saved file point.\n Notice that we must be sure to remove the previous saved file points\n since they are now worthless.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "setSavedFilePointU",
          "package": "yi",
          "signature": "URList -\u003e URList",
          "source": "src/Yi-Buffer-Undo.html#setSavedFilePointU",
          "type": "function"
        },
        "index": {
          "description": "Add saved file point so that we can tell that the buffer has not been modified since the previous saved file point Notice that we must be sure to remove the previous saved file points since they are now worthless",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "setSavedFilePointU",
          "normalized": "URList-\u003eURList",
          "package": "yi",
          "partial": "Saved File Point",
          "signature": "URList-\u003eURList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:setSavedFilePointU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis undoes one interaction step.\n\u003c/p\u003e",
          "module": "Yi.Buffer.Undo",
          "name": "undoU",
          "package": "yi",
          "signature": "Mark -\u003e URList -\u003e BufferImpl syntax -\u003e (BufferImpl syntax, (URList, [Update]))",
          "source": "src/Yi-Buffer-Undo.html#undoU",
          "type": "function"
        },
        "index": {
          "description": "This undoes one interaction step",
          "hierarchy": "Yi Buffer Undo",
          "module": "Yi.Buffer.Undo",
          "name": "undoU",
          "normalized": "Mark-\u003eURList-\u003eBufferImpl a-\u003e(BufferImpl a,(URList,[Update]))",
          "package": "yi",
          "signature": "Mark-\u003eURList-\u003eBufferImpl syntax-\u003e(BufferImpl syntax,(URList,[Update]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer-Undo.html#v:undoU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe \u003ccode\u003eBuffer\u003c/code\u003e module defines monadic editing operations over one-dimensional\n buffers, maintaining a current \u003cem\u003epoint\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eThis module acts as a Facade for the Buffer.* modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Buffer",
          "name": "Buffer",
          "package": "yi",
          "source": "src/Yi-Buffer.html",
          "type": "module"
        },
        "index": {
          "description": "The Buffer module defines monadic editing operations over one-dimensional buffers maintaining current point This module acts as Facade for the Buffer modules",
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "Buffer",
          "package": "yi",
          "partial": "Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "UIUpdate",
          "package": "yi",
          "source": "src/Yi-Buffer-Implementation.html#UIUpdate",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "UIUpdate",
          "package": "yi",
          "partial": "UIUpdate",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#t:UIUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMutation actions (also used the undo or redo list)\n\u003c/p\u003e\u003cp\u003eFor the undo\u003cem\u003eredo, we use the \u003c/em\u003epartial checkpoint/ (Berlage, pg16) strategy to store\n just the components of the state that change.\n\u003c/p\u003e\u003cp\u003eNote that the update direction is only a hint for moving the cursor\n (mainly for undo purposes); the insertions and deletions are always\n applied Forward.\n\u003c/p\u003e",
          "module": "Yi.Buffer",
          "name": "Update",
          "package": "yi",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "data"
        },
        "index": {
          "description": "Mutation actions also used the undo or redo list For the undo redo we use the partial checkpoint Berlage pg16 strategy to store just the components of the state that change Note that the update direction is only hint for moving the cursor mainly for undo purposes the insertions and deletions are always applied Forward",
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "Update",
          "package": "yi",
          "partial": "Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#t:Update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "Delete",
          "package": "yi",
          "signature": "Delete",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "Delete",
          "package": "yi",
          "partial": "Delete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:Delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "Insert",
          "package": "yi",
          "signature": "Insert",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "Insert",
          "package": "yi",
          "partial": "Insert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:Insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "StyleUpdate",
          "package": "yi",
          "signature": "StyleUpdate !Point !Size",
          "source": "src/Yi-Buffer-Implementation.html#UIUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "StyleUpdate",
          "package": "yi",
          "partial": "Style Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:StyleUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "TextUpdate",
          "package": "yi",
          "signature": "TextUpdate !Update",
          "source": "src/Yi-Buffer-Implementation.html#UIUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "TextUpdate",
          "package": "yi",
          "partial": "Text Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:TextUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "deleteUpdateString",
          "package": "yi",
          "signature": "Rope",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "deleteUpdateString",
          "package": "yi",
          "partial": "Update String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:deleteUpdateString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "insertUpdateString",
          "package": "yi",
          "signature": "Rope",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "insertUpdateString",
          "package": "yi",
          "partial": "Update String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:insertUpdateString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "updateDirection",
          "package": "yi",
          "signature": "Direction",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "updateDirection",
          "package": "yi",
          "partial": "Direction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:updateDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "updateIsDelete",
          "package": "yi",
          "signature": "Update -\u003e Bool",
          "source": "src/Yi-Buffer-Implementation.html#updateIsDelete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "updateIsDelete",
          "normalized": "Update-\u003eBool",
          "package": "yi",
          "partial": "Is Delete",
          "signature": "Update-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:updateIsDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Buffer",
          "name": "updatePoint",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Buffer-Implementation.html#Update",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Buffer",
          "module": "Yi.Buffer",
          "name": "updatePoint",
          "package": "yi",
          "partial": "Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Buffer.html#v:updatePoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "Unicode",
          "package": "yi",
          "source": "src/Yi-Char-Unicode.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "Unicode",
          "package": "yi",
          "partial": "Unicode",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "checkAmbs",
          "package": "yi",
          "signature": "[(String, String)] -\u003e [(String, String)]",
          "source": "src/Yi-Char-Unicode.html#checkAmbs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "checkAmbs",
          "normalized": "[(String,String)]-\u003e[(String,String)]",
          "package": "yi",
          "partial": "Ambs",
          "signature": "[(String,String)]-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#v:checkAmbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "disamb",
          "package": "yi",
          "signature": "[(String, String)] -\u003e [(String, String)]",
          "source": "src/Yi-Char-Unicode.html#disamb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "disamb",
          "normalized": "[(String,String)]-\u003e[(String,String)]",
          "package": "yi",
          "signature": "[(String,String)]-\u003e[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#v:disamb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "greek",
          "package": "yi",
          "signature": "[(String, String)]",
          "source": "src/Yi-Char-Unicode.html#greek",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "greek",
          "normalized": "[(String,String)]",
          "package": "yi",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#v:greek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "subscripts",
          "package": "yi",
          "signature": "[(String, String)]",
          "source": "src/Yi-Char-Unicode.html#subscripts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "subscripts",
          "normalized": "[(String,String)]",
          "package": "yi",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#v:subscripts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "superscripts",
          "package": "yi",
          "signature": "[(String, String)]",
          "source": "src/Yi-Char-Unicode.html#superscripts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "superscripts",
          "normalized": "[(String,String)]",
          "package": "yi",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#v:superscripts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Char.Unicode",
          "name": "symbols",
          "package": "yi",
          "signature": "[(String, String)]",
          "source": "src/Yi-Char-Unicode.html#symbols",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Char Unicode",
          "module": "Yi.Char.Unicode",
          "name": "symbols",
          "normalized": "[(String,String)]",
          "package": "yi",
          "signature": "[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Char-Unicode.html#v:symbols"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious high-level functions to further classify.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Command",
          "name": "Command",
          "package": "yi",
          "source": "src/Yi-Command.html",
          "type": "module"
        },
        "index": {
          "description": "Various high-level functions to further classify",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "Command",
          "package": "yi",
          "partial": "Command",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "CabalBuffer",
          "package": "yi",
          "source": "src/Yi-Command.html#CabalBuffer",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "CabalBuffer",
          "package": "yi",
          "partial": "Cabal Buffer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#t:CabalBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "CabalBuffer",
          "package": "yi",
          "signature": "CabalBuffer",
          "source": "src/Yi-Command.html#CabalBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "CabalBuffer",
          "package": "yi",
          "partial": "Cabal Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:CabalBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun the given commands with args and pipe the ouput into the build buffer,\n which is shown in an other window.\n\u003c/p\u003e",
          "module": "Yi.Command",
          "name": "buildRun",
          "package": "yi",
          "signature": "String -\u003e [String] -\u003e (Either SomeException ExitCode -\u003e YiM x) -\u003e YiM ()",
          "source": "src/Yi-Command.html#buildRun",
          "type": "function"
        },
        "index": {
          "description": "Run the given commands with args and pipe the ouput into the build buffer which is shown in an other window",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "buildRun",
          "normalized": "String-\u003e[String]-\u003e(Either SomeException ExitCode-\u003eYiM a)-\u003eYiM()",
          "package": "yi",
          "partial": "Run",
          "signature": "String-\u003e[String]-\u003e(Either SomeException ExitCode-\u003eYiM x)-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:buildRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "cabalBuffer",
          "package": "yi",
          "signature": "Maybe BufferRef",
          "source": "src/Yi-Command.html#CabalBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "cabalBuffer",
          "package": "yi",
          "partial": "Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:cabalBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecabal-build\n\u003c/p\u003e",
          "module": "[\"Yi.Command\",\"Yi.Keymap.Emacs.Utils\"]",
          "name": "cabalBuildE",
          "package": "yi",
          "signature": "CommandArguments -\u003e YiM ()",
          "source": "src/Yi-Command.html#cabalBuildE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:cabalBuildE\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:cabalBuildE\"]"
        },
        "index": {
          "description": "cabal-build",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "cabalBuildE",
          "normalized": "CommandArguments-\u003eYiM()",
          "package": "yi",
          "partial": "Build",
          "signature": "CommandArguments-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:cabalBuildE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecabal-configure\n\u003c/p\u003e",
          "module": "[\"Yi.Command\",\"Yi.Keymap.Emacs.Utils\"]",
          "name": "cabalConfigureE",
          "package": "yi",
          "signature": "CommandArguments -\u003e YiM ()",
          "source": "src/Yi-Command.html#cabalConfigureE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:cabalConfigureE\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:cabalConfigureE\"]"
        },
        "index": {
          "description": "cabal-configure",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "cabalConfigureE",
          "normalized": "CommandArguments-\u003eYiM()",
          "package": "yi",
          "partial": "Configure",
          "signature": "CommandArguments-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:cabalConfigureE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "cabalRun",
          "package": "yi",
          "signature": "String -\u003e (Either SomeException ExitCode -\u003e YiM x) -\u003e CommandArguments -\u003e YiM ()",
          "source": "src/Yi-Command.html#cabalRun",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "cabalRun",
          "normalized": "String-\u003e(Either SomeException ExitCode-\u003eYiM a)-\u003eCommandArguments-\u003eYiM()",
          "package": "yi",
          "partial": "Run",
          "signature": "String-\u003e(Either SomeException ExitCode-\u003eYiM x)-\u003eCommandArguments-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:cabalRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChanging the buffer name quite useful if you have\n several the same. This also breaks the relation with the file.\n\u003c/p\u003e",
          "module": "Yi.Command",
          "name": "changeBufferNameE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Command.html#changeBufferNameE",
          "type": "function"
        },
        "index": {
          "description": "Changing the buffer name quite useful if you have several the same This also breaks the relation with the file",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "changeBufferNameE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Buffer Name",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:changeBufferNameE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "configureExit",
          "package": "yi",
          "signature": "Either SomeException ExitCode -\u003e YiM ()",
          "source": "src/Yi-Command.html#configureExit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "configureExit",
          "normalized": "Either SomeException ExitCode-\u003eYiM()",
          "package": "yi",
          "partial": "Exit",
          "signature": "Either SomeException ExitCode-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:configureExit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform a find+grep operation\n\u003c/p\u003e",
          "module": "Yi.Command",
          "name": "grepFind",
          "package": "yi",
          "signature": "RegexTag) -\u003e YiM ()",
          "source": "src/Yi-Command.html#grepFind",
          "type": "function"
        },
        "index": {
          "description": "Perform find grep operation",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "grepFind",
          "normalized": "RegexTag)-\u003eYiM()",
          "package": "yi",
          "partial": "Find",
          "signature": "RegexTag)-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:grepFind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "makeBuild",
          "package": "yi",
          "signature": "CommandArguments -\u003e YiM ()",
          "source": "src/Yi-Command.html#makeBuild",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "makeBuild",
          "normalized": "CommandArguments-\u003eYiM()",
          "package": "yi",
          "partial": "Build",
          "signature": "CommandArguments-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:makeBuild"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Command\",\"Yi.Keymap.Emacs.Utils\"]",
          "name": "reloadProjectE",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Command.html#reloadProjectE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:reloadProjectE\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:reloadProjectE\"]"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "reloadProjectE",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Project",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:reloadProjectE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch the source files in the project.\n\u003c/p\u003e",
          "module": "Yi.Command",
          "name": "searchSources",
          "package": "yi",
          "signature": "RegexTag) -\u003e YiM ()",
          "source": "src/Yi-Command.html#searchSources",
          "type": "function"
        },
        "index": {
          "description": "Search the source files in the project",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "searchSources",
          "normalized": "RegexTag)-\u003eYiM()",
          "package": "yi",
          "partial": "Sources",
          "signature": "RegexTag)-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:searchSources"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Command",
          "name": "shell",
          "package": "yi",
          "signature": "YiM BufferRef",
          "source": "src/Yi-Command.html#shell",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "shell",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:shell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshell-command with argument prompt\n\u003c/p\u003e",
          "module": "Yi.Command",
          "name": "shellCommandE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Command.html#shellCommandE",
          "type": "function"
        },
        "index": {
          "description": "shell-command with argument prompt",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "shellCommandE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Command",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:shellCommandE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eshell-command with a known argument\n\u003c/p\u003e",
          "module": "Yi.Command",
          "name": "shellCommandV",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Command.html#shellCommandV",
          "type": "function"
        },
        "index": {
          "description": "shell-command with known argument",
          "hierarchy": "Yi Command",
          "module": "Yi.Command",
          "name": "shellCommandV",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Command",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Command.html#v:shellCommandV"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Completion",
          "name": "Completion",
          "package": "yi",
          "source": "src/Yi-Completion.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "Completion",
          "package": "yi",
          "partial": "Completion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the longest common prefix of a set of lists.\n\u003c/p\u003e\u003cpre\u003e P(xs) === all (isPrefixOf (commonPrefix xs)) xs\n length s \u003e length (commonPrefix xs) --\u003e not (all (isPrefixOf s) xs)\n\u003c/pre\u003e",
          "module": "[\"Yi.Completion\",\"Yi.Prelude\"]",
          "name": "commonPrefix",
          "package": "yi",
          "signature": "[[a]] -\u003e [a]",
          "source": "src/Yi-Prelude.html#commonPrefix",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:commonPrefix\",\"http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:commonPrefix\"]"
        },
        "index": {
          "description": "Return the longest common prefix of set of lists xs all isPrefixOf commonPrefix xs xs length length commonPrefix xs not all isPrefixOf xs",
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "commonPrefix",
          "normalized": "[[a]]-\u003e[a]",
          "package": "yi",
          "partial": "Prefix",
          "signature": "[[a]]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:commonPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplete a string given a user input string, a matching function\n and a list of possibilites.  Matching function should return the\n part of the string that matches the user string.\n\u003c/p\u003e",
          "module": "Yi.Completion",
          "name": "completeInList",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e Maybe String) -\u003e [String] -\u003e EditorM String",
          "source": "src/Yi-Completion.html#completeInList",
          "type": "function"
        },
        "index": {
          "description": "Complete string given user input string matching function and list of possibilites Matching function should return the part of the string that matches the user string",
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "completeInList",
          "normalized": "String-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String",
          "package": "yi",
          "partial": "In List",
          "signature": "String-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:completeInList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Completion",
          "name": "completeInList'",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e Maybe String) -\u003e [String] -\u003e EditorM String",
          "source": "src/Yi-Completion.html#completeInList%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "completeInList'",
          "normalized": "String-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String",
          "package": "yi",
          "partial": "In List'",
          "signature": "String-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:completeInList-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003ecompleteInList\u003c/a\u003e\u003c/code\u003e, but maps \u003ccode\u003eshowFunction\u003c/code\u003e on possible matches when printing\n\u003c/p\u003e",
          "module": "Yi.Completion",
          "name": "completeInListCustomShow",
          "package": "yi",
          "signature": "(String -\u003e String) -\u003e String -\u003e (String -\u003e Maybe String) -\u003e [String] -\u003e EditorM String",
          "source": "src/Yi-Completion.html#completeInListCustomShow",
          "type": "function"
        },
        "index": {
          "description": "Same as completeInList but maps showFunction on possible matches when printing",
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "completeInListCustomShow",
          "normalized": "(String-\u003eString)-\u003eString-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String",
          "package": "yi",
          "partial": "In List Custom Show",
          "signature": "(String-\u003eString)-\u003eString-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:completeInListCustomShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Completion",
          "name": "containsMatch",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Yi-Completion.html#containsMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "containsMatch",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "yi",
          "partial": "Match",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:containsMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Completion",
          "name": "containsMatch'",
          "package": "yi",
          "signature": "Bool -\u003e String -\u003e String -\u003e Maybe String",
          "source": "src/Yi-Completion.html#containsMatch%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "containsMatch'",
          "normalized": "Bool-\u003eString-\u003eString-\u003eMaybe String",
          "package": "yi",
          "partial": "Match'",
          "signature": "Bool-\u003eString-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:containsMatch-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Completion",
          "name": "containsMatchCaseInsensitive",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Yi-Completion.html#containsMatchCaseInsensitive",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "containsMatchCaseInsensitive",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "yi",
          "partial": "Match Case Insensitive",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:containsMatchCaseInsensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix matching function, for use with \u003ccode\u003e\u003ca\u003ecompleteInList\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Completion",
          "name": "infixMatch",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Yi-Completion.html#infixMatch",
          "type": "function"
        },
        "index": {
          "description": "Infix matching function for use with completeInList",
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "infixMatch",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "yi",
          "partial": "Match",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:infixMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Completion",
          "name": "mkIsPrefixOf",
          "package": "yi",
          "signature": "Bool -\u003e String -\u003e String -\u003e Bool",
          "source": "src/Yi-Completion.html#mkIsPrefixOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "mkIsPrefixOf",
          "normalized": "Bool-\u003eString-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Is Prefix Of",
          "signature": "Bool-\u003eString-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:mkIsPrefixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrefix matching function, for use with \u003ccode\u003e\u003ca\u003ecompleteInList\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Completion",
          "name": "prefixMatch",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Yi-Completion.html#prefixMatch",
          "type": "function"
        },
        "index": {
          "description": "Prefix matching function for use with completeInList",
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "prefixMatch",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "yi",
          "partial": "Match",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:prefixMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExample: \u003ca\u003eabc\u003c/a\u003e matches \u003ca\u003ea1b2c\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Yi.Completion",
          "name": "subsequenceMatch",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Bool",
          "source": "src/Yi-Completion.html#subsequenceMatch",
          "type": "function"
        },
        "index": {
          "description": "Example abc matches a1b2c",
          "hierarchy": "Yi Completion",
          "module": "Yi.Completion",
          "name": "subsequenceMatch",
          "normalized": "String-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Match",
          "signature": "String-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Completion.html#v:subsequenceMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "Default",
          "package": "yi",
          "source": "src/Yi-Config-Default.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "Default",
          "package": "yi",
          "partial": "Default",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "availableFrontends",
          "package": "yi",
          "signature": "[(String, UIBoot)]",
          "source": "src/Yi-Config-Default.html#availableFrontends",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "availableFrontends",
          "normalized": "[(String,UIBoot)]",
          "package": "yi",
          "partial": "Frontends",
          "signature": "[(String,UIBoot)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:availableFrontends"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "defaultConfig",
          "package": "yi",
          "signature": "Config",
          "source": "src/Yi-Config-Default.html#defaultConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "defaultConfig",
          "package": "yi",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:defaultConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "defaultCuaConfig",
          "package": "yi",
          "signature": "Config",
          "source": "src/Yi-Config-Default.html#defaultCuaConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "defaultCuaConfig",
          "package": "yi",
          "partial": "Cua Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:defaultCuaConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "defaultEmacsConfig",
          "package": "yi",
          "signature": "Config",
          "source": "src/Yi-Config-Default.html#defaultEmacsConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "defaultEmacsConfig",
          "package": "yi",
          "partial": "Emacs Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:defaultEmacsConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "defaultVimConfig",
          "package": "yi",
          "signature": "Config",
          "source": "src/Yi-Config-Default.html#defaultVimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "defaultVimConfig",
          "package": "yi",
          "partial": "Vim Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:defaultVimConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "toCuaStyleConfig",
          "package": "yi",
          "signature": "Config -\u003e Config",
          "source": "src/Yi-Config-Default.html#toCuaStyleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "toCuaStyleConfig",
          "normalized": "Config-\u003eConfig",
          "package": "yi",
          "partial": "Cua Style Config",
          "signature": "Config-\u003eConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:toCuaStyleConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "toEmacsStyleConfig",
          "package": "yi",
          "signature": "Config -\u003e Config",
          "source": "src/Yi-Config-Default.html#toEmacsStyleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "toEmacsStyleConfig",
          "normalized": "Config-\u003eConfig",
          "package": "yi",
          "partial": "Emacs Style Config",
          "signature": "Config-\u003eConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:toEmacsStyleConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "toVim2StyleConfig",
          "package": "yi",
          "signature": "Config -\u003e Config",
          "source": "src/Yi-Config-Default.html#toVim2StyleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "toVim2StyleConfig",
          "normalized": "Config-\u003eConfig",
          "package": "yi",
          "partial": "Vim Style Config",
          "signature": "Config-\u003eConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:toVim2StyleConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Default",
          "name": "toVimStyleConfig",
          "package": "yi",
          "signature": "Config -\u003e Config",
          "source": "src/Yi-Config-Default.html#toVimStyleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Default",
          "module": "Yi.Config.Default",
          "name": "toVimStyleConfig",
          "normalized": "Config-\u003eConfig",
          "package": "yi",
          "partial": "Vim Style Config",
          "signature": "Config-\u003eConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Default.html#v:toVimStyleConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Misc",
          "name": "Misc",
          "package": "yi",
          "source": "src/Yi-Config-Misc.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Config Misc",
          "module": "Yi.Config.Misc",
          "name": "Misc",
          "package": "yi",
          "partial": "Misc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Misc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Misc",
          "name": "ScrollStyle",
          "package": "yi",
          "source": "src/Yi-Config-Misc.html#ScrollStyle",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Config Misc",
          "module": "Yi.Config.Misc",
          "name": "ScrollStyle",
          "package": "yi",
          "partial": "Scroll Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Misc.html#t:ScrollStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Config.Misc\",\"Yi.Config.Simple\"]",
          "name": "SingleLine",
          "package": "yi",
          "signature": "SingleLine",
          "source": "src/Yi-Config-Misc.html#ScrollStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Misc.html#v:SingleLine\",\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:SingleLine\"]"
        },
        "index": {
          "hierarchy": "Yi Config Misc",
          "module": "Yi.Config.Misc",
          "name": "SingleLine",
          "package": "yi",
          "partial": "Single Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Misc.html#v:SingleLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Config.Misc\",\"Yi.Config.Simple\"]",
          "name": "SnapToCenter",
          "package": "yi",
          "signature": "SnapToCenter",
          "source": "src/Yi-Config-Misc.html#ScrollStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Misc.html#v:SnapToCenter\",\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:SnapToCenter\"]"
        },
        "index": {
          "hierarchy": "Yi Config Misc",
          "module": "Yi.Config.Misc",
          "name": "SnapToCenter",
          "package": "yi",
          "partial": "Snap To Center",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Misc.html#v:SnapToCenter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eexports from \u003ca\u003eYi.Config.Simple\u003c/a\u003e which are useful to \"core yi\" rather than just config files.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Config.Simple.Types",
          "name": "Types",
          "package": "yi",
          "source": "src/Yi-Config-Simple-Types.html",
          "type": "module"
        },
        "index": {
          "description": "exports from Yi.Config.Simple which are useful to core yi rather than just config files",
          "hierarchy": "Yi Config Simple Types",
          "module": "Yi.Config.Simple.Types",
          "name": "Types",
          "package": "yi",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe configuration monad. Run it with \u003ccode\u003econfigMain\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple.Types",
          "name": "ConfigM",
          "package": "yi",
          "source": "src/Yi-Config-Simple-Types.html#ConfigM",
          "type": "newtype"
        },
        "index": {
          "description": "The configuration monad Run it with configMain",
          "hierarchy": "Yi Config Simple Types",
          "module": "Yi.Config.Simple.Types",
          "name": "ConfigM",
          "package": "yi",
          "partial": "Config",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#t:ConfigM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFields that can be modified with (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003emodify\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple.Types",
          "name": "Field",
          "package": "yi",
          "source": "src/Yi-Config-Simple-Types.html#Field",
          "type": "type"
        },
        "index": {
          "description": "Fields that can be modified with get and modify",
          "hierarchy": "Yi Config Simple Types",
          "module": "Yi.Config.Simple.Types",
          "name": "Field",
          "package": "yi",
          "partial": "Field",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Simple.Types",
          "name": "ConfigM",
          "package": "yi",
          "signature": "ConfigM",
          "source": "src/Yi-Config-Simple-Types.html#ConfigM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Simple Types",
          "module": "Yi.Config.Simple.Types",
          "name": "ConfigM",
          "package": "yi",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#v:ConfigM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for any \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003e, to be used by modules defining\n\u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003es. Such modules should provide a custom-named field.\nFor instance, take the following hypothetical \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003enewtype UserName = UserName { unUserName :: String }\n  deriving(Typeable, Binary, Initializable)\ninstance YiConfigVariable UserName\n\n$(nameDeriveAccessors ''UserName (n -\u003e Just (n ++ \"A\")))\n\nuserName :: \u003ccode\u003e\u003ca\u003eField\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e\nuserName = unUserNameA \u003ccode\u003e\u003ca\u003e.\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ecustomVariable\u003c/a\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eHere, the hypothetical library would provide the field \u003ccode\u003euserName\u003c/code\u003e to be used in preference to \u003ccode\u003ecustomVariable\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Yi.Config.Simple.Types\",\"Yi.Hooks\"]",
          "name": "customVariable",
          "package": "yi",
          "signature": "Field a",
          "source": "src/Yi-Config-Simple-Types.html#customVariable",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#v:customVariable\",\"http://hackage.haskell.org/package/yi/docs/Yi-Hooks.html#v:customVariable\"]"
        },
        "index": {
          "description": "Accessor for any YiConfigVariable to be used by modules defining YiConfigVariable Such modules should provide custom-named field For instance take the following hypothetical YiConfigVariable newtype UserName UserName unUserName String deriving Typeable Binary Initializable instance YiConfigVariable UserName nameDeriveAccessors UserName Just userName Field String userName unUserNameA customVariable Here the hypothetical library would provide the field userName to be used in preference to customVariable",
          "hierarchy": "Yi Config Simple Types",
          "module": "Yi.Config.Simple.Types",
          "name": "customVariable",
          "package": "yi",
          "partial": "Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#v:customVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Simple.Types",
          "name": "runConfigM",
          "package": "yi",
          "signature": "StateT Config IO a",
          "source": "src/Yi-Config-Simple-Types.html#ConfigM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Simple Types",
          "module": "Yi.Config.Simple.Types",
          "name": "runConfigM",
          "package": "yi",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple-Types.html#v:runConfigM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simplified configuration interface for Yi. \n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Config.Simple",
          "name": "Simple",
          "package": "yi",
          "source": "src/Yi-Config-Simple.html",
          "type": "module"
        },
        "index": {
          "description": "simplified configuration interface for Yi",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "Simple",
          "package": "yi",
          "partial": "Simple",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe configuration monad. Run it with \u003ccode\u003econfigMain\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "ConfigM",
          "package": "yi",
          "source": "src/Yi-Config-Simple-Types.html#ConfigM",
          "type": "data"
        },
        "index": {
          "description": "The configuration monad Run it with configMain",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "ConfigM",
          "package": "yi",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#t:ConfigM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen should we use a \"fat\" cursor (i.e. 2 pixels wide, rather than 1)? Fat cursors have only been implemented for the Pango frontend.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "CursorStyle",
          "package": "yi",
          "source": "src/Yi-Config.html#CursorStyle",
          "type": "data"
        },
        "index": {
          "description": "When should we use fat cursor i.e pixels wide rather than Fat cursors have only been implemented for the Pango frontend",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "CursorStyle",
          "package": "yi",
          "partial": "Cursor Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#t:CursorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFields that can be modified with (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003emodify\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "Field",
          "package": "yi",
          "source": "src/Yi-Config-Simple-Types.html#Field",
          "type": "type"
        },
        "index": {
          "description": "Fields that can be modified with get and modify",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "Field",
          "package": "yi",
          "partial": "Field",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Simple",
          "name": "ScrollStyle",
          "package": "yi",
          "source": "src/Yi-Config-Misc.html#ScrollStyle",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "ScrollStyle",
          "package": "yi",
          "partial": "Scroll Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#t:ScrollStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Simple",
          "name": "Side",
          "package": "yi",
          "source": "src/Yi-Config-Simple.html#Side",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "Side",
          "package": "yi",
          "partial": "Side",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#t:Side"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a field.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "(%=)",
          "package": "yi",
          "signature": "Field a -\u003e a -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#%25%3D",
          "type": "function"
        },
        "index": {
          "description": "Set field",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "(%=) %=",
          "normalized": "Field a-\u003ea-\u003eConfigM()",
          "package": "yi",
          "signature": "Field a-\u003ea-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:-37--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Config.Simple\",\"Yi.Config\"]",
          "name": "AlwaysFat",
          "package": "yi",
          "signature": "AlwaysFat",
          "source": "src/Yi-Config.html#CursorStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:AlwaysFat\",\"http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:AlwaysFat\"]"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "AlwaysFat",
          "package": "yi",
          "partial": "Always Fat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:AlwaysFat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Config.Simple\",\"Yi.Config\"]",
          "name": "FatWhenFocused",
          "package": "yi",
          "signature": "FatWhenFocused",
          "source": "src/Yi-Config.html#CursorStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:FatWhenFocused\",\"http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:FatWhenFocused\"]"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "FatWhenFocused",
          "package": "yi",
          "partial": "Fat When Focused",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:FatWhenFocused"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Config.Simple\",\"Yi.Config\"]",
          "name": "FatWhenFocusedAndInserting",
          "package": "yi",
          "signature": "FatWhenFocusedAndInserting",
          "source": "src/Yi-Config.html#CursorStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:FatWhenFocusedAndInserting\",\"http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:FatWhenFocusedAndInserting\"]"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "FatWhenFocusedAndInserting",
          "package": "yi",
          "partial": "Fat When Focused And Inserting",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:FatWhenFocusedAndInserting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Simple",
          "name": "LeftSide",
          "package": "yi",
          "signature": "LeftSide",
          "source": "src/Yi-Config-Simple.html#Side",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "LeftSide",
          "package": "yi",
          "partial": "Left Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:LeftSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Config.Simple\",\"Yi.Config\"]",
          "name": "NeverFat",
          "package": "yi",
          "signature": "NeverFat",
          "source": "src/Yi-Config.html#CursorStyle",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:NeverFat\",\"http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:NeverFat\"]"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "NeverFat",
          "package": "yi",
          "partial": "Never Fat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:NeverFat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config.Simple",
          "name": "RightSide",
          "package": "yi",
          "signature": "RightSide",
          "source": "src/Yi-Config-Simple.html#Side",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "RightSide",
          "package": "yi",
          "partial": "Right Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:RightSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegister the given mode. It will be preferred over any modes already defined.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "addMode",
          "package": "yi",
          "signature": "Mode syntax -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#addMode",
          "type": "function"
        },
        "index": {
          "description": "Register the given mode It will be preferred over any modes already defined",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "addMode",
          "normalized": "Mode a-\u003eConfigM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "Mode syntax-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:addMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould the scroll bar autohide?\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "autoHideScrollBar",
          "package": "yi",
          "signature": "Field Bool",
          "source": "src/Yi-Config-Simple.html#autoHideScrollBar",
          "type": "function"
        },
        "index": {
          "description": "Should the scroll bar autohide",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "autoHideScrollBar",
          "package": "yi",
          "partial": "Hide Scroll Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:autoHideScrollBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould the tab bar autohide?\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "autoHideTabBar",
          "package": "yi",
          "signature": "Field Bool",
          "source": "src/Yi-Config-Simple.html#autoHideTabBar",
          "type": "function"
        },
        "index": {
          "description": "Should the tab bar autohide",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "autoHideTabBar",
          "package": "yi",
          "partial": "Hide Tab Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:autoHideTabBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e?\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "bufferUpdateHandler",
          "package": "yi",
          "signature": "Field [[Update] -\u003e BufferM ()]",
          "source": "src/Yi-Config-Simple.html#bufferUpdateHandler",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "bufferUpdateHandler",
          "normalized": "Field[[Update]-\u003eBufferM()]",
          "package": "yi",
          "partial": "Update Handler",
          "signature": "Field[[Update]-\u003eBufferM()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:bufferUpdateHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStarts with the given initial config, makes the described modifications, then starts yi.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "configMain",
          "package": "yi",
          "signature": "Config -\u003e ConfigM () -\u003e IO ()",
          "source": "src/Yi-Config-Simple.html#configMain",
          "type": "function"
        },
        "index": {
          "description": "Starts with the given initial config makes the described modifications then starts yi",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "configMain",
          "normalized": "Config-\u003eConfigM()-\u003eIO()",
          "package": "yi",
          "partial": "Main",
          "signature": "Config-\u003eConfigM()-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:configMain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSee \u003ccode\u003e\u003ca\u003eCursorStyle\u003c/a\u003e\u003c/code\u003e for documentation.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "cursorStyle",
          "package": "yi",
          "signature": "Field CursorStyle",
          "source": "src/Yi-Config-Simple.html#cursorStyle",
          "type": "function"
        },
        "index": {
          "description": "See CursorStyle for documentation",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "cursorStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:cursorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduce a .yi.dbg file with debugging information?\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "debug",
          "package": "yi",
          "signature": "Field Bool",
          "source": "src/Yi-Config-Simple.html#debug",
          "type": "function"
        },
        "index": {
          "description": "Produce yi.dbg file with debugging information",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "debug",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:debug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault keymap to use.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "defaultKm",
          "package": "yi",
          "signature": "Field KeymapSet",
          "source": "src/Yi-Config-Simple.html#defaultKm",
          "type": "function"
        },
        "index": {
          "description": "Default keymap to use",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "defaultKm",
          "package": "yi",
          "partial": "Km",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:defaultKm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe evaluator to use for \u003ccode\u003e\u003ca\u003eexecEditorAction\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003egetAllNamesInScope\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Yi.Config.Simple\",\"Yi.Eval\"]",
          "name": "evaluator",
          "package": "yi",
          "signature": "Field Evaluator",
          "source": "src/Yi-Eval.html#evaluator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:evaluator\",\"http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:evaluator\"]"
        },
        "index": {
          "description": "The evaluator to use for execEditorAction and getAllNamesInScope",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "evaluator",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:evaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the font name, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for default.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "fontName",
          "package": "yi",
          "signature": "Field (Maybe String)",
          "source": "src/Yi-Config-Simple.html#fontName",
          "type": "function"
        },
        "index": {
          "description": "Just the font name or Nothing for default",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "fontName",
          "package": "yi",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:fontName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the font size, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for default.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "fontSize",
          "package": "yi",
          "signature": "Field (Maybe Int)",
          "source": "src/Yi-Config-Simple.html#fontSize",
          "type": "function"
        },
        "index": {
          "description": "Just the font size or Nothing for default",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "fontSize",
          "package": "yi",
          "partial": "Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:fontSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet a field.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "get",
          "package": "yi",
          "signature": "Field a -\u003e ConfigM a",
          "source": "src/Yi-Config-Simple.html#get",
          "type": "function"
        },
        "index": {
          "description": "Get field",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "get",
          "normalized": "Field a-\u003eConfigM a",
          "package": "yi",
          "signature": "Field a-\u003eConfigM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:get"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluator implemented by calling GHCi. This evaluator can run arbitrary expressions in the class \u003ccode\u003e\u003ca\u003eYiAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe following two imports are always present:\n\u003c/p\u003e\u003cpre\u003e import Yi\n import qualified Yi.Keymap as Yi.Keymap\n\u003c/pre\u003e\u003cp\u003eAlso, if the file \n\u003c/p\u003e\u003cpre\u003e $HOME/.config/yi/local/Env.hs\n\u003c/pre\u003e\u003cp\u003eexists, it is imported unqualified.\n\u003c/p\u003e",
          "module": "[\"Yi.Config.Simple\",\"Yi.Eval\"]",
          "name": "ghciEvaluator",
          "package": "yi",
          "signature": "Evaluator",
          "source": "src/Yi-Eval.html#ghciEvaluator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:ghciEvaluator\",\"http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:ghciEvaluator\"]"
        },
        "index": {
          "description": "Evaluator implemented by calling GHCi This evaluator can run arbitrary expressions in the class YiAction The following two imports are always present import Yi import qualified Yi.Keymap as Yi.Keymap Also if the file HOME config yi local Env.hs exists it is imported unqualified",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "ghciEvaluator",
          "package": "yi",
          "partial": "Evaluator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:ghciEvaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds the given key bindings to the `global keymap'. The bindings will override existing bindings in the case of a clash.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "globalBindKeys",
          "package": "yi",
          "signature": "Keymap -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#globalBindKeys",
          "type": "function"
        },
        "index": {
          "description": "Adds the given key bindings to the global keymap The bindings will override existing bindings in the case of clash",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "globalBindKeys",
          "normalized": "Keymap-\u003eConfigM()",
          "package": "yi",
          "partial": "Bind Keys",
          "signature": "Keymap-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:globalBindKeys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActions to run after startup or reload. Consider using \u003ccode\u003e\u003ca\u003erunAfterStartup\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003erunManyAfterStartup\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "initialActions",
          "package": "yi",
          "signature": "Field [Action]",
          "source": "src/Yi-Config-Simple.html#initialActions",
          "type": "function"
        },
        "index": {
          "description": "Actions to run after startup or reload Consider using runAfterStartup or runManyAfterStartup instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "initialActions",
          "normalized": "Field[Action]",
          "package": "yi",
          "partial": "Actions",
          "signature": "Field[Action]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:initialActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e?\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "inputPreprocess",
          "package": "yi",
          "signature": "Field (P Event Event)",
          "source": "src/Yi-Config-Simple.html#inputPreprocess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "inputPreprocess",
          "package": "yi",
          "partial": "Preprocess",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:inputPreprocess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e for an emacs-like behaviour, where all deleted text is accumulated in a killring. Consider starting with \u003ccode\u003e\u003ca\u003edefaultEmacsConfig\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edefaultVimConfig\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003edefaultCuaConfig\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "killringAccumulate",
          "package": "yi",
          "signature": "Field Bool",
          "source": "src/Yi-Config-Simple.html#killringAccumulate",
          "type": "function"
        },
        "index": {
          "description": "Set to True for an emacs-like behaviour where all deleted text is accumulated in killring Consider starting with defaultEmacsConfig defaultVimConfig or defaultCuaConfig instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "killringAccumulate",
          "package": "yi",
          "partial": "Accumulate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:killringAccumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of registered layout managers. When cycling through layouts, this list will be consulted.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "layoutManagers",
          "package": "yi",
          "signature": "Field [AnyLayoutManager]",
          "source": "src/Yi-Config-Simple.html#layoutManagers",
          "type": "function"
        },
        "index": {
          "description": "List of registered layout managers When cycling through layouts this list will be consulted",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "layoutManagers",
          "normalized": "Field[AnyLayoutManager]",
          "package": "yi",
          "partial": "Managers",
          "signature": "Field[AnyLayoutManager]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:layoutManagers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould lines be wrapped?\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "lineWrap",
          "package": "yi",
          "signature": "Field Bool",
          "source": "src/Yi-Config-Simple.html#lineWrap",
          "type": "function"
        },
        "index": {
          "description": "Should lines be wrapped",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "lineWrap",
          "package": "yi",
          "partial": "Wrap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:lineWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodeBindKeys mode keys\u003c/code\u003e adds the keybindings in \u003ccode\u003ekeys\u003c/code\u003e to all modes with the same name as \u003ccode\u003emode\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAs with \u003ccode\u003e\u003ca\u003emodifyMode\u003c/a\u003e\u003c/code\u003e, a mode by the given name must already be registered, or the function will\n have no effect, and issue a command-line warning.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "modeBindKeys",
          "package": "yi",
          "signature": "Mode syntax -\u003e Keymap -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#modeBindKeys",
          "type": "function"
        },
        "index": {
          "description": "modeBindKeys mode keys adds the keybindings in keys to all modes with the same name as mode As with modifyMode mode by the given name must already be registered or the function will have no effect and issue command-line warning",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "modeBindKeys",
          "normalized": "Mode a-\u003eKeymap-\u003eConfigM()",
          "package": "yi",
          "partial": "Bind Keys",
          "signature": "Mode syntax-\u003eKeymap-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:modeBindKeys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodeBindKeysByName name keys\u003c/code\u003e adds the keybindings in \u003ccode\u003ekeys\u003c/code\u003e to all modes with name \u003ccode\u003ename\u003c/code\u003e (if it is registered). Consider using \u003ccode\u003e\u003ca\u003emodeBindKeys\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "modeBindKeysByName",
          "package": "yi",
          "signature": "String -\u003e Keymap -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#modeBindKeysByName",
          "type": "function"
        },
        "index": {
          "description": "modeBindKeysByName name keys adds the keybindings in keys to all modes with name name if it is registered Consider using modeBindKeys instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "modeBindKeysByName",
          "normalized": "String-\u003eKeymap-\u003eConfigM()",
          "package": "yi",
          "partial": "Bind Keys By Name",
          "signature": "String-\u003eKeymap-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:modeBindKeysByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of modes by order of preference. Consider using \u003ccode\u003e\u003ca\u003eaddMode\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emodeBindKeys\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003emodifyMode\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "modes",
          "package": "yi",
          "signature": "Field [AnyMode]",
          "source": "src/Yi-Config-Simple.html#modes",
          "type": "function"
        },
        "index": {
          "description": "List of modes by order of preference Consider using addMode modeBindKeys or modifyMode instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "modes",
          "normalized": "Field[AnyMode]",
          "package": "yi",
          "signature": "Field[AnyMode]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:modes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModify a field.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "modify",
          "package": "yi",
          "signature": "Field a -\u003e (a -\u003e a) -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#modify",
          "type": "function"
        },
        "index": {
          "description": "Modify field",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "modify",
          "normalized": "Field a-\u003e(a-\u003ea)-\u003eConfigM()",
          "package": "yi",
          "signature": "Field a-\u003e(a-\u003ea)-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:modify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodifyMode mode f\u003c/code\u003e modifies all modes with the same name as \u003ccode\u003emode\u003c/code\u003e, using the function \u003ccode\u003ef\u003c/code\u003e. \n\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003emode\u003c/code\u003e argument is only used by its \u003ccode\u003e\u003ca\u003emodeName\u003c/a\u003e\u003c/code\u003e. In particular, a mode by the given name\n must already be registered, or this function will have no effect, and issue a command-line warning.\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003emodifyMode\u003c/a\u003e\u003c/code\u003e mode f = \u003ccode\u003e\u003ca\u003emodifyModeByName\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003emodeName\u003c/a\u003e\u003c/code\u003e mode) f\u003c/pre\u003e",
          "module": "Yi.Config.Simple",
          "name": "modifyMode",
          "package": "yi",
          "signature": "Mode syntax -\u003e (forall syntax'.  Mode syntax' -\u003e Mode syntax') -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#modifyMode",
          "type": "function"
        },
        "index": {
          "description": "modifyMode mode modifies all modes with the same name as mode using the function Note that the mode argument is only used by its modeName In particular mode by the given name must already be registered or this function will have no effect and issue command-line warning modifyMode mode modifyModeByName modeName mode",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "modifyMode",
          "normalized": "Mode a-\u003e(b c Mode d-\u003eMode d)-\u003eConfigM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "Mode syntax-\u003e(forall syntax'. Mode syntax'-\u003eMode syntax')-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:modifyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodifyModeByName name f\u003c/code\u003e modifies the mode with name \u003ccode\u003ename\u003c/code\u003e using the function \u003ccode\u003ef\u003c/code\u003e. Consider using \u003ccode\u003e\u003ca\u003emodifyMode\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "modifyModeByName",
          "package": "yi",
          "signature": "String -\u003e (forall syntax.  Mode syntax -\u003e Mode syntax) -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#modifyModeByName",
          "type": "function"
        },
        "index": {
          "description": "modifyModeByName name modifies the mode with name name using the function Consider using modifyMode instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "modifyModeByName",
          "normalized": "String-\u003e(a b Mode c-\u003eMode c)-\u003eConfigM()",
          "package": "yi",
          "partial": "Mode By Name",
          "signature": "String-\u003e(forall syntax. Mode syntax-\u003eMode syntax)-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:modifyModeByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePublish the given action, by the given name. This will overwrite any existing actions by the same name.\n\u003c/p\u003e",
          "module": "[\"Yi.Config.Simple\",\"Yi.Eval\"]",
          "name": "publishAction",
          "package": "yi",
          "signature": "String -\u003e a -\u003e ConfigM ()",
          "source": "src/Yi-Eval.html#publishAction",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:publishAction\",\"http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:publishAction\"]"
        },
        "index": {
          "description": "Publish the given action by the given name This will overwrite any existing actions by the same name",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "publishAction",
          "normalized": "String-\u003ea-\u003eConfigM()",
          "package": "yi",
          "partial": "Action",
          "signature": "String-\u003ea-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:publishAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for the published actions. Consider using \u003ccode\u003e\u003ca\u003epublishAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Yi.Config.Simple\",\"Yi.Eval\"]",
          "name": "publishedActions",
          "package": "yi",
          "signature": "Field (HashMap String Action)",
          "source": "src/Yi-Eval.html#publishedActions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:publishedActions\",\"http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:publishedActions\"]"
        },
        "index": {
          "description": "Accessor for the published actions Consider using publishAction",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "publishedActions",
          "package": "yi",
          "partial": "Actions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:publishedActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluator based on a fixed list of published actions. Has a few differences from \u003ccode\u003e\u003ca\u003eghciEvaluator\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e expressions can't be evaluated\n\u003c/li\u003e\u003cli\u003e all suggested actions are actually valued\n\u003c/li\u003e\u003cli\u003e (related to the above) doesn't contain junk actions from Prelude\n\u003c/li\u003e\u003cli\u003e doesn't require GHCi backend, so uses less memory\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "[\"Yi.Config.Simple\",\"Yi.Eval\"]",
          "name": "publishedActionsEvaluator",
          "package": "yi",
          "signature": "Evaluator",
          "source": "src/Yi-Eval.html#publishedActionsEvaluator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:publishedActionsEvaluator\",\"http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:publishedActionsEvaluator\"]"
        },
        "index": {
          "description": "Evaluator based on fixed list of published actions Has few differences from ghciEvaluator expressions can be evaluated all suggested actions are actually valued related to the above doesn contain junk actions from Prelude doesn require GHCi backend so uses less memory",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "publishedActionsEvaluator",
          "package": "yi",
          "partial": "Actions Evaluator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:publishedActionsEvaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet to \u003ccode\u003e\u003ca\u003eExclusive\u003c/a\u003e\u003c/code\u003e for an emacs-like behaviour. Consider starting with \u003ccode\u003e\u003ca\u003edefaultEmacsConfig\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edefaultVimConfig\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003edefaultCuaConfig\u003c/a\u003e\u003c/code\u003e to instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "regionStyle",
          "package": "yi",
          "signature": "Field RegionStyle",
          "source": "src/Yi-Config-Simple.html#regionStyle",
          "type": "function"
        },
        "index": {
          "description": "Set to Exclusive for an emacs-like behaviour Consider starting with defaultEmacsConfig defaultVimConfig or defaultCuaConfig to instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "regionStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:regionStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun after the startup actions have completed, or on reload (this is run after all actions which have already been registered)\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "runAfterStartup",
          "package": "yi",
          "signature": "Action -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#runAfterStartup",
          "type": "function"
        },
        "index": {
          "description": "Run after the startup actions have completed or on reload this is run after all actions which have already been registered",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "runAfterStartup",
          "normalized": "Action-\u003eConfigM()",
          "package": "yi",
          "partial": "After Startup",
          "signature": "Action-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:runAfterStartup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun when the editor is started (this is run after all actions which have already been registered)\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "runOnStartup",
          "package": "yi",
          "signature": "Action -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#runOnStartup",
          "type": "function"
        },
        "index": {
          "description": "Run when the editor is started this is run after all actions which have already been registered",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "runOnStartup",
          "normalized": "Action-\u003eConfigM()",
          "package": "yi",
          "partial": "On Startup",
          "signature": "Action-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:runOnStartup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhich side to display the scroll bar on.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "scrollBarSide",
          "package": "yi",
          "signature": "Field Side",
          "source": "src/Yi-Config-Simple.html#scrollBarSide",
          "type": "function"
        },
        "index": {
          "description": "Which side to display the scroll bar on",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "scrollBarSide",
          "package": "yi",
          "partial": "Bar Side",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:scrollBarSide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the scroll style, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e for default.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "scrollStyle",
          "package": "yi",
          "signature": "Field (Maybe ScrollStyle)",
          "source": "src/Yi-Config-Simple.html#scrollStyle",
          "type": "function"
        },
        "index": {
          "description": "Just the scroll style or Nothing for default",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "scrollStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:scrollStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAmount to move the buffer when using the scroll wheel.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "scrollWheelAmount",
          "package": "yi",
          "signature": "Field Int",
          "source": "src/Yi-Config-Simple.html#scrollWheelAmount",
          "type": "function"
        },
        "index": {
          "description": "Amount to move the buffer when using the scroll wheel",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "scrollWheelAmount",
          "package": "yi",
          "partial": "Wheel Amount",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:scrollWheelAmount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the frontend, if it is available.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "setFrontend",
          "package": "yi",
          "signature": "String -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#setFrontend",
          "type": "function"
        },
        "index": {
          "description": "Sets the frontend if it is available",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "setFrontend",
          "normalized": "String-\u003eConfigM()",
          "package": "yi",
          "partial": "Frontend",
          "signature": "String-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:setFrontend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the frontend to the first frontend from the list which is installed.\n\u003c/p\u003e\u003cp\u003eAvailable frontends are a subset of: \"vte\", \"vty\", \"pango\", \"cocoa\", and \"batch\".\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "setFrontendPreferences",
          "package": "yi",
          "signature": "[String] -\u003e ConfigM ()",
          "source": "src/Yi-Config-Simple.html#setFrontendPreferences",
          "type": "function"
        },
        "index": {
          "description": "Sets the frontend to the first frontend from the list which is installed Available frontends are subset of vte vty pango cocoa and batch",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "setFrontendPreferences",
          "normalized": "[String]-\u003eConfigM()",
          "package": "yi",
          "partial": "Frontend Preferences",
          "signature": "[String]-\u003eConfigM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:setFrontendPreferences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActions to run when the editor is started. Consider using \u003ccode\u003e\u003ca\u003erunOnStartup\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003erunManyOnStartup\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "startActions",
          "package": "yi",
          "signature": "Field [Action]",
          "source": "src/Yi-Config-Simple.html#startActions",
          "type": "function"
        },
        "index": {
          "description": "Actions to run when the editor is started Consider using runOnStartup or runManyOnStartup instead",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "startActions",
          "normalized": "Field[Action]",
          "package": "yi",
          "partial": "Actions",
          "signature": "Field[Action]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:startActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUI colour theme.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "theme",
          "package": "yi",
          "signature": "Field Theme",
          "source": "src/Yi-Config-Simple.html#theme",
          "type": "function"
        },
        "index": {
          "description": "UI colour theme",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "theme",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:theme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe character with which to fill empty window space. Usually '~' for vi-like editors, ' ' for everything else.\n\u003c/p\u003e",
          "module": "Yi.Config.Simple",
          "name": "windowFill",
          "package": "yi",
          "signature": "Field Char",
          "source": "src/Yi-Config-Simple.html#windowFill",
          "type": "function"
        },
        "index": {
          "description": "The character with which to fill empty window space Usually for vi-like editors for everything else",
          "hierarchy": "Yi Config Simple",
          "module": "Yi.Config.Simple",
          "name": "windowFill",
          "package": "yi",
          "partial": "Fill",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config-Simple.html#v:windowFill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "Config",
          "package": "yi",
          "source": "src/Yi-Config.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "Config",
          "package": "yi",
          "partial": "Config",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfiguration record. All Yi hooks can be set here.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "Config",
          "package": "yi",
          "source": "src/Yi-Config.html#Config",
          "type": "data"
        },
        "index": {
          "description": "Configuration record All Yi hooks can be set here",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "Config",
          "package": "yi",
          "partial": "Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#t:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen should we use a \"fat\" cursor (i.e. 2 pixels wide, rather than 1)? Fat cursors have only been implemented for the Pango frontend.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "CursorStyle",
          "package": "yi",
          "source": "src/Yi-Config.html#CursorStyle",
          "type": "data"
        },
        "index": {
          "description": "When should we use fat cursor i.e pixels wide rather than Fat cursors have only been implemented for the Pango frontend",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "CursorStyle",
          "package": "yi",
          "partial": "Cursor Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#t:CursorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "UIBoot",
          "package": "yi",
          "source": "src/Yi-Config.html#UIBoot",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "UIBoot",
          "package": "yi",
          "partial": "UIBoot",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#t:UIBoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "UIConfig",
          "package": "yi",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "UIConfig",
          "package": "yi",
          "partial": "UIConfig",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#t:UIConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "Config",
          "package": "yi",
          "signature": "Config",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "Config",
          "package": "yi",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:Config"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "UIConfig",
          "package": "yi",
          "signature": "UIConfig",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "UIConfig",
          "package": "yi",
          "partial": "UIConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:UIConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "bufferUpdateHandler",
          "package": "yi",
          "signature": "[[Update] -\u003e BufferM ()]",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "bufferUpdateHandler",
          "normalized": "[[Update]-\u003eBufferM()]",
          "package": "yi",
          "partial": "Update Handler",
          "signature": "[[Update]-\u003eBufferM()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:bufferUpdateHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "bufferUpdateHandlerA",
          "package": "yi",
          "signature": "T Config [[Update] -\u003e BufferM ()]",
          "source": "src/Yi-Config.html#bufferUpdateHandlerA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "bufferUpdateHandlerA",
          "normalized": "T Config[[Update]-\u003eBufferM()]",
          "package": "yi",
          "partial": "Update Handler",
          "signature": "T Config[[Update]-\u003eBufferM()]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:bufferUpdateHandlerA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHide scrollbar automatically if text fits on one page.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configAutoHideScrollBar",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Hide scrollbar automatically if text fits on one page",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configAutoHideScrollBar",
          "package": "yi",
          "partial": "Auto Hide Scroll Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configAutoHideScrollBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configAutoHideScrollBarA",
          "package": "yi",
          "signature": "T UIConfig Bool",
          "source": "src/Yi-Config.html#configAutoHideScrollBarA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configAutoHideScrollBarA",
          "package": "yi",
          "partial": "Auto Hide Scroll Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configAutoHideScrollBarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHide the tabbar automatically if only one tab is present\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configAutoHideTabBar",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Hide the tabbar automatically if only one tab is present",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configAutoHideTabBar",
          "package": "yi",
          "partial": "Auto Hide Tab Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configAutoHideTabBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configAutoHideTabBarA",
          "package": "yi",
          "signature": "T UIConfig Bool",
          "source": "src/Yi-Config.html#configAutoHideTabBarA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configAutoHideTabBarA",
          "package": "yi",
          "partial": "Auto Hide Tab Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configAutoHideTabBarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configCheckExternalChangesObsessively",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configCheckExternalChangesObsessively",
          "package": "yi",
          "partial": "Check External Changes Obsessively",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configCheckExternalChangesObsessively"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configCheckExternalChangesObsessivelyA",
          "package": "yi",
          "signature": "T Config Bool",
          "source": "src/Yi-Config.html#configCheckExternalChangesObsessivelyA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configCheckExternalChangesObsessivelyA",
          "package": "yi",
          "partial": "Check External Changes Obsessively",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configCheckExternalChangesObsessivelyA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configCursorStyle",
          "package": "yi",
          "signature": "CursorStyle",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configCursorStyle",
          "package": "yi",
          "partial": "Cursor Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configCursorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configCursorStyleA",
          "package": "yi",
          "signature": "T UIConfig CursorStyle",
          "source": "src/Yi-Config.html#configCursorStyleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configCursorStyleA",
          "package": "yi",
          "partial": "Cursor Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configCursorStyleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFont name, for the UI that support it.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configFontName",
          "package": "yi",
          "signature": "Maybe String",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Font name for the UI that support it",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configFontName",
          "package": "yi",
          "partial": "Font Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configFontName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configFontNameA",
          "package": "yi",
          "signature": "T UIConfig (Maybe String)",
          "source": "src/Yi-Config.html#configFontNameA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configFontNameA",
          "package": "yi",
          "partial": "Font Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configFontNameA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFont size, for the UI that support it.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configFontSize",
          "package": "yi",
          "signature": "Maybe Int",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Font size for the UI that support it",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configFontSize",
          "package": "yi",
          "partial": "Font Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configFontSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configFontSizeA",
          "package": "yi",
          "signature": "T UIConfig (Maybe Int)",
          "source": "src/Yi-Config.html#configFontSizeA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configFontSizeA",
          "package": "yi",
          "partial": "Font Size",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configFontSizeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configFundamentalMode",
          "package": "yi",
          "signature": "Config -\u003e AnyMode",
          "source": "src/Yi-Config.html#configFundamentalMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configFundamentalMode",
          "normalized": "Config-\u003eAnyMode",
          "package": "yi",
          "partial": "Fundamental Mode",
          "signature": "Config-\u003eAnyMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configFundamentalMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configInputPreprocess",
          "package": "yi",
          "signature": "P Event Event",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configInputPreprocess",
          "package": "yi",
          "partial": "Input Preprocess",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configInputPreprocess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configInputPreprocessA",
          "package": "yi",
          "signature": "T Config (P Event Event)",
          "source": "src/Yi-Config.html#configInputPreprocessA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configInputPreprocessA",
          "package": "yi",
          "partial": "Input Preprocess",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configInputPreprocessA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e for an emacs-like behaviour, where \n all deleted text is accumulated in a killring.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configKillringAccumulate",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Set to True for an emacs-like behaviour where all deleted text is accumulated in killring",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configKillringAccumulate",
          "package": "yi",
          "partial": "Killring Accumulate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configKillringAccumulate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configKillringAccumulateA",
          "package": "yi",
          "signature": "T Config Bool",
          "source": "src/Yi-Config.html#configKillringAccumulateA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configKillringAccumulateA",
          "package": "yi",
          "partial": "Killring Accumulate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configKillringAccumulateA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould the scrollbar be shown on the left side?\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configLeftSideScrollBar",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Should the scrollbar be shown on the left side",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configLeftSideScrollBar",
          "package": "yi",
          "partial": "Left Side Scroll Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configLeftSideScrollBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configLeftSideScrollBarA",
          "package": "yi",
          "signature": "T UIConfig Bool",
          "source": "src/Yi-Config.html#configLeftSideScrollBarA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configLeftSideScrollBarA",
          "package": "yi",
          "partial": "Left Side Scroll Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configLeftSideScrollBarA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap lines at the edge of the window if too long to display.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configLineWrap",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Wrap lines at the edge of the window if too long to display",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configLineWrap",
          "package": "yi",
          "partial": "Line Wrap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configLineWrap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configLineWrapA",
          "package": "yi",
          "signature": "T UIConfig Bool",
          "source": "src/Yi-Config.html#configLineWrapA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configLineWrapA",
          "package": "yi",
          "partial": "Line Wrap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configLineWrapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet to \u003ccode\u003e\u003ca\u003eExclusive\u003c/a\u003e\u003c/code\u003e for an emacs-like behaviour.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configRegionStyle",
          "package": "yi",
          "signature": "RegionStyle",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Set to Exclusive for an emacs-like behaviour",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configRegionStyle",
          "package": "yi",
          "partial": "Region Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configRegionStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configRegionStyleA",
          "package": "yi",
          "signature": "T Config RegionStyle",
          "source": "src/Yi-Config.html#configRegionStyleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configRegionStyleA",
          "package": "yi",
          "partial": "Region Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configRegionStyleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStyle of scroll\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configScrollStyle",
          "package": "yi",
          "signature": "Maybe ScrollStyle",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Style of scroll",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configScrollStyle",
          "package": "yi",
          "partial": "Scroll Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configScrollStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configScrollStyleA",
          "package": "yi",
          "signature": "T UIConfig (Maybe ScrollStyle)",
          "source": "src/Yi-Config.html#configScrollStyleA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configScrollStyleA",
          "package": "yi",
          "partial": "Scroll Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configScrollStyleA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAmount to move the buffer when using the scroll wheel\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configScrollWheelAmount",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "Amount to move the buffer when using the scroll wheel",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configScrollWheelAmount",
          "package": "yi",
          "partial": "Scroll Wheel Amount",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configScrollWheelAmount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configScrollWheelAmountA",
          "package": "yi",
          "signature": "T UIConfig Int",
          "source": "src/Yi-Config.html#configScrollWheelAmountA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configScrollWheelAmountA",
          "package": "yi",
          "partial": "Scroll Wheel Amount",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configScrollWheelAmountA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configStyle",
          "package": "yi",
          "signature": "UIConfig -\u003e UIStyle",
          "source": "src/Yi-Config.html#configStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configStyle",
          "normalized": "UIConfig-\u003eUIStyle",
          "package": "yi",
          "partial": "Style",
          "signature": "UIConfig-\u003eUIStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUI colours\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configTheme",
          "package": "yi",
          "signature": "Theme",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "UI colours",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configTheme",
          "package": "yi",
          "partial": "Theme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configTheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configThemeA",
          "package": "yi",
          "signature": "T UIConfig Theme",
          "source": "src/Yi-Config.html#configThemeA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configThemeA",
          "package": "yi",
          "partial": "Theme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configThemeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configTopLevelKeymap",
          "package": "yi",
          "signature": "Config -\u003e Keymap",
          "source": "src/Yi-Config.html#configTopLevelKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configTopLevelKeymap",
          "normalized": "Config-\u003eKeymap",
          "package": "yi",
          "partial": "Top Level Keymap",
          "signature": "Config-\u003eKeymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configTopLevelKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUI-specific configuration.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configUI",
          "package": "yi",
          "signature": "UIConfig",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "UI-specific configuration",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configUI",
          "package": "yi",
          "partial": "UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configUIA",
          "package": "yi",
          "signature": "T Config UIConfig",
          "source": "src/Yi-Config.html#configUIA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configUIA",
          "package": "yi",
          "partial": "UIA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configUIA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCustom configuration, containing the \u003ccode\u003eYiConfigVariable\u003c/code\u003es. Configure with \u003ccode\u003econfigVariableA\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configVars",
          "package": "yi",
          "signature": "ConfigVariables",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Custom configuration containing the YiConfigVariable Configure with configVariableA",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configVars",
          "package": "yi",
          "partial": "Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configVars"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configVarsA",
          "package": "yi",
          "signature": "T Config ConfigVariables",
          "source": "src/Yi-Config.html#configVarsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configVarsA",
          "package": "yi",
          "partial": "Vars",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configVarsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configVtyEscDelay",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configVtyEscDelay",
          "package": "yi",
          "partial": "Vty Esc Delay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configVtyEscDelay"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configVtyEscDelayA",
          "package": "yi",
          "signature": "T UIConfig Int",
          "source": "src/Yi-Config.html#configVtyEscDelayA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configVtyEscDelayA",
          "package": "yi",
          "partial": "Vty Esc Delay",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configVtyEscDelayA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe char with which to fill empty window space.  Usually '~' for vi-like\n editors, ' ' for everything else.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "configWindowFill",
          "package": "yi",
          "signature": "Char",
          "source": "src/Yi-Config.html#UIConfig",
          "type": "function"
        },
        "index": {
          "description": "The char with which to fill empty window space Usually for vi-like editors for everything else",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configWindowFill",
          "package": "yi",
          "partial": "Window Fill",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configWindowFill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "configWindowFillA",
          "package": "yi",
          "signature": "T UIConfig Char",
          "source": "src/Yi-Config.html#configWindowFillA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "configWindowFillA",
          "package": "yi",
          "partial": "Window Fill",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:configWindowFillA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProduce a .yi.dbg file with a lot of debug information.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "debugMode",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Produce yi.dbg file with lot of debug information",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "debugMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:debugMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "debugModeA",
          "package": "yi",
          "signature": "T Config Bool",
          "source": "src/Yi-Config.html#debugModeA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "debugModeA",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:debugModeA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault keymap to use.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "defaultKm",
          "package": "yi",
          "signature": "KeymapSet",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Default keymap to use",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "defaultKm",
          "package": "yi",
          "partial": "Km",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:defaultKm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "defaultKmA",
          "package": "yi",
          "signature": "T Config KeymapSet",
          "source": "src/Yi-Config.html#defaultKmA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "defaultKmA",
          "package": "yi",
          "partial": "Km",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:defaultKmA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActions to run after startup (after startActions) or reload.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "initialActions",
          "package": "yi",
          "signature": "[Action]",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Actions to run after startup after startActions or reload",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "initialActions",
          "normalized": "[Action]",
          "package": "yi",
          "partial": "Actions",
          "signature": "[Action]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:initialActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "initialActionsA",
          "package": "yi",
          "signature": "T Config [Action]",
          "source": "src/Yi-Config.html#initialActionsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "initialActionsA",
          "normalized": "T Config[Action]",
          "package": "yi",
          "partial": "Actions",
          "signature": "T Config[Action]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:initialActionsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of layout managers for \u003ccode\u003ecycleLayoutManagersNext\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "layoutManagers",
          "package": "yi",
          "signature": "[AnyLayoutManager]",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "List of layout managers for cycleLayoutManagersNext",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "layoutManagers",
          "normalized": "[AnyLayoutManager]",
          "package": "yi",
          "partial": "Managers",
          "signature": "[AnyLayoutManager]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:layoutManagers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "layoutManagersA",
          "package": "yi",
          "signature": "T Config [AnyLayoutManager]",
          "source": "src/Yi-Config.html#layoutManagersA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "layoutManagersA",
          "normalized": "T Config[AnyLayoutManager]",
          "package": "yi",
          "partial": "Managers",
          "signature": "T Config[AnyLayoutManager]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:layoutManagersA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList modes by order of preference.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "modeTable",
          "package": "yi",
          "signature": "[AnyMode]",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "List modes by order of preference",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "modeTable",
          "normalized": "[AnyMode]",
          "package": "yi",
          "partial": "Table",
          "signature": "[AnyMode]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:modeTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "modeTableA",
          "package": "yi",
          "signature": "T Config [AnyMode]",
          "source": "src/Yi-Config.html#modeTableA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "modeTableA",
          "normalized": "T Config[AnyMode]",
          "package": "yi",
          "partial": "Table",
          "signature": "T Config[AnyMode]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:modeTableA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActions to run when the editor is started.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "startActions",
          "package": "yi",
          "signature": "[Action]",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "Actions to run when the editor is started",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "startActions",
          "normalized": "[Action]",
          "package": "yi",
          "partial": "Actions",
          "signature": "[Action]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:startActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "startActionsA",
          "package": "yi",
          "signature": "T Config [Action]",
          "source": "src/Yi-Config.html#startActionsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "startActionsA",
          "normalized": "T Config[Action]",
          "package": "yi",
          "partial": "Actions",
          "signature": "T Config[Action]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:startActionsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUI to use.\n\u003c/p\u003e",
          "module": "Yi.Config",
          "name": "startFrontEnd",
          "package": "yi",
          "signature": "UIBoot",
          "source": "src/Yi-Config.html#Config",
          "type": "function"
        },
        "index": {
          "description": "UI to use",
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "startFrontEnd",
          "package": "yi",
          "partial": "Front End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:startFrontEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Config",
          "name": "startFrontEndA",
          "package": "yi",
          "signature": "T Config UIBoot",
          "source": "src/Yi-Config.html#startFrontEndA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Config",
          "module": "Yi.Config",
          "name": "startFrontEndA",
          "package": "yi",
          "partial": "Front End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Config.html#v:startFrontEndA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe core actions of yi. This module is the link between the editor\n and the UI. Key bindings, and libraries should manipulate Yi through\n the interface defined here.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Core",
          "name": "Core",
          "package": "yi",
          "source": "src/Yi-Core.html",
          "type": "module"
        },
        "index": {
          "description": "The core actions of yi This module is the link between the editor and the UI Key bindings and libraries should manipulate Yi through the interface defined here",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "Core",
          "package": "yi",
          "partial": "Core",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose the current window.\n If this is the last window open, quit the program.\n CONSIDER: call quitEditor when there are no other window in the \u003ccode\u003einteractive\u003c/code\u003e function.\n (Not possible since the windowset type disallows it -- should it be relaxed?)\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "closeWindow",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Core.html#closeWindow",
          "type": "function"
        },
        "index": {
          "description": "Close the current window If this is the last window open quit the program CONSIDER call quitEditor when there are no other window in the interactive function Not possible since the windowset type disallows it should it be relaxed",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "closeWindow",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Window",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:closeWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow an error on the status line and log it.\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "errorEditor",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Core.html#errorEditor",
          "type": "function"
        },
        "index": {
          "description": "Show an error on the status line and log it",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "errorEditor",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Editor",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:errorEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Core",
          "name": "focusAllSyntax",
          "package": "yi",
          "signature": "Editor -\u003e Editor",
          "source": "src/Yi-Core.html#focusAllSyntax",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "focusAllSyntax",
          "normalized": "Editor-\u003eEditor",
          "package": "yi",
          "partial": "All Syntax",
          "signature": "Editor-\u003eEditor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:focusAllSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Core",
          "name": "msgEditor",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Core.html#msgEditor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "msgEditor",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Editor",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:msgEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuit.\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "quitEditor",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Core.html#quitEditor",
          "type": "function"
        },
        "index": {
          "description": "Quit",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "quitEditor",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Editor",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:quitEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRedraw\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "refreshEditor",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Core.html#refreshEditor",
          "type": "function"
        },
        "index": {
          "description": "Redraw",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "refreshEditor",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Editor",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:refreshEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Core",
          "name": "runAction",
          "package": "yi",
          "signature": "Action -\u003e YiM ()",
          "source": "src/Yi-Core.html#runAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "runAction",
          "normalized": "Action-\u003eYiM()",
          "package": "yi",
          "partial": "Action",
          "signature": "Action-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:runAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePipe a string through an external command, returning the stdout\n chomp any trailing newline (is this desirable?)\n\u003c/p\u003e\u003cp\u003eTodo: varients with marks?\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "runProcessWithInput",
          "package": "yi",
          "signature": "String -\u003e String -\u003e YiM String",
          "source": "src/Yi-Core.html#runProcessWithInput",
          "type": "function"
        },
        "index": {
          "description": "Pipe string through an external command returning the stdout chomp any trailing newline is this desirable Todo varients with marks",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "runProcessWithInput",
          "normalized": "String-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "Process With Input",
          "signature": "String-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:runProcessWithInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Core",
          "name": "sendToProcess",
          "package": "yi",
          "signature": "BufferRef -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Core.html#sendToProcess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "sendToProcess",
          "normalized": "BufferRef-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "To Process",
          "signature": "BufferRef-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:sendToProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart up the editor, setting any state with the user preferences\n and file names passed in, and turning on the UI\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "startEditor",
          "package": "yi",
          "signature": "Config -\u003e Maybe Editor -\u003e IO ()",
          "source": "src/Yi-Core.html#startEditor",
          "type": "function"
        },
        "index": {
          "description": "Start up the editor setting any state with the user preferences and file names passed in and turning on the UI",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "startEditor",
          "normalized": "Config-\u003eMaybe Editor-\u003eIO()",
          "package": "yi",
          "partial": "Editor",
          "signature": "Config-\u003eMaybe Editor-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:startEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart a subprocess with the given command and arguments.\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "startSubprocess",
          "package": "yi",
          "signature": "FilePath -\u003e [String] -\u003e (Either SomeException ExitCode -\u003e YiM x) -\u003e YiM BufferRef",
          "source": "src/Yi-Core.html#startSubprocess",
          "type": "function"
        },
        "index": {
          "description": "Start subprocess with the given command and arguments",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "startSubprocess",
          "normalized": "FilePath-\u003e[String]-\u003e(Either SomeException ExitCode-\u003eYiM a)-\u003eYiM BufferRef",
          "package": "yi",
          "partial": "Subprocess",
          "signature": "FilePath-\u003e[String]-\u003e(Either SomeException ExitCode-\u003eYiM x)-\u003eYiM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:startSubprocess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuspend the program\n\u003c/p\u003e",
          "module": "Yi.Core",
          "name": "suspendEditor",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Core.html#suspendEditor",
          "type": "function"
        },
        "index": {
          "description": "Suspend the program",
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "suspendEditor",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Editor",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:suspendEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Core",
          "name": "userForceRefresh",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Core.html#userForceRefresh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "userForceRefresh",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Force Refresh",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:userForceRefresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Core",
          "name": "withSyntax",
          "package": "yi",
          "signature": "(forall syntax.  Mode syntax -\u003e syntax -\u003e a) -\u003e YiM ()",
          "source": "src/Yi-Core.html#withSyntax",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Core",
          "module": "Yi.Core",
          "name": "withSyntax",
          "normalized": "(a b Mode c-\u003ec-\u003ed)-\u003eYiM()",
          "package": "yi",
          "partial": "Syntax",
          "signature": "(forall syntax. Mode syntax-\u003esyntax-\u003ea)-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Core.html#v:withSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Debug",
          "name": "Debug",
          "package": "yi",
          "source": "src/Yi-Debug.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "Debug",
          "package": "yi",
          "partial": "Debug",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Debug",
          "name": "error",
          "package": "yi",
          "signature": "String -\u003e a",
          "source": "src/Yi-Debug.html#error",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "error",
          "normalized": "String-\u003ea",
          "package": "yi",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the file to which debugging output should be written. Though this\n is called \u003cem\u003einit\u003c/em\u003eDebug. \n Debugging output is not created by default (i.e., if this function\n is never called.)\n The target file can not be changed, nor debugging disabled.\n\u003c/p\u003e",
          "module": "Yi.Debug",
          "name": "initDebug",
          "package": "yi",
          "signature": "FilePath -\u003e IO ()",
          "source": "src/Yi-Debug.html#initDebug",
          "type": "function"
        },
        "index": {
          "description": "Set the file to which debugging output should be written Though this is called init Debug Debugging output is not created by default i.e if this function is never called The target file can not be changed nor debugging disabled",
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "initDebug",
          "normalized": "FilePath-\u003eIO()",
          "package": "yi",
          "partial": "Debug",
          "signature": "FilePath-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:initDebug"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Debug",
          "name": "logError",
          "package": "yi",
          "signature": "String -\u003e m ()",
          "source": "src/Yi-Debug.html#logError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "logError",
          "normalized": "String-\u003ea()",
          "package": "yi",
          "partial": "Error",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:logError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Debug",
          "name": "logPutStrLn",
          "package": "yi",
          "signature": "String -\u003e m ()",
          "source": "src/Yi-Debug.html#logPutStrLn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "logPutStrLn",
          "normalized": "String-\u003ea()",
          "package": "yi",
          "partial": "Put Str Ln",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:logPutStrLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Debug",
          "name": "logStream",
          "package": "yi",
          "signature": "String -\u003e Chan a -\u003e IO ()",
          "source": "src/Yi-Debug.html#logStream",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "logStream",
          "normalized": "String-\u003eChan a-\u003eIO()",
          "package": "yi",
          "partial": "Stream",
          "signature": "String-\u003eChan a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:logStream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutputs the given string before returning the second argument.\n\u003c/p\u003e",
          "module": "Yi.Debug",
          "name": "trace",
          "package": "yi",
          "signature": "String -\u003e a -\u003e a",
          "source": "src/Yi-Debug.html#trace",
          "type": "function"
        },
        "index": {
          "description": "Outputs the given string before returning the second argument",
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "trace",
          "normalized": "String-\u003ea-\u003ea",
          "package": "yi",
          "signature": "String-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:trace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTraces \u003ccode\u003ex\u003c/code\u003e and returns \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Debug",
          "name": "traceM",
          "package": "yi",
          "signature": "String -\u003e a -\u003e m a",
          "source": "src/Yi-Debug.html#traceM",
          "type": "function"
        },
        "index": {
          "description": "Traces and returns",
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "traceM",
          "normalized": "String-\u003ea-\u003eb a",
          "package": "yi",
          "signature": "String-\u003ea-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:traceM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike traceM, but returns ().\n\u003c/p\u003e",
          "module": "Yi.Debug",
          "name": "traceM_",
          "package": "yi",
          "signature": "String -\u003e m ()",
          "source": "src/Yi-Debug.html#traceM_",
          "type": "function"
        },
        "index": {
          "description": "Like traceM but returns",
          "hierarchy": "Yi Debug",
          "module": "Yi.Debug",
          "name": "traceM_",
          "normalized": "String-\u003ea()",
          "package": "yi",
          "signature": "String-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Debug.html#v:traceM_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA Simple Dired Implementation for Yi\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Dired",
          "name": "Dired",
          "package": "yi",
          "source": "src/Yi-Dired.html",
          "type": "module"
        },
        "index": {
          "description": "Simple Dired Implementation for Yi",
          "hierarchy": "Yi Dired",
          "module": "Yi.Dired",
          "name": "Dired",
          "package": "yi",
          "partial": "Dired",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dired.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Dired",
          "name": "dired",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Dired.html#dired",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Dired",
          "module": "Yi.Dired",
          "name": "dired",
          "normalized": "YiM()",
          "package": "yi",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dired.html#v:dired"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Dired",
          "name": "diredDir",
          "package": "yi",
          "signature": "FilePath -\u003e YiM ()",
          "source": "src/Yi-Dired.html#diredDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Dired",
          "module": "Yi.Dired",
          "name": "diredDir",
          "normalized": "FilePath-\u003eYiM()",
          "package": "yi",
          "partial": "Dir",
          "signature": "FilePath-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dired.html#v:diredDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Dired",
          "name": "diredDirBuffer",
          "package": "yi",
          "signature": "FilePath -\u003e YiM BufferRef",
          "source": "src/Yi-Dired.html#diredDirBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Dired",
          "module": "Yi.Dired",
          "name": "diredDirBuffer",
          "normalized": "FilePath-\u003eYiM BufferRef",
          "package": "yi",
          "partial": "Dir Buffer",
          "signature": "FilePath-\u003eYiM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dired.html#v:diredDirBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Dynamic",
          "name": "Dynamic",
          "package": "yi",
          "source": "src/Yi-Dynamic.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "Dynamic",
          "package": "yi",
          "partial": "Dynamic",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \"extensible record\" of \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003es. Can be constructed and accessed with \u003ccode\u003e\u003ca\u003einitial\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003econfigVariableA\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis type can be thought of as a record containing \u003cem\u003eall\u003c/em\u003e \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003es in existence.\n\u003c/p\u003e",
          "module": "Yi.Dynamic",
          "name": "ConfigVariables",
          "package": "yi",
          "source": "src/Yi-Dynamic.html#ConfigVariables",
          "type": "data"
        },
        "index": {
          "description": "An extensible record of YiConfigVariable Can be constructed and accessed with initial and configVariableA This type can be thought of as record containing all YiConfigVariable in existence",
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "ConfigVariables",
          "package": "yi",
          "partial": "Config Variables",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#t:ConfigVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn extensible record, indexed by type.\n\u003c/p\u003e",
          "module": "Yi.Dynamic",
          "name": "DynamicValues",
          "package": "yi",
          "source": "src/Yi-Dynamic.html#DynamicValues",
          "type": "data"
        },
        "index": {
          "description": "An extensible record indexed by type",
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "DynamicValues",
          "package": "yi",
          "partial": "Dynamic Values",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#t:DynamicValues"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of values that can go in a \u003ccode\u003eConfigDynamic\u003c/code\u003e or a \u003ccode\u003eConfigDynamicValues\u003c/code\u003e.\n These will typically go in a \u003ccode\u003eConfig\u003c/code\u003e. As the \u003ccode\u003eConfig\u003c/code\u003e has no mutable state,\n there is no need to serialize these values: if needed, they will be set in the\n user's configuration file. The \u003ccode\u003e\u003ca\u003eInitializable\u003c/a\u003e\u003c/code\u003e constraint ensures that, even if\n the user hasn't customised this config variable, a value is stil available.\n\u003c/p\u003e",
          "module": "Yi.Dynamic",
          "name": "YiConfigVariable",
          "package": "yi",
          "source": "src/Yi-Dynamic.html#YiConfigVariable",
          "type": "class"
        },
        "index": {
          "description": "Class of values that can go in ConfigDynamic or ConfigDynamicValues These will typically go in Config As the Config has no mutable state there is no need to serialize these values if needed they will be set in the user configuration file The Initializable constraint ensures that even if the user hasn customised this config variable value is stil available",
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "YiConfigVariable",
          "package": "yi",
          "partial": "Yi Config Variable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#t:YiConfigVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass of values that can go in a \u003ccode\u003eDynamic\u003c/code\u003e or a \u003ccode\u003e\u003ca\u003eDynamicValues\u003c/a\u003e\u003c/code\u003e. These are\n typically for storing custom state in a \u003ccode\u003eFBuffer\u003c/code\u003e or an \u003ccode\u003eEditor\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Dynamic",
          "name": "YiVariable",
          "package": "yi",
          "source": "src/Yi-Dynamic.html#YiVariable",
          "type": "class"
        },
        "index": {
          "description": "Class of values that can go in Dynamic or DynamicValues These are typically for storing custom state in FBuffer or an Editor",
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "YiVariable",
          "package": "yi",
          "partial": "Yi Variable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#t:YiVariable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for any \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003e. Neither reader nor writer can fail:\n if the user's config file hasn't set a value for a \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003e,\n then the default value is used.\n\u003c/p\u003e",
          "module": "Yi.Dynamic",
          "name": "configVariableA",
          "package": "yi",
          "signature": "Accessor ConfigVariables a",
          "source": "src/Yi-Dynamic.html#configVariableA",
          "type": "function"
        },
        "index": {
          "description": "Accessor for any YiConfigVariable Neither reader nor writer can fail if the user config file hasn set value for YiConfigVariable then the default value is used",
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "configVariableA",
          "package": "yi",
          "partial": "Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#v:configVariableA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for a dynamic component. If the component is not found, the value \u003ccode\u003e\u003ca\u003einitial\u003c/a\u003e\u003c/code\u003e is used.\n\u003c/p\u003e",
          "module": "Yi.Dynamic",
          "name": "dynamicValueA",
          "package": "yi",
          "signature": "Accessor DynamicValues a",
          "source": "src/Yi-Dynamic.html#dynamicValueA",
          "type": "function"
        },
        "index": {
          "description": "Accessor for dynamic component If the component is not found the value initial is used",
          "hierarchy": "Yi Dynamic",
          "module": "Yi.Dynamic",
          "name": "dynamicValueA",
          "package": "yi",
          "partial": "Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Dynamic.html#v:dynamicValueA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe top level editor state, and operations on it.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Editor",
          "name": "Editor",
          "package": "yi",
          "source": "src/Yi-Editor.html",
          "type": "module"
        },
        "index": {
          "description": "The top level editor state and operations on it",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "Editor",
          "package": "yi",
          "partial": "Editor",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Editor state\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "Editor",
          "package": "yi",
          "source": "src/Yi-Editor.html#Editor",
          "type": "data"
        },
        "index": {
          "description": "The Editor state",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "Editor",
          "package": "yi",
          "partial": "Editor",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#t:Editor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "EditorM",
          "package": "yi",
          "source": "src/Yi-Editor.html#EditorM",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "EditorM",
          "package": "yi",
          "partial": "Editor",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#t:EditorM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "MonadEditor",
          "package": "yi",
          "source": "src/Yi-Editor.html#MonadEditor",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "MonadEditor",
          "package": "yi",
          "partial": "Monad Editor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#t:MonadEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "Status",
          "package": "yi",
          "source": "src/Yi-Editor.html#Status",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "Status",
          "package": "yi",
          "partial": "Status",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#t:Status"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "Statuses",
          "package": "yi",
          "source": "src/Yi-Editor.html#Statuses",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "Statuses",
          "package": "yi",
          "partial": "Statuses",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#t:Statuses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the hint for the next temp buffer's name.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "TempBufferNameHint",
          "package": "yi",
          "source": "src/Yi-Editor.html#TempBufferNameHint",
          "type": "data"
        },
        "index": {
          "description": "Specifies the hint for the next temp buffer name",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "TempBufferNameHint",
          "package": "yi",
          "partial": "Temp Buffer Name Hint",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#t:TempBufferNameHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "Editor",
          "package": "yi",
          "signature": "Editor",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "Editor",
          "package": "yi",
          "partial": "Editor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:Editor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "EditorM",
          "package": "yi",
          "signature": "EditorM",
          "source": "src/Yi-Editor.html#EditorM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "EditorM",
          "package": "yi",
          "partial": "Editor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:EditorM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "TempBufferNameHint",
          "package": "yi",
          "signature": "TempBufferNameHint",
          "source": "src/Yi-Editor.html#TempBufferNameHint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "TempBufferNameHint",
          "package": "yi",
          "partial": "Temp Buffer Name Hint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:TempBufferNameHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "acceptedInputs",
          "package": "yi",
          "signature": "EditorM [String]",
          "source": "src/Yi-Editor.html#acceptedInputs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "acceptedInputs",
          "normalized": "EditorM[String]",
          "package": "yi",
          "partial": "Inputs",
          "signature": "EditorM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:acceptedInputs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "addJumpHereE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#addJumpHereE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "addJumpHereE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Jump Here",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:addJumpHereE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "alternateBufferE",
          "package": "yi",
          "signature": "Int -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#alternateBufferE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "alternateBufferE",
          "normalized": "Int-\u003eEditorM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:alternateBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "askCfg",
          "package": "yi",
          "signature": "m Config",
          "source": "src/Yi-Editor.html#askCfg",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "askCfg",
          "package": "yi",
          "partial": "Cfg",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:askCfg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "askConfigVariableA",
          "package": "yi",
          "signature": "m b",
          "source": "src/Yi-Editor.html#askConfigVariableA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "askConfigVariableA",
          "package": "yi",
          "partial": "Config Variable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:askConfigVariableA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the buffers we have, \u003cem\u003ein no particular order\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "bufferSet",
          "package": "yi",
          "signature": "Editor -\u003e [FBuffer]",
          "source": "src/Yi-Editor.html#bufferSet",
          "type": "function"
        },
        "index": {
          "description": "Return the buffers we have in no particular order",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "bufferSet",
          "normalized": "Editor-\u003e[FBuffer]",
          "package": "yi",
          "partial": "Set",
          "signature": "Editor-\u003e[FBuffer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:bufferSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStack of all the buffers. \n Invariant: never empty\n Invariant: first buffer is the current one.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "bufferStack",
          "package": "yi",
          "signature": "[BufferRef]",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "Stack of all the buffers Invariant never empty Invariant first buffer is the current one",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "bufferStack",
          "normalized": "[BufferRef]",
          "package": "yi",
          "partial": "Stack",
          "signature": "[BufferRef]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:bufferStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "bufferStackA",
          "package": "yi",
          "signature": "T Editor [BufferRef]",
          "source": "src/Yi-Editor.html#bufferStackA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "bufferStackA",
          "normalized": "T Editor[BufferRef]",
          "package": "yi",
          "partial": "Stack",
          "signature": "T Editor[BufferRef]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:bufferStackA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "buffers",
          "package": "yi",
          "signature": "(Map BufferRef FBuffer)",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "buffers",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:buffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "buffersA",
          "package": "yi",
          "signature": "T Editor (Map BufferRef FBuffer)",
          "source": "src/Yi-Editor.html#buffersA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "buffersA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:buffersA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose current buffer and window, unless it's the last one.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "closeBufferAndWindowE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#closeBufferAndWindowE",
          "type": "function"
        },
        "index": {
          "description": "Close current buffer and window unless it the last one",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "closeBufferAndWindowE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Buffer And Window",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:closeBufferAndWindowE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose a buffer.\n Note: close the current buffer if the empty string is given\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "closeBufferE",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#closeBufferE",
          "type": "function"
        },
        "index": {
          "description": "Close buffer Note close the current buffer if the empty string is given",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "closeBufferE",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:closeBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake the current window the only window on the screen\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "closeOtherE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#closeOtherE",
          "type": "function"
        },
        "index": {
          "description": "Make the current window the only window on the screen",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "closeOtherE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Other",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:closeOtherE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear the status line\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "clrStatus",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#clrStatus",
          "type": "function"
        },
        "index": {
          "description": "Clear the status line",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "clrStatus",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Status",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:clrStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a prefix that can be removed from all buffer paths while keeping them\n unique.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "commonNamePrefix",
          "package": "yi",
          "signature": "Editor -\u003e [String]",
          "source": "src/Yi-Editor.html#commonNamePrefix",
          "type": "function"
        },
        "index": {
          "description": "Return prefix that can be removed from all buffer paths while keeping them unique",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "commonNamePrefix",
          "normalized": "Editor-\u003e[String]",
          "package": "yi",
          "partial": "Name Prefix",
          "signature": "Editor-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:commonNamePrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the current buffer\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "currentBuffer",
          "package": "yi",
          "signature": "Editor -\u003e BufferRef",
          "source": "src/Yi-Editor.html#currentBuffer",
          "type": "function"
        },
        "index": {
          "description": "Return the current buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "currentBuffer",
          "normalized": "Editor-\u003eBufferRef",
          "package": "yi",
          "partial": "Buffer",
          "signature": "Editor-\u003eBufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:currentBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrently highlighted regex (also most recent regex for use in vim bindings)\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "currentRegex",
          "package": "yi",
          "signature": "(Maybe SearchExp)",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "currently highlighted regex also most recent regex for use in vim bindings",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "currentRegex",
          "package": "yi",
          "partial": "Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:currentRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "currentRegexA",
          "package": "yi",
          "signature": "T Editor (Maybe SearchExp)",
          "source": "src/Yi-Editor.html#currentRegexA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "currentRegexA",
          "package": "yi",
          "partial": "Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:currentRegexA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "currentTabA",
          "package": "yi",
          "signature": "Accessor Editor Tab",
          "source": "src/Yi-Editor.html#currentTabA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "currentTabA",
          "package": "yi",
          "partial": "Tab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:currentTabA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "currentWindowA",
          "package": "yi",
          "signature": "Accessor Editor Window",
          "source": "src/Yi-Editor.html#currentWindowA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "currentWindowA",
          "package": "yi",
          "partial": "Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:currentWindowA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete a buffer (and release resources associated with it).\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "deleteBuffer",
          "package": "yi",
          "signature": "BufferRef -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#deleteBuffer",
          "type": "function"
        },
        "index": {
          "description": "Delete buffer and release resources associated with it",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "deleteBuffer",
          "normalized": "BufferRef-\u003eEditorM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "BufferRef-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:deleteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeletes the current tab. If there is only one tab open then error out.\n   When the last tab is focused, move focus to the left, otherwise\n   move focus to the right.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "deleteTabE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#deleteTabE",
          "type": "function"
        },
        "index": {
          "description": "Deletes the current tab If there is only one tab open then error out When the last tab is focused move focus to the left otherwise move focus to the right",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "deleteTabE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Tab",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:deleteTabE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "dynA",
          "package": "yi",
          "signature": "Accessor Editor a",
          "source": "src/Yi-Editor.html#dynA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "dynA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:dynA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edynamic components\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "dynamic",
          "package": "yi",
          "signature": "DynamicValues",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "dynamic components",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "dynamic",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:dynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "dynamicA",
          "package": "yi",
          "signature": "T Editor DynamicValues",
          "source": "src/Yi-Editor.html#dynamicA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "dynamicA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:dynamicA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe initial state\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "emptyEditor",
          "package": "yi",
          "signature": "Editor",
          "source": "src/Yi-Editor.html#emptyEditor",
          "type": "function"
        },
        "index": {
          "description": "The initial state",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "emptyEditor",
          "package": "yi",
          "partial": "Editor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:emptyEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnlarge the current window\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "enlargeWinE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#enlargeWinE",
          "type": "function"
        },
        "index": {
          "description": "Enlarge the current window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "enlargeWinE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:enlargeWinE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "findBuffer",
          "package": "yi",
          "signature": "BufferRef -\u003e EditorM (Maybe FBuffer)",
          "source": "src/Yi-Editor.html#findBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "findBuffer",
          "normalized": "BufferRef-\u003eEditorM(Maybe FBuffer)",
          "package": "yi",
          "partial": "Buffer",
          "signature": "BufferRef-\u003eEditorM(Maybe FBuffer)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:findBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind buffer with this key\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "findBufferWith",
          "package": "yi",
          "signature": "BufferRef -\u003e Editor -\u003e FBuffer",
          "source": "src/Yi-Editor.html#findBufferWith",
          "type": "function"
        },
        "index": {
          "description": "Find buffer with this key",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "findBufferWith",
          "normalized": "BufferRef-\u003eEditor-\u003eFBuffer",
          "package": "yi",
          "partial": "Buffer With",
          "signature": "BufferRef-\u003eEditor-\u003eFBuffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:findBufferWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind buffer with this name\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "findBufferWithName",
          "package": "yi",
          "signature": "String -\u003e Editor -\u003e [BufferRef]",
          "source": "src/Yi-Editor.html#findBufferWithName",
          "type": "function"
        },
        "index": {
          "description": "Find buffer with this name",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "findBufferWithName",
          "normalized": "String-\u003eEditor-\u003e[BufferRef]",
          "package": "yi",
          "partial": "Buffer With Name",
          "signature": "String-\u003eEditor-\u003e[BufferRef]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:findBufferWithName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "findWindowWith",
          "package": "yi",
          "signature": "WindowRef -\u003e Editor -\u003e Window",
          "source": "src/Yi-Editor.html#findWindowWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "findWindowWith",
          "normalized": "WindowRef-\u003eEditor-\u003eWindow",
          "package": "yi",
          "partial": "Window With",
          "signature": "WindowRef-\u003eEditor-\u003eWindow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:findWindowWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ca\u003efake\u003c/a\u003e accessor that fixes the current buffer after a change of the current\n window. \n Enforces invariant that top of buffer stack is the buffer of the current window.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "fixCurrentBufferA_",
          "package": "yi",
          "signature": "Accessor Editor Editor",
          "source": "src/Yi-Editor.html#fixCurrentBufferA_",
          "type": "function"
        },
        "index": {
          "description": "fake accessor that fixes the current buffer after change of the current window Enforces invariant that top of buffer stack is the buffer of the current window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "fixCurrentBufferA_",
          "package": "yi",
          "partial": "Current Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:fixCurrentBufferA_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCounterpart of fixCurrentBufferA_: fix the current window to point to the\n right buffer.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "fixCurrentWindow",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#fixCurrentWindow",
          "type": "function"
        },
        "index": {
          "description": "Counterpart of fixCurrentBufferA fix the current window to point to the right buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "fixCurrentWindow",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Current Window",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:fixCurrentWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebring the editor focus the window with the given key.\n\u003c/p\u003e\u003cp\u003eFails if no window with the given key is found.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "focusWindowE",
          "package": "yi",
          "signature": "WindowRef -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#focusWindowE",
          "type": "function"
        },
        "index": {
          "description": "bring the editor focus the window with the given key Fails if no window with the given key is found",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "focusWindowE",
          "normalized": "WindowRef-\u003eEditorM()",
          "package": "yi",
          "partial": "Window",
          "signature": "WindowRef-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:focusWindowE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "forceFold1",
          "package": "yi",
          "signature": "t a -\u003e t a",
          "source": "src/Yi-Editor.html#forceFold1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "forceFold1",
          "normalized": "a b-\u003ea b",
          "package": "yi",
          "partial": "Fold",
          "signature": "t a-\u003et a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:forceFold1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "forceFoldTabs",
          "package": "yi",
          "signature": "t Tab -\u003e t Tab",
          "source": "src/Yi-Editor.html#forceFoldTabs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "forceFoldTabs",
          "normalized": "a Tab-\u003ea Tab",
          "package": "yi",
          "partial": "Fold Tabs",
          "signature": "t Tab-\u003et Tab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:forceFoldTabs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "fromEditorM",
          "package": "yi",
          "signature": "RWS Config () Editor a",
          "source": "src/Yi-Editor.html#EditorM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "fromEditorM",
          "normalized": "RWS Config()Editor a",
          "package": "yi",
          "partial": "Editor",
          "signature": "RWS Config()Editor a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:fromEditorM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "getBufferStack",
          "package": "yi",
          "signature": "EditorM [FBuffer]",
          "source": "src/Yi-Editor.html#getBufferStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "getBufferStack",
          "normalized": "EditorM[FBuffer]",
          "package": "yi",
          "partial": "Buffer Stack",
          "signature": "EditorM[FBuffer]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:getBufferStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind buffer with given name. Fail if not found.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "getBufferWithName",
          "package": "yi",
          "signature": "String -\u003e EditorM BufferRef",
          "source": "src/Yi-Editor.html#getBufferWithName",
          "type": "function"
        },
        "index": {
          "description": "Find buffer with given name Fail if not found",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "getBufferWithName",
          "normalized": "String-\u003eEditorM BufferRef",
          "package": "yi",
          "partial": "Buffer With Name",
          "signature": "String-\u003eEditorM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:getBufferWithName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "getBufferWithNameOrCurrent",
          "package": "yi",
          "signature": "String -\u003e EditorM BufferRef",
          "source": "src/Yi-Editor.html#getBufferWithNameOrCurrent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "getBufferWithNameOrCurrent",
          "normalized": "String-\u003eEditorM BufferRef",
          "package": "yi",
          "partial": "Buffer With Name Or Current",
          "signature": "String-\u003eEditorM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:getBufferWithNameOrCurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDynamically-extensible state components.\n\u003c/p\u003e\u003cp\u003eThese hooks are used by keymaps to store values that result from\n Actions (i.e. that restult from IO), as opposed to the pure values\n they generate themselves, and can be stored internally.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003edynamic\u003c/a\u003e\u003c/code\u003e field is a type-indexed map.\n\u003c/p\u003e\u003cp\u003eRetrieve a value from the extensible state\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "getDynamic",
          "package": "yi",
          "signature": "EditorM a",
          "source": "src/Yi-Editor.html#getDynamic",
          "type": "function"
        },
        "index": {
          "description": "Dynamically-extensible state components These hooks are used by keymaps to store values that result from Actions i.e that restult from IO as opposed to the pure values they generate themselves and can be stored internally The dynamic field is type-indexed map Retrieve value from the extensible state",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "getDynamic",
          "package": "yi",
          "partial": "Dynamic",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:getDynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the contents of the yank register\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "getRegE",
          "package": "yi",
          "signature": "EditorM String",
          "source": "src/Yi-Editor.html#getRegE",
          "type": "function"
        },
        "index": {
          "description": "Return the contents of the yank register",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "getRegE",
          "package": "yi",
          "partial": "Reg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:getRegE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "insertBuffer",
          "package": "yi",
          "signature": "FBuffer -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#insertBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "insertBuffer",
          "normalized": "FBuffer-\u003eEditorM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "FBuffer-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:insertBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "jumpBackE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#jumpBackE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "jumpBackE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Back",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:jumpBackE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "jumpForwardE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#jumpForwardE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "jumpForwardE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Forward",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:jumpForwardE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "killring",
          "package": "yi",
          "signature": "Killring",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "killring",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:killring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "killringA",
          "package": "yi",
          "signature": "T Editor Killring",
          "source": "src/Yi-Editor.html#killringA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "killringA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:killringA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNext variant of the current layout manager, as given by \u003ccode\u003e\u003ca\u003enextVariant\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "layoutManagerNextVariantE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#layoutManagerNextVariantE",
          "type": "function"
        },
        "index": {
          "description": "Next variant of the current layout manager as given by nextVariant",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "layoutManagerNextVariantE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Manager Next Variant",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:layoutManagerNextVariantE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrevious variant of the current layout manager, as given by \u003ccode\u003e\u003ca\u003epreviousVariant\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "layoutManagerPreviousVariantE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#layoutManagerPreviousVariantE",
          "type": "function"
        },
        "index": {
          "description": "Previous variant of the current layout manager as given by previousVariant",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "layoutManagerPreviousVariantE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Manager Previous Variant",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:layoutManagerPreviousVariantE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycle to the next layout manager, or the first one if the current one is nonstandard.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "layoutManagersNextE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#layoutManagersNextE",
          "type": "function"
        },
        "index": {
          "description": "Cycle to the next layout manager or the first one if the current one is nonstandard",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "layoutManagersNextE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Managers Next",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:layoutManagersNextE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycle to the previous layout manager, or the first one if the current one is nonstandard.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "layoutManagersPreviousE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#layoutManagersPreviousE",
          "type": "function"
        },
        "index": {
          "description": "Cycle to the previous layout manager or the first one if the current one is nonstandard",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "layoutManagersPreviousE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Managers Previous",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:layoutManagersPreviousE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "liftEditor",
          "package": "yi",
          "signature": "EditorM a -\u003e m a",
          "source": "src/Yi-Editor.html#liftEditor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "liftEditor",
          "normalized": "EditorM a-\u003eb a",
          "package": "yi",
          "partial": "Editor",
          "signature": "EditorM a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:liftEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "maxStatusHeight",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "maxStatusHeight",
          "package": "yi",
          "partial": "Status Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:maxStatusHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "maxStatusHeightA",
          "package": "yi",
          "signature": "T Editor Int",
          "source": "src/Yi-Editor.html#maxStatusHeightA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "maxStatusHeightA",
          "package": "yi",
          "partial": "Status Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:maxStatusHeightA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "modifyJumpListE",
          "package": "yi",
          "signature": "(JumpList -\u003e JumpList) -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#modifyJumpListE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "modifyJumpListE",
          "normalized": "(JumpList-\u003eJumpList)-\u003eEditorM()",
          "package": "yi",
          "partial": "Jump List",
          "signature": "(JumpList-\u003eJumpList)-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:modifyJumpListE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMoves the focused tab to the given index, or to the end if the index is not specified.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "moveTab",
          "package": "yi",
          "signature": "Maybe Int -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#moveTab",
          "type": "function"
        },
        "index": {
          "description": "Moves the focused tab to the given index or to the end if the index is not specified",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "moveTab",
          "normalized": "Maybe Int-\u003eEditorM()",
          "package": "yi",
          "partial": "Tab",
          "signature": "Maybe Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:moveTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap focused window with the next one\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "moveWinNextE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#moveWinNextE",
          "type": "function"
        },
        "index": {
          "description": "Swap focused window with the next one",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "moveWinNextE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win Next",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:moveWinNextE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwap focused window with the previous one\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "moveWinPrevE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#moveWinPrevE",
          "type": "function"
        },
        "index": {
          "description": "Swap focused window with the previous one",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "moveWinPrevE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win Prev",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:moveWinPrevE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "newBufRef",
          "package": "yi",
          "signature": "EditorM BufferRef",
          "source": "src/Yi-Editor.html#newBufRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newBufRef",
          "package": "yi",
          "partial": "Buf Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newBufRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike fnewE, create a new buffer filled with the String \u003ccode\u003es\u003c/code\u003e,\n Switch the current window to this buffer. Doesn't associate any file\n with the buffer (unlike fnewE) and so is good for popup internal\n buffers (like scratch)\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "newBufferE",
          "package": "yi",
          "signature": "BufferId-\u003e Rope-\u003e EditorM BufferRef",
          "type": "function"
        },
        "index": {
          "description": "Like fnewE create new buffer filled with the String Switch the current window to this buffer Doesn associate any file with the buffer unlike fnewE and so is good for popup internal buffers like scratch",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newBufferE",
          "normalized": "BufferId-\u003eRope-\u003eEditorM BufferRef",
          "package": "yi",
          "partial": "Buffer",
          "signature": "BufferId-\u003eRope-\u003eEditorM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "newRef",
          "package": "yi",
          "signature": "EditorM Int",
          "source": "src/Yi-Editor.html#newRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newRef",
          "package": "yi",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a new tab containing a window that views the current buffer.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "newTabE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#newTabE",
          "type": "function"
        },
        "index": {
          "description": "Creates new tab containing window that views the current buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newTabE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Tab",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newTabE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates an in-memory buffer with a unique name. \n\u003c/p\u003e\u003cp\u003eA hint for the buffer naming scheme can be specified in the dynamic variable TempBufferNameHint\n The new buffer always has a buffer ID that did not exist before newTempBufferE.\n TODO: this probably a lot more complicated than it should be: why not count from zero every time?\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "newTempBufferE",
          "package": "yi",
          "signature": "EditorM BufferRef",
          "source": "src/Yi-Editor.html#newTempBufferE",
          "type": "function"
        },
        "index": {
          "description": "Creates an in-memory buffer with unique name hint for the buffer naming scheme can be specified in the dynamic variable TempBufferNameHint The new buffer always has buffer ID that did not exist before newTempBufferE TODO this probably lot more complicated than it should be why not count from zero every time",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newTempBufferE",
          "package": "yi",
          "partial": "Temp Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newTempBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new window onto the given buffer.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "newWindowE",
          "package": "yi",
          "signature": "Bool -\u003e BufferRef -\u003e EditorM Window",
          "source": "src/Yi-Editor.html#newWindowE",
          "type": "function"
        },
        "index": {
          "description": "Create new window onto the given buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newWindowE",
          "normalized": "Bool-\u003eBufferRef-\u003eEditorM Window",
          "package": "yi",
          "partial": "Window",
          "signature": "Bool-\u003eBufferRef-\u003eEditorM Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newWindowE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new zero size window on a given buffer\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "newZeroSizeWindow",
          "package": "yi",
          "signature": "Bool -\u003e BufferRef -\u003e WindowRef -\u003e Window",
          "source": "src/Yi-Editor.html#newZeroSizeWindow",
          "type": "function"
        },
        "index": {
          "description": "Create new zero size window on given buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "newZeroSizeWindow",
          "normalized": "Bool-\u003eBufferRef-\u003eWindowRef-\u003eWindow",
          "package": "yi",
          "partial": "Zero Size Window",
          "signature": "Bool-\u003eBufferRef-\u003eWindowRef-\u003eWindow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:newZeroSizeWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach the next buffer in the buffer stack to the current window.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "nextBufW",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#nextBufW",
          "type": "function"
        },
        "index": {
          "description": "Attach the next buffer in the buffer stack to the current window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "nextBufW",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Buf",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:nextBufW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMoves to the next tab in the round robin set of tabs\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "nextTabE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#nextTabE",
          "type": "function"
        },
        "index": {
          "description": "Moves to the next tab in the round robin set of tabs",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "nextTabE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Tab",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:nextTabE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate focus to the next window\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "nextWinE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#nextWinE",
          "type": "function"
        },
        "index": {
          "description": "Rotate focus to the next window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "nextWinE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:nextWinE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActions to be run when the buffer is closed; should be scrapped.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "onCloseActions",
          "package": "yi",
          "signature": "(Map BufferRef (EditorM ()))",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "Actions to be run when the buffer is closed should be scrapped",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "onCloseActions",
          "normalized": "(Map BufferRef(EditorM()))",
          "package": "yi",
          "partial": "Close Actions",
          "signature": "(Map BufferRef(EditorM()))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:onCloseActions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "onCloseActionsA",
          "package": "yi",
          "signature": "T Editor (Map BufferRef (EditorM ()))",
          "source": "src/Yi-Editor.html#onCloseActionsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "onCloseActionsA",
          "normalized": "T Editor(Map BufferRef(EditorM()))",
          "package": "yi",
          "partial": "Close Actions",
          "signature": "T Editor(Map BufferRef(EditorM()))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:onCloseActionsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefines an action to be executed when the current buffer is closed. \n\u003c/p\u003e\u003cp\u003eUsed by the minibuffer to assure the focus is restored to the buffer that spawned the minibuffer.\n\u003c/p\u003e\u003cp\u003etodo: These actions are not restored on reload.\n\u003c/p\u003e\u003cp\u003etodo: These actions should probably be very careful at what they do.\n TODO: All in all, this is a very ugly way to achieve the purpose. The nice way to proceed\n is to somehow attach the miniwindow to the window that has spawned it.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "onCloseBufferE",
          "package": "yi",
          "signature": "BufferRef -\u003e EditorM () -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#onCloseBufferE",
          "type": "function"
        },
        "index": {
          "description": "Defines an action to be executed when the current buffer is closed Used by the minibuffer to assure the focus is restored to the buffer that spawned the minibuffer todo These actions are not restored on reload todo These actions should probably be very careful at what they do TODO All in all this is very ugly way to achieve the purpose The nice way to proceed is to somehow attach the miniwindow to the window that has spawned it",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "onCloseBufferE",
          "normalized": "BufferRef-\u003eEditorM()-\u003eEditorM()",
          "package": "yi",
          "partial": "Close Buffer",
          "signature": "BufferRef-\u003eEditorM()-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:onCloseBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake all buffers visible by splitting the current window list.\n FIXME: rename to displayAllBuffersE; make sure buffers are not open twice.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "openAllBuffersE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#openAllBuffersE",
          "type": "function"
        },
        "index": {
          "description": "Make all buffers visible by splitting the current window list FIXME rename to displayAllBuffersE make sure buffers are not open twice",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "openAllBuffersE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "All Buffers",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:openAllBuffersE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eProcessed events that didn't yield any action yet.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "pendingEvents",
          "package": "yi",
          "signature": "[Event]",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "Processed events that didn yield any action yet",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "pendingEvents",
          "normalized": "[Event]",
          "package": "yi",
          "partial": "Events",
          "signature": "[Event]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:pendingEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "pendingEventsA",
          "package": "yi",
          "signature": "T Editor [Event]",
          "source": "src/Yi-Editor.html#pendingEventsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "pendingEventsA",
          "normalized": "T Editor[Event]",
          "package": "yi",
          "partial": "Events",
          "signature": "T Editor[Event]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:pendingEventsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach the previous buffer in the stack list to the current window.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "prevBufW",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#prevBufW",
          "type": "function"
        },
        "index": {
          "description": "Attach the previous buffer in the stack list to the current window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "prevBufW",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Buf",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:prevBufW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate focus to the previous window\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "prevWinE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#prevWinE",
          "type": "function"
        },
        "index": {
          "description": "Rotate focus to the previous window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "prevWinE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:prevWinE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMoves to the previous tab in the round robin set of tabs\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "previousTabE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#previousTabE",
          "type": "function"
        },
        "index": {
          "description": "Moves to the previous tab in the round robin set of tabs",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "previousTabE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Tab",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:previousTabE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisplay a transient message\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "printMsg",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#printMsg",
          "type": "function"
        },
        "index": {
          "description": "Display transient message",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "printMsg",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Msg",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:printMsg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "printMsgs",
          "package": "yi",
          "signature": "[String] -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#printMsgs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "printMsgs",
          "normalized": "[String]-\u003eEditorM()",
          "package": "yi",
          "partial": "Msgs",
          "signature": "[String]-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:printMsgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "printStatus",
          "package": "yi",
          "signature": "Status -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#printStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "printStatus",
          "normalized": "Status-\u003eEditorM()",
          "package": "yi",
          "partial": "Status",
          "signature": "Status-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:printStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMoves the focused window to the first window, and moves all other windows down the stack.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "pushWinToFirstE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#pushWinToFirstE",
          "type": "function"
        },
        "index": {
          "description": "Moves the focused window to the first window and moves all other windows down the stack",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "pushWinToFirstE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win To First",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:pushWinToFirstE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupply for buffer, window and tab ids.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "refSupply",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "Supply for buffer window and tab ids",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "refSupply",
          "package": "yi",
          "partial": "Supply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:refSupply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "refSupplyA",
          "package": "yi",
          "signature": "T Editor Int",
          "source": "src/Yi-Editor.html#refSupplyA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "refSupplyA",
          "package": "yi",
          "partial": "Supply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:refSupplyA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "runEditor",
          "package": "yi",
          "signature": "Config -\u003e EditorM a -\u003e Editor -\u003e (Editor, a)",
          "source": "src/Yi-Editor.html#runEditor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "runEditor",
          "normalized": "Config-\u003eEditorM a-\u003eEditor-\u003e(Editor,a)",
          "package": "yi",
          "partial": "Editor",
          "signature": "Config-\u003eEditorM a-\u003eEditor-\u003e(Editor,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:runEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "searchDirection",
          "package": "yi",
          "signature": "Direction",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "searchDirection",
          "package": "yi",
          "partial": "Direction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:searchDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "searchDirectionA",
          "package": "yi",
          "signature": "T Editor Direction",
          "source": "src/Yi-Editor.html#searchDirectionA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "searchDirectionA",
          "package": "yi",
          "partial": "Direction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:searchDirectionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSets the given divider position on the current tab\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "setDividerPosE",
          "package": "yi",
          "signature": "DividerRef -\u003e DividerPosition -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#setDividerPosE",
          "type": "function"
        },
        "index": {
          "description": "Sets the given divider position on the current tab",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "setDividerPosE",
          "normalized": "DividerRef-\u003eDividerPosition-\u003eEditorM()",
          "package": "yi",
          "partial": "Divider Pos",
          "signature": "DividerRef-\u003eDividerPosition-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:setDividerPosE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert a value into the extensible state, keyed by its type\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "setDynamic",
          "package": "yi",
          "signature": "a -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#setDynamic",
          "type": "function"
        },
        "index": {
          "description": "Insert value into the extensible state keyed by its type",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "setDynamic",
          "normalized": "a-\u003eEditorM()",
          "package": "yi",
          "partial": "Dynamic",
          "signature": "a-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:setDynamic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut string into yank register\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "setRegE",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#setRegE",
          "type": "function"
        },
        "index": {
          "description": "Put string into yank register",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "setRegE",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Reg",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:setRegE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the \u003ca\u003ebackground\u003c/a\u003e status line \n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "setStatus",
          "package": "yi",
          "signature": "Status -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#setStatus",
          "type": "function"
        },
        "index": {
          "description": "Set the background status line",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "setStatus",
          "normalized": "Status-\u003eEditorM()",
          "package": "yi",
          "partial": "Status",
          "signature": "Status-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:setStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "setTmpStatus",
          "package": "yi",
          "signature": "Int -\u003e Status -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#setTmpStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "setTmpStatus",
          "normalized": "Int-\u003eStatus-\u003eEditorM()",
          "package": "yi",
          "partial": "Tmp Status",
          "signature": "Int-\u003eStatus-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:setTmpStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRotate the buffer stack by the given amount.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "shiftBuffer",
          "package": "yi",
          "signature": "Int -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#shiftBuffer",
          "type": "function"
        },
        "index": {
          "description": "Rotate the buffer stack by the given amount",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "shiftBuffer",
          "normalized": "Int-\u003eEditorM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:shiftBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch focus to some other window. If none is available, create one.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "shiftOtherWindow",
          "package": "yi",
          "signature": "m ()",
          "source": "src/Yi-Editor.html#shiftOtherWindow",
          "type": "function"
        },
        "index": {
          "description": "Switch focus to some other window If none is available create one",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "shiftOtherWindow",
          "normalized": "a()",
          "package": "yi",
          "partial": "Other Window",
          "signature": "m()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:shiftOtherWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShrink the current window\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "shrinkWinE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#shrinkWinE",
          "type": "function"
        },
        "index": {
          "description": "Shrink the current window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "shrinkWinE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:shrinkWinE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the current window, opening a second window onto current buffer.\n TODO: unfold newWindowE here?\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "splitE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#splitE",
          "type": "function"
        },
        "index": {
          "description": "Split the current window opening second window onto current buffer TODO unfold newWindowE here",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "splitE",
          "normalized": "EditorM()",
          "package": "yi",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:splitE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "statusLine",
          "package": "yi",
          "signature": "Editor -\u003e [String]",
          "source": "src/Yi-Editor.html#statusLine",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "statusLine",
          "normalized": "Editor-\u003e[String]",
          "package": "yi",
          "partial": "Line",
          "signature": "Editor-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:statusLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "statusLineInfo",
          "package": "yi",
          "signature": "Editor -\u003e Status",
          "source": "src/Yi-Editor.html#statusLineInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "statusLineInfo",
          "normalized": "Editor-\u003eStatus",
          "package": "yi",
          "partial": "Line Info",
          "signature": "Editor-\u003eStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:statusLineInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "statusLines",
          "package": "yi",
          "signature": "Statuses",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "statusLines",
          "package": "yi",
          "partial": "Lines",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:statusLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "statusLinesA",
          "package": "yi",
          "signature": "T Editor Statuses",
          "source": "src/Yi-Editor.html#statusLinesA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "statusLinesA",
          "package": "yi",
          "partial": "Lines",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:statusLinesA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate and fill a new buffer, using contents of string.\n | Does not focus the window, or make it the current window.\n | Call newWindowE or switchToBufferE to take care of that.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "stringToNewBuffer",
          "package": "yi",
          "signature": "BufferId-\u003e Rope-\u003e EditorM BufferRef",
          "type": "function"
        },
        "index": {
          "description": "Create and fill new buffer using contents of string Does not focus the window or make it the current window Call newWindowE or switchToBufferE to take care of that",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "stringToNewBuffer",
          "normalized": "BufferId-\u003eRope-\u003eEditorM BufferRef",
          "package": "yi",
          "partial": "To New Buffer",
          "signature": "BufferId-\u003eRope-\u003eEditorM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:stringToNewBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwaps the focused window with the first window. Useful for layouts such as \u003ccode\u003eHPairOneStack\u003c/code\u003e, for which the first window is the largest.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "swapWinWithFirstE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#swapWinWithFirstE",
          "type": "function"
        },
        "index": {
          "description": "Swaps the focused window with the first window Useful for layouts such as HPairOneStack for which the first window is the largest",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "swapWinWithFirstE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Win With First",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:swapWinWithFirstE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach the specified buffer to the current window\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "switchToBufferE",
          "package": "yi",
          "signature": "BufferRef -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#switchToBufferE",
          "type": "function"
        },
        "index": {
          "description": "Attach the specified buffer to the current window",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "switchToBufferE",
          "normalized": "BufferRef-\u003eEditorM()",
          "package": "yi",
          "partial": "To Buffer",
          "signature": "BufferRef-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:switchToBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAttach the specified buffer to some other window than the current one\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "switchToBufferOtherWindowE",
          "package": "yi",
          "signature": "BufferRef -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#switchToBufferOtherWindowE",
          "type": "function"
        },
        "index": {
          "description": "Attach the specified buffer to some other window than the current one",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "switchToBufferOtherWindowE",
          "normalized": "BufferRef-\u003eEditorM()",
          "package": "yi",
          "partial": "To Buffer Other Window",
          "signature": "BufferRef-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:switchToBufferOtherWindowE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch to the buffer specified as parameter. If the buffer name is empty, switch to the next buffer.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "switchToBufferWithNameE",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#switchToBufferWithNameE",
          "type": "function"
        },
        "index": {
          "description": "Switch to the buffer specified as parameter If the buffer name is empty switch to the next buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "switchToBufferWithNameE",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "To Buffer With Name",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:switchToBufferWithNameE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "tabsA",
          "package": "yi",
          "signature": "Accessor Editor (PointedList Tab)",
          "source": "src/Yi-Editor.html#tabsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "tabsA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:tabsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent tab contains the visible windows pointed list.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "tabs_",
          "package": "yi",
          "signature": "(PointedList Tab)",
          "source": "src/Yi-Editor.html#Editor",
          "type": "function"
        },
        "index": {
          "description": "current tab contains the visible windows pointed list",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "tabs_",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:tabs_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "tabs_A",
          "package": "yi",
          "signature": "T Editor (PointedList Tab)",
          "source": "src/Yi-Editor.html#tabs_A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "tabs_A",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:tabs_A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "tmp_name_base",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Editor.html#TempBufferNameHint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "tmp_name_base",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:tmp_name_base"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "tmp_name_index",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Editor.html#TempBufferNameHint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "tmp_name_index",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:tmp_name_index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClose the current window. If there is only one tab open and the tab \n contains only one window then do nothing.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "tryCloseE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Editor.html#tryCloseE",
          "type": "function"
        },
        "index": {
          "description": "Close the current window If there is only one tab open and the tab contains only one window then do nothing",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "tryCloseE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Close",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:tryCloseE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "windows",
          "package": "yi",
          "signature": "Editor -\u003e PointedList Window",
          "source": "src/Yi-Editor.html#windows",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "windows",
          "normalized": "Editor-\u003ePointedList Window",
          "package": "yi",
          "signature": "Editor-\u003ePointedList Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:windows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "windowsA",
          "package": "yi",
          "signature": "Accessor Editor (PointedList Window)",
          "source": "src/Yi-Editor.html#windowsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "windowsA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:windowsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the windows that are currently open on the buffer whose key is given\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "windowsOnBufferE",
          "package": "yi",
          "signature": "BufferRef -\u003e EditorM [Window]",
          "source": "src/Yi-Editor.html#windowsOnBufferE",
          "type": "function"
        },
        "index": {
          "description": "Return the windows that are currently open on the buffer whose key is given",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "windowsOnBufferE",
          "normalized": "BufferRef-\u003eEditorM[Window]",
          "package": "yi",
          "partial": "On Buffer",
          "signature": "BufferRef-\u003eEditorM[Window]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:windowsOnBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform action with current window's buffer\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "withBuffer0",
          "package": "yi",
          "signature": "BufferM a -\u003e EditorM a",
          "source": "src/Yi-Editor.html#withBuffer0",
          "type": "function"
        },
        "index": {
          "description": "Perform action with current window buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withBuffer0",
          "normalized": "BufferM a-\u003eEditorM a",
          "package": "yi",
          "partial": "Buffer",
          "signature": "BufferM a-\u003eEditorM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withBuffer0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "withEditor",
          "package": "yi",
          "signature": "EditorM a -\u003e m a",
          "source": "src/Yi-Editor.html#withEditor",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withEditor",
          "normalized": "EditorM a-\u003eb a",
          "package": "yi",
          "partial": "Editor",
          "signature": "EditorM a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform action with any given buffer, using the last window that was used for that buffer.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "withGivenBuffer0",
          "package": "yi",
          "signature": "BufferRef -\u003e BufferM a -\u003e EditorM a",
          "source": "src/Yi-Editor.html#withGivenBuffer0",
          "type": "function"
        },
        "index": {
          "description": "Perform action with any given buffer using the last window that was used for that buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withGivenBuffer0",
          "normalized": "BufferRef-\u003eBufferM a-\u003eEditorM a",
          "package": "yi",
          "partial": "Given Buffer",
          "signature": "BufferRef-\u003eBufferM a-\u003eEditorM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withGivenBuffer0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePerform action with any given buffer\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "withGivenBufferAndWindow0",
          "package": "yi",
          "signature": "Window -\u003e BufferRef -\u003e BufferM a -\u003e EditorM a",
          "source": "src/Yi-Editor.html#withGivenBufferAndWindow0",
          "type": "function"
        },
        "index": {
          "description": "Perform action with any given buffer",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withGivenBufferAndWindow0",
          "normalized": "Window-\u003eBufferRef-\u003eBufferM a-\u003eEditorM a",
          "package": "yi",
          "partial": "Given Buffer And Window",
          "signature": "Window-\u003eBufferRef-\u003eBufferM a-\u003eEditorM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withGivenBufferAndWindow0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHelper function for \u003ccode\u003elayoutManagersNext\u003c/code\u003e and \u003ccode\u003elayoutManagersPrevious\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "withLMStack",
          "package": "yi",
          "signature": "(PointedList AnyLayoutManager -\u003e PointedList AnyLayoutManager) -\u003e EditorM ()",
          "source": "src/Yi-Editor.html#withLMStack",
          "type": "function"
        },
        "index": {
          "description": "Helper function for layoutManagersNext and layoutManagersPrevious",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withLMStack",
          "normalized": "(PointedList AnyLayoutManager-\u003ePointedList AnyLayoutManager)-\u003eEditorM()",
          "package": "yi",
          "partial": "LMStack",
          "signature": "(PointedList AnyLayoutManager-\u003ePointedList AnyLayoutManager)-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withLMStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExecute the argument in the context of an other window. Create\n one if necessary. The current window is re-focused after the\n argument has completed.\n\u003c/p\u003e",
          "module": "Yi.Editor",
          "name": "withOtherWindow",
          "package": "yi",
          "signature": "m a -\u003e m a",
          "source": "src/Yi-Editor.html#withOtherWindow",
          "type": "function"
        },
        "index": {
          "description": "Execute the argument in the context of an other window Create one if necessary The current window is re-focused after the argument has completed",
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withOtherWindow",
          "normalized": "a b-\u003ea b",
          "package": "yi",
          "partial": "Other Window",
          "signature": "m a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withOtherWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Editor",
          "name": "withWindowE",
          "package": "yi",
          "signature": "Window -\u003e BufferM a -\u003e EditorM a",
          "source": "src/Yi-Editor.html#withWindowE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Editor",
          "module": "Yi.Editor",
          "name": "withWindowE",
          "normalized": "Window-\u003eBufferM a-\u003eEditorM a",
          "package": "yi",
          "partial": "Window",
          "signature": "Window-\u003eBufferM a-\u003eEditorM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Editor.html#v:withWindowE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Eval",
          "name": "Eval",
          "package": "yi",
          "source": "src/Yi-Eval.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "Eval",
          "package": "yi",
          "partial": "Eval",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfig variable for customising the behaviour of \u003ccode\u003e\u003ca\u003eexecEditorAction\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003egetAllNamesInScope\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e\u003cp\u003eSet this variable using \u003ccode\u003e\u003ca\u003eevaluator\u003c/a\u003e\u003c/code\u003e. See \u003ccode\u003e\u003ca\u003eghciEvaluator\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003efiniteListEvaluator\u003c/code\u003e for two implementation.\n\u003c/p\u003e",
          "module": "Yi.Eval",
          "name": "Evaluator",
          "package": "yi",
          "source": "src/Yi-Eval.html#Evaluator",
          "type": "data"
        },
        "index": {
          "description": "Config variable for customising the behaviour of execEditorAction and getAllNamesInScope Set this variable using evaluator See ghciEvaluator and finiteListEvaluator for two implementation",
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "Evaluator",
          "package": "yi",
          "partial": "Evaluator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#t:Evaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Eval",
          "name": "Evaluator",
          "package": "yi",
          "signature": "Evaluator",
          "source": "src/Yi-Eval.html#Evaluator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "Evaluator",
          "package": "yi",
          "partial": "Evaluator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:Evaluator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Eval",
          "name": "consoleKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Eval.html#consoleKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "consoleKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:consoleKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRuns the action, as written by the user.\n\u003c/p\u003e\u003cp\u003eThe behaviour of this function can be customised by modifying the \u003ccode\u003e\u003ca\u003eEvaluator\u003c/a\u003e\u003c/code\u003e variable.\n\u003c/p\u003e",
          "module": "Yi.Eval",
          "name": "execEditorAction",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Eval.html#execEditorAction",
          "type": "function"
        },
        "index": {
          "description": "Runs the action as written by the user The behaviour of this function can be customised by modifying the Evaluator variable",
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "execEditorAction",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Editor Action",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:execEditorAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimplementation of \u003ccode\u003e\u003ca\u003eexecEditorAction\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Eval",
          "name": "execEditorActionImpl",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Eval.html#Evaluator",
          "type": "function"
        },
        "index": {
          "description": "implementation of execEditorAction",
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "execEditorActionImpl",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Editor Action Impl",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:execEditorActionImpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLists the action names in scope, for use by \u003ccode\u003e\u003ca\u003eexecEditorAction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe behaviour of this function can be customised by modifying the \u003ccode\u003e\u003ca\u003eEvaluator\u003c/a\u003e\u003c/code\u003e variable.\n\u003c/p\u003e",
          "module": "Yi.Eval",
          "name": "getAllNamesInScope",
          "package": "yi",
          "signature": "YiM [String]",
          "source": "src/Yi-Eval.html#getAllNamesInScope",
          "type": "function"
        },
        "index": {
          "description": "Lists the action names in scope for use by execEditorAction The behaviour of this function can be customised by modifying the Evaluator variable",
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "getAllNamesInScope",
          "normalized": "YiM[String]",
          "package": "yi",
          "partial": "All Names In Scope",
          "signature": "YiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:getAllNamesInScope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimplementation of \u003ccode\u003e\u003ca\u003egetAllNamesInScope\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Eval",
          "name": "getAllNamesInScopeImpl",
          "package": "yi",
          "signature": "YiM [String]",
          "source": "src/Yi-Eval.html#Evaluator",
          "type": "function"
        },
        "index": {
          "description": "implementation of getAllNamesInScope",
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "getAllNamesInScopeImpl",
          "normalized": "YiM[String]",
          "package": "yi",
          "partial": "All Names In Scope Impl",
          "signature": "YiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:getAllNamesInScopeImpl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Eval",
          "name": "jumpToE",
          "package": "yi",
          "signature": "String -\u003e Int -\u003e Int -\u003e YiM ()",
          "source": "src/Yi-Eval.html#jumpToE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "jumpToE",
          "normalized": "String-\u003eInt-\u003eInt-\u003eYiM()",
          "package": "yi",
          "partial": "To",
          "signature": "String-\u003eInt-\u003eInt-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:jumpToE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Eval",
          "name": "jumpToErrorE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Eval.html#jumpToErrorE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Eval",
          "module": "Yi.Eval",
          "name": "jumpToErrorE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "To Error",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Eval.html#v:jumpToErrorE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "Event",
          "package": "yi",
          "source": "src/Yi-Event.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "Event",
          "package": "yi",
          "partial": "Event",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "Event",
          "package": "yi",
          "source": "src/Yi-Event.html#Event",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "Event",
          "package": "yi",
          "partial": "Event",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#t:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "Key",
          "package": "yi",
          "source": "src/Yi-Event.html#Key",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "Key",
          "package": "yi",
          "partial": "Key",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "Modifier",
          "package": "yi",
          "source": "src/Yi-Event.html#Modifier",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "Modifier",
          "package": "yi",
          "partial": "Modifier",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#t:Modifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "Event",
          "package": "yi",
          "signature": "Event Key [Modifier]",
          "source": "src/Yi-Event.html#Event",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "Event",
          "normalized": "Event Key[Modifier]",
          "package": "yi",
          "partial": "Event",
          "signature": "Event Key[Modifier]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:Event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KASCII",
          "package": "yi",
          "signature": "KASCII Char",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KASCII",
          "package": "yi",
          "partial": "KASCII",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KASCII"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KBS",
          "package": "yi",
          "signature": "KBS",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KBS",
          "package": "yi",
          "partial": "KBS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KBS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KDel",
          "package": "yi",
          "signature": "KDel",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KDel",
          "package": "yi",
          "partial": "KDel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KDel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KDown",
          "package": "yi",
          "signature": "KDown",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KDown",
          "package": "yi",
          "partial": "KDown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KEnd",
          "package": "yi",
          "signature": "KEnd",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KEnd",
          "package": "yi",
          "partial": "KEnd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KEnter",
          "package": "yi",
          "signature": "KEnter",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KEnter",
          "package": "yi",
          "partial": "KEnter",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KEnter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KEsc",
          "package": "yi",
          "signature": "KEsc",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KEsc",
          "package": "yi",
          "partial": "KEsc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KEsc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KFun",
          "package": "yi",
          "signature": "KFun Int",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KFun",
          "package": "yi",
          "partial": "KFun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KHome",
          "package": "yi",
          "signature": "KHome",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KHome",
          "package": "yi",
          "partial": "KHome",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KHome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KIns",
          "package": "yi",
          "signature": "KIns",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KIns",
          "package": "yi",
          "partial": "KIns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KIns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KLeft",
          "package": "yi",
          "signature": "KLeft",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KLeft",
          "package": "yi",
          "partial": "KLeft",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KMenu",
          "package": "yi",
          "signature": "KMenu",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KMenu",
          "package": "yi",
          "partial": "KMenu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KMenu"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KNP5",
          "package": "yi",
          "signature": "KNP5",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KNP5",
          "package": "yi",
          "partial": "KNP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KNP5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KPageDown",
          "package": "yi",
          "signature": "KPageDown",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KPageDown",
          "package": "yi",
          "partial": "KPage Down",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KPageDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KPageUp",
          "package": "yi",
          "signature": "KPageUp",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KPageUp",
          "package": "yi",
          "partial": "KPage Up",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KPageUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KPause",
          "package": "yi",
          "signature": "KPause",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KPause",
          "package": "yi",
          "partial": "KPause",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KPause"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KPrtScr",
          "package": "yi",
          "signature": "KPrtScr",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KPrtScr",
          "package": "yi",
          "partial": "KPrt Scr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KPrtScr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KRight",
          "package": "yi",
          "signature": "KRight",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KRight",
          "package": "yi",
          "partial": "KRight",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KTab",
          "package": "yi",
          "signature": "KTab",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KTab",
          "package": "yi",
          "partial": "KTab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "KUp",
          "package": "yi",
          "signature": "KUp",
          "source": "src/Yi-Event.html#Key",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "KUp",
          "package": "yi",
          "partial": "KUp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:KUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "MCtrl",
          "package": "yi",
          "signature": "MCtrl",
          "source": "src/Yi-Event.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "MCtrl",
          "package": "yi",
          "partial": "MCtrl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:MCtrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "MHyper",
          "package": "yi",
          "signature": "MHyper",
          "source": "src/Yi-Event.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "MHyper",
          "package": "yi",
          "partial": "MHyper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:MHyper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "MMeta",
          "package": "yi",
          "signature": "MMeta",
          "source": "src/Yi-Event.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "MMeta",
          "package": "yi",
          "partial": "MMeta",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:MMeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "MShift",
          "package": "yi",
          "signature": "MShift",
          "source": "src/Yi-Event.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "MShift",
          "package": "yi",
          "partial": "MShift",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:MShift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "MSuper",
          "package": "yi",
          "signature": "MSuper",
          "source": "src/Yi-Event.html#Modifier",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "MSuper",
          "package": "yi",
          "partial": "MSuper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:MSuper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap an Event to a Char. This is used in the emacs keymap for Ctrl-Q and vim keymap \u003ccode\u003einsertSpecialChar\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Event",
          "name": "eventToChar",
          "package": "yi",
          "signature": "Event -\u003e Char",
          "source": "src/Yi-Event.html#eventToChar",
          "type": "function"
        },
        "index": {
          "description": "Map an Event to Char This is used in the emacs keymap for Ctrl-Q and vim keymap insertSpecialChar",
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "eventToChar",
          "normalized": "Event-\u003eChar",
          "package": "yi",
          "partial": "To Char",
          "signature": "Event-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:eventToChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Event",
          "name": "prettyEvent",
          "package": "yi",
          "signature": "Event -\u003e String",
          "source": "src/Yi-Event.html#prettyEvent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Event",
          "module": "Yi.Event",
          "name": "prettyEvent",
          "normalized": "Event-\u003eString",
          "package": "yi",
          "partial": "Event",
          "signature": "Event-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Event.html#v:prettyEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.File",
          "name": "File",
          "package": "yi",
          "source": "src/Yi-File.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "File",
          "package": "yi",
          "partial": "File",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a backup copy of file\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "backupE",
          "package": "yi",
          "signature": "FilePath -\u003e YiM ()",
          "source": "src/Yi-File.html#backupE",
          "type": "function"
        },
        "index": {
          "description": "Make backup copy of file",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "backupE",
          "normalized": "FilePath-\u003eYiM()",
          "package": "yi",
          "signature": "FilePath-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:backupE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf file exists, read contents of file into a new buffer, otherwise\n creating a new empty buffer. Replace the current window with a new\n window onto the new buffer.\n\u003c/p\u003e\u003cp\u003eIf the file is already open, just switch to the corresponding buffer.\n\u003c/p\u003e\u003cp\u003eNeed to clean up semantics for when buffers exist, and how to attach\n windows to buffers.\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "editFile",
          "package": "yi",
          "signature": "FilePath -\u003e YiM BufferRef",
          "source": "src/Yi-File.html#editFile",
          "type": "function"
        },
        "index": {
          "description": "If file exists read contents of file into new buffer otherwise creating new empty buffer Replace the current window with new window onto the new buffer If the file is already open just switch to the corresponding buffer Need to clean up semantics for when buffers exist and how to attach windows to buffers",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "editFile",
          "normalized": "FilePath-\u003eYiM BufferRef",
          "package": "yi",
          "partial": "File",
          "signature": "FilePath-\u003eYiM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:editFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite all open buffers\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "fwriteAllE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-File.html#fwriteAllE",
          "type": "function"
        },
        "index": {
          "description": "Write all open buffers",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "fwriteAllE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "All",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:fwriteAllE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite a given buffer to disk if it is associated with a file.\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "fwriteBufferE",
          "package": "yi",
          "signature": "BufferRef -\u003e YiM ()",
          "source": "src/Yi-File.html#fwriteBufferE",
          "type": "function"
        },
        "index": {
          "description": "Write given buffer to disk if it is associated with file",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "fwriteBufferE",
          "normalized": "BufferRef-\u003eYiM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "BufferRef-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:fwriteBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite current buffer to disk, if this buffer is associated with a file\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "fwriteE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-File.html#fwriteE",
          "type": "function"
        },
        "index": {
          "description": "Write current buffer to disk if this buffer is associated with file",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "fwriteE",
          "normalized": "YiM()",
          "package": "yi",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:fwriteE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite current buffer to disk as \u003ccode\u003ef\u003c/code\u003e. The file is also set to \u003ccode\u003ef\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "fwriteToE",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-File.html#fwriteToE",
          "type": "function"
        },
        "index": {
          "description": "Write current buffer to disk as The file is also set to",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "fwriteToE",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "To",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:fwriteToE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRevert to the contents of the file on disk\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "revertE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-File.html#revertE",
          "type": "function"
        },
        "index": {
          "description": "Revert to the contents of the file on disk",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "revertE",
          "normalized": "YiM()",
          "package": "yi",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:revertE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssociate buffer with file; canonicalize the given path name.\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "setFileName",
          "package": "yi",
          "signature": "BufferRef -\u003e FilePath -\u003e YiM ()",
          "source": "src/Yi-File.html#setFileName",
          "type": "function"
        },
        "index": {
          "description": "Associate buffer with file canonicalize the given path name",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "setFileName",
          "normalized": "BufferRef-\u003eFilePath-\u003eYiM()",
          "package": "yi",
          "partial": "File Name",
          "signature": "BufferRef-\u003eFilePath-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:setFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to write to a named file if it doesn't exist. Error out if it does.\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "viSafeWriteTo",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-File.html#viSafeWriteTo",
          "type": "function"
        },
        "index": {
          "description": "Try to write to named file if it doesn exist Error out if it does",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "viSafeWriteTo",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Safe Write To",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:viSafeWriteTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to write a file in the manner of vi/vim\n Need to catch any exception to avoid losing bindings\n\u003c/p\u003e",
          "module": "[\"Yi.File\",\"Yi.Keymap.Vim\"]",
          "name": "viWrite",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-File.html#viWrite",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:viWrite\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:viWrite\"]"
        },
        "index": {
          "description": "Try to write file in the manner of vi vim Need to catch any exception to avoid losing bindings",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "viWrite",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Write",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:viWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to write to a named file in the manner of vi/vim\n\u003c/p\u003e",
          "module": "Yi.File",
          "name": "viWriteTo",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-File.html#viWriteTo",
          "type": "function"
        },
        "index": {
          "description": "Try to write to named file in the manner of vi vim",
          "hierarchy": "Yi File",
          "module": "Yi.File",
          "name": "viWriteTo",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Write To",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-File.html#v:viWriteTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "History",
          "package": "yi",
          "source": "src/Yi-History.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "History",
          "package": "yi",
          "partial": "History",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "Histories",
          "package": "yi",
          "source": "src/Yi-History.html#Histories",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "Histories",
          "package": "yi",
          "partial": "Histories",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#t:Histories"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "History",
          "package": "yi",
          "source": "src/Yi-History.html#History",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "History",
          "package": "yi",
          "partial": "History",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#t:History"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "History",
          "package": "yi",
          "signature": "History",
          "source": "src/Yi-History.html#History",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "History",
          "package": "yi",
          "partial": "History",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:History"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "_historyContents",
          "package": "yi",
          "signature": "[String]",
          "source": "src/Yi-History.html#History",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "_historyContents",
          "normalized": "[String]",
          "package": "yi",
          "partial": "Contents",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:_historyContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "_historyCurrent",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-History.html#History",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "_historyCurrent",
          "package": "yi",
          "partial": "Current",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:_historyCurrent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "_historyPrefix",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-History.html#History",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "_historyPrefix",
          "package": "yi",
          "partial": "Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:_historyPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "dynKeyA",
          "package": "yi",
          "signature": "k -\u003e Accessor (Map k v) v",
          "source": "src/Yi-History.html#dynKeyA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "dynKeyA",
          "normalized": "a-\u003eAccessor(Map a b)b",
          "package": "yi",
          "partial": "Key",
          "signature": "k-\u003eAccessor(Map k v)v",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:dynKeyA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyDown",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-History.html#historyDown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyDown",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Down",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyDown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyFind",
          "package": "yi",
          "signature": "[String] -\u003e Int -\u003e Int -\u003e Int -\u003e String -\u003e Int",
          "source": "src/Yi-History.html#historyFind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyFind",
          "normalized": "[String]-\u003eInt-\u003eInt-\u003eInt-\u003eString-\u003eInt",
          "package": "yi",
          "partial": "Find",
          "signature": "[String]-\u003eInt-\u003eInt-\u003eInt-\u003eString-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyFind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyFinish",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-History.html#historyFinish",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyFinish",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Finish",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyFinish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinish the current input session with history.\n\u003c/p\u003e",
          "module": "Yi.History",
          "name": "historyFinishGen",
          "package": "yi",
          "signature": "String -\u003e EditorM String -\u003e EditorM ()",
          "source": "src/Yi-History.html#historyFinishGen",
          "type": "function"
        },
        "index": {
          "description": "Finish the current input session with history",
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyFinishGen",
          "normalized": "String-\u003eEditorM String-\u003eEditorM()",
          "package": "yi",
          "partial": "Finish Gen",
          "signature": "String-\u003eEditorM String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyFinishGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyMove",
          "package": "yi",
          "signature": "String -\u003e Int -\u003e EditorM ()",
          "source": "src/Yi-History.html#historyMove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyMove",
          "normalized": "String-\u003eInt-\u003eEditorM()",
          "package": "yi",
          "partial": "Move",
          "signature": "String-\u003eInt-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyMoveGen",
          "package": "yi",
          "signature": "String -\u003e Int -\u003e EditorM String -\u003e EditorM String",
          "source": "src/Yi-History.html#historyMoveGen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyMoveGen",
          "normalized": "String-\u003eInt-\u003eEditorM String-\u003eEditorM String",
          "package": "yi",
          "partial": "Move Gen",
          "signature": "String-\u003eInt-\u003eEditorM String-\u003eEditorM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyMoveGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyPrefixSet",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-History.html#historyPrefixSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyPrefixSet",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Prefix Set",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyPrefixSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyPrefixSet'",
          "package": "yi",
          "signature": "String -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-History.html#historyPrefixSet%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyPrefixSet'",
          "normalized": "String-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Prefix Set'",
          "signature": "String-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyPrefixSet-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyStart",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-History.html#historyStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyStart",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Start",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart an input session with History\n\u003c/p\u003e",
          "module": "Yi.History",
          "name": "historyStartGen",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-History.html#historyStartGen",
          "type": "function"
        },
        "index": {
          "description": "Start an input session with History",
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyStartGen",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Start Gen",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyStartGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "historyUp",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-History.html#historyUp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "historyUp",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Up",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:historyUp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.History",
          "name": "miniBuffer",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-History.html#miniBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi History",
          "module": "Yi.History",
          "name": "miniBuffer",
          "package": "yi",
          "partial": "Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-History.html#v:miniBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eProvides functions for calling Hoogle on the commandline, and processing results\n into a form useful for completion or insertion.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Hoogle",
          "name": "Hoogle",
          "package": "yi",
          "source": "src/Yi-Hoogle.html",
          "type": "module"
        },
        "index": {
          "description": "Provides functions for calling Hoogle on the commandline and processing results into form useful for completion or insertion",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "Hoogle",
          "package": "yi",
          "partial": "Hoogle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove anything starting with uppercase letter. These denote either module names or types.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "caseSensitize",
          "package": "yi",
          "signature": "[String] -\u003e [String]",
          "source": "src/Yi-Hoogle.html#caseSensitize",
          "type": "function"
        },
        "index": {
          "description": "Remove anything starting with uppercase letter These denote either module names or types",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "caseSensitize",
          "normalized": "[String]-\u003e[String]",
          "package": "yi",
          "partial": "Sensitize",
          "signature": "[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:caseSensitize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHoogle's output includes a sort of type keyword, telling whether a hit is a package name, syntax,\n a module name, etc. But we care primarily about the function names, so we filter out anything containing\n the keywords.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "gv",
          "package": "yi",
          "signature": "[String] -\u003e [String]",
          "source": "src/Yi-Hoogle.html#gv",
          "type": "function"
        },
        "index": {
          "description": "Hoogle output includes sort of type keyword telling whether hit is package name syntax module name etc But we care primarily about the function names so we filter out anything containing the keywords",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "gv",
          "normalized": "[String]-\u003e[String]",
          "package": "yi",
          "signature": "[String]-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:gv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall out to \u003ccode\u003e\u003ca\u003ehoogleFunModule\u003c/a\u003e\u003c/code\u003e, and overwrite the word at point with\n the first returned function.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "hoogle",
          "package": "yi",
          "signature": "YiM String",
          "source": "src/Yi-Hoogle.html#hoogle",
          "type": "function"
        },
        "index": {
          "description": "Call out to hoogleFunModule and overwrite the word at point with the first returned function",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "hoogle",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:hoogle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn module-function pairs.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "hoogleFunModule",
          "package": "yi",
          "signature": "String -\u003e IO [(String, String)]",
          "source": "src/Yi-Hoogle.html#hoogleFunModule",
          "type": "function"
        },
        "index": {
          "description": "Return module-function pairs",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "hoogleFunModule",
          "normalized": "String-\u003eIO[(String,String)]",
          "package": "yi",
          "partial": "Fun Module",
          "signature": "String-\u003eIO[(String,String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:hoogleFunModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFilter the output of \u003ccode\u003e\u003ca\u003ehoogleRaw\u003c/a\u003e\u003c/code\u003e to leave just functions.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "hoogleFunctions",
          "package": "yi",
          "signature": "String -\u003e IO [String]",
          "source": "src/Yi-Hoogle.html#hoogleFunctions",
          "type": "function"
        },
        "index": {
          "description": "Filter the output of hoogleRaw to leave just functions",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "hoogleFunctions",
          "normalized": "String-\u003eIO[String]",
          "package": "yi",
          "partial": "Functions",
          "signature": "String-\u003eIO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:hoogleFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuery Hoogle, with given search and options. This errors out on no\n results or if the hoogle command is not on path.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "hoogleRaw",
          "package": "yi",
          "signature": "String -\u003e String -\u003e IO [String]",
          "source": "src/Yi-Hoogle.html#hoogleRaw",
          "type": "function"
        },
        "index": {
          "description": "Query Hoogle with given search and options This errors out on no results or if the hoogle command is not on path",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "hoogleRaw",
          "normalized": "String-\u003eString-\u003eIO[String]",
          "package": "yi",
          "partial": "Raw",
          "signature": "String-\u003eString-\u003eIO[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:hoogleRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCall out to \u003ccode\u003e\u003ca\u003ehoogleRaw\u003c/a\u003e\u003c/code\u003e, and print inside the Minibuffer the results of\n searching Hoogle with the word at point.\n\u003c/p\u003e",
          "module": "Yi.Hoogle",
          "name": "hoogleSearch",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Hoogle.html#hoogleSearch",
          "type": "function"
        },
        "index": {
          "description": "Call out to hoogleRaw and print inside the Minibuffer the results of searching Hoogle with the word at point",
          "hierarchy": "Yi Hoogle",
          "module": "Yi.Hoogle",
          "name": "hoogleSearch",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Search",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hoogle.html#v:hoogleSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module provides assistance in implementing \"hooks\" in Yi. This module provides no major new functionality -- only assistance in using \u003ccode\u003e\u003ca\u003eYiConfigVariable\u003c/a\u003e\u003c/code\u003es more easily to implement hooks.\n\u003c/p\u003e\u003cp\u003eWe consider a simple example. Suppose we have a function\n\u003c/p\u003e\u003cpre\u003e promptForFile :: Maybe FilePath -\u003e YiM FilePath\n\u003c/pre\u003e\u003cp\u003ewhich prompts the user to select a file from their file system, starting with the provided directory (if actually provided).\nSince this is a frequent task in Yi, it is important for it to be as user-friendly as possible. If opinions vary on the\nmeaning of \"user-friendly\", then we would really like to provide multiple implementations of \u003ccode\u003epromptForFile\u003c/code\u003e, and allow\nusers to select which implementation to use in their config files.\n\u003c/p\u003e\u003cp\u003eA way to achieve this is using hooks, as follows:\n\u003c/p\u003e\u003cpre\u003e -- create a new type\n newtype FilePrompter = FilePrompter { runFilePrompter :: Maybe FilePath -\u003e YiM FilePath }\n   deriving(Typeable)\n $(nameDeriveAccessors ''FilePrompter (n -\u003e Just (n ++ \"A\")))\n\n -- give some implementations\n filePrompter1, filePrompter2, filePrompter3 :: FilePrompter\n ...\n\n -- declare FilePrompter as a YiConfigVariable (so it can go in the Config)\n instance YiConfigVariable FilePrompter\n\n -- specify the default FilePrompter\n instance Initializable FilePrompter where\n    initial = filePrompter1\n\n -- replace the old promptForFile function with a shim\n promptForFile :: Maybe FilePath -\u003e YiM FilePath\n promptForFile = runHook runFilePrompter\n\n -- provide a custom-named Field for Yi.Config.Simple (not strictly necessary, but user-friendly)\n filePrompter :: Field FilePrompter\n filePrompter = customVariable\n\u003c/pre\u003e\u003cp\u003eThe user can write\n\u003c/p\u003e\u003cpre\u003e ...\n    filePrompter %= filePrompter2\n ...\n\u003c/pre\u003e\u003cp\u003ein their config file, and calls to \u003ccode\u003epromptForFile\u003c/code\u003e will now use the different prompter. Library code which\ncalled \u003ccode\u003epromptForFile\u003c/code\u003e does not need to be changed, but it gets the new \u003ccode\u003efilePrompter2\u003c/code\u003e behaviour automatically.\n\u003c/p\u003e\u003cp\u003eSee \u003ca\u003eYi.Eval\u003c/a\u003e for a real example of hooks.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Hooks",
          "name": "Hooks",
          "package": "yi",
          "source": "src/Yi-Hooks.html",
          "type": "module"
        },
        "index": {
          "description": "This module provides assistance in implementing hooks in Yi This module provides no major new functionality only assistance in using YiConfigVariable more easily to implement hooks We consider simple example Suppose we have function promptForFile Maybe FilePath YiM FilePath which prompts the user to select file from their file system starting with the provided directory if actually provided Since this is frequent task in Yi it is important for it to be as user-friendly as possible If opinions vary on the meaning of user-friendly then we would really like to provide multiple implementations of promptForFile and allow users to select which implementation to use in their config files way to achieve this is using hooks as follows create new type newtype FilePrompter FilePrompter runFilePrompter Maybe FilePath YiM FilePath deriving Typeable nameDeriveAccessors FilePrompter Just give some implementations filePrompter1 filePrompter2 filePrompter3 FilePrompter declare FilePrompter as YiConfigVariable so it can go in the Config instance YiConfigVariable FilePrompter specify the default FilePrompter instance Initializable FilePrompter where initial filePrompter1 replace the old promptForFile function with shim promptForFile Maybe FilePath YiM FilePath promptForFile runHook runFilePrompter provide custom-named Field for Yi.Config.Simple not strictly necessary but user-friendly filePrompter Field FilePrompter filePrompter customVariable The user can write filePrompter filePrompter2 in their config file and calls to promptForFile will now use the different prompter Library code which called promptForFile does not need to be changed but it gets the new filePrompter2 behaviour automatically See Yi.Eval for real example of hooks",
          "hierarchy": "Yi Hooks",
          "module": "Yi.Hooks",
          "name": "Hooks",
          "package": "yi",
          "partial": "Hooks",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hooks.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFields that can be modified with (\u003ccode\u003e\u003ca\u003e%=\u003c/a\u003e\u003c/code\u003e), \u003ccode\u003eget\u003c/code\u003e and \u003ccode\u003emodify\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Hooks",
          "name": "Field",
          "package": "yi",
          "source": "src/Yi-Config-Simple-Types.html#Field",
          "type": "type"
        },
        "index": {
          "description": "Fields that can be modified with get and modify",
          "hierarchy": "Yi Hooks",
          "module": "Yi.Hooks",
          "name": "Field",
          "package": "yi",
          "partial": "Field",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hooks.html#t:Field"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class of \"valid hooks\". This class is exported abstractly, but the instances can be phrased quite simply: the functions (of arbitrarily many arguments, including zero) which run in either the \u003ccode\u003e\u003ca\u003eEditorM\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eYiM\u003c/a\u003e\u003c/code\u003e monads.\n\u003c/p\u003e\u003cp\u003eA typical example would be something like \n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eInt -\u003e String -\u003e \u003ccode\u003e\u003ca\u003eEditorM\u003c/a\u003e\u003c/code\u003e String\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Hooks",
          "name": "HookType",
          "package": "yi",
          "source": "src/Yi-Hooks.html#HookType",
          "type": "class"
        },
        "index": {
          "description": "The class of valid hooks This class is exported abstractly but the instances can be phrased quite simply the functions of arbitrarily many arguments including zero which run in either the EditorM or YiM monads typical example would be something like Int String EditorM String",
          "hierarchy": "Yi Hooks",
          "module": "Yi.Hooks",
          "name": "HookType",
          "package": "yi",
          "partial": "Hook Type",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hooks.html#t:HookType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLooks up the configured value for the hook, and runs it. The argument to \u003ccode\u003e\u003ca\u003erunHook\u003c/a\u003e\u003c/code\u003e will typically be a record accessor. See \u003ccode\u003e\u003ca\u003eHookType\u003c/a\u003e\u003c/code\u003e for the valid hook types.\n\u003c/p\u003e",
          "module": "Yi.Hooks",
          "name": "runHook",
          "package": "yi",
          "signature": "(var -\u003e ty) -\u003e ty",
          "source": "src/Yi-Hooks.html#runHook",
          "type": "function"
        },
        "index": {
          "description": "Looks up the configured value for the hook and runs it The argument to runHook will typically be record accessor See HookType for the valid hook types",
          "hierarchy": "Yi Hooks",
          "module": "Yi.Hooks",
          "name": "runHook",
          "normalized": "(a-\u003eb)-\u003eb",
          "package": "yi",
          "partial": "Hook",
          "signature": "(var-\u003ety)-\u003ety",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Hooks.html#v:runHook"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a list type and operations on it; it further\n provides functions which write in and out the list.\n The goal is to make it easy for the user to store a large number of text buffers\n and cycle among them, making edits as she goes. The idea is inspired by\n \"incremental reading\", see \u003ca\u003ehttp://en.wikipedia.org/wiki/Incremental_reading\u003c/a\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.IReader",
          "name": "IReader",
          "package": "yi",
          "source": "src/Yi-IReader.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines list type and operations on it it further provides functions which write in and out the list The goal is to make it easy for the user to store large number of text buffers and cycle among them making edits as she goes The idea is inspired by incremental reading see http en.wikipedia.org wiki Incremental reading",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "IReader",
          "package": "yi",
          "partial": "IReader",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IReader",
          "name": "Article",
          "package": "yi",
          "source": "src/Yi-IReader.html#Article",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "Article",
          "package": "yi",
          "partial": "Article",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#t:Article"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IReader",
          "name": "ArticleDB",
          "package": "yi",
          "source": "src/Yi-IReader.html#ArticleDB",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "ArticleDB",
          "package": "yi",
          "partial": "Article DB",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#t:ArticleDB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IReader",
          "name": "ADB",
          "package": "yi",
          "signature": "ADB",
          "source": "src/Yi-IReader.html#ArticleDB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "ADB",
          "package": "yi",
          "partial": "ADB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:ADB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDelete current article (the article as in the database), and go to next one.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "deleteAndNextArticle",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-IReader.html#deleteAndNextArticle",
          "type": "function"
        },
        "index": {
          "description": "Delete current article the article as in the database and go to next one",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "deleteAndNextArticle",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "And Next Article",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:deleteAndNextArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IReader",
          "name": "getBufferContents",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-IReader.html#getBufferContents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "getBufferContents",
          "package": "yi",
          "partial": "Buffer Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:getBufferContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the first article in the list. We use the list to express relative priority;\n the first is the most, the last least. We then just cycle through - every article gets equal time.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "getLatestArticle",
          "package": "yi",
          "signature": "ArticleDB -\u003e Article",
          "source": "src/Yi-IReader.html#getLatestArticle",
          "type": "function"
        },
        "index": {
          "description": "Get the first article in the list We use the list to express relative priority the first is the most the last least We then just cycle through every article gets equal time",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "getLatestArticle",
          "normalized": "ArticleDB-\u003eArticle",
          "package": "yi",
          "partial": "Latest Article",
          "signature": "ArticleDB-\u003eArticle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:getLatestArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert a new article with top priority (that is, at the front of the list).\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "insertArticle",
          "package": "yi",
          "signature": "ArticleDB -\u003e Article -\u003e ArticleDB",
          "source": "src/Yi-IReader.html#insertArticle",
          "type": "function"
        },
        "index": {
          "description": "Insert new article with top priority that is at the front of the list",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "insertArticle",
          "normalized": "ArticleDB-\u003eArticle-\u003eArticleDB",
          "package": "yi",
          "partial": "Article",
          "signature": "ArticleDB-\u003eArticle-\u003eArticleDB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:insertArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGo to next one. This ignores the buffer, but it doesn't remove anything from the database.\n However, the ordering does change.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "nextArticle",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-IReader.html#nextArticle",
          "type": "function"
        },
        "index": {
          "description": "Go to next one This ignores the buffer but it doesn remove anything from the database However the ordering does change",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "nextArticle",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Article",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:nextArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the database as it exists on the disk, and the current Yi buffer contents.\n   Note that the Initializable typeclass gives us an empty Seq. So first we try the buffer\n   state in the hope we can avoid a very expensive read from disk, and if we find nothing\n   (that is, if we get an empty Seq), only then do we call \u003ccode\u003e\u003ca\u003ereadDB\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "oldDbNewArticle",
          "package": "yi",
          "signature": "YiM (ArticleDB, Article)",
          "source": "src/Yi-IReader.html#oldDbNewArticle",
          "type": "function"
        },
        "index": {
          "description": "Returns the database as it exists on the disk and the current Yi buffer contents Note that the Initializable typeclass gives us an empty Seq So first we try the buffer state in the hope we can avoid very expensive read from disk and if we find nothing that is if we get an empty Seq only then do we call readDB",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "oldDbNewArticle",
          "normalized": "YiM(ArticleDB,Article)",
          "package": "yi",
          "partial": "Db New Article",
          "signature": "YiM(ArticleDB,Article)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:oldDbNewArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in database from \u003ccode\u003e\u003ca\u003egetArticleDbFilename\u003c/a\u003e\u003c/code\u003e and then parse it into an \u003ccode\u003e\u003ca\u003eArticleDB\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "readDB",
          "package": "yi",
          "signature": "YiM ArticleDB",
          "source": "src/Yi-IReader.html#readDB",
          "type": "function"
        },
        "index": {
          "description": "Read in database from getArticleDbFilename and then parse it into an ArticleDB",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "readDB",
          "package": "yi",
          "partial": "DB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:readDB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWe remove the old first article, and we stick it on the end of the\n list using the presumably modified version.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "removeSetLast",
          "package": "yi",
          "signature": "ArticleDB -\u003e Article -\u003e ArticleDB",
          "source": "src/Yi-IReader.html#removeSetLast",
          "type": "function"
        },
        "index": {
          "description": "We remove the old first article and we stick it on the end of the list using the presumably modified version",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "removeSetLast",
          "normalized": "ArticleDB-\u003eArticle-\u003eArticleDB",
          "package": "yi",
          "partial": "Set Last",
          "signature": "ArticleDB-\u003eArticle-\u003eArticleDB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:removeSetLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main action. We fetch the old database, we fetch the modified article from the buffer,\n then we call the function \u003ccode\u003eupdateSetLast\u003c/code\u003e which removes the first article and pushes our modified article\n to the end of the list.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "saveAndNextArticle",
          "package": "yi",
          "signature": "Int -\u003e YiM ()",
          "source": "src/Yi-IReader.html#saveAndNextArticle",
          "type": "function"
        },
        "index": {
          "description": "The main action We fetch the old database we fetch the modified article from the buffer then we call the function updateSetLast which removes the first article and pushes our modified article to the end of the list",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "saveAndNextArticle",
          "normalized": "Int-\u003eYiM()",
          "package": "yi",
          "partial": "And Next Article",
          "signature": "Int-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:saveAndNextArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssume the buffer is an entirely new article just imported this second, and save it.\n We don't want to use \u003ccode\u003eupdateSetLast\u003c/code\u003e since that will erase an article.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "saveAsNewArticle",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-IReader.html#saveAsNewArticle",
          "type": "function"
        },
        "index": {
          "description": "Assume the buffer is an entirely new article just imported this second and save it We don want to use updateSetLast since that will erase an article",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "saveAsNewArticle",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "As New Article",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:saveAsNewArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an \u003ccode\u003e\u003ca\u003eArticleDB\u003c/a\u003e\u003c/code\u003e, dump the scheduled article into the buffer (replacing previous contents).\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "setDisplayedArticle",
          "package": "yi",
          "signature": "ArticleDB -\u003e YiM ()",
          "source": "src/Yi-IReader.html#setDisplayedArticle",
          "type": "function"
        },
        "index": {
          "description": "Given an ArticleDB dump the scheduled article into the buffer replacing previous contents",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "setDisplayedArticle",
          "normalized": "ArticleDB-\u003eYiM()",
          "package": "yi",
          "partial": "Displayed Article",
          "signature": "ArticleDB-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:setDisplayedArticle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IReader",
          "name": "shift",
          "package": "yi",
          "signature": "Int -\u003e ArticleDB -\u003e ArticleDB",
          "source": "src/Yi-IReader.html#shift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "shift",
          "normalized": "Int-\u003eArticleDB-\u003eArticleDB",
          "package": "yi",
          "signature": "Int-\u003eArticleDB-\u003eArticleDB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake an \u003ccode\u003e\u003ca\u003eArticleDB\u003c/a\u003e\u003c/code\u003e, and return the first \u003ccode\u003e\u003ca\u003eArticle\u003c/a\u003e\u003c/code\u003e and an ArticleDB - *without* that article.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "split",
          "package": "yi",
          "signature": "ArticleDB -\u003e (Article, ArticleDB)",
          "source": "src/Yi-IReader.html#split",
          "type": "function"
        },
        "index": {
          "description": "Take an ArticleDB and return the first Article and an ArticleDB without that article",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "split",
          "normalized": "ArticleDB-\u003e(Article,ArticleDB)",
          "package": "yi",
          "signature": "ArticleDB-\u003e(Article,ArticleDB)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IReader",
          "name": "unADB",
          "package": "yi",
          "signature": "Seq Article",
          "source": "src/Yi-IReader.html#ArticleDB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "unADB",
          "package": "yi",
          "partial": "ADB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:unADB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSerialize given \u003ccode\u003e\u003ca\u003eArticleDB\u003c/a\u003e\u003c/code\u003e out.\n\u003c/p\u003e",
          "module": "Yi.IReader",
          "name": "writeDB",
          "package": "yi",
          "signature": "ArticleDB -\u003e YiM ()",
          "source": "src/Yi-IReader.html#writeDB",
          "type": "function"
        },
        "index": {
          "description": "Serialize given ArticleDB out",
          "hierarchy": "Yi IReader",
          "module": "Yi.IReader",
          "name": "writeDB",
          "normalized": "ArticleDB-\u003eYiM()",
          "package": "yi",
          "partial": "DB",
          "signature": "ArticleDB-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IReader.html#v:writeDB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "IncrementalParse",
          "package": "yi",
          "source": "src/Yi-IncrementalParse.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "IncrementalParse",
          "package": "yi",
          "partial": "Incremental Parse",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexer state\n\u003c/p\u003e",
          "module": "Yi.IncrementalParse",
          "name": "AlexState",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html#AlexState",
          "type": "data"
        },
        "index": {
          "description": "Lexer state",
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "AlexState",
          "package": "yi",
          "partial": "Alex State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#t:AlexState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "P",
          "package": "yi",
          "source": "src/Yi-IncrementalParse.html#P",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "P",
          "package": "yi",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser specification\n\u003c/p\u003e",
          "module": "Yi.IncrementalParse",
          "name": "Parser",
          "package": "yi",
          "source": "src/Parser-Incremental.html#Parser",
          "type": "data"
        },
        "index": {
          "description": "Parser specification",
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "Parser",
          "package": "yi",
          "partial": "Parser",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#t:Parser"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "State",
          "package": "yi",
          "source": "src/Yi-IncrementalParse.html#State",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "State",
          "package": "yi",
          "partial": "State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.IncrementalParse\",\"Yi.Lexer.Alex\"]",
          "name": "AlexState",
          "package": "yi",
          "signature": "AlexState",
          "source": "src/Yi-Lexer-Alex.html#AlexState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:AlexState\",\"http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:AlexState\"]"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "AlexState",
          "package": "yi",
          "partial": "Alex State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:AlexState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "Enter",
          "package": "yi",
          "signature": "String -\u003e Parser s a -\u003e Parser s a",
          "source": "src/Parser-Incremental.html#Parser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "Enter",
          "normalized": "String-\u003eParser a b-\u003eParser a b",
          "package": "yi",
          "partial": "Enter",
          "signature": "String-\u003eParser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:Enter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "Look",
          "package": "yi",
          "signature": "Parser s a -\u003e (s -\u003e Parser s a) -\u003e Parser s a",
          "source": "src/Parser-Incremental.html#Parser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "Look",
          "normalized": "Parser a b-\u003e(a-\u003eParser a b)-\u003eParser a b",
          "package": "yi",
          "partial": "Look",
          "signature": "Parser s a-\u003e(s-\u003eParser s a)-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:Look"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "Yuck",
          "package": "yi",
          "signature": "Parser s a -\u003e Parser s a",
          "source": "src/Parser-Incremental.html#Parser",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "Yuck",
          "normalized": "Parser a b-\u003eParser a b",
          "package": "yi",
          "partial": "Yuck",
          "signature": "Parser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:Yuck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "eof",
          "package": "yi",
          "signature": "forall s.  Parser s ()",
          "source": "src/Parser-Incremental.html#eof",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "eof",
          "normalized": "a b Parser c()",
          "package": "yi",
          "signature": "forall s. Parser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "lookNext",
          "package": "yi",
          "signature": "Parser s (Maybe s)",
          "source": "src/Parser-Incremental.html#lookNext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "lookNext",
          "package": "yi",
          "partial": "Next",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:lookNext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.IncrementalParse\",\"Yi.Lexer.Alex\"]",
          "name": "lookedOffset",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Lexer-Alex.html#AlexState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:lookedOffset\",\"http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:lookedOffset\"]"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "lookedOffset",
          "package": "yi",
          "partial": "Offset",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:lookedOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse the same thing as the argument, but will be used only as\n backup. ie, it will be used only if disjuncted with a failing\n parser.\n\u003c/p\u003e",
          "module": "Yi.IncrementalParse",
          "name": "recoverWith",
          "package": "yi",
          "signature": "Parser s a -\u003e Parser s a",
          "source": "src/Parser-Incremental.html#recoverWith",
          "type": "function"
        },
        "index": {
          "description": "Parse the same thing as the argument but will be used only as backup ie it will be used only if disjuncted with failing parser",
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "recoverWith",
          "normalized": "Parser a b-\u003eParser a b",
          "package": "yi",
          "partial": "With",
          "signature": "Parser s a-\u003eParser s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:recoverWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "scanner",
          "package": "yi",
          "signature": "forall st token result.  Parser token result -\u003e Scanner st token -\u003e Scanner (State st token result) result",
          "source": "src/Yi-IncrementalParse.html#scanner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "scanner",
          "normalized": "a b c d Parser c e-\u003eScanner b c-\u003eScanner(State b c e)e",
          "package": "yi",
          "signature": "forall st token result. Parser token result-\u003eScanner st token-\u003eScanner(State st token result)result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:scanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.IncrementalParse\",\"Yi.Lexer.Alex\"]",
          "name": "stLexer",
          "package": "yi",
          "signature": "lexerState",
          "source": "src/Yi-Lexer-Alex.html#AlexState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:stLexer\",\"http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:stLexer\"]"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "stLexer",
          "package": "yi",
          "partial": "Lexer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:stLexer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.IncrementalParse\",\"Yi.Lexer.Alex\"]",
          "name": "stPosn",
          "package": "yi",
          "signature": "Posn",
          "source": "src/Yi-Lexer-Alex.html#AlexState",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:stPosn\",\"http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:stPosn\"]"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "stPosn",
          "package": "yi",
          "partial": "Posn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:stPosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "symbol",
          "package": "yi",
          "signature": "forall s.  (s -\u003e Bool) -\u003e Parser s s",
          "source": "src/Parser-Incremental.html#symbol",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "symbol",
          "normalized": "a b(c-\u003eBool)-\u003eParser c c",
          "package": "yi",
          "signature": "forall s.(s-\u003eBool)-\u003eParser s s",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.IncrementalParse",
          "name": "testNext",
          "package": "yi",
          "signature": "(Maybe s -\u003e Bool) -\u003e Parser s ()",
          "source": "src/Parser-Incremental.html#testNext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi IncrementalParse",
          "module": "Yi.IncrementalParse",
          "name": "testNext",
          "normalized": "(Maybe a-\u003eBool)-\u003eParser a()",
          "package": "yi",
          "partial": "Next",
          "signature": "(Maybe s-\u003eBool)-\u003eParser s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-IncrementalParse.html#v:testNext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is a library of interactive processes combinators, usable to\ndefine extensible keymaps.\n\u003c/p\u003e\u003cp\u003e(Inspired by the Parsec library, written by Koen Claessen)\n\u003c/p\u003e\u003cp\u003eThe processes are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e composable: in parallel using \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e, in sequence using monadic bind.\n\u003c/li\u003e\u003cli\u003e extensible: it is always possible to override a behaviour by combination of\n  \u003ccode\u003e\u003ca\u003eadjustPriority\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e. (See also \u003ccode\u003e\u003ca\u003e\u003c||\u003c/a\u003e\u003c/code\u003e for a convenient combination of the two.)\n\u003c/li\u003e\u003cli\u003e monadic: sequencing is done via monadic bind. (leveraging the whole\n  battery of monadic tools that Haskell provides)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe processes can parse input, and write output that depends on it.\n\u003c/p\u003e\u003cp\u003eThe semantics are quite obvious; only disjunction\ndeserve a bit more explanation:\n\u003c/p\u003e\u003cp\u003ein \u003ccode\u003ep = (a \u003ccode\u003e\u003ca\u003e\u003c|\u003e\u003c/a\u003e\u003c/code\u003e b)\u003c/code\u003e, what happens if \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e recognize the same\ninput (prefix), but produce conflicting output?\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if the output is the same (as by the PEq class), then the processes (prefixes) are \u003ca\u003emerged\u003c/a\u003e\n* if a Write is more prioritized than the other, the one with low priority will be discarded\n* otherwise, the output will be delayed until one of the branches can be discarded.\n* if there is no way to disambiguate, then no output will be generated anymore. \n  This situation can be detected by using \u003ccode\u003epossibleActions\u003c/code\u003e however.\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Yi.Interact",
          "name": "Interact",
          "package": "yi",
          "source": "src/Yi-Interact.html",
          "type": "module"
        },
        "index": {
          "description": "This is library of interactive processes combinators usable to define extensible keymaps Inspired by the Parsec library written by Koen Claessen The processes are composable in parallel using in sequence using monadic bind extensible it is always possible to override behaviour by combination of adjustPriority and See also for convenient combination of the two monadic sequencing is done via monadic bind leveraging the whole battery of monadic tools that Haskell provides The processes can parse input and write output that depends on it The semantics are quite obvious only disjunction deserve bit more explanation in what happens if and recognize the same input prefix but produce conflicting output if the output is the same as by the PEq class then the processes prefixes are merged if Write is more prioritized than the other the one with low priority will be discarded otherwise the output will be delayed until one of the branches can be discarded if there is no way to disambiguate then no output will be generated anymore This situation can be detected by using possibleActions however",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "Interact",
          "package": "yi",
          "partial": "Interact",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInteractive process description\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "I",
          "package": "yi",
          "source": "src/Yi-Interact.html#I",
          "type": "data"
        },
        "index": {
          "description": "Interactive process description",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "I",
          "package": "yi",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#t:I"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstraction of the automaton state.\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "InteractState",
          "package": "yi",
          "source": "src/Yi-Interact.html#InteractState",
          "type": "data"
        },
        "index": {
          "description": "Abstraction of the automaton state",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "InteractState",
          "package": "yi",
          "partial": "Interact State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#t:InteractState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstraction of monadic interactive processes\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "MonadInteract",
          "package": "yi",
          "source": "src/Yi-Interact.html#MonadInteract",
          "type": "class"
        },
        "index": {
          "description": "Abstraction of monadic interactive processes",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "MonadInteract",
          "package": "yi",
          "partial": "Monad Interact",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#t:MonadInteract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperational representation of a process\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "P",
          "package": "yi",
          "source": "src/Yi-Interact.html#P",
          "type": "data"
        },
        "index": {
          "description": "Operational representation of process",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "P",
          "package": "yi",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "PEq",
          "package": "yi",
          "source": "src/Yi-Interact.html#PEq",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "PEq",
          "package": "yi",
          "partial": "PEq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#t:PEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "(||\u003e)",
          "package": "yi",
          "signature": "f a -\u003e f a -\u003e f a",
          "source": "src/Yi-Interact.html#%7C%7C%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "(||\u003e) ||\u003e",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "yi",
          "signature": "f a-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:-124--124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "(\u003c||)",
          "package": "yi",
          "signature": "f a -\u003e f a -\u003e f a",
          "source": "src/Yi-Interact.html#%3C%7C%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "(\u003c||) \u003c||",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "yi",
          "signature": "f a-\u003ef a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:-60--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "Ambiguous",
          "package": "yi",
          "signature": "Ambiguous [(Int, w, P event w)]",
          "source": "src/Yi-Interact.html#InteractState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "Ambiguous",
          "normalized": "Ambiguous[(Int,a,P b a)]",
          "package": "yi",
          "partial": "Ambiguous",
          "signature": "Ambiguous[(Int,w,P event w)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:Ambiguous"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "Chain",
          "package": "yi",
          "signature": "Chain (P event mid) (P mid w)",
          "source": "src/Yi-Interact.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "Chain",
          "package": "yi",
          "partial": "Chain",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:Chain"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "Dead",
          "package": "yi",
          "signature": "Dead",
          "source": "src/Yi-Interact.html#InteractState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "Dead",
          "package": "yi",
          "partial": "Dead",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:Dead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "End",
          "package": "yi",
          "signature": "End",
          "source": "src/Yi-Interact.html#P",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "End",
          "package": "yi",
          "partial": "End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:End"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "Running",
          "package": "yi",
          "signature": "Running w (P event w)",
          "source": "src/Yi-Interact.html#InteractState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "Running",
          "package": "yi",
          "partial": "Running",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:Running"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "Waiting",
          "package": "yi",
          "signature": "Waiting",
          "source": "src/Yi-Interact.html#InteractState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "Waiting",
          "package": "yi",
          "partial": "Waiting",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:Waiting"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "accepted",
          "package": "yi",
          "signature": "Int -\u003e P ev w -\u003e [[String]]",
          "source": "src/Yi-Interact.html#accepted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "accepted",
          "normalized": "Int-\u003eP a b-\u003e[[String]]",
          "package": "yi",
          "signature": "Int-\u003eP ev w-\u003e[[String]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:accepted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "adjustPriority",
          "package": "yi",
          "signature": "Int -\u003e m ()",
          "source": "src/Yi-Interact.html#adjustPriority",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "adjustPriority",
          "normalized": "Int-\u003ea()",
          "package": "yi",
          "partial": "Priority",
          "signature": "Int-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:adjustPriority"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "anyEvent",
          "package": "yi",
          "signature": "m event",
          "source": "src/Yi-Interact.html#anyEvent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "anyEvent",
          "package": "yi",
          "partial": "Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:anyEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombines all parsers in the specified list.\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "choice",
          "package": "yi",
          "signature": "[m a] -\u003e m a",
          "source": "src/Yi-Interact.html#choice",
          "type": "function"
        },
        "index": {
          "description": "Combines all parsers in the specified list",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "choice",
          "normalized": "[a b]-\u003ea b",
          "package": "yi",
          "signature": "[m a]-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "computeState",
          "package": "yi",
          "signature": "P event w -\u003e InteractState event w",
          "source": "src/Yi-Interact.html#computeState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "computeState",
          "normalized": "P a b-\u003eInteractState a b",
          "package": "yi",
          "partial": "State",
          "signature": "P event w-\u003eInteractState event w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:computeState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "deprioritize",
          "package": "yi",
          "signature": "f ()",
          "source": "src/Yi-Interact.html#deprioritize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "deprioritize",
          "normalized": "a()",
          "package": "yi",
          "signature": "f()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:deprioritize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "equiv",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Yi-Interact.html#equiv",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "equiv",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:equiv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses and returns the specified character.\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "event",
          "package": "yi",
          "signature": "event -\u003e m event",
          "source": "src/Yi-Interact.html#event",
          "type": "function"
        },
        "index": {
          "description": "Parses and returns the specified character",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "event",
          "normalized": "a-\u003eb a",
          "package": "yi",
          "signature": "event-\u003em event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:event"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "eventBetween",
          "package": "yi",
          "signature": "e -\u003e e -\u003e m e",
          "source": "src/Yi-Interact.html#eventBetween",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "eventBetween",
          "normalized": "a-\u003ea-\u003eb a",
          "package": "yi",
          "partial": "Between",
          "signature": "e-\u003ee-\u003em e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:eventBetween"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConsumes and returns the next character.\n   Fails if there is no input left, or outside the given bounds.\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "eventBounds",
          "package": "yi",
          "signature": "Maybe e -\u003e Maybe e -\u003e m e",
          "source": "src/Yi-Interact.html#eventBounds",
          "type": "method"
        },
        "index": {
          "description": "Consumes and returns the next character Fails if there is no input left or outside the given bounds",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "eventBounds",
          "normalized": "Maybe a-\u003eMaybe a-\u003eb a",
          "package": "yi",
          "partial": "Bounds",
          "signature": "Maybe e-\u003eMaybe e-\u003em e",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:eventBounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses and returns the specified list of events (lazily).\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "events",
          "package": "yi",
          "signature": "[event] -\u003e m [event]",
          "source": "src/Yi-Interact.html#events",
          "type": "function"
        },
        "index": {
          "description": "Parses and returns the specified list of events lazily",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "events",
          "normalized": "[a]-\u003eb[a]",
          "package": "yi",
          "signature": "[event]-\u003em[event]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:events"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "idAutomaton",
          "package": "yi",
          "signature": "P a a",
          "source": "src/Yi-Interact.html#idAutomaton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "idAutomaton",
          "package": "yi",
          "partial": "Automaton",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:idAutomaton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "mkAutomaton",
          "package": "yi",
          "signature": "I ev w a -\u003e P ev w",
          "source": "src/Yi-Interact.html#mkAutomaton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "mkAutomaton",
          "normalized": "I a b c-\u003eP a b",
          "package": "yi",
          "partial": "Automaton",
          "signature": "I ev w a-\u003eP ev w",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:mkAutomaton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "oneOf",
          "package": "yi",
          "signature": "[event] -\u003e m event",
          "source": "src/Yi-Interact.html#oneOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "oneOf",
          "normalized": "[a]-\u003eb a",
          "package": "yi",
          "partial": "Of",
          "signature": "[event]-\u003em event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:oneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eoption x p\u003c/code\u003e will either parse \u003ccode\u003ep\u003c/code\u003e or return \u003ccode\u003ex\u003c/code\u003e without consuming\n   any input.\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "option",
          "package": "yi",
          "signature": "a -\u003e m a -\u003e m a",
          "source": "src/Yi-Interact.html#option",
          "type": "function"
        },
        "index": {
          "description": "option will either parse or return without consuming any input",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "option",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "yi",
          "signature": "a-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "processOneEvent",
          "package": "yi",
          "signature": "P event w -\u003e event -\u003e ([w], P event w)",
          "source": "src/Yi-Interact.html#processOneEvent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "processOneEvent",
          "normalized": "P a b-\u003ea-\u003e([b],P a b)",
          "package": "yi",
          "partial": "One Event",
          "signature": "P event w-\u003eevent-\u003e([w],P event w)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:processOneEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Interact",
          "name": "runWrite",
          "package": "yi",
          "signature": "P event w -\u003e [event] -\u003e [w]",
          "source": "src/Yi-Interact.html#runWrite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "runWrite",
          "normalized": "P a b-\u003e[a]-\u003e[b]",
          "package": "yi",
          "partial": "Write",
          "signature": "P event w-\u003e[event]-\u003e[w]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:runWrite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOutputs a result.\n\u003c/p\u003e",
          "module": "Yi.Interact",
          "name": "write",
          "package": "yi",
          "signature": "w -\u003e m ()",
          "source": "src/Yi-Interact.html#write",
          "type": "method"
        },
        "index": {
          "description": "Outputs result",
          "hierarchy": "Yi Interact",
          "module": "Yi.Interact",
          "name": "write",
          "normalized": "a-\u003eb()",
          "package": "yi",
          "signature": "w-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Interact.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "JumpList",
          "package": "yi",
          "source": "src/Yi-JumpList.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "JumpList",
          "package": "yi",
          "partial": "Jump List",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "Jump",
          "package": "yi",
          "source": "src/Yi-JumpList.html#Jump",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "Jump",
          "package": "yi",
          "partial": "Jump",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#t:Jump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "JumpList",
          "package": "yi",
          "source": "src/Yi-JumpList.html#JumpList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "JumpList",
          "package": "yi",
          "partial": "Jump List",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#t:JumpList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "Jump",
          "package": "yi",
          "signature": "Jump",
          "source": "src/Yi-JumpList.html#Jump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "Jump",
          "package": "yi",
          "partial": "Jump",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#v:Jump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "addJump",
          "package": "yi",
          "signature": "Jump -\u003e JumpList -\u003e JumpList",
          "source": "src/Yi-JumpList.html#addJump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "addJump",
          "normalized": "Jump-\u003eJumpList-\u003eJumpList",
          "package": "yi",
          "partial": "Jump",
          "signature": "Jump-\u003eJumpList-\u003eJumpList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#v:addJump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "jumpBack",
          "package": "yi",
          "signature": "JumpList -\u003e JumpList",
          "source": "src/Yi-JumpList.html#jumpBack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "jumpBack",
          "normalized": "JumpList-\u003eJumpList",
          "package": "yi",
          "partial": "Back",
          "signature": "JumpList-\u003eJumpList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#v:jumpBack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "jumpBufferRef",
          "package": "yi",
          "signature": "BufferRef",
          "source": "src/Yi-JumpList.html#Jump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "jumpBufferRef",
          "package": "yi",
          "partial": "Buffer Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#v:jumpBufferRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "jumpForward",
          "package": "yi",
          "signature": "JumpList -\u003e JumpList",
          "source": "src/Yi-JumpList.html#jumpForward",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "jumpForward",
          "normalized": "JumpList-\u003eJumpList",
          "package": "yi",
          "partial": "Forward",
          "signature": "JumpList-\u003eJumpList",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#v:jumpForward"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.JumpList",
          "name": "jumpMark",
          "package": "yi",
          "signature": "Mark",
          "source": "src/Yi-JumpList.html#Jump",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi JumpList",
          "module": "Yi.JumpList",
          "name": "jumpMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-JumpList.html#v:jumpMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is a little helper for completion interfaces.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Keymap.Completion",
          "name": "Completion",
          "package": "yi",
          "source": "src/Yi-Keymap-Completion.html",
          "type": "module"
        },
        "index": {
          "description": "This is little helper for completion interfaces",
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "Completion",
          "package": "yi",
          "partial": "Completion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "CompletionTree",
          "package": "yi",
          "source": "src/Yi-Keymap-Completion.html#CompletionTree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "CompletionTree",
          "package": "yi",
          "partial": "Completion Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#t:CompletionTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "CT",
          "package": "yi",
          "signature": "CT [(a, CompletionTree a)]",
          "source": "src/Yi-Keymap-Completion.html#CompletionTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "CT",
          "normalized": "CT[(a,CompletionTree a)]",
          "package": "yi",
          "partial": "CT",
          "signature": "CT[(a,CompletionTree a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#v:CT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "complete",
          "package": "yi",
          "signature": "CompletionTree a -\u003e [a] -\u003e ([a], CompletionTree a)",
          "source": "src/Yi-Keymap-Completion.html#complete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "complete",
          "normalized": "CompletionTree a-\u003e[a]-\u003e([a],CompletionTree a)",
          "package": "yi",
          "signature": "CompletionTree a-\u003e[a]-\u003e([a],CompletionTree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#v:complete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "listToTree",
          "package": "yi",
          "signature": "[a] -\u003e CompletionTree a",
          "source": "src/Yi-Keymap-Completion.html#listToTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "listToTree",
          "normalized": "[a]-\u003eCompletionTree a",
          "package": "yi",
          "partial": "To Tree",
          "signature": "[a]-\u003eCompletionTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#v:listToTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "mergeTrees",
          "package": "yi",
          "signature": "[CompletionTree a] -\u003e CompletionTree a",
          "source": "src/Yi-Keymap-Completion.html#mergeTrees",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "mergeTrees",
          "normalized": "[CompletionTree a]-\u003eCompletionTree a",
          "package": "yi",
          "partial": "Trees",
          "signature": "[CompletionTree a]-\u003eCompletionTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#v:mergeTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "obvious",
          "package": "yi",
          "signature": "CompletionTree a -\u003e ([a], CompletionTree a)",
          "source": "src/Yi-Keymap-Completion.html#obvious",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "obvious",
          "normalized": "CompletionTree a-\u003e([a],CompletionTree a)",
          "package": "yi",
          "signature": "CompletionTree a-\u003e([a],CompletionTree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#v:obvious"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Completion",
          "name": "stepTree",
          "package": "yi",
          "signature": "CompletionTree a -\u003e a -\u003e Maybe ([a], CompletionTree a)",
          "source": "src/Yi-Keymap-Completion.html#stepTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Completion",
          "module": "Yi.Keymap.Completion",
          "name": "stepTree",
          "normalized": "CompletionTree a-\u003ea-\u003eMaybe([a],CompletionTree a)",
          "package": "yi",
          "partial": "Tree",
          "signature": "CompletionTree a-\u003ea-\u003eMaybe([a],CompletionTree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Completion.html#v:stepTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "Cua",
          "package": "yi",
          "source": "src/Yi-Keymap-Cua.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "Cua",
          "package": "yi",
          "partial": "Cua",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "copy",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Cua.html#copy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "copy",
          "normalized": "EditorM()",
          "package": "yi",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:copy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "customizedCuaKeymapSet",
          "package": "yi",
          "signature": "Keymap -\u003e KeymapSet",
          "source": "src/Yi-Keymap-Cua.html#customizedCuaKeymapSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "customizedCuaKeymapSet",
          "normalized": "Keymap-\u003eKeymapSet",
          "package": "yi",
          "partial": "Cua Keymap Set",
          "signature": "Keymap-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:customizedCuaKeymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "cut",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Cua.html#cut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "cut",
          "normalized": "EditorM()",
          "package": "yi",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:cut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "del",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Cua.html#del",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "del",
          "normalized": "EditorM()",
          "package": "yi",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:del"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "keymap",
          "package": "yi",
          "signature": "KeymapSet",
          "source": "src/Yi-Keymap-Cua.html#keymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "keymap",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:keymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Cua",
          "name": "paste",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Cua.html#paste",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "paste",
          "normalized": "EditorM()",
          "package": "yi",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:paste"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntroduce a keymap that is compatible with both windows and osx,\n   by parameterising the event modifier required for commands\n\u003c/p\u003e",
          "module": "Yi.Keymap.Cua",
          "name": "portableKeymap",
          "package": "yi",
          "signature": "(Event -\u003e Event) -\u003e KeymapSet",
          "source": "src/Yi-Keymap-Cua.html#portableKeymap",
          "type": "function"
        },
        "index": {
          "description": "Introduce keymap that is compatible with both windows and osx by parameterising the event modifier required for commands",
          "hierarchy": "Yi Keymap Cua",
          "module": "Yi.Keymap.Cua",
          "name": "portableKeymap",
          "normalized": "(Event-\u003eEvent)-\u003eKeymapSet",
          "package": "yi",
          "partial": "Keymap",
          "signature": "(Event-\u003eEvent)-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Cua.html#v:portableKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "KillRing",
          "package": "yi",
          "source": "src/Yi-Keymap-Emacs-KillRing.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "KillRing",
          "package": "yi",
          "partial": "Kill Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC-M-w\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "appendNextKillE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#appendNextKillE",
          "type": "function"
        },
        "index": {
          "description": "C-M-w",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "appendNextKillE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Next Kill",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:appendNextKillE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC-k\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killLineE",
          "package": "yi",
          "signature": "Maybe Int -\u003e YiM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#killLineE",
          "type": "function"
        },
        "index": {
          "description": "C-k",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killLineE",
          "normalized": "Maybe Int-\u003eYiM()",
          "package": "yi",
          "partial": "Line",
          "signature": "Maybe Int-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:killLineE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC-w\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killRegion",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#killRegion",
          "type": "function"
        },
        "index": {
          "description": "C-w",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killRegion",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:killRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKill the rest of line\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killRestOfLine",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#killRestOfLine",
          "type": "function"
        },
        "index": {
          "description": "Kill the rest of line",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killRestOfLine",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Rest Of Line",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:killRestOfLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eM-w\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killRingSaveE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#killRingSaveE",
          "type": "function"
        },
        "index": {
          "description": "M-w",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killRingSaveE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Ring Save",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:killRingSaveE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killringPut",
          "package": "yi",
          "signature": "Direction -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#killringPut",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "killringPut",
          "normalized": "Direction-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Put",
          "signature": "Direction-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:killringPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eC-y\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "yankE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#yankE",
          "type": "function"
        },
        "index": {
          "description": "C-y",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "yankE",
          "normalized": "EditorM()",
          "package": "yi",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:yankE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eM-y\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "yankPopE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Emacs-KillRing.html#yankPopE",
          "type": "function"
        },
        "index": {
          "description": "M-y",
          "hierarchy": "Yi Keymap Emacs KillRing",
          "module": "Yi.Keymap.Emacs.KillRing",
          "name": "yankPopE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Pop",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-KillRing.html#v:yankPopE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "Utils",
          "package": "yi",
          "source": "src/Yi-Keymap-Emacs-Utils.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "Utils",
          "package": "yi",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "UnivArgument",
          "package": "yi",
          "source": "src/Yi-Keymap-Emacs-Utils.html#UnivArgument",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "UnivArgument",
          "package": "yi",
          "partial": "Univ Argument",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#t:UnivArgument"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the universal argument to a number of repetitions\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "argToInt",
          "package": "yi",
          "signature": "UnivArgument -\u003e Int",
          "source": "src/Yi-Keymap-Emacs-Utils.html#argToInt",
          "type": "function"
        },
        "index": {
          "description": "Convert the universal argument to number of repetitions",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "argToInt",
          "normalized": "UnivArgument-\u003eInt",
          "package": "yi",
          "partial": "To Int",
          "signature": "UnivArgument-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:argToInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuits the editor if there are no unmodified buffers\n if there are unmodified buffers then we ask individually for\n each modified buffer whether or not the user wishes to save\n it or not. If we get to the end of this list and there are still\n some modified buffers then we ask again if the user wishes to\n quit, but this is then a simple yes or no.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "askQuitEditor",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#askQuitEditor",
          "type": "function"
        },
        "index": {
          "description": "Quits the editor if there are no unmodified buffers if there are unmodified buffers then we ask individually for each modified buffer whether or not the user wishes to save it or not If we get to the end of this list and there are still some modified buffers then we ask again if the user wishes to quit but this is then simple yes or no",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "askQuitEditor",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Quit Editor",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:askQuitEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuits the editor if there are no unmodified buffers\n if there are unmodified buffers then we ask individually for\n each modified buffer whether or not the user wishes to save\n it or not. If we get to the end of this list and there are still\n some modified buffers then we ask again if the user wishes to\n quit, but this is then a simple yes or no.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "askSaveEditor",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#askSaveEditor",
          "type": "function"
        },
        "index": {
          "description": "Quits the editor if there are no unmodified buffers if there are unmodified buffers then we ask individually for each modified buffer whether or not the user wishes to save it or not If we get to the end of this list and there are still some modified buffers then we ask again if the user wishes to quit but this is then simple yes or no",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "askSaveEditor",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Save Editor",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:askSaveEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "evalRegionE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#evalRegionE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "evalRegionE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Region",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:evalRegionE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "executeExtendedCommandE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#executeExtendedCommandE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "executeExtendedCommandE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Extended Command",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:executeExtendedCommandE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen a file using the minibuffer. We have to set up some stuff to allow hints\n   and auto-completion.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "findFile",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#findFile",
          "type": "function"
        },
        "index": {
          "description": "Open file using the minibuffer We have to set up some stuff to allow hints and auto-completion",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "findFile",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "File",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:findFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen a file in a new tab using the minibuffer.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "findFileNewTab",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#findFileNewTab",
          "type": "function"
        },
        "index": {
          "description": "Open file in new tab using the minibuffer",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "findFileNewTab",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "File New Tab",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:findFileNewTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInsert next character, \u003ca\u003eraw\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "insertNextC",
          "package": "yi",
          "signature": "UnivArgument -\u003e KeymapM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#insertNextC",
          "type": "function"
        },
        "index": {
          "description": "Insert next character raw",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "insertNextC",
          "normalized": "UnivArgument-\u003eKeymapM()",
          "package": "yi",
          "partial": "Next",
          "signature": "UnivArgument-\u003eKeymapM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:insertNextC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "isearchKeymap",
          "package": "yi",
          "signature": "Direction -\u003e Keymap",
          "source": "src/Yi-Keymap-Emacs-Utils.html#isearchKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "isearchKeymap",
          "normalized": "Direction-\u003eKeymap",
          "package": "yi",
          "partial": "Keymap",
          "signature": "Direction-\u003eKeymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:isearchKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJoin this line to previous (or next N if universal)\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "joinLinesE",
          "package": "yi",
          "signature": "UnivArgument -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#joinLinesE",
          "type": "function"
        },
        "index": {
          "description": "Join this line to previous or next if universal",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "joinLinesE",
          "normalized": "UnivArgument-\u003eBufferM()",
          "package": "yi",
          "partial": "Lines",
          "signature": "UnivArgument-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:joinLinesE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf on separators (space, tab, unicode seps), reduce multiple\n   separators to just a single separator.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "justOneSep",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#justOneSep",
          "type": "function"
        },
        "index": {
          "description": "If on separators space tab unicode seps reduce multiple separators to just single separator",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "justOneSep",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "One Sep",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:justOneSep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "killBufferE",
          "package": "yi",
          "signature": "ToKill) -\u003e YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#killBufferE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "killBufferE",
          "normalized": "ToKill)-\u003eYiM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "ToKill)-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:killBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eQuits the editor if there are no unmodified buffers\n if there are then simply confirms with the user that they\n with to quit.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "modifiedQuitEditor",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#modifiedQuitEditor",
          "type": "function"
        },
        "index": {
          "description": "Quits the editor if there are no unmodified buffers if there are then simply confirms with the user that they with to quit",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "modifiedQuitEditor",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Quit Editor",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:modifiedQuitEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneric emacs style prompt file action. Takes a \u003ccode\u003eprompt and a continuation \u003c/code\u003eact\n   and prompts the user with file hints\n\u003c/p\u003e",
          "module": "[\"Yi.Keymap.Emacs.Utils\",\"Yi.Misc\"]",
          "name": "promptFile",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e YiM ()) -\u003e YiM ()",
          "source": "src/Yi-Misc.html#promptFile",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:promptFile\",\"http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:promptFile\"]"
        },
        "index": {
          "description": "Generic emacs style prompt file action Takes prompt and continuation act and prompts the user with file hints",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "promptFile",
          "normalized": "String-\u003e(String-\u003eYiM())-\u003eYiM()",
          "package": "yi",
          "partial": "File",
          "signature": "String-\u003e(String-\u003eYiM())-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:promptFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrompt the user to give a tag and then jump to that tag\n\u003c/p\u003e",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "promptTag",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#promptTag",
          "type": "function"
        },
        "index": {
          "description": "Prompt the user to give tag and then jump to that tag",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "promptTag",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Tag",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:promptTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "queryReplaceE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#queryReplaceE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "queryReplaceE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Replace",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:queryReplaceE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "readUniversalArg",
          "package": "yi",
          "signature": "KeymapM (Maybe Int)",
          "source": "src/Yi-Keymap-Emacs-Utils.html#readUniversalArg",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "readUniversalArg",
          "package": "yi",
          "partial": "Universal Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:readUniversalArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "scrollDownE",
          "package": "yi",
          "signature": "UnivArgument -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#scrollDownE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "scrollDownE",
          "normalized": "UnivArgument-\u003eBufferM()",
          "package": "yi",
          "partial": "Down",
          "signature": "UnivArgument-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:scrollDownE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "scrollUpE",
          "package": "yi",
          "signature": "UnivArgument -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#scrollUpE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "scrollUpE",
          "normalized": "UnivArgument-\u003eBufferM()",
          "package": "yi",
          "partial": "Up",
          "signature": "UnivArgument-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:scrollUpE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "switchBufferE",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap-Emacs-Utils.html#switchBufferE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "switchBufferE",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Buffer",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:switchBufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithMinibuffer prompt completer act\u003c/code\u003e: open a minibuffer with \u003ccode\u003eprompt\u003c/code\u003e. Once\n a string \u003ccode\u003es\u003c/code\u003e is obtained, run \u003ccode\u003eact s\u003c/code\u003e. \u003ccode\u003ecompleter\u003c/code\u003e can be used to complete\n functions: it returns a list of possible matches.\n\u003c/p\u003e",
          "module": "[\"Yi.Keymap.Emacs.Utils\",\"Yi.MiniBuffer\"]",
          "name": "withMinibuffer",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e YiM [String]) -\u003e (String -\u003e YiM ()) -\u003e YiM ()",
          "source": "src/Yi-MiniBuffer.html#withMinibuffer",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:withMinibuffer\",\"http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:withMinibuffer\"]"
        },
        "index": {
          "description": "withMinibuffer prompt completer act open minibuffer with prompt Once string is obtained run act completer can be used to complete functions it returns list of possible matches",
          "hierarchy": "Yi Keymap Emacs Utils",
          "module": "Yi.Keymap.Emacs.Utils",
          "name": "withMinibuffer",
          "normalized": "String-\u003e(String-\u003eYiM[String])-\u003e(String-\u003eYiM())-\u003eYiM()",
          "package": "yi",
          "partial": "Minibuffer",
          "signature": "String-\u003e(String-\u003eYiM[String])-\u003e(String-\u003eYiM())-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs-Utils.html#v:withMinibuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module aims at a mode that should be (mostly) intuitive to\n emacs users, but mapping things into the Yi world when\n convenient. Hence, do not go into the trouble of trying 100%\n emulation. For example, M-x gives access to Yi (Haskell) functions,\n with their native names.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Keymap.Emacs",
          "name": "Emacs",
          "package": "yi",
          "source": "src/Yi-Keymap-Emacs.html",
          "type": "module"
        },
        "index": {
          "description": "This module aims at mode that should be mostly intuitive to emacs users but mapping things into the Yi world when convenient Hence do not go into the trouble of trying emulation For example M-x gives access to Yi Haskell functions with their native names",
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "Emacs",
          "package": "yi",
          "partial": "Emacs",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "ModeMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Emacs.html#ModeMap",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "ModeMap",
          "package": "yi",
          "partial": "Mode Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#t:ModeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "ModeMap",
          "package": "yi",
          "signature": "ModeMap",
          "source": "src/Yi-Keymap-Emacs.html#ModeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "ModeMap",
          "package": "yi",
          "partial": "Mode Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#v:ModeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "completionCaseSensitive",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Emacs.html#ModeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "completionCaseSensitive",
          "package": "yi",
          "partial": "Case Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#v:completionCaseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "defKeymap",
          "package": "yi",
          "signature": "Proto ModeMap",
          "source": "src/Yi-Keymap-Emacs.html#defKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "defKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#v:defKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "eKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap-Emacs.html#ModeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "eKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#v:eKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "keymap",
          "package": "yi",
          "signature": "KeymapSet",
          "source": "src/Yi-Keymap-Emacs.html#keymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "keymap",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#v:keymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Emacs",
          "name": "mkKeymap",
          "package": "yi",
          "signature": "Proto ModeMap -\u003e KeymapSet",
          "source": "src/Yi-Keymap-Emacs.html#mkKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Emacs",
          "module": "Yi.Keymap.Emacs",
          "name": "mkKeymap",
          "normalized": "Proto ModeMap-\u003eKeymapSet",
          "package": "yi",
          "partial": "Keymap",
          "signature": "Proto ModeMap-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Emacs.html#v:mkKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCombinators for building keymaps.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Keymap.Keys",
          "name": "Keys",
          "package": "yi",
          "source": "src/Yi-Keymap-Keys.html",
          "type": "module"
        },
        "index": {
          "description": "Combinators for building keymaps",
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "Keys",
          "package": "yi",
          "partial": "Keys",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "(\u003e\u003e!)",
          "package": "yi",
          "signature": "m b -\u003e a -\u003e m ()",
          "source": "src/Yi-Keymap-Keys.html#%3E%3E%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "(\u003e\u003e!) \u003e\u003e!",
          "normalized": "a b-\u003ec-\u003ea()",
          "package": "yi",
          "signature": "m b-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:-62--62--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "(\u003e\u003e=!)",
          "package": "yi",
          "signature": "m b -\u003e (b -\u003e a) -\u003e m ()",
          "source": "src/Yi-Keymap-Keys.html#%3E%3E%3D%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "(\u003e\u003e=!) \u003e\u003e=!",
          "normalized": "a b-\u003e(b-\u003ec)-\u003ea()",
          "package": "yi",
          "signature": "m b-\u003e(b-\u003ea)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:-62--62--61--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "(?*\u003e\u003e)",
          "package": "yi",
          "signature": "[Event] -\u003e m a -\u003e m a",
          "source": "src/Yi-Keymap-Keys.html#%3F%2A%3E%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "(?*\u003e\u003e) ?*\u003e\u003e",
          "normalized": "[Event]-\u003ea b-\u003ea b",
          "package": "yi",
          "signature": "[Event]-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:-63--42--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "(?*\u003e\u003e!)",
          "package": "yi",
          "signature": "[Event] -\u003e a -\u003e m ()",
          "source": "src/Yi-Keymap-Keys.html#%3F%2A%3E%3E%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "(?*\u003e\u003e!) ?*\u003e\u003e!",
          "normalized": "[Event]-\u003ea-\u003eb()",
          "package": "yi",
          "signature": "[Event]-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:-63--42--62--62--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "(?\u003e\u003e)",
          "package": "yi",
          "signature": "Event -\u003e m a -\u003e m a",
          "source": "src/Yi-Keymap-Keys.html#%3F%3E%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "(?\u003e\u003e) ?\u003e\u003e",
          "normalized": "Event-\u003ea b-\u003ea b",
          "package": "yi",
          "signature": "Event-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:-63--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "(?\u003e\u003e!)",
          "package": "yi",
          "signature": "Event -\u003e a -\u003e m ()",
          "source": "src/Yi-Keymap-Keys.html#%3F%3E%3E%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "(?\u003e\u003e!) ?\u003e\u003e!",
          "normalized": "Event-\u003ea-\u003eb()",
          "package": "yi",
          "signature": "Event-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:-63--62--62--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "char",
          "package": "yi",
          "signature": "Char -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#char",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "char",
          "normalized": "Char-\u003eEvent",
          "package": "yi",
          "signature": "Char-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "charOf",
          "package": "yi",
          "signature": "(Event -\u003e Event) -\u003e Char -\u003e Char -\u003e m Char",
          "source": "src/Yi-Keymap-Keys.html#charOf",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "charOf",
          "normalized": "(Event-\u003eEvent)-\u003eChar-\u003eChar-\u003ea Char",
          "package": "yi",
          "partial": "Of",
          "signature": "(Event-\u003eEvent)-\u003eChar-\u003eChar-\u003em Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:charOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "ctrl",
          "package": "yi",
          "signature": "Event -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#ctrl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "ctrl",
          "normalized": "Event-\u003eEvent",
          "package": "yi",
          "signature": "Event-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:ctrl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "ctrlCh",
          "package": "yi",
          "signature": "Char -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#ctrlCh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "ctrlCh",
          "normalized": "Char-\u003eEvent",
          "package": "yi",
          "partial": "Ch",
          "signature": "Char-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:ctrlCh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "hyper",
          "package": "yi",
          "signature": "Event -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#hyper",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "hyper",
          "normalized": "Event-\u003eEvent",
          "package": "yi",
          "signature": "Event-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:hyper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "hyperCh",
          "package": "yi",
          "signature": "Char -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#hyperCh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "hyperCh",
          "normalized": "Char-\u003eEvent",
          "package": "yi",
          "partial": "Ch",
          "signature": "Char-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:hyperCh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "meta",
          "package": "yi",
          "signature": "Event -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#meta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "meta",
          "normalized": "Event-\u003eEvent",
          "package": "yi",
          "signature": "Event-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:meta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "metaCh",
          "package": "yi",
          "signature": "Char -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#metaCh",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "metaCh",
          "normalized": "Char-\u003eEvent",
          "package": "yi",
          "partial": "Ch",
          "signature": "Char-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:metaCh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eoptMod f ev\u003c/code\u003e produces a \u003ccode\u003e\u003ca\u003eMonadInteract\u003c/a\u003e\u003c/code\u003e that consumes \u003ccode\u003eev\u003c/code\u003e or \u003ccode\u003ef ev\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Keymap.Keys",
          "name": "optMod",
          "package": "yi",
          "signature": "(Event -\u003e Event) -\u003e Event -\u003e m Event",
          "source": "src/Yi-Keymap-Keys.html#optMod",
          "type": "function"
        },
        "index": {
          "description": "optMod ev produces MonadInteract that consumes ev or ev",
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "optMod",
          "normalized": "(Event-\u003eEvent)-\u003eEvent-\u003ea Event",
          "package": "yi",
          "partial": "Mod",
          "signature": "(Event-\u003eEvent)-\u003eEvent-\u003em Event",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:optMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "pString",
          "package": "yi",
          "signature": "String -\u003e m [Event]",
          "source": "src/Yi-Keymap-Keys.html#pString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "pString",
          "normalized": "String-\u003ea[Event]",
          "package": "yi",
          "partial": "String",
          "signature": "String-\u003em[Event]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:pString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "printableChar",
          "package": "yi",
          "signature": "m Char",
          "source": "src/Yi-Keymap-Keys.html#printableChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "printableChar",
          "package": "yi",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:printableChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "shift",
          "package": "yi",
          "signature": "Event -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#shift",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "shift",
          "normalized": "Event-\u003eEvent",
          "package": "yi",
          "signature": "Event-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:shift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a special key into an event\n\u003c/p\u003e",
          "module": "Yi.Keymap.Keys",
          "name": "spec",
          "package": "yi",
          "signature": "Key -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#spec",
          "type": "function"
        },
        "index": {
          "description": "Convert special key into an event",
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "spec",
          "normalized": "Key-\u003eEvent",
          "package": "yi",
          "signature": "Key-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:spec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Keys",
          "name": "super",
          "package": "yi",
          "signature": "Event -\u003e Event",
          "source": "src/Yi-Keymap-Keys.html#super",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "super",
          "normalized": "Event-\u003eEvent",
          "package": "yi",
          "signature": "Event-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:super"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse any character that can be inserted in the text.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Keys",
          "name": "textChar",
          "package": "yi",
          "signature": "KeymapM Char",
          "source": "src/Yi-Keymap-Keys.html#textChar",
          "type": "function"
        },
        "index": {
          "description": "Parse any character that can be inserted in the text",
          "hierarchy": "Yi Keymap Keys",
          "module": "Yi.Keymap.Keys",
          "name": "textChar",
          "package": "yi",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Keys.html#v:textChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Readline",
          "name": "Readline",
          "package": "yi",
          "source": "src/Yi-Keymap-Readline.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Readline",
          "module": "Yi.Keymap.Readline",
          "name": "Readline",
          "package": "yi",
          "partial": "Readline",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Readline.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReadline-like movement bindings intended for minibuffer keymaps\n\u003c/p\u003e",
          "module": "Yi.Keymap.Readline",
          "name": "standardMovementBindings",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap-Readline.html#standardMovementBindings",
          "type": "function"
        },
        "index": {
          "description": "Readline-like movement bindings intended for minibuffer keymaps",
          "hierarchy": "Yi Keymap Readline",
          "module": "Yi.Keymap.Readline",
          "name": "standardMovementBindings",
          "package": "yi",
          "partial": "Movement Bindings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Readline.html#v:standardMovementBindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "TagStack",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim-TagStack.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "TagStack",
          "package": "yi",
          "partial": "Tag Stack",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "VimTagStack",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim-TagStack.html#VimTagStack",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "VimTagStack",
          "package": "yi",
          "partial": "Vim Tag Stack",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#t:VimTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "VimTagStack",
          "package": "yi",
          "signature": "VimTagStack",
          "source": "src/Yi-Keymap-Vim-TagStack.html#VimTagStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "VimTagStack",
          "package": "yi",
          "partial": "Vim Tag Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:VimTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "getTagStack",
          "package": "yi",
          "signature": "EditorM VimTagStack",
          "source": "src/Yi-Keymap-Vim-TagStack.html#getTagStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "getTagStack",
          "package": "yi",
          "partial": "Tag Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:getTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim.TagStack\",\"Yi.Keymap.Vim\"]",
          "name": "listTagStack",
          "package": "yi",
          "signature": "EditorM [(FilePath, Point)]",
          "source": "src/Yi-Keymap-Vim-TagStack.html#listTagStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:listTagStack\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:listTagStack\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "listTagStack",
          "normalized": "EditorM[(FilePath,Point)]",
          "package": "yi",
          "partial": "Tag Stack",
          "signature": "EditorM[(FilePath,Point)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:listTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim.TagStack\",\"Yi.Keymap.Vim\"]",
          "name": "peekTagStack",
          "package": "yi",
          "signature": "EditorM (Maybe (FilePath, Point))",
          "source": "src/Yi-Keymap-Vim-TagStack.html#peekTagStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:peekTagStack\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:peekTagStack\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "peekTagStack",
          "normalized": "EditorM(Maybe(FilePath,Point))",
          "package": "yi",
          "partial": "Tag Stack",
          "signature": "EditorM(Maybe(FilePath,Point))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:peekTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim.TagStack\",\"Yi.Keymap.Vim\"]",
          "name": "popTagStack",
          "package": "yi",
          "signature": "Int -\u003e EditorM (Maybe (FilePath, Point))",
          "source": "src/Yi-Keymap-Vim-TagStack.html#popTagStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:popTagStack\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:popTagStack\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "popTagStack",
          "normalized": "Int-\u003eEditorM(Maybe(FilePath,Point))",
          "package": "yi",
          "partial": "Tag Stack",
          "signature": "Int-\u003eEditorM(Maybe(FilePath,Point))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:popTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim.TagStack\",\"Yi.Keymap.Vim\"]",
          "name": "pushTagStack",
          "package": "yi",
          "signature": "FilePath -\u003e Point -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim-TagStack.html#pushTagStack",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:pushTagStack\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:pushTagStack\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "pushTagStack",
          "normalized": "FilePath-\u003ePoint-\u003eEditorM()",
          "package": "yi",
          "partial": "Tag Stack",
          "signature": "FilePath-\u003ePoint-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:pushTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "setTagStack",
          "package": "yi",
          "signature": "VimTagStack -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim-TagStack.html#setTagStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "setTagStack",
          "normalized": "VimTagStack-\u003eEditorM()",
          "package": "yi",
          "partial": "Tag Stack",
          "signature": "VimTagStack-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:setTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "tagsStack",
          "package": "yi",
          "signature": "[(FilePath, Point)]",
          "source": "src/Yi-Keymap-Vim-TagStack.html#VimTagStack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim TagStack",
          "module": "Yi.Keymap.Vim.TagStack",
          "name": "tagsStack",
          "normalized": "[(FilePath,Point)]",
          "package": "yi",
          "partial": "Stack",
          "signature": "[(FilePath,Point)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim-TagStack.html#v:tagsStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVim keymap for Yi. Emulates vim :set nocompatible\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "Vim",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim.html",
          "type": "module"
        },
        "index": {
          "description": "Vim keymap for Yi Emulates vim set nocompatible",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "Vim",
          "package": "yi",
          "partial": "Vim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Vim keymap is divided into several parts, roughly corresponding\n to the different modes of vi. Each mode is in turn broken up into\n separate VimProcs for each phase of key input in that mode.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "ModeMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim.html#ModeMap",
          "type": "data"
        },
        "index": {
          "description": "The Vim keymap is divided into several parts roughly corresponding to the different modes of vi Each mode is in turn broken up into separate VimProcs for each phase of key input in that mode",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "ModeMap",
          "package": "yi",
          "partial": "Mode Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#t:ModeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "VimExCmd",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim.html#VimExCmd",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "VimExCmd",
          "package": "yi",
          "partial": "Vim Ex Cmd",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#t:VimExCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "VimOpts",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim.html#VimOpts",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "VimOpts",
          "package": "yi",
          "partial": "Vim Opts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#t:VimOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "ModeMap",
          "package": "yi",
          "signature": "ModeMap",
          "source": "src/Yi-Keymap-Vim.html#ModeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "ModeMap",
          "package": "yi",
          "partial": "Mode Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:ModeMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "VimExCmd",
          "package": "yi",
          "signature": "VimExCmd",
          "source": "src/Yi-Keymap-Vim.html#VimExCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "VimExCmd",
          "package": "yi",
          "partial": "Vim Ex Cmd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:VimExCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "VimOpts",
          "package": "yi",
          "signature": "VimOpts",
          "source": "src/Yi-Keymap-Vim.html#VimOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "VimOpts",
          "package": "yi",
          "partial": "Vim Opts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:VimOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "beginIns",
          "package": "yi",
          "signature": "ModeMap -\u003e a -\u003e I Event Action ()",
          "source": "src/Yi-Keymap-Vim.html#beginIns",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "beginIns",
          "normalized": "ModeMap-\u003ea-\u003eI Event Action()",
          "package": "yi",
          "partial": "Ins",
          "signature": "ModeMap-\u003ea-\u003eI Event Action()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:beginIns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "beginInsB",
          "package": "yi",
          "signature": "ModeMap -\u003e BufferM () -\u003e I Event Action ()",
          "source": "src/Yi-Keymap-Vim.html#beginInsB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "beginInsB",
          "normalized": "ModeMap-\u003eBufferM()-\u003eI Event Action()",
          "package": "yi",
          "partial": "Ins",
          "signature": "ModeMap-\u003eBufferM()-\u003eI Event Action()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:beginInsB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "beginInsE",
          "package": "yi",
          "signature": "ModeMap -\u003e EditorM () -\u003e I Event Action ()",
          "source": "src/Yi-Keymap-Vim.html#beginInsE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "beginInsE",
          "normalized": "ModeMap-\u003eEditorM()-\u003eI Event Action()",
          "package": "yi",
          "partial": "Ins",
          "signature": "ModeMap-\u003eEditorM()-\u003eI Event Action()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:beginInsE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "cmdFn",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#VimExCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "cmdFn",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Fn",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:cmdFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "cmdNames",
          "package": "yi",
          "signature": "[String]",
          "source": "src/Yi-Keymap-Vim.html#VimExCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "cmdNames",
          "normalized": "[String]",
          "package": "yi",
          "partial": "Names",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:cmdNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "completeCaseSensitive",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim.html#VimOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "completeCaseSensitive",
          "package": "yi",
          "partial": "Case Sensitive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:completeCaseSensitive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "completeFn",
          "package": "yi",
          "signature": "Maybe (String -\u003e YiM ())",
          "source": "src/Yi-Keymap-Vim.html#VimExCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "completeFn",
          "normalized": "Maybe(String-\u003eYiM())",
          "package": "yi",
          "partial": "Fn",
          "signature": "Maybe(String-\u003eYiM())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:completeFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "defKeymap",
          "package": "yi",
          "signature": "Proto ModeMap",
          "source": "src/Yi-Keymap-Vim.html#defKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "defKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:defKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "enableTagStack",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim.html#VimOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "enableTagStack",
          "package": "yi",
          "partial": "Tag Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:enableTagStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exCmd",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e YiM ()) -\u003e Maybe (String -\u003e YiM ()) -\u003e VimExCmd",
          "source": "src/Yi-Keymap-Vim.html#exCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exCmd",
          "normalized": "String-\u003e(String-\u003eYiM())-\u003eMaybe(String-\u003eYiM())-\u003eVimExCmd",
          "package": "yi",
          "partial": "Cmd",
          "signature": "String-\u003e(String-\u003eYiM())-\u003eMaybe(String-\u003eYiM())-\u003eVimExCmd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exCmds",
          "package": "yi",
          "signature": "[(String, String -\u003e YiM (), Maybe (String -\u003e YiM ()))] -\u003e VimExCmdMap",
          "source": "src/Yi-Keymap-Vim.html#exCmds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exCmds",
          "normalized": "[(String,String-\u003eYiM(),Maybe(String-\u003eYiM()))]-\u003eVimExCmdMap",
          "package": "yi",
          "partial": "Cmds",
          "signature": "[(String,String-\u003eYiM(),Maybe(String-\u003eYiM()))]-\u003eVimExCmdMap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exCmds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeval an ex command to an YiM (), also appends to the ex history\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "exEval",
          "package": "yi",
          "signature": "ModeMap -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exEval",
          "type": "function"
        },
        "index": {
          "description": "eval an ex command to an YiM also appends to the ex history",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exEval",
          "normalized": "ModeMap-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Eval",
          "signature": "ModeMap-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exHistComplete",
          "package": "yi",
          "signature": "(String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exHistComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exHistComplete",
          "normalized": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Hist Complete",
          "signature": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exHistComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exHistComplete'",
          "package": "yi",
          "signature": "Bool -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exHistComplete%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exHistComplete'",
          "normalized": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Hist Complete'",
          "signature": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exHistComplete-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exHistInfixComplete",
          "package": "yi",
          "signature": "(String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exHistInfixComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exHistInfixComplete",
          "normalized": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Hist Infix Complete",
          "signature": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exHistInfixComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exHistInfixComplete'",
          "package": "yi",
          "signature": "Bool -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exHistInfixComplete%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exHistInfixComplete'",
          "normalized": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Hist Infix Complete'",
          "signature": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exHistInfixComplete-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exInfixComplete",
          "package": "yi",
          "signature": "(String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exInfixComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exInfixComplete",
          "normalized": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Infix Complete",
          "signature": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exInfixComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exInfixComplete'",
          "package": "yi",
          "signature": "Bool -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exInfixComplete%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exInfixComplete'",
          "normalized": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Infix Complete'",
          "signature": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exInfixComplete-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exMode",
          "package": "yi",
          "signature": "ModeMap -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim.html#exMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exMode",
          "normalized": "ModeMap-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "ModeMap-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "exSimpleComplete",
          "package": "yi",
          "signature": "(String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#exSimpleComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "exSimpleComplete",
          "normalized": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Simple Complete",
          "signature": "(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:exSimpleComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "keymapSet",
          "package": "yi",
          "signature": "KeymapSet",
          "source": "src/Yi-Keymap-Vim.html#keymapSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "keymapSet",
          "package": "yi",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:keymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeave a mode. This always has priority over catch-all actions inside the mode.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "leave",
          "package": "yi",
          "signature": "VimMode",
          "source": "src/Yi-Keymap-Vim.html#leave",
          "type": "function"
        },
        "index": {
          "description": "Leave mode This always has priority over catch-all actions inside the mode",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "leave",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:leave"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "leaveInsRep",
          "package": "yi",
          "signature": "VimMode",
          "source": "src/Yi-Keymap-Vim.html#leaveInsRep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "leaveInsRep",
          "package": "yi",
          "partial": "Ins Rep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:leaveInsRep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "mkExHistComplete",
          "package": "yi",
          "signature": "(String -\u003e String -\u003e Bool) -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#mkExHistComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "mkExHistComplete",
          "normalized": "(String-\u003eString-\u003eBool)-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Ex Hist Complete",
          "signature": "(String-\u003eString-\u003eBool)-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:mkExHistComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "mkKeymap",
          "package": "yi",
          "signature": "Proto ModeMap -\u003e KeymapSet",
          "source": "src/Yi-Keymap-Vim.html#mkKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "mkKeymap",
          "normalized": "Proto ModeMap-\u003eKeymapSet",
          "package": "yi",
          "partial": "Keymap",
          "signature": "Proto ModeMap-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:mkKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "nilCmd",
          "package": "yi",
          "signature": "VimExCmd",
          "source": "src/Yi-Keymap-Vim.html#nilCmd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "nilCmd",
          "package": "yi",
          "partial": "Cmd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:nilCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "savingCommandE",
          "package": "yi",
          "signature": "(Int -\u003e EditorM ()) -\u003e Int -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim.html#savingCommandE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingCommandE",
          "normalized": "(Int-\u003eEditorM())-\u003eInt-\u003eEditorM()",
          "package": "yi",
          "partial": "Command",
          "signature": "(Int-\u003eEditorM())-\u003eInt-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingCommandE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "savingCommandY",
          "package": "yi",
          "signature": "(Int -\u003e YiM ()) -\u003e Int -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim.html#savingCommandY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingCommandY",
          "normalized": "(Int-\u003eYiM())-\u003eInt-\u003eYiM()",
          "package": "yi",
          "partial": "Command",
          "signature": "(Int-\u003eYiM())-\u003eInt-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingCommandY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe given action should be a deletion action.\n The only well tested buffer actions are deleting one character,\n or one word, forward or backward.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "savingDeleteB",
          "package": "yi",
          "signature": "BufferM () -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim.html#savingDeleteB",
          "type": "function"
        },
        "index": {
          "description": "The given action should be deletion action The only well tested buffer actions are deleting one character or one word forward or backward",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingDeleteB",
          "normalized": "BufferM()-\u003eBufferM()",
          "package": "yi",
          "partial": "Delete",
          "signature": "BufferM()-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingDeleteB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "savingDeleteCharB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim.html#savingDeleteCharB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingDeleteCharB",
          "normalized": "Direction-\u003eBufferM()",
          "package": "yi",
          "partial": "Delete Char",
          "signature": "Direction-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingDeleteCharB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "savingDeleteWordB",
          "package": "yi",
          "signature": "Direction -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim.html#savingDeleteWordB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingDeleteWordB",
          "normalized": "Direction-\u003eBufferM()",
          "package": "yi",
          "partial": "Delete Word",
          "signature": "Direction-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingDeleteWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe given buffer action should be an insertion action.\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "savingInsertB",
          "package": "yi",
          "signature": "BufferM () -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim.html#savingInsertB",
          "type": "function"
        },
        "index": {
          "description": "The given buffer action should be an insertion action",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingInsertB",
          "normalized": "BufferM()-\u003eBufferM()",
          "package": "yi",
          "partial": "Insert",
          "signature": "BufferM()-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingInsertB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "savingInsertCharB",
          "package": "yi",
          "signature": "Char -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim.html#savingInsertCharB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingInsertCharB",
          "normalized": "Char-\u003eBufferM()",
          "package": "yi",
          "partial": "Insert Char",
          "signature": "Char-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingInsertCharB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "savingInsertStringB",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim.html#savingInsertStringB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "savingInsertStringB",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Insert String",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:savingInsertStringB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "tildeop",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim.html#VimOpts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "tildeop",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:tildeop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "v_ex_cmds",
          "package": "yi",
          "signature": "VimExCmdMap",
          "source": "src/Yi-Keymap-Vim.html#ModeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "v_ex_cmds",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:v_ex_cmds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evim insert mode\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "v_ins_char",
          "package": "yi",
          "signature": "VimMode",
          "source": "src/Yi-Keymap-Vim.html#ModeMap",
          "type": "function"
        },
        "index": {
          "description": "vim insert mode",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "v_ins_char",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:v_ins_char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim",
          "name": "v_opts",
          "package": "yi",
          "signature": "VimOpts",
          "source": "src/Yi-Keymap-Vim.html#ModeMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "v_opts",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:v_opts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTop level mode\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim",
          "name": "v_top_level",
          "package": "yi",
          "signature": "VimMode",
          "source": "src/Yi-Keymap-Vim.html#ModeMap",
          "type": "function"
        },
        "index": {
          "description": "Top level mode",
          "hierarchy": "Yi Keymap Vim",
          "module": "Yi.Keymap.Vim",
          "name": "v_top_level",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim.html#v:v_top_level"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Common",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Common",
          "package": "yi",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "EventString",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#EventString",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "EventString",
          "package": "yi",
          "partial": "Event String",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:EventString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "GotoCharCommand",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#GotoCharCommand",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "GotoCharCommand",
          "package": "yi",
          "partial": "Goto Char Command",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:GotoCharCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "MatchResult",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#MatchResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "MatchResult",
          "package": "yi",
          "partial": "Match Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:MatchResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "OperatorName",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#OperatorName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "OperatorName",
          "package": "yi",
          "partial": "Operator Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:OperatorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Register",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#Register",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Register",
          "package": "yi",
          "partial": "Register",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:Register"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RegisterName",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#RegisterName",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RegisterName",
          "package": "yi",
          "partial": "Register Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:RegisterName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RepeatToken",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatToken",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RepeatToken",
          "package": "yi",
          "partial": "Repeat Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:RepeatToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RepeatableAction",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatableAction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RepeatableAction",
          "package": "yi",
          "partial": "Repeatable Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:RepeatableAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimBinding",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimBinding",
          "package": "yi",
          "partial": "Vim Binding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:VimBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimMode",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimMode",
          "package": "yi",
          "partial": "Vim Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:VimMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimState",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimState",
          "package": "yi",
          "partial": "Vim State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#t:VimState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Continue",
          "package": "yi",
          "signature": "Continue",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Continue",
          "package": "yi",
          "partial": "Continue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Continue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Drop",
          "package": "yi",
          "signature": "Drop",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Drop",
          "package": "yi",
          "partial": "Drop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Ex",
          "package": "yi",
          "signature": "Ex",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Ex",
          "package": "yi",
          "partial": "Ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Ex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Finish",
          "package": "yi",
          "signature": "Finish",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Finish",
          "package": "yi",
          "partial": "Finish",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Finish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "GotoCharCommand",
          "package": "yi",
          "signature": "GotoCharCommand !Char !Direction !RegionStyle",
          "source": "src/Yi-Keymap-Vim2-Common.html#GotoCharCommand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "GotoCharCommand",
          "package": "yi",
          "partial": "Goto Char Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:GotoCharCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echar denotes how state got into insert mode (\u003ccode\u003ei\u003c/code\u003e, \u003ccode\u003ea\u003c/code\u003e, etc.)\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Insert",
          "package": "yi",
          "signature": "Insert Char",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "description": "char denotes how state got into insert mode etc",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Insert",
          "package": "yi",
          "partial": "Insert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eafter C-o\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "InsertNormal",
          "package": "yi",
          "signature": "InsertNormal",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "description": "after C-o",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "InsertNormal",
          "package": "yi",
          "partial": "Insert Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:InsertNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eafter C-o and one of v, V, C-v\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "InsertVisual",
          "package": "yi",
          "signature": "InsertVisual",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "description": "after C-o and one of C-v",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "InsertVisual",
          "package": "yi",
          "partial": "Insert Visual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:InsertVisual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2.MatchResult\"]",
          "name": "NoMatch",
          "package": "yi",
          "signature": "NoMatch",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#MatchResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:NoMatch\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#v:NoMatch\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "NoMatch",
          "package": "yi",
          "partial": "No Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:NoMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Normal",
          "package": "yi",
          "signature": "Normal",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Normal",
          "package": "yi",
          "partial": "Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "NormalOperatorPending",
          "package": "yi",
          "signature": "NormalOperatorPending OperatorName",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "NormalOperatorPending",
          "package": "yi",
          "partial": "Normal Operator Pending",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:NormalOperatorPending"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2.MatchResult\"]",
          "name": "PartialMatch",
          "package": "yi",
          "signature": "PartialMatch",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#MatchResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:PartialMatch\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#v:PartialMatch\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "PartialMatch",
          "package": "yi",
          "partial": "Partial Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:PartialMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Register",
          "package": "yi",
          "signature": "Register",
          "source": "src/Yi-Keymap-Vim2-Common.html#Register",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Register",
          "package": "yi",
          "partial": "Register",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Register"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RepeatableAction",
          "package": "yi",
          "signature": "RepeatableAction",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatableAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "RepeatableAction",
          "package": "yi",
          "partial": "Repeatable Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:RepeatableAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Replace",
          "package": "yi",
          "signature": "Replace",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Replace",
          "package": "yi",
          "partial": "Replace",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "ReplaceSingleChar",
          "package": "yi",
          "signature": "ReplaceSingleChar",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "ReplaceSingleChar",
          "package": "yi",
          "partial": "Replace Single Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:ReplaceSingleChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Search",
          "package": "yi",
          "signature": "Search",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Search",
          "package": "yi",
          "partial": "Search",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Search"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2\"]",
          "name": "VimBindingE",
          "package": "yi",
          "signature": "VimBindingE",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:VimBindingE\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:VimBindingE\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimBindingE",
          "package": "yi",
          "partial": "Vim Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:VimBindingE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2\"]",
          "name": "VimBindingY",
          "package": "yi",
          "signature": "VimBindingY",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:VimBindingY\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:VimBindingY\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimBindingY",
          "package": "yi",
          "partial": "Vim Binding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:VimBindingY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimState",
          "package": "yi",
          "signature": "VimState",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "VimState",
          "package": "yi",
          "partial": "Vim State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:VimState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Visual",
          "package": "yi",
          "signature": "Visual RegionStyle",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "Visual",
          "package": "yi",
          "partial": "Visual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:Visual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2.MatchResult\"]",
          "name": "WholeMatch",
          "package": "yi",
          "signature": "WholeMatch a",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#MatchResult",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:WholeMatch\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#v:WholeMatch\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "WholeMatch",
          "package": "yi",
          "partial": "Whole Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:WholeMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "direction",
          "package": "yi",
          "signature": "Direction",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "direction",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:direction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "previousMode",
          "package": "yi",
          "signature": "VimMode",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "previousMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:previousMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "raActionString",
          "package": "yi",
          "signature": "EventString",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatableAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "raActionString",
          "package": "yi",
          "partial": "Action String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:raActionString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "raPreviousCount",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Keymap-Vim2-Common.html#RepeatableAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "raPreviousCount",
          "package": "yi",
          "partial": "Previous Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:raPreviousCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "regContent",
          "package": "yi",
          "signature": "Rope",
          "source": "src/Yi-Keymap-Vim2-Common.html#Register",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "regContent",
          "package": "yi",
          "partial": "Content",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:regContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "regRegionStyle",
          "package": "yi",
          "signature": "RegionStyle",
          "source": "src/Yi-Keymap-Vim2-Common.html#Register",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "regRegionStyle",
          "package": "yi",
          "partial": "Region Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:regRegionStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2\"]",
          "name": "vbPrerequisite",
          "package": "yi",
          "signature": "EventString -\u003e VimState -\u003e MatchResult ()",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vbPrerequisite\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vbPrerequisite\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vbPrerequisite",
          "normalized": "EventString-\u003eVimState-\u003eMatchResult()",
          "package": "yi",
          "partial": "Prerequisite",
          "signature": "EventString-\u003eVimState-\u003eMatchResult()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vbPrerequisite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2\"]",
          "name": "vbeAction",
          "package": "yi",
          "signature": "EventString -\u003e EditorM RepeatToken",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vbeAction\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vbeAction\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vbeAction",
          "normalized": "EventString-\u003eEditorM RepeatToken",
          "package": "yi",
          "partial": "Action",
          "signature": "EventString-\u003eEditorM RepeatToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vbeAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Common\",\"Yi.Keymap.Vim2\"]",
          "name": "vbyAction",
          "package": "yi",
          "signature": "EventString -\u003e YiM RepeatToken",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vbyAction\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vbyAction\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vbyAction",
          "normalized": "EventString-\u003eYiM RepeatToken",
          "package": "yi",
          "partial": "Action",
          "signature": "EventString-\u003eYiM RepeatToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vbyAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efor repeat and potentially macros\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsAccumulator",
          "package": "yi",
          "signature": "EventString",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "description": "for repeat and potentially macros",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsAccumulator",
          "package": "yi",
          "partial": "Accumulator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsAccumulator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsActiveRegister",
          "package": "yi",
          "signature": "RegisterName",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsActiveRegister",
          "package": "yi",
          "partial": "Active Register",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsActiveRegister"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsBindingAccumulator",
          "package": "yi",
          "signature": "EventString",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsBindingAccumulator",
          "package": "yi",
          "partial": "Binding Accumulator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsBindingAccumulator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsCount",
          "package": "yi",
          "signature": "(Maybe Int)",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsCount",
          "package": "yi",
          "partial": "Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsLastGotoCharCommand",
          "package": "yi",
          "signature": "(Maybe GotoCharCommand)",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsLastGotoCharCommand",
          "package": "yi",
          "partial": "Last Goto Char Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsLastGotoCharCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsMode",
          "package": "yi",
          "signature": "VimMode",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsOngoingInsertEvents",
          "package": "yi",
          "signature": "EventString",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsOngoingInsertEvents",
          "package": "yi",
          "partial": "Ongoing Insert Events",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsOngoingInsertEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elike vim's :help paste\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsPaste",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "description": "like vim help paste",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsPaste",
          "package": "yi",
          "partial": "Paste",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsPaste"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsRegisterMap",
          "package": "yi",
          "signature": "(HashMap RegisterName Register)",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsRegisterMap",
          "package": "yi",
          "partial": "Register Map",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsRegisterMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsRepeatableAction",
          "package": "yi",
          "signature": "(Maybe RepeatableAction)",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsRepeatableAction",
          "package": "yi",
          "partial": "Repeatable Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsRepeatableAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsSecondaryCursors",
          "package": "yi",
          "signature": "[Point]",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsSecondaryCursors",
          "normalized": "[Point]",
          "package": "yi",
          "partial": "Secondary Cursors",
          "signature": "[Point]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsSecondaryCursors"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eis set on $, allows j and k walk the right edge of lines\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsStickyEol",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "description": "is set on allows and walk the right edge of lines",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsStickyEol",
          "package": "yi",
          "partial": "Sticky Eol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsStickyEol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esee Yi.Keymap.Vim2.vimEval comment\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsStringToEval",
          "package": "yi",
          "signature": "EventString",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "description": "see Yi.Keymap.Vim2.vimEval comment",
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsStringToEval",
          "package": "yi",
          "partial": "String To Eval",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsStringToEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsTextObjectAccumulator",
          "package": "yi",
          "signature": "EventString",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Common",
          "module": "Yi.Keymap.Vim2.Common",
          "name": "vsTextObjectAccumulator",
          "package": "yi",
          "partial": "Text Object Accumulator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Common.html#v:vsTextObjectAccumulator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Digraph",
          "name": "Digraph",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Digraph.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Digraph",
          "module": "Yi.Keymap.Vim2.Digraph",
          "name": "Digraph",
          "package": "yi",
          "partial": "Digraph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Digraph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Digraph",
          "name": "charFromDigraph",
          "package": "yi",
          "signature": "[(String, Char)] -\u003e Char -\u003e Char -\u003e Maybe Char",
          "source": "src/Yi-Keymap-Vim2-Digraph.html#charFromDigraph",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Digraph",
          "module": "Yi.Keymap.Vim2.Digraph",
          "name": "charFromDigraph",
          "normalized": "[(String,Char)]-\u003eChar-\u003eChar-\u003eMaybe Char",
          "package": "yi",
          "partial": "From Digraph",
          "signature": "[(String,Char)]-\u003eChar-\u003eChar-\u003eMaybe Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Digraph.html#v:charFromDigraph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Digraph",
          "name": "defDigraphs",
          "package": "yi",
          "signature": "[(String, Char)]",
          "source": "src/Yi-Keymap-Vim2-Digraph.html#defDigraphs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Digraph",
          "module": "Yi.Keymap.Vim2.Digraph",
          "name": "defDigraphs",
          "normalized": "[(String,Char)]",
          "package": "yi",
          "partial": "Digraphs",
          "signature": "[(String,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Digraph.html#v:defDigraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Eval",
          "name": "Eval",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Eval.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Eval",
          "module": "Yi.Keymap.Vim2.Eval",
          "name": "Eval",
          "package": "yi",
          "partial": "Eval",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Eval.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Eval",
          "name": "scheduleActionStringForEval",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-Eval.html#scheduleActionStringForEval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Eval",
          "module": "Yi.Keymap.Vim2.Eval",
          "name": "scheduleActionStringForEval",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Action String For Eval",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Eval.html#v:scheduleActionStringForEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "EventUtils",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "EventUtils",
          "package": "yi",
          "partial": "Event Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "eventToString",
          "package": "yi",
          "signature": "Event -\u003e String",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html#eventToString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "eventToString",
          "normalized": "Event-\u003eString",
          "package": "yi",
          "partial": "To String",
          "signature": "Event-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:eventToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "normalizeCount",
          "package": "yi",
          "signature": "String -\u003e String",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html#normalizeCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "normalizeCount",
          "normalized": "String-\u003eString",
          "package": "yi",
          "partial": "Count",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:normalizeCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "parseEvents",
          "package": "yi",
          "signature": "String -\u003e [Event]",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html#parseEvents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "parseEvents",
          "normalized": "String-\u003e[Event]",
          "package": "yi",
          "partial": "Events",
          "signature": "String-\u003e[Event]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:parseEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.EventUtils\",\"Yi.Keymap.Vim2.Utils\"]",
          "name": "splitCountedCommand",
          "package": "yi",
          "signature": "String -\u003e (Int, String)",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html#splitCountedCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:splitCountedCommand\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:splitCountedCommand\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "splitCountedCommand",
          "normalized": "String-\u003e(Int,String)",
          "package": "yi",
          "partial": "Counted Command",
          "signature": "String-\u003e(Int,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:splitCountedCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "stringToEvent",
          "package": "yi",
          "signature": "String -\u003e Event",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html#stringToEvent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "stringToEvent",
          "normalized": "String-\u003eEvent",
          "package": "yi",
          "partial": "To Event",
          "signature": "String-\u003eEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:stringToEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "stringToRepeatableAction",
          "package": "yi",
          "signature": "String -\u003e RepeatableAction",
          "source": "src/Yi-Keymap-Vim2-EventUtils.html#stringToRepeatableAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 EventUtils",
          "module": "Yi.Keymap.Vim2.EventUtils",
          "name": "stringToRepeatableAction",
          "normalized": "String-\u003eRepeatableAction",
          "package": "yi",
          "partial": "To Repeatable Action",
          "signature": "String-\u003eRepeatableAction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-EventUtils.html#v:stringToRepeatableAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.BufferDelete",
          "name": "BufferDelete",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-BufferDelete.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands BufferDelete",
          "module": "Yi.Keymap.Vim2.Ex.Commands.BufferDelete",
          "name": "BufferDelete",
          "package": "yi",
          "partial": "Buffer Delete",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-BufferDelete.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.BufferDelete",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-BufferDelete.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands BufferDelete",
          "module": "Yi.Keymap.Vim2.Ex.Commands.BufferDelete",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-BufferDelete.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Common",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Common",
          "package": "yi",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "OptionAction",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#OptionAction",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "OptionAction",
          "package": "yi",
          "partial": "Option Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#t:OptionAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Ask",
          "package": "yi",
          "signature": "Ask",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#OptionAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Ask",
          "package": "yi",
          "partial": "Ask",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:Ask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Invert",
          "package": "yi",
          "signature": "Invert",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#OptionAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Invert",
          "package": "yi",
          "partial": "Invert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:Invert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Set",
          "package": "yi",
          "signature": "Set !Bool",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#OptionAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "Set",
          "package": "yi",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "filenameComplete",
          "package": "yi",
          "signature": "FilePath -\u003e YiM [FilePath]",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#filenameComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "filenameComplete",
          "normalized": "FilePath-\u003eYiM[FilePath]",
          "package": "yi",
          "partial": "Complete",
          "signature": "FilePath-\u003eYiM[FilePath]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:filenameComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "forAllBuffers",
          "package": "yi",
          "signature": "(BufferRef -\u003e m ()) -\u003e m ()",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#forAllBuffers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "forAllBuffers",
          "normalized": "(BufferRef-\u003ea())-\u003ea()",
          "package": "yi",
          "partial": "All Buffers",
          "signature": "(BufferRef-\u003em())-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:forAllBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "impureExCommand",
          "package": "yi",
          "signature": "ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#impureExCommand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "impureExCommand",
          "package": "yi",
          "partial": "Ex Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:impureExCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "parse",
          "package": "yi",
          "signature": "GenParser Char () ExCommand -\u003e String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "parse",
          "normalized": "GenParser Char()ExCommand-\u003eString-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "GenParser Char()ExCommand-\u003eString-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "parseOption",
          "package": "yi",
          "signature": "String -\u003e (OptionAction -\u003e Action) -\u003e String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#parseOption",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "parseOption",
          "normalized": "String-\u003e(OptionAction-\u003eAction)-\u003eString-\u003eMaybe ExCommand",
          "package": "yi",
          "partial": "Option",
          "signature": "String-\u003e(OptionAction-\u003eAction)-\u003eString-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:parseOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "parseRange",
          "package": "yi",
          "signature": "GenParser Char () LineRange",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#parseRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "parseRange",
          "normalized": "GenParser Char()LineRange",
          "package": "yi",
          "partial": "Range",
          "signature": "GenParser Char()LineRange",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:parseRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "pureExCommand",
          "package": "yi",
          "signature": "ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Common.html#pureExCommand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Common",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Common",
          "name": "pureExCommand",
          "package": "yi",
          "partial": "Ex Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Common.html#v:pureExCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Delete",
          "name": "Delete",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Delete.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Delete",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Delete",
          "name": "Delete",
          "package": "yi",
          "partial": "Delete",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Delete.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Delete",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Delete.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Delete",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Delete",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Delete.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Edit",
          "name": "Edit",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Edit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Edit",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Edit",
          "name": "Edit",
          "package": "yi",
          "partial": "Edit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Edit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Edit",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Edit.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Edit",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Edit",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Edit.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Global",
          "name": "Global",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Global.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Global",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Global",
          "name": "Global",
          "package": "yi",
          "partial": "Global",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Global.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Global",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Global.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Global",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Global",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Global.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.GotoLine",
          "name": "GotoLine",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-GotoLine.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands GotoLine",
          "module": "Yi.Keymap.Vim2.Ex.Commands.GotoLine",
          "name": "GotoLine",
          "package": "yi",
          "partial": "Goto Line",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-GotoLine.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.GotoLine",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-GotoLine.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands GotoLine",
          "module": "Yi.Keymap.Vim2.Ex.Commands.GotoLine",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-GotoLine.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Nohl",
          "name": "Nohl",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Nohl.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Nohl",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Nohl",
          "name": "Nohl",
          "package": "yi",
          "partial": "Nohl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Nohl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Nohl",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Nohl.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Nohl",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Nohl",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Nohl.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Paste",
          "name": "Paste",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Paste.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Paste",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Paste",
          "name": "Paste",
          "package": "yi",
          "partial": "Paste",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Paste.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Paste",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Paste.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Paste",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Paste",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Paste.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Quit",
          "name": "Quit",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Quit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Quit",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Quit",
          "name": "Quit",
          "package": "yi",
          "partial": "Quit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Quit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Quit",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Quit.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Quit",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Quit",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Quit.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Reload",
          "name": "Reload",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Reload.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Reload",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Reload",
          "name": "Reload",
          "package": "yi",
          "partial": "Reload",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Reload.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Reload",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Reload.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Reload",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Reload",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Reload.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Substitute",
          "name": "Substitute",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Substitute.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Substitute",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Substitute",
          "name": "Substitute",
          "package": "yi",
          "partial": "Substitute",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Substitute.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Substitute",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Substitute.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Substitute",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Substitute",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Substitute.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Write",
          "name": "Write",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Write.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Write",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Write",
          "name": "Write",
          "package": "yi",
          "partial": "Write",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Write.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Write",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Write.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Write",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Write",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Write.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Yi",
          "name": "Yi",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Yi.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Yi",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Yi",
          "name": "Yi",
          "package": "yi",
          "partial": "Yi",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Yi.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Commands.Yi",
          "name": "parse",
          "package": "yi",
          "signature": "String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Commands-Yi.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Commands Yi",
          "module": "Yi.Keymap.Vim2.Ex.Commands.Yi",
          "name": "parse",
          "normalized": "String-\u003eMaybe ExCommand",
          "package": "yi",
          "signature": "String-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Commands-Yi.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Eval",
          "name": "Eval",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Eval.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Eval",
          "module": "Yi.Keymap.Vim2.Ex.Eval",
          "name": "Eval",
          "package": "yi",
          "partial": "Eval",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Eval.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Eval\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "exEvalE",
          "package": "yi",
          "signature": "[String -\u003e Maybe ExCommand] -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-Ex-Eval.html#exEvalE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Eval.html#v:exEvalE\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:exEvalE\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Eval",
          "module": "Yi.Keymap.Vim2.Ex.Eval",
          "name": "exEvalE",
          "normalized": "[String-\u003eMaybe ExCommand]-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Eval",
          "signature": "[String-\u003eMaybe ExCommand]-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Eval.html#v:exEvalE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Eval\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "exEvalY",
          "package": "yi",
          "signature": "[String -\u003e Maybe ExCommand] -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim2-Ex-Eval.html#exEvalY",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Eval.html#v:exEvalY\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:exEvalY\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Eval",
          "module": "Yi.Keymap.Vim2.Ex.Eval",
          "name": "exEvalY",
          "normalized": "[String-\u003eMaybe ExCommand]-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Eval",
          "signature": "[String-\u003eMaybe ExCommand]-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Eval.html#v:exEvalY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "Types",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "Types",
          "package": "yi",
          "partial": "Types",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "ExCommand",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "ExCommand",
          "package": "yi",
          "partial": "Ex Command",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#t:ExCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "LineRange",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#LineRange",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "LineRange",
          "package": "yi",
          "partial": "Line Range",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#t:LineRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "CurrentLineRange",
          "package": "yi",
          "signature": "CurrentLineRange",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#LineRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "CurrentLineRange",
          "package": "yi",
          "partial": "Current Line Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:CurrentLineRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "ExCommand",
          "package": "yi",
          "signature": "ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:ExCommand\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:ExCommand\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "ExCommand",
          "package": "yi",
          "partial": "Ex Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:ExCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e%\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "FullRange",
          "package": "yi",
          "signature": "FullRange",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#LineRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "FullRange",
          "package": "yi",
          "partial": "Full Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:FullRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e'a,'b\n\u003c/p\u003e",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "MarkRange",
          "package": "yi",
          "signature": "MarkRange String String",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#LineRange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "MarkRange",
          "package": "yi",
          "partial": "Mark Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:MarkRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "cmdAcceptsRange",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdAcceptsRange\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:cmdAcceptsRange\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "cmdAcceptsRange",
          "package": "yi",
          "partial": "Accepts Range",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdAcceptsRange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "cmdAction",
          "package": "yi",
          "signature": "Action",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdAction\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:cmdAction\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "cmdAction",
          "package": "yi",
          "partial": "Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "cmdComplete",
          "package": "yi",
          "signature": "YiM [String]",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdComplete\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:cmdComplete\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "cmdComplete",
          "normalized": "YiM[String]",
          "package": "yi",
          "partial": "Complete",
          "signature": "YiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "cmdIsPure",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdIsPure\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:cmdIsPure\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "cmdIsPure",
          "package": "yi",
          "partial": "Is Pure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdIsPure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "cmdShow",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdShow\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:cmdShow\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "cmdShow",
          "package": "yi",
          "partial": "Show",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:cmdShow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Ex.Types\",\"Yi.Keymap.Vim2.Ex\"]",
          "name": "stringToExCommand",
          "package": "yi",
          "signature": "[String -\u003e Maybe ExCommand] -\u003e String -\u003e Maybe ExCommand",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#stringToExCommand",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:stringToExCommand\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:stringToExCommand\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex Types",
          "module": "Yi.Keymap.Vim2.Ex.Types",
          "name": "stringToExCommand",
          "normalized": "[String-\u003eMaybe ExCommand]-\u003eString-\u003eMaybe ExCommand",
          "package": "yi",
          "partial": "To Ex Command",
          "signature": "[String-\u003eMaybe ExCommand]-\u003eString-\u003eMaybe ExCommand",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex-Types.html#v:stringToExCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex",
          "name": "Ex",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex",
          "module": "Yi.Keymap.Vim2.Ex",
          "name": "Ex",
          "package": "yi",
          "partial": "Ex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex",
          "name": "ExCommand",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Ex-Types.html#ExCommand",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex",
          "module": "Yi.Keymap.Vim2.Ex",
          "name": "ExCommand",
          "package": "yi",
          "partial": "Ex Command",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#t:ExCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Ex",
          "name": "defExCommandParsers",
          "package": "yi",
          "signature": "[String -\u003e Maybe ExCommand]",
          "source": "src/Yi-Keymap-Vim2-Ex.html#defExCommandParsers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Ex",
          "module": "Yi.Keymap.Vim2.Ex",
          "name": "defExCommandParsers",
          "normalized": "[String-\u003eMaybe ExCommand]",
          "package": "yi",
          "partial": "Ex Command Parsers",
          "signature": "[String-\u003eMaybe ExCommand]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Ex.html#v:defExCommandParsers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.ExMap",
          "name": "ExMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-ExMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 ExMap",
          "module": "Yi.Keymap.Vim2.ExMap",
          "name": "ExMap",
          "package": "yi",
          "partial": "Ex Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-ExMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.ExMap",
          "name": "defExMap",
          "package": "yi",
          "signature": "[String -\u003e Maybe ExCommand] -\u003e [VimBinding]",
          "source": "src/Yi-Keymap-Vim2-ExMap.html#defExMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 ExMap",
          "module": "Yi.Keymap.Vim2.ExMap",
          "name": "defExMap",
          "normalized": "[String-\u003eMaybe ExCommand]-\u003e[VimBinding]",
          "package": "yi",
          "partial": "Ex Map",
          "signature": "[String-\u003eMaybe ExCommand]-\u003e[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-ExMap.html#v:defExMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.InsertMap",
          "name": "InsertMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-InsertMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 InsertMap",
          "module": "Yi.Keymap.Vim2.InsertMap",
          "name": "InsertMap",
          "package": "yi",
          "partial": "Insert Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-InsertMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.InsertMap",
          "name": "defInsertMap",
          "package": "yi",
          "signature": "[(String, Char)] -\u003e [VimBinding]",
          "source": "src/Yi-Keymap-Vim2-InsertMap.html#defInsertMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 InsertMap",
          "module": "Yi.Keymap.Vim2.InsertMap",
          "name": "defInsertMap",
          "normalized": "[(String,Char)]-\u003e[VimBinding]",
          "package": "yi",
          "partial": "Insert Map",
          "signature": "[(String,Char)]-\u003e[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-InsertMap.html#v:defInsertMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "MatchResult",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 MatchResult",
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "MatchResult",
          "package": "yi",
          "partial": "Match Result",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "MatchResult",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#MatchResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 MatchResult",
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "MatchResult",
          "package": "yi",
          "partial": "Match Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#t:MatchResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "lookupBestMatch",
          "package": "yi",
          "signature": "String -\u003e [(String, a)] -\u003e MatchResult a",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#lookupBestMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 MatchResult",
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "lookupBestMatch",
          "normalized": "String-\u003e[(String,a)]-\u003eMatchResult a",
          "package": "yi",
          "partial": "Best Match",
          "signature": "String-\u003e[(String,a)]-\u003eMatchResult a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#v:lookupBestMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "matchesString",
          "package": "yi",
          "signature": "String -\u003e String -\u003e MatchResult ()",
          "source": "src/Yi-Keymap-Vim2-MatchResult.html#matchesString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 MatchResult",
          "module": "Yi.Keymap.Vim2.MatchResult",
          "name": "matchesString",
          "normalized": "String-\u003eString-\u003eMatchResult()",
          "package": "yi",
          "partial": "String",
          "signature": "String-\u003eString-\u003eMatchResult()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-MatchResult.html#v:matchesString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "Motion",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Motion.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "Motion",
          "package": "yi",
          "partial": "Motion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "CountedMove",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Motion.html#CountedMove",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "CountedMove",
          "package": "yi",
          "partial": "Counted Move",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#t:CountedMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "Move",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Motion.html#Move",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "Move",
          "package": "yi",
          "partial": "Move",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#t:Move"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "CountedMove",
          "package": "yi",
          "signature": "CountedMove !(Maybe Int) !Move",
          "source": "src/Yi-Keymap-Vim2-Motion.html#CountedMove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "CountedMove",
          "package": "yi",
          "partial": "Counted Move",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:CountedMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "Move",
          "package": "yi",
          "signature": "Move",
          "source": "src/Yi-Keymap-Vim2-Motion.html#Move",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "Move",
          "package": "yi",
          "partial": "Move",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:Move"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "changeMoveStyle",
          "package": "yi",
          "signature": "(RegionStyle -\u003e RegionStyle) -\u003e Move -\u003e Move",
          "source": "src/Yi-Keymap-Vim2-Motion.html#changeMoveStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "changeMoveStyle",
          "normalized": "(RegionStyle-\u003eRegionStyle)-\u003eMove-\u003eMove",
          "package": "yi",
          "partial": "Move Style",
          "signature": "(RegionStyle-\u003eRegionStyle)-\u003eMove-\u003eMove",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:changeMoveStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "moveAction",
          "package": "yi",
          "signature": "Maybe Int -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim2-Motion.html#Move",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "moveAction",
          "normalized": "Maybe Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Action",
          "signature": "Maybe Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:moveAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "moveIsJump",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Keymap-Vim2-Motion.html#Move",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "moveIsJump",
          "package": "yi",
          "partial": "Is Jump",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:moveIsJump"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "moveStyle",
          "package": "yi",
          "signature": "RegionStyle",
          "source": "src/Yi-Keymap-Vim2-Motion.html#Move",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "moveStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:moveStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "regionOfMoveB",
          "package": "yi",
          "signature": "CountedMove -\u003e BufferM StyledRegion",
          "source": "src/Yi-Keymap-Vim2-Motion.html#regionOfMoveB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "regionOfMoveB",
          "normalized": "CountedMove-\u003eBufferM StyledRegion",
          "package": "yi",
          "partial": "Of Move",
          "signature": "CountedMove-\u003eBufferM StyledRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:regionOfMoveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "stringToMove",
          "package": "yi",
          "signature": "String -\u003e MatchResult Move",
          "source": "src/Yi-Keymap-Vim2-Motion.html#stringToMove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Motion",
          "module": "Yi.Keymap.Vim2.Motion",
          "name": "stringToMove",
          "normalized": "String-\u003eMatchResult Move",
          "package": "yi",
          "partial": "To Move",
          "signature": "String-\u003eMatchResult Move",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Motion.html#v:stringToMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.NormalMap",
          "name": "NormalMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-NormalMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 NormalMap",
          "module": "Yi.Keymap.Vim2.NormalMap",
          "name": "NormalMap",
          "package": "yi",
          "partial": "Normal Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-NormalMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.NormalMap",
          "name": "defNormalMap",
          "package": "yi",
          "signature": "[VimOperator] -\u003e [VimBinding]",
          "source": "src/Yi-Keymap-Vim2-NormalMap.html#defNormalMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 NormalMap",
          "module": "Yi.Keymap.Vim2.NormalMap",
          "name": "defNormalMap",
          "normalized": "[VimOperator]-\u003e[VimBinding]",
          "package": "yi",
          "partial": "Normal Map",
          "signature": "[VimOperator]-\u003e[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-NormalMap.html#v:defNormalMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.NormalOperatorPendingMap",
          "name": "NormalOperatorPendingMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-NormalOperatorPendingMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 NormalOperatorPendingMap",
          "module": "Yi.Keymap.Vim2.NormalOperatorPendingMap",
          "name": "NormalOperatorPendingMap",
          "package": "yi",
          "partial": "Normal Operator Pending Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-NormalOperatorPendingMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.NormalOperatorPendingMap",
          "name": "defNormalOperatorPendingMap",
          "package": "yi",
          "signature": "[VimOperator] -\u003e [VimBinding]",
          "source": "src/Yi-Keymap-Vim2-NormalOperatorPendingMap.html#defNormalOperatorPendingMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 NormalOperatorPendingMap",
          "module": "Yi.Keymap.Vim2.NormalOperatorPendingMap",
          "name": "defNormalOperatorPendingMap",
          "normalized": "[VimOperator]-\u003e[VimBinding]",
          "package": "yi",
          "partial": "Normal Operator Pending Map",
          "signature": "[VimOperator]-\u003e[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-NormalOperatorPendingMap.html#v:defNormalOperatorPendingMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "Operator",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Operator.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "Operator",
          "package": "yi",
          "partial": "Operator",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "VimOperator",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Operator.html#VimOperator",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "VimOperator",
          "package": "yi",
          "partial": "Vim Operator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#t:VimOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Operator\",\"Yi.Keymap.Vim2\"]",
          "name": "VimOperator",
          "package": "yi",
          "signature": "VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#VimOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:VimOperator\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:VimOperator\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "VimOperator",
          "package": "yi",
          "partial": "Vim Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:VimOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "defOperators",
          "package": "yi",
          "signature": "[VimOperator]",
          "source": "src/Yi-Keymap-Vim2-Operator.html#defOperators",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "defOperators",
          "normalized": "[VimOperator]",
          "package": "yi",
          "partial": "Operators",
          "signature": "[VimOperator]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:defOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "lastCharForOperator",
          "package": "yi",
          "signature": "VimOperator -\u003e String",
          "source": "src/Yi-Keymap-Vim2-Operator.html#lastCharForOperator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "lastCharForOperator",
          "normalized": "VimOperator-\u003eString",
          "package": "yi",
          "partial": "Char For Operator",
          "signature": "VimOperator-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:lastCharForOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "mkCharTransformOperator",
          "package": "yi",
          "signature": "OperatorName -\u003e (Char -\u003e Char) -\u003e VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#mkCharTransformOperator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "mkCharTransformOperator",
          "normalized": "OperatorName-\u003e(Char-\u003eChar)-\u003eVimOperator",
          "package": "yi",
          "partial": "Char Transform Operator",
          "signature": "OperatorName-\u003e(Char-\u003eChar)-\u003eVimOperator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:mkCharTransformOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opChange",
          "package": "yi",
          "signature": "VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#opChange",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opChange",
          "package": "yi",
          "partial": "Change",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:opChange"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opDelete",
          "package": "yi",
          "signature": "VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#opDelete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opDelete",
          "package": "yi",
          "partial": "Delete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:opDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opFormat",
          "package": "yi",
          "signature": "VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#opFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opFormat",
          "package": "yi",
          "partial": "Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:opFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opYank",
          "package": "yi",
          "signature": "VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#opYank",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "opYank",
          "package": "yi",
          "partial": "Yank",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:opYank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Operator\",\"Yi.Keymap.Vim2\"]",
          "name": "operatorApplyToRegionE",
          "package": "yi",
          "signature": "Int -\u003e StyledRegion -\u003e EditorM RepeatToken",
          "source": "src/Yi-Keymap-Vim2-Operator.html#VimOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:operatorApplyToRegionE\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:operatorApplyToRegionE\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "operatorApplyToRegionE",
          "normalized": "Int-\u003eStyledRegion-\u003eEditorM RepeatToken",
          "package": "yi",
          "partial": "Apply To Region",
          "signature": "Int-\u003eStyledRegion-\u003eEditorM RepeatToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:operatorApplyToRegionE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "operatorApplyToTextObjectE",
          "package": "yi",
          "signature": "VimOperator -\u003e Int -\u003e CountedTextObject -\u003e EditorM RepeatToken",
          "source": "src/Yi-Keymap-Vim2-Operator.html#operatorApplyToTextObjectE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "operatorApplyToTextObjectE",
          "normalized": "VimOperator-\u003eInt-\u003eCountedTextObject-\u003eEditorM RepeatToken",
          "package": "yi",
          "partial": "Apply To Text Object",
          "signature": "VimOperator-\u003eInt-\u003eCountedTextObject-\u003eEditorM RepeatToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:operatorApplyToTextObjectE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Keymap.Vim2.Operator\",\"Yi.Keymap.Vim2\"]",
          "name": "operatorName",
          "package": "yi",
          "signature": "OperatorName",
          "source": "src/Yi-Keymap-Vim2-Operator.html#VimOperator",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:operatorName\",\"http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:operatorName\"]"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "operatorName",
          "package": "yi",
          "partial": "Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:operatorName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "stringToOperator",
          "package": "yi",
          "signature": "[VimOperator] -\u003e OperatorName -\u003e Maybe VimOperator",
          "source": "src/Yi-Keymap-Vim2-Operator.html#stringToOperator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Operator",
          "module": "Yi.Keymap.Vim2.Operator",
          "name": "stringToOperator",
          "normalized": "[VimOperator]-\u003eOperatorName-\u003eMaybe VimOperator",
          "package": "yi",
          "partial": "To Operator",
          "signature": "[VimOperator]-\u003eOperatorName-\u003eMaybe VimOperator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Operator.html#v:stringToOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.ReplaceMap",
          "name": "ReplaceMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-ReplaceMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 ReplaceMap",
          "module": "Yi.Keymap.Vim2.ReplaceMap",
          "name": "ReplaceMap",
          "package": "yi",
          "partial": "Replace Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-ReplaceMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.ReplaceMap",
          "name": "defReplaceMap",
          "package": "yi",
          "signature": "[VimBinding]",
          "source": "src/Yi-Keymap-Vim2-ReplaceMap.html#defReplaceMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 ReplaceMap",
          "module": "Yi.Keymap.Vim2.ReplaceMap",
          "name": "defReplaceMap",
          "normalized": "[VimBinding]",
          "package": "yi",
          "partial": "Replace Map",
          "signature": "[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-ReplaceMap.html#v:defReplaceMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.ReplaceSingleCharMap",
          "name": "ReplaceSingleCharMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-ReplaceSingleCharMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 ReplaceSingleCharMap",
          "module": "Yi.Keymap.Vim2.ReplaceSingleCharMap",
          "name": "ReplaceSingleCharMap",
          "package": "yi",
          "partial": "Replace Single Char Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-ReplaceSingleCharMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.ReplaceSingleCharMap",
          "name": "defReplaceSingleMap",
          "package": "yi",
          "signature": "[VimBinding]",
          "source": "src/Yi-Keymap-Vim2-ReplaceSingleCharMap.html#defReplaceSingleMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 ReplaceSingleCharMap",
          "module": "Yi.Keymap.Vim2.ReplaceSingleCharMap",
          "name": "defReplaceSingleMap",
          "normalized": "[VimBinding]",
          "package": "yi",
          "partial": "Replace Single Map",
          "signature": "[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-ReplaceSingleCharMap.html#v:defReplaceSingleMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Search",
          "name": "Search",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Search.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Search",
          "module": "Yi.Keymap.Vim2.Search",
          "name": "Search",
          "package": "yi",
          "partial": "Search",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Search.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Search",
          "name": "continueVimSearch",
          "package": "yi",
          "signature": "(SearchExp, Direction) -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim2-Search.html#continueVimSearch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Search",
          "module": "Yi.Keymap.Vim2.Search",
          "name": "continueVimSearch",
          "normalized": "(SearchExp,Direction)-\u003eBufferM()",
          "package": "yi",
          "partial": "Vim Search",
          "signature": "(SearchExp,Direction)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Search.html#v:continueVimSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Search",
          "name": "doVimSearch",
          "package": "yi",
          "signature": "Maybe String -\u003e [SearchOption] -\u003e Direction -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-Search.html#doVimSearch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Search",
          "module": "Yi.Keymap.Vim2.Search",
          "name": "doVimSearch",
          "normalized": "Maybe String-\u003e[SearchOption]-\u003eDirection-\u003eEditorM()",
          "package": "yi",
          "partial": "Vim Search",
          "signature": "Maybe String-\u003e[SearchOption]-\u003eDirection-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Search.html#v:doVimSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.SearchMotionMap",
          "name": "SearchMotionMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-SearchMotionMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 SearchMotionMap",
          "module": "Yi.Keymap.Vim2.SearchMotionMap",
          "name": "SearchMotionMap",
          "package": "yi",
          "partial": "Search Motion Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-SearchMotionMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.SearchMotionMap",
          "name": "defSearchMotionMap",
          "package": "yi",
          "signature": "[VimBinding]",
          "source": "src/Yi-Keymap-Vim2-SearchMotionMap.html#defSearchMotionMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 SearchMotionMap",
          "module": "Yi.Keymap.Vim2.SearchMotionMap",
          "name": "defSearchMotionMap",
          "normalized": "[VimBinding]",
          "package": "yi",
          "partial": "Search Motion Map",
          "signature": "[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-SearchMotionMap.html#v:defSearchMotionMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "StateUtils",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "StateUtils",
          "package": "yi",
          "partial": "State Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "accumulateBindingEventE",
          "package": "yi",
          "signature": "Event -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#accumulateBindingEventE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "accumulateBindingEventE",
          "normalized": "Event-\u003eEditorM()",
          "package": "yi",
          "partial": "Binding Event",
          "signature": "Event-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:accumulateBindingEventE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "accumulateEventE",
          "package": "yi",
          "signature": "Event -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#accumulateEventE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "accumulateEventE",
          "normalized": "Event-\u003eEditorM()",
          "package": "yi",
          "partial": "Event",
          "signature": "Event-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:accumulateEventE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "accumulateTextObjectEventE",
          "package": "yi",
          "signature": "EventString -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#accumulateTextObjectEventE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "accumulateTextObjectEventE",
          "normalized": "EventString-\u003eEditorM()",
          "package": "yi",
          "partial": "Text Object Event",
          "signature": "EventString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:accumulateTextObjectEventE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "dropAccumulatorE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#dropAccumulatorE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "dropAccumulatorE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Accumulator",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:dropAccumulatorE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "dropBindingAccumulatorE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#dropBindingAccumulatorE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "dropBindingAccumulatorE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Binding Accumulator",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:dropBindingAccumulatorE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "dropTextObjectAccumulatorE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#dropTextObjectAccumulatorE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "dropTextObjectAccumulatorE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Text Object Accumulator",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:dropTextObjectAccumulatorE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "flushAccumulatorIntoRepeatableActionE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#flushAccumulatorIntoRepeatableActionE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "flushAccumulatorIntoRepeatableActionE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Accumulator Into Repeatable Action",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:flushAccumulatorIntoRepeatableActionE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "getCountE",
          "package": "yi",
          "signature": "EditorM Int",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#getCountE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "getCountE",
          "package": "yi",
          "partial": "Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:getCountE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "getMaybeCountE",
          "package": "yi",
          "signature": "EditorM (Maybe Int)",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#getMaybeCountE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "getMaybeCountE",
          "package": "yi",
          "partial": "Maybe Count",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:getMaybeCountE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "getRegisterE",
          "package": "yi",
          "signature": "RegisterName -\u003e EditorM (Maybe Register)",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#getRegisterE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "getRegisterE",
          "normalized": "RegisterName-\u003eEditorM(Maybe Register)",
          "package": "yi",
          "partial": "Register",
          "signature": "RegisterName-\u003eEditorM(Maybe Register)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:getRegisterE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "maybeMult",
          "package": "yi",
          "signature": "Maybe a -\u003e Maybe a -\u003e Maybe a",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#maybeMult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "maybeMult",
          "normalized": "Maybe a-\u003eMaybe a-\u003eMaybe a",
          "package": "yi",
          "partial": "Mult",
          "signature": "Maybe a-\u003eMaybe a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:maybeMult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "modifyStateE",
          "package": "yi",
          "signature": "(VimState -\u003e VimState) -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#modifyStateE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "modifyStateE",
          "normalized": "(VimState-\u003eVimState)-\u003eEditorM()",
          "package": "yi",
          "partial": "State",
          "signature": "(VimState-\u003eVimState)-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:modifyStateE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "normalizeCountE",
          "package": "yi",
          "signature": "Maybe Int -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#normalizeCountE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "normalizeCountE",
          "normalized": "Maybe Int-\u003eEditorM()",
          "package": "yi",
          "partial": "Count",
          "signature": "Maybe Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:normalizeCountE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "resetCount",
          "package": "yi",
          "signature": "VimState -\u003e VimState",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#resetCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "resetCount",
          "normalized": "VimState-\u003eVimState",
          "package": "yi",
          "partial": "Count",
          "signature": "VimState-\u003eVimState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:resetCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "resetCountE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#resetCountE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "resetCountE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Count",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:resetCountE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "saveInsertEventStringE",
          "package": "yi",
          "signature": "EventString -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#saveInsertEventStringE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "saveInsertEventStringE",
          "normalized": "EventString-\u003eEditorM()",
          "package": "yi",
          "partial": "Insert Event String",
          "signature": "EventString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:saveInsertEventStringE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "setCountE",
          "package": "yi",
          "signature": "Int -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#setCountE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "setCountE",
          "normalized": "Int-\u003eEditorM()",
          "package": "yi",
          "partial": "Count",
          "signature": "Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:setCountE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "setRegisterE",
          "package": "yi",
          "signature": "RegisterName -\u003e RegionStyle -\u003e Rope -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#setRegisterE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "setRegisterE",
          "normalized": "RegisterName-\u003eRegionStyle-\u003eRope-\u003eEditorM()",
          "package": "yi",
          "partial": "Register",
          "signature": "RegisterName-\u003eRegionStyle-\u003eRope-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:setRegisterE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "setStickyEolE",
          "package": "yi",
          "signature": "Bool -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#setStickyEolE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "setStickyEolE",
          "normalized": "Bool-\u003eEditorM()",
          "package": "yi",
          "partial": "Sticky Eol",
          "signature": "Bool-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:setStickyEolE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "switchMode",
          "package": "yi",
          "signature": "VimMode -\u003e VimState -\u003e VimState",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#switchMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "switchMode",
          "normalized": "VimMode-\u003eVimState-\u003eVimState",
          "package": "yi",
          "partial": "Mode",
          "signature": "VimMode-\u003eVimState-\u003eVimState",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:switchMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "switchModeE",
          "package": "yi",
          "signature": "VimMode -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#switchModeE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "switchModeE",
          "normalized": "VimMode-\u003eEditorM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "VimMode-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:switchModeE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "updateModeIndicatorE",
          "package": "yi",
          "signature": "VimMode -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2-StateUtils.html#updateModeIndicatorE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StateUtils",
          "module": "Yi.Keymap.Vim2.StateUtils",
          "name": "updateModeIndicatorE",
          "normalized": "VimMode-\u003eEditorM()",
          "package": "yi",
          "partial": "Mode Indicator",
          "signature": "VimMode-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StateUtils.html#v:updateModeIndicatorE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "StyledRegion",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-StyledRegion.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StyledRegion",
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "StyledRegion",
          "package": "yi",
          "partial": "Styled Region",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StyledRegion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "StyledRegion",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-StyledRegion.html#StyledRegion",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StyledRegion",
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "StyledRegion",
          "package": "yi",
          "partial": "Styled Region",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StyledRegion.html#t:StyledRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "StyledRegion",
          "package": "yi",
          "signature": "StyledRegion !RegionStyle !Region",
          "source": "src/Yi-Keymap-Vim2-StyledRegion.html#StyledRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StyledRegion",
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "StyledRegion",
          "package": "yi",
          "partial": "Styled Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StyledRegion.html#v:StyledRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "normalizeRegion",
          "package": "yi",
          "signature": "StyledRegion -\u003e BufferM StyledRegion",
          "source": "src/Yi-Keymap-Vim2-StyledRegion.html#normalizeRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StyledRegion",
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "normalizeRegion",
          "normalized": "StyledRegion-\u003eBufferM StyledRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "StyledRegion-\u003eBufferM StyledRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StyledRegion.html#v:normalizeRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "transformCharactersInLineN",
          "package": "yi",
          "signature": "Int -\u003e (Char -\u003e Char) -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim2-StyledRegion.html#transformCharactersInLineN",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StyledRegion",
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "transformCharactersInLineN",
          "normalized": "Int-\u003e(Char-\u003eChar)-\u003eBufferM()",
          "package": "yi",
          "partial": "Characters In Line",
          "signature": "Int-\u003e(Char-\u003eChar)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StyledRegion.html#v:transformCharactersInLineN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "transformCharactersInRegionB",
          "package": "yi",
          "signature": "StyledRegion -\u003e (Char -\u003e Char) -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim2-StyledRegion.html#transformCharactersInRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 StyledRegion",
          "module": "Yi.Keymap.Vim2.StyledRegion",
          "name": "transformCharactersInRegionB",
          "normalized": "StyledRegion-\u003e(Char-\u003eChar)-\u003eBufferM()",
          "package": "yi",
          "partial": "Characters In Region",
          "signature": "StyledRegion-\u003e(Char-\u003eChar)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-StyledRegion.html#v:transformCharactersInRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "TextObject",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-TextObject.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "TextObject",
          "package": "yi",
          "partial": "Text Object",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "CountedTextObject",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#CountedTextObject",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "CountedTextObject",
          "package": "yi",
          "partial": "Counted Text Object",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#t:CountedTextObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "TextObject",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#TextObject",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "TextObject",
          "package": "yi",
          "partial": "Text Object",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#t:TextObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "CountedTextObject",
          "package": "yi",
          "signature": "CountedTextObject !Int !TextObject",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#CountedTextObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "CountedTextObject",
          "package": "yi",
          "partial": "Counted Text Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#v:CountedTextObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "TextObject",
          "package": "yi",
          "signature": "TextObject !RegionStyle !TextUnit",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#TextObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "TextObject",
          "package": "yi",
          "partial": "Text Object",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#v:TextObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "changeTextObjectCount",
          "package": "yi",
          "signature": "Int -\u003e CountedTextObject -\u003e CountedTextObject",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#changeTextObjectCount",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "changeTextObjectCount",
          "normalized": "Int-\u003eCountedTextObject-\u003eCountedTextObject",
          "package": "yi",
          "partial": "Text Object Count",
          "signature": "Int-\u003eCountedTextObject-\u003eCountedTextObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#v:changeTextObjectCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "changeTextObjectStyle",
          "package": "yi",
          "signature": "(RegionStyle -\u003e RegionStyle) -\u003e TextObject -\u003e TextObject",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#changeTextObjectStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "changeTextObjectStyle",
          "normalized": "(RegionStyle-\u003eRegionStyle)-\u003eTextObject-\u003eTextObject",
          "package": "yi",
          "partial": "Text Object Style",
          "signature": "(RegionStyle-\u003eRegionStyle)-\u003eTextObject-\u003eTextObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#v:changeTextObjectStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "regionOfTextObjectB",
          "package": "yi",
          "signature": "CountedTextObject -\u003e BufferM StyledRegion",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#regionOfTextObjectB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "regionOfTextObjectB",
          "normalized": "CountedTextObject-\u003eBufferM StyledRegion",
          "package": "yi",
          "partial": "Of Text Object",
          "signature": "CountedTextObject-\u003eBufferM StyledRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#v:regionOfTextObjectB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "stringToTextObject",
          "package": "yi",
          "signature": "String -\u003e Maybe TextObject",
          "source": "src/Yi-Keymap-Vim2-TextObject.html#stringToTextObject",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 TextObject",
          "module": "Yi.Keymap.Vim2.TextObject",
          "name": "stringToTextObject",
          "normalized": "String-\u003eMaybe TextObject",
          "package": "yi",
          "partial": "To Text Object",
          "signature": "String-\u003eMaybe TextObject",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-TextObject.html#v:stringToTextObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "Utils",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Utils.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "Utils",
          "package": "yi",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "addNewLineIfNecessary",
          "package": "yi",
          "signature": "Rope -\u003e Rope",
          "source": "src/Yi-Keymap-Vim2-Utils.html#addNewLineIfNecessary",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "addNewLineIfNecessary",
          "normalized": "Rope-\u003eRope",
          "package": "yi",
          "partial": "New Line If Necessary",
          "signature": "Rope-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:addNewLineIfNecessary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "indentBlockRegionB",
          "package": "yi",
          "signature": "Int -\u003e Region -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim2-Utils.html#indentBlockRegionB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "indentBlockRegionB",
          "normalized": "Int-\u003eRegion-\u003eBufferM()",
          "package": "yi",
          "partial": "Block Region",
          "signature": "Int-\u003eRegion-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:indentBlockRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "matchFromBool",
          "package": "yi",
          "signature": "Bool -\u003e MatchResult ()",
          "source": "src/Yi-Keymap-Vim2-Utils.html#matchFromBool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "matchFromBool",
          "normalized": "Bool-\u003eMatchResult()",
          "package": "yi",
          "partial": "From Bool",
          "signature": "Bool-\u003eMatchResult()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:matchFromBool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkBindingE",
          "package": "yi",
          "signature": "VimMode -\u003e RepeatToken -\u003e (Event, EditorM (), VimState -\u003e VimState) -\u003e VimBinding",
          "source": "src/Yi-Keymap-Vim2-Utils.html#mkBindingE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkBindingE",
          "normalized": "VimMode-\u003eRepeatToken-\u003e(Event,EditorM(),VimState-\u003eVimState)-\u003eVimBinding",
          "package": "yi",
          "partial": "Binding",
          "signature": "VimMode-\u003eRepeatToken-\u003e(Event,EditorM(),VimState-\u003eVimState)-\u003eVimBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:mkBindingE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkBindingY",
          "package": "yi",
          "signature": "VimMode -\u003e (Event, YiM (), VimState -\u003e VimState) -\u003e VimBinding",
          "source": "src/Yi-Keymap-Vim2-Utils.html#mkBindingY",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkBindingY",
          "normalized": "VimMode-\u003e(Event,YiM(),VimState-\u003eVimState)-\u003eVimBinding",
          "package": "yi",
          "partial": "Binding",
          "signature": "VimMode-\u003e(Event,YiM(),VimState-\u003eVimState)-\u003eVimBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:mkBindingY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkChooseRegisterBinding",
          "package": "yi",
          "signature": "(VimState -\u003e Bool) -\u003e VimBinding",
          "source": "src/Yi-Keymap-Vim2-Utils.html#mkChooseRegisterBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkChooseRegisterBinding",
          "normalized": "(VimState-\u003eBool)-\u003eVimBinding",
          "package": "yi",
          "partial": "Choose Register Binding",
          "signature": "(VimState-\u003eBool)-\u003eVimBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:mkChooseRegisterBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkMotionBinding",
          "package": "yi",
          "signature": "RepeatToken -\u003e (VimMode -\u003e Bool) -\u003e VimBinding",
          "source": "src/Yi-Keymap-Vim2-Utils.html#mkMotionBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkMotionBinding",
          "normalized": "RepeatToken-\u003e(VimMode-\u003eBool)-\u003eVimBinding",
          "package": "yi",
          "partial": "Motion Binding",
          "signature": "RepeatToken-\u003e(VimMode-\u003eBool)-\u003eVimBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:mkMotionBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkStringBindingE",
          "package": "yi",
          "signature": "VimMode -\u003e RepeatToken -\u003e (String, EditorM (), VimState -\u003e VimState) -\u003e VimBinding",
          "source": "src/Yi-Keymap-Vim2-Utils.html#mkStringBindingE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "mkStringBindingE",
          "normalized": "VimMode-\u003eRepeatToken-\u003e(String,EditorM(),VimState-\u003eVimState)-\u003eVimBinding",
          "package": "yi",
          "partial": "String Binding",
          "signature": "VimMode-\u003eRepeatToken-\u003e(String,EditorM(),VimState-\u003eVimState)-\u003eVimBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:mkStringBindingE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "pasteInclusiveB",
          "package": "yi",
          "signature": "Rope -\u003e RegionStyle -\u003e BufferM ()",
          "source": "src/Yi-Keymap-Vim2-Utils.html#pasteInclusiveB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "pasteInclusiveB",
          "normalized": "Rope-\u003eRegionStyle-\u003eBufferM()",
          "package": "yi",
          "partial": "Inclusive",
          "signature": "Rope-\u003eRegionStyle-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:pasteInclusiveB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "selectBinding",
          "package": "yi",
          "signature": "String -\u003e VimState -\u003e [VimBinding] -\u003e MatchResult VimBinding",
          "source": "src/Yi-Keymap-Vim2-Utils.html#selectBinding",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 Utils",
          "module": "Yi.Keymap.Vim2.Utils",
          "name": "selectBinding",
          "normalized": "String-\u003eVimState-\u003e[VimBinding]-\u003eMatchResult VimBinding",
          "package": "yi",
          "partial": "Binding",
          "signature": "String-\u003eVimState-\u003e[VimBinding]-\u003eMatchResult VimBinding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-Utils.html#v:selectBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.VisualMap",
          "name": "VisualMap",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-VisualMap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 VisualMap",
          "module": "Yi.Keymap.Vim2.VisualMap",
          "name": "VisualMap",
          "package": "yi",
          "partial": "Visual Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-VisualMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2.VisualMap",
          "name": "defVisualMap",
          "package": "yi",
          "signature": "[VimOperator] -\u003e [VimBinding]",
          "source": "src/Yi-Keymap-Vim2-VisualMap.html#defVisualMap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2 VisualMap",
          "module": "Yi.Keymap.Vim2.VisualMap",
          "name": "defVisualMap",
          "normalized": "[VimOperator]-\u003e[VimBinding]",
          "package": "yi",
          "partial": "Visual Map",
          "signature": "[VimOperator]-\u003e[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2-VisualMap.html#v:defVisualMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "Vim2",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "Vim2",
          "package": "yi",
          "partial": "Vim",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "VimBinding",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Common.html#VimBinding",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "VimBinding",
          "package": "yi",
          "partial": "Vim Binding",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#t:VimBinding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "VimConfig",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "VimConfig",
          "package": "yi",
          "partial": "Vim Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#t:VimConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "VimOperator",
          "package": "yi",
          "source": "src/Yi-Keymap-Vim2-Operator.html#VimOperator",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "VimOperator",
          "package": "yi",
          "partial": "Vim Operator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#t:VimOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "VimConfig",
          "package": "yi",
          "signature": "VimConfig",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "VimConfig",
          "package": "yi",
          "partial": "Vim Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:VimConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "defVimConfig",
          "package": "yi",
          "signature": "Proto VimConfig",
          "source": "src/Yi-Keymap-Vim2.html#defVimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "defVimConfig",
          "package": "yi",
          "partial": "Vim Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:defVimConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "impureEval",
          "package": "yi",
          "signature": "VimConfig -\u003e String -\u003e YiM ()",
          "source": "src/Yi-Keymap-Vim2.html#impureEval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "impureEval",
          "normalized": "VimConfig-\u003eString-\u003eYiM()",
          "package": "yi",
          "partial": "Eval",
          "signature": "VimConfig-\u003eString-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:impureEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "keymapSet",
          "package": "yi",
          "signature": "KeymapSet",
          "source": "src/Yi-Keymap-Vim2.html#keymapSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "keymapSet",
          "package": "yi",
          "partial": "Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:keymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "mkKeymapSet",
          "package": "yi",
          "signature": "Proto VimConfig -\u003e KeymapSet",
          "source": "src/Yi-Keymap-Vim2.html#mkKeymapSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "mkKeymapSet",
          "normalized": "Proto VimConfig-\u003eKeymapSet",
          "package": "yi",
          "partial": "Keymap Set",
          "signature": "Proto VimConfig-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:mkKeymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "pureEval",
          "package": "yi",
          "signature": "VimConfig -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-Keymap-Vim2.html#pureEval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "pureEval",
          "normalized": "VimConfig-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Eval",
          "signature": "VimConfig-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:pureEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "vimBindings",
          "package": "yi",
          "signature": "[VimBinding]",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "vimBindings",
          "normalized": "[VimBinding]",
          "package": "yi",
          "partial": "Bindings",
          "signature": "[VimBinding]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vimBindings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "vimDigraphs",
          "package": "yi",
          "signature": "[(String, Char)]",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "vimDigraphs",
          "normalized": "[(String,Char)]",
          "package": "yi",
          "partial": "Digraphs",
          "signature": "[(String,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vimDigraphs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "vimExCommandParsers",
          "package": "yi",
          "signature": "[String -\u003e Maybe ExCommand]",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "vimExCommandParsers",
          "normalized": "[String-\u003eMaybe ExCommand]",
          "package": "yi",
          "partial": "Ex Command Parsers",
          "signature": "[String-\u003eMaybe ExCommand]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vimExCommandParsers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "vimKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "vimKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vimKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap.Vim2",
          "name": "vimOperators",
          "package": "yi",
          "signature": "[VimOperator]",
          "source": "src/Yi-Keymap-Vim2.html#VimConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap Vim2",
          "module": "Yi.Keymap.Vim2",
          "name": "vimOperators",
          "normalized": "[VimOperator]",
          "package": "yi",
          "partial": "Operators",
          "signature": "[VimOperator]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap-Vim2.html#v:vimOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "Keymap",
          "package": "yi",
          "source": "src/Yi-Keymap.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "Keymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "Action",
          "package": "yi",
          "source": "src/Yi-Keymap.html#Action",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "Action",
          "package": "yi",
          "partial": "Action",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:Action"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "Interact",
          "package": "yi",
          "source": "src/Yi-Keymap.html#Interact",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "Interact",
          "package": "yi",
          "partial": "Interact",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:Interact"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "Keymap",
          "package": "yi",
          "source": "src/Yi-Keymap.html#Keymap",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "Keymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:Keymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "KeymapEndo",
          "package": "yi",
          "source": "src/Yi-Keymap.html#KeymapEndo",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "KeymapEndo",
          "package": "yi",
          "partial": "Keymap Endo",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:KeymapEndo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "KeymapM",
          "package": "yi",
          "source": "src/Yi-Keymap.html#KeymapM",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "KeymapM",
          "package": "yi",
          "partial": "Keymap",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:KeymapM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "KeymapProcess",
          "package": "yi",
          "source": "src/Yi-Keymap.html#KeymapProcess",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "KeymapProcess",
          "package": "yi",
          "partial": "Keymap Process",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:KeymapProcess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "KeymapSet",
          "package": "yi",
          "source": "src/Yi-Keymap.html#KeymapSet",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "KeymapSet",
          "package": "yi",
          "partial": "Keymap Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:KeymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "Yi",
          "package": "yi",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "Yi",
          "package": "yi",
          "partial": "Yi",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:Yi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "YiAction",
          "package": "yi",
          "source": "src/Yi-Keymap.html#YiAction",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "YiAction",
          "package": "yi",
          "partial": "Yi Action",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:YiAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of user-bindable functions\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "YiM",
          "package": "yi",
          "source": "src/Yi-Keymap.html#YiM",
          "type": "newtype"
        },
        "index": {
          "description": "The type of user-bindable functions",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "YiM",
          "package": "yi",
          "partial": "Yi",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:YiM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "YiVar",
          "package": "yi",
          "source": "src/Yi-Keymap.html#YiVar",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "YiVar",
          "package": "yi",
          "partial": "Yi Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#t:YiVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "BufferA",
          "package": "yi",
          "signature": "BufferA (BufferM a)",
          "source": "src/Yi-Keymap.html#Action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "BufferA",
          "package": "yi",
          "partial": "Buffer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:BufferA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "EditorA",
          "package": "yi",
          "signature": "EditorA (EditorM a)",
          "source": "src/Yi-Keymap.html#Action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "EditorA",
          "package": "yi",
          "partial": "Editor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:EditorA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "KeymapSet",
          "package": "yi",
          "signature": "KeymapSet",
          "source": "src/Yi-Keymap.html#KeymapSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "KeymapSet",
          "package": "yi",
          "partial": "Keymap Set",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:KeymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "Yi",
          "package": "yi",
          "signature": "Yi",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "Yi",
          "package": "yi",
          "partial": "Yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:Yi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "YiA",
          "package": "yi",
          "signature": "YiA (YiM a)",
          "source": "src/Yi-Keymap.html#Action",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "YiA",
          "package": "yi",
          "partial": "Yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:YiA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "YiM",
          "package": "yi",
          "signature": "YiM",
          "source": "src/Yi-Keymap.html#YiM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "YiM",
          "package": "yi",
          "partial": "Yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:YiM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "YiVar",
          "package": "yi",
          "signature": "YiVar",
          "source": "src/Yi-Keymap.html#YiVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "YiVar",
          "package": "yi",
          "partial": "Yi Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:YiVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "catchDynE",
          "package": "yi",
          "signature": "YiM a -\u003e (exception -\u003e YiM a) -\u003e YiM a",
          "source": "src/Yi-Keymap.html#catchDynE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "catchDynE",
          "normalized": "YiM a-\u003e(b-\u003eYiM a)-\u003eYiM a",
          "package": "yi",
          "partial": "Dyn",
          "signature": "YiM a-\u003e(exception-\u003eYiM a)-\u003eYiM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:catchDynE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "catchJustE",
          "package": "yi",
          "signature": "(e -\u003e Maybe b)-\u003e YiM a-\u003e (b -\u003e YiM a)-\u003e YiM a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "catchJustE",
          "normalized": "(a-\u003eMaybe b)-\u003eYiM c-\u003e(b-\u003eYiM c)-\u003eYiM c",
          "package": "yi",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003eYiM a-\u003e(b-\u003eYiM a)-\u003eYiM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:catchJustE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "emptyAction",
          "package": "yi",
          "signature": "Action",
          "source": "src/Yi-Keymap.html#emptyAction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "emptyAction",
          "package": "yi",
          "partial": "Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:emptyAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "extractTopKeymap",
          "package": "yi",
          "signature": "KeymapSet -\u003e Keymap",
          "source": "src/Yi-Keymap.html#extractTopKeymap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "extractTopKeymap",
          "normalized": "KeymapSet-\u003eKeymap",
          "package": "yi",
          "partial": "Top Keymap",
          "signature": "KeymapSet-\u003eKeymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:extractTopKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "handleJustE",
          "package": "yi",
          "signature": "(e -\u003e Maybe b) -\u003e (b -\u003e YiM a) -\u003e YiM a -\u003e YiM a",
          "source": "src/Yi-Keymap.html#handleJustE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "handleJustE",
          "normalized": "(a-\u003eMaybe b)-\u003e(b-\u003eYiM c)-\u003eYiM c-\u003eYiM c",
          "package": "yi",
          "partial": "Just",
          "signature": "(e-\u003eMaybe b)-\u003e(b-\u003eYiM a)-\u003eYiM a-\u003eYiM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:handleJustE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einput stream\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "input",
          "package": "yi",
          "signature": "Event -\u003e IO ()",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "function"
        },
        "index": {
          "description": "input stream",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "input",
          "normalized": "Event-\u003eIO()",
          "package": "yi",
          "signature": "Event-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:input"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor insertion-only modes \n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "insertKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap.html#KeymapSet",
          "type": "function"
        },
        "index": {
          "description": "For insertion-only modes",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "insertKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:insertKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "insertKeymapA",
          "package": "yi",
          "signature": "T KeymapSet Keymap",
          "source": "src/Yi-Keymap.html#insertKeymapA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "insertKeymapA",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:insertKeymapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "makeAction",
          "package": "yi",
          "signature": "a -\u003e Action",
          "source": "src/Yi-Keymap.html#makeAction",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "makeAction",
          "normalized": "a-\u003eAction",
          "package": "yi",
          "partial": "Action",
          "signature": "a-\u003eAction",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:makeAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "modelessKeymapSet",
          "package": "yi",
          "signature": "Keymap -\u003e KeymapSet",
          "source": "src/Yi-Keymap.html#modelessKeymapSet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "modelessKeymapSet",
          "normalized": "Keymap-\u003eKeymapSet",
          "package": "yi",
          "partial": "Keymap Set",
          "signature": "Keymap-\u003eKeymapSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:modelessKeymapSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoutput stream\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "output",
          "package": "yi",
          "signature": "[Action] -\u003e IO ()",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "function"
        },
        "index": {
          "description": "output stream",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "output",
          "normalized": "[Action]-\u003eIO()",
          "package": "yi",
          "signature": "[Action]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:output"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "readEditor",
          "package": "yi",
          "signature": "(Editor -\u003e a) -\u003e m a",
          "source": "src/Yi-Keymap.html#readEditor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "readEditor",
          "normalized": "(Editor-\u003ea)-\u003eb a",
          "package": "yi",
          "partial": "Editor",
          "signature": "(Editor-\u003ea)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:readEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "runYiM",
          "package": "yi",
          "signature": "ReaderT Yi IO a",
          "source": "src/Yi-Keymap.html#YiM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "runYiM",
          "package": "yi",
          "partial": "Yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:runYiM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShut down all of our threads. Should free buffers etc.\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "shutdown",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Keymap.html#shutdown",
          "type": "function"
        },
        "index": {
          "description": "Shut down all of our threads Should free buffers etc",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "shutdown",
          "normalized": "YiM()",
          "package": "yi",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:shutdown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStartup when entering insert mode\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "startInsertKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap.html#KeymapSet",
          "type": "function"
        },
        "index": {
          "description": "Startup when entering insert mode",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "startInsertKeymap",
          "package": "yi",
          "partial": "Insert Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:startInsertKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "startInsertKeymapA",
          "package": "yi",
          "signature": "T KeymapSet Keymap",
          "source": "src/Yi-Keymap.html#startInsertKeymapA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "startInsertKeymapA",
          "package": "yi",
          "partial": "Insert Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:startInsertKeymapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStartup bit, to execute only once at the beginning.\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "startTopKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap.html#KeymapSet",
          "type": "function"
        },
        "index": {
          "description": "Startup bit to execute only once at the beginning",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "startTopKeymap",
          "package": "yi",
          "partial": "Top Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:startTopKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "startTopKeymapA",
          "package": "yi",
          "signature": "T KeymapSet Keymap",
          "source": "src/Yi-Keymap.html#startTopKeymapA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "startTopKeymapA",
          "package": "yi",
          "partial": "Top Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:startTopKeymapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall our threads\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "threads",
          "package": "yi",
          "signature": "[ThreadId]",
          "source": "src/Yi-Keymap.html#YiVar",
          "type": "function"
        },
        "index": {
          "description": "all our threads",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "threads",
          "normalized": "[ThreadId]",
          "package": "yi",
          "signature": "[ThreadId]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:threads"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eContent of the top-level loop.\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "topKeymap",
          "package": "yi",
          "signature": "Keymap",
          "source": "src/Yi-Keymap.html#KeymapSet",
          "type": "function"
        },
        "index": {
          "description": "Content of the top-level loop",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "topKeymap",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:topKeymap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "topKeymapA",
          "package": "yi",
          "signature": "T KeymapSet Keymap",
          "source": "src/Yi-Keymap.html#topKeymapA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "topKeymapA",
          "package": "yi",
          "partial": "Keymap",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:topKeymapA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "unsafeWithEditor",
          "package": "yi",
          "signature": "Config -\u003e MVar YiVar -\u003e EditorM a -\u003e IO a",
          "source": "src/Yi-Keymap.html#unsafeWithEditor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "unsafeWithEditor",
          "normalized": "Config-\u003eMVar YiVar-\u003eEditorM a-\u003eIO a",
          "package": "yi",
          "partial": "With Editor",
          "signature": "Config-\u003eMVar YiVar-\u003eEditorM a-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:unsafeWithEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "withBuffer",
          "package": "yi",
          "signature": "BufferM a -\u003e m a",
          "source": "src/Yi-Keymap.html#withBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "withBuffer",
          "normalized": "BufferM a-\u003eb a",
          "package": "yi",
          "partial": "Buffer",
          "signature": "BufferM a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:withBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "withGivenBuffer",
          "package": "yi",
          "signature": "BufferRef -\u003e BufferM a -\u003e m a",
          "source": "src/Yi-Keymap.html#withGivenBuffer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "withGivenBuffer",
          "normalized": "BufferRef-\u003eBufferM a-\u003eb a",
          "package": "yi",
          "partial": "Given Buffer",
          "signature": "BufferRef-\u003eBufferM a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:withGivenBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "withUI",
          "package": "yi",
          "signature": "(UI -\u003e IO a) -\u003e YiM a",
          "source": "src/Yi-Keymap.html#withUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "withUI",
          "normalized": "(UI-\u003eIO a)-\u003eYiM a",
          "package": "yi",
          "partial": "UI",
          "signature": "(UI-\u003eIO a)-\u003eYiM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:withUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewrite a\u003c/code\u003e returns a keymap that just outputs the action \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "write",
          "package": "yi",
          "signature": "a -\u003e m ()",
          "source": "src/Yi-Keymap.html#write",
          "type": "function"
        },
        "index": {
          "description": "write returns keymap that just outputs the action",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "write",
          "normalized": "a-\u003eb()",
          "package": "yi",
          "signature": "a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:write"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "yiConfig",
          "package": "yi",
          "signature": "Config",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "yiConfig",
          "package": "yi",
          "partial": "Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:yiConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "yiEditor",
          "package": "yi",
          "signature": "Editor",
          "source": "src/Yi-Keymap.html#YiVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "yiEditor",
          "package": "yi",
          "partial": "Editor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:yiEditor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "yiSubprocessIdSupply",
          "package": "yi",
          "signature": "SubprocessId",
          "source": "src/Yi-Keymap.html#YiVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "yiSubprocessIdSupply",
          "package": "yi",
          "partial": "Subprocess Id Supply",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:yiSubprocessIdSupply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "yiSubprocesses",
          "package": "yi",
          "signature": "(Map SubprocessId SubprocessInfo)",
          "source": "src/Yi-Keymap.html#YiVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "yiSubprocesses",
          "package": "yi",
          "partial": "Subprocesses",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:yiSubprocesses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Keymap",
          "name": "yiUi",
          "package": "yi",
          "signature": "UI",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "yiUi",
          "package": "yi",
          "partial": "Ui",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:yiUi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe only mutable state in the program\n\u003c/p\u003e",
          "module": "Yi.Keymap",
          "name": "yiVar",
          "package": "yi",
          "signature": "MVar YiVar",
          "source": "src/Yi-Keymap.html#Yi",
          "type": "function"
        },
        "index": {
          "description": "The only mutable state in the program",
          "hierarchy": "Yi Keymap",
          "module": "Yi.Keymap",
          "name": "yiVar",
          "package": "yi",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Keymap.html#v:yiVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.KillRing",
          "name": "KillRing",
          "package": "yi",
          "source": "src/Yi-KillRing.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "KillRing",
          "package": "yi",
          "partial": "Kill Ring",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.KillRing",
          "name": "Killring",
          "package": "yi",
          "source": "src/Yi-KillRing.html#Killring",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "Killring",
          "package": "yi",
          "partial": "Killring",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#t:Killring"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.KillRing",
          "name": "krContents",
          "package": "yi",
          "signature": "Killring -\u003e [String]",
          "source": "src/Yi-KillRing.html#krContents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krContents",
          "normalized": "Killring-\u003e[String]",
          "package": "yi",
          "partial": "Contents",
          "signature": "Killring-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.KillRing",
          "name": "krEmpty",
          "package": "yi",
          "signature": "Killring",
          "source": "src/Yi-KillRing.html#krEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krEmpty",
          "package": "yi",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinish an atomic command, for the purpose of killring accumulation.\n\u003c/p\u003e",
          "module": "Yi.KillRing",
          "name": "krEndCmd",
          "package": "yi",
          "signature": "Killring -\u003e Killring",
          "source": "src/Yi-KillRing.html#krEndCmd",
          "type": "function"
        },
        "index": {
          "description": "Finish an atomic command for the purpose of killring accumulation",
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krEndCmd",
          "normalized": "Killring-\u003eKillring",
          "package": "yi",
          "partial": "End Cmd",
          "signature": "Killring-\u003eKillring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krEndCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the top of the killring.\n\u003c/p\u003e",
          "module": "Yi.KillRing",
          "name": "krGet",
          "package": "yi",
          "signature": "Killring -\u003e String",
          "source": "src/Yi-KillRing.html#krGet",
          "type": "function"
        },
        "index": {
          "description": "Get the top of the killring",
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krGet",
          "normalized": "Killring-\u003eString",
          "package": "yi",
          "partial": "Get",
          "signature": "Killring-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.KillRing",
          "name": "krKilled",
          "package": "yi",
          "signature": "Killring -\u003e Bool",
          "source": "src/Yi-KillRing.html#krKilled",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krKilled",
          "normalized": "Killring-\u003eBool",
          "package": "yi",
          "partial": "Killed",
          "signature": "Killring-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krKilled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut some text in the killring.\n It's accumulated if the last command was a kill too\n\u003c/p\u003e",
          "module": "Yi.KillRing",
          "name": "krPut",
          "package": "yi",
          "signature": "Direction -\u003e String -\u003e Killring -\u003e Killring",
          "source": "src/Yi-KillRing.html#krPut",
          "type": "function"
        },
        "index": {
          "description": "Put some text in the killring It accumulated if the last command was kill too",
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krPut",
          "normalized": "Direction-\u003eString-\u003eKillring-\u003eKillring",
          "package": "yi",
          "partial": "Put",
          "signature": "Direction-\u003eString-\u003eKillring-\u003eKillring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet the top of the killring. Never accumulate the previous content.\n\u003c/p\u003e",
          "module": "Yi.KillRing",
          "name": "krSet",
          "package": "yi",
          "signature": "String -\u003e Killring -\u003e Killring",
          "source": "src/Yi-KillRing.html#krSet",
          "type": "function"
        },
        "index": {
          "description": "Set the top of the killring Never accumulate the previous content",
          "hierarchy": "Yi KillRing",
          "module": "Yi.KillRing",
          "name": "krSet",
          "normalized": "String-\u003eKillring-\u003eKillring",
          "package": "yi",
          "partial": "Set",
          "signature": "String-\u003eKillring-\u003eKillring",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-KillRing.html#v:krSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the layout manager interface (see \u003ccode\u003e\u003ca\u003eLayoutManager\u003c/a\u003e\u003c/code\u003e). To desgin a new layout manager, just make an instance of this class.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Layout",
          "name": "Layout",
          "package": "yi",
          "source": "src/Yi-Layout.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the layout manager interface see LayoutManager To desgin new layout manager just make an instance of this class",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Layout",
          "package": "yi",
          "partial": "Layout",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExistential wrapper for \u003ccode\u003e\u003ca\u003eLayout\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "AnyLayoutManager",
          "package": "yi",
          "source": "src/Yi-Layout.html#AnyLayoutManager",
          "type": "data"
        },
        "index": {
          "description": "Existential wrapper for Layout",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "AnyLayoutManager",
          "package": "yi",
          "partial": "Any Layout Manager",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:AnyLayoutManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivider position, in the range (0,1)\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "DividerPosition",
          "package": "yi",
          "source": "src/Yi-Layout.html#DividerPosition",
          "type": "type"
        },
        "index": {
          "description": "Divider position in the range",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "DividerPosition",
          "package": "yi",
          "partial": "Divider Position",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:DividerPosition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDivider reference\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "DividerRef",
          "package": "yi",
          "source": "src/Yi-Layout.html#DividerRef",
          "type": "type"
        },
        "index": {
          "description": "Divider reference",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "DividerRef",
          "package": "yi",
          "partial": "Divider Ref",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:DividerRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUI-agnostic layout schema. The basic constructs are\n (horizontal/vertical) stacks with fixed ratios between window\n sizes; and (horizontal/vertical) pairs with a slider in between (if\n available).\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "Layout",
          "package": "yi",
          "source": "src/Yi-Layout.html#Layout",
          "type": "data"
        },
        "index": {
          "description": "UI-agnostic layout schema The basic constructs are horizontal vertical stacks with fixed ratios between window sizes and horizontal vertical pairs with slider in between if available",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Layout",
          "package": "yi",
          "partial": "Layout",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:Layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA 'Layout a' wrapped in a state monad for tracking \u003ccode\u003e\u003ca\u003eDividerRef\u003c/a\u003e\u003c/code\u003es. This type is \u003cem\u003enot\u003c/em\u003e itself a monad, but should rather be thought of as a \u003ccode\u003e\u003ca\u003eDividerRef\u003c/a\u003e\u003c/code\u003e-free version of the \u003ccode\u003e\u003ca\u003eLayout\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "LayoutM",
          "package": "yi",
          "source": "src/Yi-Layout.html#LayoutM",
          "type": "data"
        },
        "index": {
          "description": "Layout wrapped in state monad for tracking DividerRef This type is not itself monad but should rather be thought of as DividerRef free version of the Layout type",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "LayoutM",
          "package": "yi",
          "partial": "Layout",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:LayoutM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of layout managers. See the layout managers \u003ccode\u003e\u003ca\u003etall\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ehPairNStack\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eslidyTall\u003c/a\u003e\u003c/code\u003e for some example implementations.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "LayoutManager",
          "package": "yi",
          "source": "src/Yi-Layout.html#LayoutManager",
          "type": "class"
        },
        "index": {
          "description": "The type of layout managers See the layout managers tall hPairNStack and slidyTall for some example implementations",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "LayoutManager",
          "package": "yi",
          "partial": "Layout Manager",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:LayoutManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrientations for \u003ccode\u003e\u003ca\u003eStack\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ePair\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "Orientation",
          "package": "yi",
          "source": "src/Yi-Layout.html#Orientation",
          "type": "data"
        },
        "index": {
          "description": "Orientations for Stack and Pair",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Orientation",
          "package": "yi",
          "partial": "Orientation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:Orientation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA general bounding box\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "Rectangle",
          "package": "yi",
          "source": "src/Yi-Layout.html#Rectangle",
          "type": "data"
        },
        "index": {
          "description": "general bounding box",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Rectangle",
          "package": "yi",
          "partial": "Rectangle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:Rectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelative sizes, for \u003ccode\u003e\u003ca\u003eStack\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "RelativeSize",
          "package": "yi",
          "source": "src/Yi-Layout.html#RelativeSize",
          "type": "type"
        },
        "index": {
          "description": "Relative sizes for Stack",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "RelativeSize",
          "package": "yi",
          "partial": "Relative Size",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:RelativeSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThings with orientations which can be flipped\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "Transposable",
          "package": "yi",
          "source": "src/Yi-Layout.html#Transposable",
          "type": "class"
        },
        "index": {
          "description": "Things with orientations which can be flipped",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Transposable",
          "package": "yi",
          "partial": "Transposable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:Transposable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003elm\u003c/code\u003e, but with all \u003ccode\u003e\u003ca\u003eOrientation\u003c/a\u003e\u003c/code\u003es \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003ed. See \u003ccode\u003e\u003ca\u003eslidyWide\u003c/a\u003e\u003c/code\u003e for an example of its use.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "Transposed",
          "package": "yi",
          "source": "src/Yi-Layout.html#Transposed",
          "type": "newtype"
        },
        "index": {
          "description": "Same as lm but with all Orientation transpose See slidyWide for an example of its use",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Transposed",
          "package": "yi",
          "partial": "Transposed",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#t:Transposed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "AnyLayoutManager",
          "package": "yi",
          "signature": "AnyLayoutManager !m",
          "source": "src/Yi-Layout.html#AnyLayoutManager",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "AnyLayoutManager",
          "package": "yi",
          "partial": "Any Layout Manager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:AnyLayoutManager"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "Horizontal",
          "package": "yi",
          "signature": "Horizontal",
          "source": "src/Yi-Layout.html#Orientation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Horizontal",
          "package": "yi",
          "partial": "Horizontal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:Horizontal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "Pair",
          "package": "yi",
          "signature": "Pair",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Pair",
          "package": "yi",
          "partial": "Pair",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:Pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "Rectangle",
          "package": "yi",
          "signature": "Rectangle",
          "source": "src/Yi-Layout.html#Rectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Rectangle",
          "package": "yi",
          "partial": "Rectangle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:Rectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "SingleWindow",
          "package": "yi",
          "signature": "SingleWindow a",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "SingleWindow",
          "package": "yi",
          "partial": "Single Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:SingleWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "Stack",
          "package": "yi",
          "signature": "Stack",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Stack",
          "package": "yi",
          "partial": "Stack",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:Stack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "Transposed",
          "package": "yi",
          "signature": "Transposed lm",
          "source": "src/Yi-Layout.html#Transposed",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Transposed",
          "package": "yi",
          "partial": "Transposed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:Transposed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "Vertical",
          "package": "yi",
          "signature": "Vertical",
          "source": "src/Yi-Layout.html#Orientation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "Vertical",
          "package": "yi",
          "partial": "Vertical",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:Vertical"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribe the layout in a form suitable for the user.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "describeLayout",
          "package": "yi",
          "signature": "m -\u003e String",
          "source": "src/Yi-Layout.html#describeLayout",
          "type": "method"
        },
        "index": {
          "description": "Describe the layout in form suitable for the user",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "describeLayout",
          "normalized": "a-\u003eString",
          "package": "yi",
          "partial": "Layout",
          "signature": "m-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:describeLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial position of the divider\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "divPos",
          "package": "yi",
          "signature": "DividerPosition",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "description": "Initial position of the divider",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "divPos",
          "package": "yi",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:divPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIndex of the divider (for updating the divider position)\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "divRef",
          "package": "yi",
          "signature": "DividerRef",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "description": "Index of the divider for updating the divider position",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "divRef",
          "package": "yi",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:divRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for the \u003ccode\u003e\u003ca\u003eDividerPosition\u003c/a\u003e\u003c/code\u003e with given reference\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "dividerPositionA",
          "package": "yi",
          "signature": "DividerRef -\u003e Accessor (Layout a) DividerPosition",
          "source": "src/Yi-Layout.html#dividerPositionA",
          "type": "function"
        },
        "index": {
          "description": "Accessor for the DividerPosition with given reference",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "dividerPositionA",
          "normalized": "DividerRef-\u003eAccessor(Layout a)DividerPosition",
          "package": "yi",
          "partial": "Position",
          "signature": "DividerRef-\u003eAccessor(Layout a)DividerPosition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:dividerPositionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecial case of \u003ccode\u003e\u003ca\u003estack\u003c/a\u003e\u003c/code\u003e with all \u003ccode\u003e\u003ca\u003eRelativeSize\u003c/a\u003e\u003c/code\u003es equal.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "evenStack",
          "package": "yi",
          "signature": "Orientation -\u003e [LayoutM a] -\u003e LayoutM a",
          "source": "src/Yi-Layout.html#evenStack",
          "type": "function"
        },
        "index": {
          "description": "Special case of stack with all RelativeSize equal",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "evenStack",
          "normalized": "Orientation-\u003e[LayoutM a]-\u003eLayoutM a",
          "package": "yi",
          "partial": "Stack",
          "signature": "Orientation-\u003e[LayoutM a]-\u003eLayoutM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:evenStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003en\u003c/code\u003e windows on the left; stack of windows on the right.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "hPairNStack",
          "package": "yi",
          "signature": "Int -\u003e AnyLayoutManager",
          "source": "src/Yi-Layout.html#hPairNStack",
          "type": "function"
        },
        "index": {
          "description": "windows on the left stack of windows on the right",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "hPairNStack",
          "normalized": "Int-\u003eAnyLayoutManager",
          "package": "yi",
          "partial": "Pair NStack",
          "signature": "Int-\u003eAnyLayoutManager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:hPairNStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if the internal layout managers have the same type (but are not necessarily equal).\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "layoutManagerSameType",
          "package": "yi",
          "signature": "AnyLayoutManager -\u003e AnyLayoutManager -\u003e Bool",
          "source": "src/Yi-Layout.html#layoutManagerSameType",
          "type": "function"
        },
        "index": {
          "description": "True if the internal layout managers have the same type but are not necessarily equal",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "layoutManagerSameType",
          "normalized": "AnyLayoutManager-\u003eAnyLayoutManager-\u003eBool",
          "package": "yi",
          "partial": "Manager Same Type",
          "signature": "AnyLayoutManager-\u003eAnyLayoutManager-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:layoutManagerSameType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "layoutToRectangles",
          "package": "yi",
          "signature": "Rectangle -\u003e Layout a -\u003e [(a, Rectangle)]",
          "source": "src/Yi-Layout.html#layoutToRectangles",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "layoutToRectangles",
          "normalized": "Rectangle-\u003eLayout a-\u003e[(a,Rectangle)]",
          "package": "yi",
          "partial": "To Rectangles",
          "signature": "Rectangle-\u003eLayout a-\u003e[(a,Rectangle)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:layoutToRectangles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycles to the next variant, if there is one (the default is \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "nextVariant",
          "package": "yi",
          "signature": "m -\u003e m",
          "source": "src/Yi-Layout.html#nextVariant",
          "type": "method"
        },
        "index": {
          "description": "Cycles to the next variant if there is one the default is id",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "nextVariant",
          "normalized": "a-\u003ea",
          "package": "yi",
          "partial": "Variant",
          "signature": "m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:nextVariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrientation\n\u003c/p\u003e\u003cp\u003eOrientation\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "orientation",
          "package": "yi",
          "signature": "Orientation",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "description": "Orientation Orientation",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "orientation",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:orientation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "pair",
          "package": "yi",
          "signature": "Orientation -\u003e DividerPosition -\u003e LayoutM a -\u003e LayoutM a -\u003e LayoutM a",
          "source": "src/Yi-Layout.html#pair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "pair",
          "normalized": "Orientation-\u003eDividerPosition-\u003eLayoutM a-\u003eLayoutM a-\u003eLayoutM a",
          "package": "yi",
          "signature": "Orientation-\u003eDividerPosition-\u003eLayoutM a-\u003eLayoutM a-\u003eLayoutM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:pair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUpper of of the pair\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "pairFst",
          "package": "yi",
          "signature": "(Layout a)",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "description": "Upper of of the pair",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "pairFst",
          "package": "yi",
          "partial": "Fst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:pairFst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLower of the pair\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "pairSnd",
          "package": "yi",
          "signature": "(Layout a)",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "description": "Lower of the pair",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "pairSnd",
          "package": "yi",
          "partial": "Snd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:pairSnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCycles to the previous variant, if there is one (the default is \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "previousVariant",
          "package": "yi",
          "signature": "m -\u003e m",
          "source": "src/Yi-Layout.html#previousVariant",
          "type": "method"
        },
        "index": {
          "description": "Cycles to the previous variant if there is one the default is id",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "previousVariant",
          "normalized": "a-\u003ea",
          "package": "yi",
          "partial": "Variant",
          "signature": "m-\u003em",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:previousVariant"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven the old layout and the new list of windows, construct a\n layout for the new list of windows.\n\u003c/p\u003e\u003cp\u003eIf the layout manager uses sliding dividers, then a user will expect that most\n of these dividers don't move when adding a new window. It is the layout\n manager's responsibility to ensure that this is the case, and this is the\n purpose of the \u003ccode\u003eLayout a\u003c/code\u003e argument.\n\u003c/p\u003e\u003cp\u003eThe old layout may come from a different layout manager, in which case the layout manager is free to ignore it.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "pureLayout",
          "package": "yi",
          "signature": "m -\u003e Layout a -\u003e [a] -\u003e Layout a",
          "source": "src/Yi-Layout.html#pureLayout",
          "type": "method"
        },
        "index": {
          "description": "Given the old layout and the new list of windows construct layout for the new list of windows If the layout manager uses sliding dividers then user will expect that most of these dividers don move when adding new window It is the layout manager responsibility to ensure that this is the case and this is the purpose of the Layout argument The old layout may come from different layout manager in which case the layout manager is free to ignore it",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "pureLayout",
          "normalized": "a-\u003eLayout b-\u003e[b]-\u003eLayout b",
          "package": "yi",
          "partial": "Layout",
          "signature": "m-\u003eLayout a-\u003e[a]-\u003eLayout a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:pureLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "rectHeight",
          "package": "yi",
          "signature": "Double",
          "source": "src/Yi-Layout.html#Rectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "rectHeight",
          "package": "yi",
          "partial": "Height",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:rectHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "rectWidth",
          "package": "yi",
          "signature": "Double",
          "source": "src/Yi-Layout.html#Rectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "rectWidth",
          "package": "yi",
          "partial": "Width",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:rectWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "rectX",
          "package": "yi",
          "signature": "Double",
          "source": "src/Yi-Layout.html#Rectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "rectX",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:rectX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "rectY",
          "package": "yi",
          "signature": "Double",
          "source": "src/Yi-Layout.html#Rectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "rectY",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:rectY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "runLayoutM",
          "package": "yi",
          "signature": "LayoutM a -\u003e Layout a",
          "source": "src/Yi-Layout.html#runLayoutM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "runLayoutM",
          "normalized": "LayoutM a-\u003eLayout a",
          "package": "yi",
          "partial": "Layout",
          "signature": "LayoutM a-\u003eLayout a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:runLayoutM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "singleWindow",
          "package": "yi",
          "signature": "a -\u003e LayoutM a",
          "source": "src/Yi-Layout.html#singleWindow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "singleWindow",
          "normalized": "a-\u003eLayoutM a",
          "package": "yi",
          "partial": "Window",
          "signature": "a-\u003eLayoutM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:singleWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTall windows, arranged in a balanced binary tree with sliders in between them.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "slidyTall",
          "package": "yi",
          "signature": "AnyLayoutManager",
          "source": "src/Yi-Layout.html#slidyTall",
          "type": "function"
        },
        "index": {
          "description": "Tall windows arranged in balanced binary tree with sliders in between them",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "slidyTall",
          "package": "yi",
          "partial": "Tall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:slidyTall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransposed version of \u003ccode\u003e\u003ca\u003eslidyTall\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "slidyWide",
          "package": "yi",
          "signature": "AnyLayoutManager",
          "source": "src/Yi-Layout.html#slidyWide",
          "type": "function"
        },
        "index": {
          "description": "Transposed version of slidyTall",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "slidyWide",
          "package": "yi",
          "partial": "Wide",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:slidyWide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "stack",
          "package": "yi",
          "signature": "Orientation -\u003e [(LayoutM a, RelativeSize)] -\u003e LayoutM a",
          "source": "src/Yi-Layout.html#stack",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "stack",
          "normalized": "Orientation-\u003e[(LayoutM a,RelativeSize)]-\u003eLayoutM a",
          "package": "yi",
          "signature": "Orientation-\u003e[(LayoutM a,RelativeSize)]-\u003eLayoutM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:stack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWindows placed side-by-side, equally spaced.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "tall",
          "package": "yi",
          "signature": "AnyLayoutManager",
          "source": "src/Yi-Layout.html#tall",
          "type": "function"
        },
        "index": {
          "description": "Windows placed side-by-side equally spaced",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "tall",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:tall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Layout",
          "name": "transpose",
          "package": "yi",
          "signature": "r -\u003e r",
          "source": "src/Yi-Layout.html#transpose",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "transpose",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "r-\u003er",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransposed version of \u003ccode\u003e\u003ca\u003ehPairNStack\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "vPairNStack",
          "package": "yi",
          "signature": "Int -\u003e AnyLayoutManager",
          "source": "src/Yi-Layout.html#vPairNStack",
          "type": "function"
        },
        "index": {
          "description": "Transposed version of hPairNStack",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "vPairNStack",
          "normalized": "Int-\u003eAnyLayoutManager",
          "package": "yi",
          "partial": "Pair NStack",
          "signature": "Int-\u003eAnyLayoutManager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:vPairNStack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWindows placed on top of one another, equally spaced\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "wide",
          "package": "yi",
          "signature": "AnyLayoutManager",
          "source": "src/Yi-Layout.html#wide",
          "type": "function"
        },
        "index": {
          "description": "Windows placed on top of one another equally spaced",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "wide",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:wide"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe layout stack, with the given weights\n TODO: fix strictness for stack (it's still lazy)\n\u003c/p\u003e",
          "module": "Yi.Layout",
          "name": "wins",
          "package": "yi",
          "signature": "[(Layout a, RelativeSize)]",
          "source": "src/Yi-Layout.html#Layout",
          "type": "function"
        },
        "index": {
          "description": "The layout stack with the given weights TODO fix strictness for stack it still lazy",
          "hierarchy": "Yi Layout",
          "module": "Yi.Layout",
          "name": "wins",
          "normalized": "[(Layout a,RelativeSize)]",
          "package": "yi",
          "signature": "[(Layout a,RelativeSize)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Layout.html#v:wins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Abella",
          "package": "yi",
          "source": "src/Yi-Lexer-Abella.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Abella",
          "package": "yi",
          "partial": "Abella",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "HlState",
          "package": "yi",
          "source": "src/Yi-Lexer-Abella.html#HlState",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "HlState",
          "package": "yi",
          "partial": "Hl State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#t:HlState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Reserved",
          "package": "yi",
          "source": "src/Yi-Lexer-Abella.html#Reserved",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Reserved",
          "package": "yi",
          "partial": "Reserved",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#t:Reserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "ReservedOp",
          "package": "yi",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "ReservedOp",
          "package": "yi",
          "partial": "Reserved Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#t:ReservedOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "TT",
          "package": "yi",
          "source": "src/Yi-Lexer-Abella.html#TT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "TT",
          "package": "yi",
          "partial": "TT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#t:TT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "And",
          "package": "yi",
          "signature": "And",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "And",
          "package": "yi",
          "partial": "And",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:And"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "BackSlash",
          "package": "yi",
          "signature": "BackSlash",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "BackSlash",
          "package": "yi",
          "partial": "Back Slash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:BackSlash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "CommentLine",
          "package": "yi",
          "signature": "CommentLine",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "CommentLine",
          "package": "yi",
          "partial": "Comment Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:CommentLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "ConsIdent",
          "package": "yi",
          "signature": "ConsIdent",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "ConsIdent",
          "package": "yi",
          "partial": "Cons Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:ConsIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Dot",
          "package": "yi",
          "signature": "Dot",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Dot",
          "package": "yi",
          "partial": "Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "DoubleRightArrow",
          "package": "yi",
          "signature": "DoubleRightArrow",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "DoubleRightArrow",
          "package": "yi",
          "partial": "Double Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:DoubleRightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Exists",
          "package": "yi",
          "signature": "Exists",
          "source": "src/Yi-Lexer-Abella.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Exists",
          "package": "yi",
          "partial": "Exists",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Exists"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Forall",
          "package": "yi",
          "signature": "Forall",
          "source": "src/Yi-Lexer-Abella.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Forall",
          "package": "yi",
          "partial": "Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Number",
          "package": "yi",
          "signature": "Number",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Number",
          "package": "yi",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Or",
          "package": "yi",
          "signature": "Or",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Or",
          "package": "yi",
          "partial": "Or",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Or"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Other",
          "package": "yi",
          "signature": "Other",
          "source": "src/Yi-Lexer-Abella.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Other",
          "package": "yi",
          "partial": "Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Other"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "OtherOp",
          "package": "yi",
          "signature": "OtherOp",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "OtherOp",
          "package": "yi",
          "partial": "Other Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:OtherOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Reserved",
          "package": "yi",
          "signature": "Reserved !Reserved",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Reserved",
          "package": "yi",
          "partial": "Reserved",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Reserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "ReservedOp",
          "package": "yi",
          "signature": "ReservedOp !ReservedOp",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "ReservedOp",
          "package": "yi",
          "partial": "Reserved Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:ReservedOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "RightArrow",
          "package": "yi",
          "signature": "RightArrow",
          "source": "src/Yi-Lexer-Abella.html#ReservedOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "RightArrow",
          "package": "yi",
          "partial": "Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:RightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Skip",
          "package": "yi",
          "signature": "Skip",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Skip",
          "package": "yi",
          "partial": "Skip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Skip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "Unrecognized",
          "package": "yi",
          "signature": "Unrecognized",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "Unrecognized",
          "package": "yi",
          "partial": "Unrecognized",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:Unrecognized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "VarIdent",
          "package": "yi",
          "signature": "VarIdent",
          "source": "src/Yi-Lexer-Abella.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "VarIdent",
          "package": "yi",
          "partial": "Var Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:VarIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Abella",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Abella.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Abella.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "isComment",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Lexer-Abella.html#isComment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "isComment",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Comment",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:isComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "tokenToStyle",
          "package": "yi",
          "signature": "Token -\u003e StyleName",
          "source": "src/Yi-Lexer-Abella.html#tokenToStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "tokenToStyle",
          "normalized": "Token-\u003eStyleName",
          "package": "yi",
          "partial": "To Style",
          "signature": "Token-\u003eStyleName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:tokenToStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Abella",
          "name": "tokenToText",
          "package": "yi",
          "signature": "Token -\u003e Maybe String",
          "source": "src/Yi-Lexer-Abella.html#tokenToText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Abella",
          "module": "Yi.Lexer.Abella",
          "name": "tokenToText",
          "normalized": "Token-\u003eMaybe String",
          "package": "yi",
          "partial": "To Text",
          "signature": "Token-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Abella.html#v:tokenToText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities to turn a lexer generated by Alex into a scanner\n   that can be used by Yi.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "Alex",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities to turn lexer generated by Alex into scanner that can be used by Yi",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Alex",
          "package": "yi",
          "partial": "Alex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "ASI",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html#ASI",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "ASI",
          "package": "yi",
          "partial": "ASI",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:ASI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "AlexInput",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html#AlexInput",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "AlexInput",
          "package": "yi",
          "partial": "Alex Input",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:AlexInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexer state\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "AlexState",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html#AlexState",
          "type": "data"
        },
        "index": {
          "description": "Lexer state",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "AlexState",
          "package": "yi",
          "partial": "Alex State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:AlexState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "Posn",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html#Posn",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Posn",
          "package": "yi",
          "partial": "Posn",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:Posn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of a buffer region\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "Size",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Size",
          "type": "newtype"
        },
        "index": {
          "description": "Size of buffer region",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Size",
          "package": "yi",
          "partial": "Size",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:Size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "Stroke",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Stroke",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Stroke",
          "package": "yi",
          "partial": "Stroke",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:Stroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "Tok",
          "package": "yi",
          "source": "src/Yi-Lexer-Alex.html#Tok",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Tok",
          "package": "yi",
          "partial": "Tok",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#t:Tok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "(~-)",
          "package": "yi",
          "signature": "absolute -\u003e absolute -\u003e relative",
          "source": "src/Yi-Prelude.html#~-",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "(~-) ~-",
          "normalized": "a-\u003ea-\u003eb",
          "package": "yi",
          "signature": "absolute-\u003eabsolute-\u003erelative",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:-126--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "(+~)",
          "package": "yi",
          "signature": "absolute -\u003e relative -\u003e absolute",
          "source": "src/Yi-Prelude.html#%2B~",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "(+~) +~",
          "normalized": "a-\u003eb-\u003ea",
          "package": "yi",
          "signature": "absolute-\u003erelative-\u003eabsolute",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:-43--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "Posn",
          "package": "yi",
          "signature": "Posn",
          "source": "src/Yi-Lexer-Alex.html#Posn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Posn",
          "package": "yi",
          "partial": "Posn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:Posn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "Tok",
          "package": "yi",
          "signature": "Tok",
          "source": "src/Yi-Lexer-Alex.html#Tok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "Tok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:Tok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a constant token, and modify the lexer state\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "actionAndModify",
          "package": "yi",
          "signature": "(lexState -\u003e lexState) -\u003e token -\u003e Action lexState token",
          "source": "src/Yi-Lexer-Alex.html#actionAndModify",
          "type": "function"
        },
        "index": {
          "description": "Return constant token and modify the lexer state",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "actionAndModify",
          "normalized": "(a-\u003ea)-\u003eb-\u003eAction a b",
          "package": "yi",
          "partial": "And Modify",
          "signature": "(lexState-\u003elexState)-\u003etoken-\u003eAction lexState token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:actionAndModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a constant token\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "actionConst",
          "package": "yi",
          "signature": "token -\u003e Action lexState token",
          "source": "src/Yi-Lexer-Alex.html#actionConst",
          "type": "function"
        },
        "index": {
          "description": "Return constant token",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "actionConst",
          "normalized": "a-\u003eAction b a",
          "package": "yi",
          "partial": "Const",
          "signature": "token-\u003eAction lexState token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:actionConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the parsed string into a token,\n   and also modify the lexer state\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "actionStringAndModify",
          "package": "yi",
          "signature": "(lexState -\u003e lexState) -\u003e (String -\u003e token) -\u003e Action lexState token",
          "source": "src/Yi-Lexer-Alex.html#actionStringAndModify",
          "type": "function"
        },
        "index": {
          "description": "Convert the parsed string into token and also modify the lexer state",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "actionStringAndModify",
          "normalized": "(a-\u003ea)-\u003e(String-\u003eb)-\u003eAction a b",
          "package": "yi",
          "partial": "String And Modify",
          "signature": "(lexState-\u003elexState)-\u003e(String-\u003etoken)-\u003eAction lexState token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:actionStringAndModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert the parsed string into a token\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "actionStringConst",
          "package": "yi",
          "signature": "(String -\u003e token) -\u003e Action lexState token",
          "source": "src/Yi-Lexer-Alex.html#actionStringConst",
          "type": "function"
        },
        "index": {
          "description": "Convert the parsed string into token",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "actionStringConst",
          "normalized": "(String-\u003ea)-\u003eAction b a",
          "package": "yi",
          "partial": "String Const",
          "signature": "(String-\u003etoken)-\u003eAction lexState token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:actionStringConst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "alexCollectChar",
          "package": "yi",
          "signature": "AlexInput -\u003e [Char]",
          "source": "src/Yi-Lexer-Alex.html#alexCollectChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "alexCollectChar",
          "normalized": "AlexInput-\u003e[Char]",
          "package": "yi",
          "partial": "Collect Char",
          "signature": "AlexInput-\u003e[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:alexCollectChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "alexGetByte",
          "package": "yi",
          "signature": "AlexInput -\u003e Maybe (Word8, AlexInput)",
          "source": "src/Yi-Lexer-Alex.html#alexGetByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "alexGetByte",
          "normalized": "AlexInput-\u003eMaybe(Word,AlexInput)",
          "package": "yi",
          "partial": "Get Byte",
          "signature": "AlexInput-\u003eMaybe(Word,AlexInput)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:alexGetByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "alexGetChar",
          "package": "yi",
          "signature": "AlexInput -\u003e Maybe (Char, AlexInput)",
          "source": "src/Yi-Lexer-Alex.html#alexGetChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "alexGetChar",
          "normalized": "AlexInput-\u003eMaybe(Char,AlexInput)",
          "package": "yi",
          "partial": "Get Char",
          "signature": "AlexInput-\u003eMaybe(Char,AlexInput)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:alexGetChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "alexInputPrevChar",
          "package": "yi",
          "signature": "AlexInput -\u003e Char",
          "source": "src/Yi-Lexer-Alex.html#alexInputPrevChar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "alexInputPrevChar",
          "normalized": "AlexInput-\u003eChar",
          "package": "yi",
          "partial": "Input Prev Char",
          "signature": "AlexInput-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:alexInputPrevChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine a character scanner with a lexer to produce a token scanner.\n   May be used together with \u003ccode\u003emkHighlighter\u003c/code\u003e to produce a \u003ccode\u003e\u003ca\u003eHighlighter\u003c/a\u003e\u003c/code\u003e,\n   or with \u003ccode\u003elinearSyntaxMode\u003c/code\u003e to produce a \u003ccode\u003eMode\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "lexScanner",
          "package": "yi",
          "signature": "((AlexState lexerState, AlexInput) -\u003e Maybe (token, (AlexState lexerState, AlexInput)))-\u003e lexerState-\u003e Scanner Point Char-\u003e Scanner (AlexState lexerState) token",
          "type": "function"
        },
        "index": {
          "description": "Combine character scanner with lexer to produce token scanner May be used together with mkHighlighter to produce Highlighter or with linearSyntaxMode to produce Mode",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "lexScanner",
          "normalized": "((AlexState a,AlexInput)-\u003eMaybe(b,(AlexState a,AlexInput)))-\u003ea-\u003eScanner Point Char-\u003eScanner(AlexState a)b",
          "package": "yi",
          "partial": "Scanner",
          "signature": "((AlexState lexerState,AlexInput)-\u003eMaybe(token,(AlexState lexerState,AlexInput)))-\u003elexerState-\u003eScanner Point Char-\u003eScanner(AlexState lexerState)token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:lexScanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "moveStr",
          "package": "yi",
          "signature": "Posn -\u003e IndexedStr -\u003e Posn",
          "source": "src/Yi-Lexer-Alex.html#moveStr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "moveStr",
          "normalized": "Posn-\u003eIndexedStr-\u003ePosn",
          "package": "yi",
          "partial": "Str",
          "signature": "Posn-\u003eIndexedStr-\u003ePosn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:moveStr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "posnCol",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Lexer-Alex.html#Posn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "posnCol",
          "package": "yi",
          "partial": "Col",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:posnCol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "posnLine",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Lexer-Alex.html#Posn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "posnLine",
          "package": "yi",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:posnLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "posnOfs",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Lexer-Alex.html#Posn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "posnOfs",
          "package": "yi",
          "partial": "Ofs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:posnOfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "startPosn",
          "package": "yi",
          "signature": "Posn",
          "source": "src/Yi-Lexer-Alex.html#startPosn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "startPosn",
          "package": "yi",
          "partial": "Posn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:startPosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokBegin",
          "package": "yi",
          "signature": "forall t.  Tok t -\u003e Point",
          "source": "src/Yi-Lexer-Alex.html#tokBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokBegin",
          "normalized": "a b Tok c-\u003ePoint",
          "package": "yi",
          "partial": "Begin",
          "signature": "forall t. Tok t-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokEnd",
          "package": "yi",
          "signature": "forall t.  Tok t -\u003e Point",
          "source": "src/Yi-Lexer-Alex.html#tokEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokEnd",
          "normalized": "a b Tok c-\u003ePoint",
          "package": "yi",
          "partial": "End",
          "signature": "forall t. Tok t-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokFromT",
          "package": "yi",
          "signature": "forall t.  t -\u003e Tok t",
          "source": "src/Yi-Lexer-Alex.html#tokFromT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokFromT",
          "normalized": "a b c-\u003eTok c",
          "package": "yi",
          "partial": "From",
          "signature": "forall t. t-\u003eTok t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokFromT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokLen",
          "package": "yi",
          "signature": "Size",
          "source": "src/Yi-Lexer-Alex.html#Tok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokLen",
          "package": "yi",
          "partial": "Len",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokPosn",
          "package": "yi",
          "signature": "Posn",
          "source": "src/Yi-Lexer-Alex.html#Tok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokPosn",
          "package": "yi",
          "partial": "Posn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokPosn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokRegion",
          "package": "yi",
          "signature": "Tok t -\u003e Region",
          "source": "src/Yi-Lexer-Alex.html#tokRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokRegion",
          "normalized": "Tok a-\u003eRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "Tok t-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokT",
          "package": "yi",
          "signature": "t",
          "source": "src/Yi-Lexer-Alex.html#Tok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokT",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Alex",
          "name": "tokToSpan",
          "package": "yi",
          "signature": "Tok t -\u003e Span t",
          "source": "src/Yi-Lexer-Alex.html#tokToSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "tokToSpan",
          "normalized": "Tok a-\u003eSpan a",
          "package": "yi",
          "partial": "To Span",
          "signature": "Tok t-\u003eSpan t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:tokToSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunfold lexer function into a function that returns a stream of (state x token)\n\u003c/p\u003e",
          "module": "Yi.Lexer.Alex",
          "name": "unfoldLexer",
          "package": "yi",
          "signature": "((AlexState lexState, input) -\u003e Maybe (token, (AlexState lexState, input))) -\u003e (AlexState lexState, input) -\u003e [(AlexState lexState, token)]",
          "source": "src/Yi-Lexer-Alex.html#unfoldLexer",
          "type": "function"
        },
        "index": {
          "description": "unfold lexer function into function that returns stream of state token",
          "hierarchy": "Yi Lexer Alex",
          "module": "Yi.Lexer.Alex",
          "name": "unfoldLexer",
          "normalized": "((AlexState a,b)-\u003eMaybe(c,(AlexState a,b)))-\u003e(AlexState a,b)-\u003e[(AlexState a,c)]",
          "package": "yi",
          "partial": "Lexer",
          "signature": "((AlexState lexState,input)-\u003eMaybe(token,(AlexState lexState,input)))-\u003e(AlexState lexState,input)-\u003e[(AlexState lexState,token)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Alex.html#v:unfoldLexer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.C",
          "name": "C",
          "package": "yi",
          "source": "src/Yi-Lexer-C.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer C",
          "module": "Yi.Lexer.C",
          "name": "C",
          "package": "yi",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-C.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.C",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-C.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer C",
          "module": "Yi.Lexer.C",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-C.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.C",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-C.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer C",
          "module": "Yi.Lexer.C",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-C.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Cabal",
          "name": "Cabal",
          "package": "yi",
          "source": "src/Yi-Lexer-Cabal.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Cabal",
          "module": "Yi.Lexer.Cabal",
          "name": "Cabal",
          "package": "yi",
          "partial": "Cabal",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Cabal.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Cabal",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Cabal.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Cabal",
          "module": "Yi.Lexer.Cabal",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Cabal.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Cabal",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Cabal.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Cabal",
          "module": "Yi.Lexer.Cabal",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Cabal.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Compilation",
          "name": "Compilation",
          "package": "yi",
          "source": "src/Yi-Lexer-Compilation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Compilation",
          "module": "Yi.Lexer.Compilation",
          "name": "Compilation",
          "package": "yi",
          "partial": "Compilation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Compilation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Compilation",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-Compilation.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Compilation",
          "module": "Yi.Lexer.Compilation",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Compilation.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Compilation",
          "name": "Report",
          "package": "yi",
          "signature": "Report String Int Int String",
          "source": "src/Yi-Lexer-Compilation.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Compilation",
          "module": "Yi.Lexer.Compilation",
          "name": "Report",
          "package": "yi",
          "partial": "Report",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Compilation.html#v:Report"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Compilation",
          "name": "Text",
          "package": "yi",
          "signature": "Text String",
          "source": "src/Yi-Lexer-Compilation.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Compilation",
          "module": "Yi.Lexer.Compilation",
          "name": "Text",
          "package": "yi",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Compilation.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Compilation",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Compilation.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Compilation",
          "module": "Yi.Lexer.Compilation",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Compilation.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Compilation",
          "name": "initState",
          "package": "yi",
          "signature": "()",
          "source": "src/Yi-Lexer-Compilation.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Compilation",
          "module": "Yi.Lexer.Compilation",
          "name": "initState",
          "normalized": "()",
          "package": "yi",
          "partial": "State",
          "signature": "()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Compilation.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Cplusplus",
          "name": "Cplusplus",
          "package": "yi",
          "source": "src/Yi-Lexer-Cplusplus.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Cplusplus",
          "module": "Yi.Lexer.Cplusplus",
          "name": "Cplusplus",
          "package": "yi",
          "partial": "Cplusplus",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Cplusplus.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Cplusplus",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Cplusplus.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Cplusplus",
          "module": "Yi.Lexer.Cplusplus",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Cplusplus.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Cplusplus",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Cplusplus.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Cplusplus",
          "module": "Yi.Lexer.Cplusplus",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Cplusplus.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.GNUMake",
          "name": "GNUMake",
          "package": "yi",
          "source": "src/Yi-Lexer-GNUMake.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer GNUMake",
          "module": "Yi.Lexer.GNUMake",
          "name": "GNUMake",
          "package": "yi",
          "partial": "GNUMake",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GNUMake.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.GNUMake",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-GNUMake.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer GNUMake",
          "module": "Yi.Lexer.GNUMake",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GNUMake.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.GNUMake",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-GNUMake.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer GNUMake",
          "module": "Yi.Lexer.GNUMake",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GNUMake.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.GitCommit",
          "name": "GitCommit",
          "package": "yi",
          "source": "src/Yi-Lexer-GitCommit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer GitCommit",
          "module": "Yi.Lexer.GitCommit",
          "name": "GitCommit",
          "package": "yi",
          "partial": "Git Commit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GitCommit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.GitCommit",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-GitCommit.html#Token",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer GitCommit",
          "module": "Yi.Lexer.GitCommit",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GitCommit.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.GitCommit",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-GitCommit.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer GitCommit",
          "module": "Yi.Lexer.GitCommit",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GitCommit.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.GitCommit",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-GitCommit.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer GitCommit",
          "module": "Yi.Lexer.GitCommit",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-GitCommit.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Haskell",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Haskell",
          "package": "yi",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "CommentType",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html#CommentType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "CommentType",
          "package": "yi",
          "partial": "Comment Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#t:CommentType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "HlState",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html#HlState",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "HlState",
          "package": "yi",
          "partial": "Hl State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#t:HlState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "OpType",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "OpType",
          "package": "yi",
          "partial": "Op Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#t:OpType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "ReservedType",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "ReservedType",
          "package": "yi",
          "partial": "Reserved Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#t:ReservedType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "TT",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html#TT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "TT",
          "package": "yi",
          "partial": "TT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#t:TT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Arobase",
          "package": "yi",
          "signature": "Arobase",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Arobase",
          "package": "yi",
          "partial": "Arobase",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Arobase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "As",
          "package": "yi",
          "signature": "As",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "As",
          "package": "yi",
          "partial": "As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:As"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "BackSlash",
          "package": "yi",
          "signature": "BackSlash",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "BackSlash",
          "package": "yi",
          "partial": "Back Slash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:BackSlash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "CharTok",
          "package": "yi",
          "signature": "CharTok",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "CharTok",
          "package": "yi",
          "partial": "Char Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:CharTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Class",
          "package": "yi",
          "signature": "Class",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Class",
          "package": "yi",
          "partial": "Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Class"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Close",
          "package": "yi",
          "signature": "Close",
          "source": "src/Yi-Lexer-Haskell.html#CommentType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Close",
          "package": "yi",
          "partial": "Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Close"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Comment",
          "package": "yi",
          "signature": "Comment !CommentType",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Comment",
          "package": "yi",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "ConsIdent",
          "package": "yi",
          "signature": "ConsIdent",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "ConsIdent",
          "package": "yi",
          "partial": "Cons Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:ConsIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "ConsOperator",
          "package": "yi",
          "signature": "ConsOperator String",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "ConsOperator",
          "package": "yi",
          "partial": "Cons Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:ConsOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "CppDirective",
          "package": "yi",
          "signature": "CppDirective",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "CppDirective",
          "package": "yi",
          "partial": "Cpp Directive",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:CppDirective"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Data",
          "package": "yi",
          "signature": "Data",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Data",
          "package": "yi",
          "partial": "Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Data"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Deriving",
          "package": "yi",
          "signature": "Deriving",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Deriving",
          "package": "yi",
          "partial": "Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Deriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Do",
          "package": "yi",
          "signature": "Do",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Do",
          "package": "yi",
          "partial": "Do",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Do"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "DoubleColon",
          "package": "yi",
          "signature": "DoubleColon",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "DoubleColon",
          "package": "yi",
          "partial": "Double Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:DoubleColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "DoubleDot",
          "package": "yi",
          "signature": "DoubleDot",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "DoubleDot",
          "package": "yi",
          "partial": "Double Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:DoubleDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "DoubleRightArrow",
          "package": "yi",
          "signature": "DoubleRightArrow",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "DoubleRightArrow",
          "package": "yi",
          "partial": "Double Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:DoubleRightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Equal",
          "package": "yi",
          "signature": "Equal",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Equal",
          "package": "yi",
          "partial": "Equal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Forall",
          "package": "yi",
          "signature": "Forall",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Forall",
          "package": "yi",
          "partial": "Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Hiding",
          "package": "yi",
          "signature": "Hiding",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Hiding",
          "package": "yi",
          "partial": "Hiding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Hiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Import",
          "package": "yi",
          "signature": "Import",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Import",
          "package": "yi",
          "partial": "Import",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Import"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "In",
          "package": "yi",
          "signature": "In",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "In",
          "package": "yi",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:In"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Instance",
          "package": "yi",
          "signature": "Instance",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Instance",
          "package": "yi",
          "partial": "Instance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "LeftArrow",
          "package": "yi",
          "signature": "LeftArrow",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "LeftArrow",
          "package": "yi",
          "partial": "Left Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:LeftArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Let",
          "package": "yi",
          "signature": "Let",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Let",
          "package": "yi",
          "partial": "Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Line",
          "package": "yi",
          "signature": "Line",
          "source": "src/Yi-Lexer-Haskell.html#CommentType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Line",
          "package": "yi",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Line"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Module",
          "package": "yi",
          "signature": "Module",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Module",
          "package": "yi",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "NewType",
          "package": "yi",
          "signature": "NewType",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "NewType",
          "package": "yi",
          "partial": "New Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:NewType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Number",
          "package": "yi",
          "signature": "Number",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Number",
          "package": "yi",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Of",
          "package": "yi",
          "signature": "Of",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Of",
          "package": "yi",
          "partial": "Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Open",
          "package": "yi",
          "signature": "Open",
          "source": "src/Yi-Lexer-Haskell.html#CommentType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Open",
          "package": "yi",
          "partial": "Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Open"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Operator",
          "package": "yi",
          "signature": "Operator String",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Operator",
          "package": "yi",
          "partial": "Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Other",
          "package": "yi",
          "signature": "Other",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Other",
          "package": "yi",
          "partial": "Other",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Other"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "OtherLayout",
          "package": "yi",
          "signature": "OtherLayout",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "OtherLayout",
          "package": "yi",
          "partial": "Other Layout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:OtherLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Pipe",
          "package": "yi",
          "signature": "Pipe",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Pipe",
          "package": "yi",
          "partial": "Pipe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Pipe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Qualified",
          "package": "yi",
          "signature": "Qualified",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Qualified",
          "package": "yi",
          "partial": "Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Qualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Reserved",
          "package": "yi",
          "signature": "Reserved !ReservedType",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Reserved",
          "package": "yi",
          "partial": "Reserved",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Reserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "ReservedOp",
          "package": "yi",
          "signature": "ReservedOp !OpType",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "ReservedOp",
          "package": "yi",
          "partial": "Reserved Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:ReservedOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "RightArrow",
          "package": "yi",
          "signature": "RightArrow",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "RightArrow",
          "package": "yi",
          "partial": "Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:RightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Special",
          "package": "yi",
          "signature": "Special Char",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Special",
          "package": "yi",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "StringTok",
          "package": "yi",
          "signature": "StringTok",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "StringTok",
          "package": "yi",
          "partial": "String Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:StringTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "THQuote",
          "package": "yi",
          "signature": "THQuote",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "THQuote",
          "package": "yi",
          "partial": "THQuote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:THQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Text",
          "package": "yi",
          "signature": "Text",
          "source": "src/Yi-Lexer-Haskell.html#CommentType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Text",
          "package": "yi",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Tilda",
          "package": "yi",
          "signature": "Tilda",
          "source": "src/Yi-Lexer-Haskell.html#OpType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Tilda",
          "package": "yi",
          "partial": "Tilda",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Tilda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Type",
          "package": "yi",
          "signature": "Type",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Type",
          "package": "yi",
          "partial": "Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Unrecognized",
          "package": "yi",
          "signature": "Unrecognized",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Unrecognized",
          "package": "yi",
          "partial": "Unrecognized",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Unrecognized"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "VarIdent",
          "package": "yi",
          "signature": "VarIdent",
          "source": "src/Yi-Lexer-Haskell.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "VarIdent",
          "package": "yi",
          "partial": "Var Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:VarIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "Where",
          "package": "yi",
          "signature": "Where",
          "source": "src/Yi-Lexer-Haskell.html#ReservedType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "Where",
          "package": "yi",
          "partial": "Where",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:Where"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Haskell",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Haskell.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Haskell.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "isComment",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Lexer-Haskell.html#isComment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "isComment",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Comment",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:isComment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "isErrorTok",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Lexer-Haskell.html#isErrorTok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "isErrorTok",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Error Tok",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:isErrorTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "isSpecial",
          "package": "yi",
          "signature": "String -\u003e Token -\u003e Bool",
          "source": "src/Yi-Lexer-Haskell.html#isSpecial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "isSpecial",
          "normalized": "String-\u003eToken-\u003eBool",
          "package": "yi",
          "partial": "Special",
          "signature": "String-\u003eToken-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:isSpecial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "startsLayout",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Lexer-Haskell.html#startsLayout",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "startsLayout",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Layout",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:startsLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "tokenToStyle",
          "package": "yi",
          "signature": "Token -\u003e StyleName",
          "source": "src/Yi-Lexer-Haskell.html#tokenToStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "tokenToStyle",
          "normalized": "Token-\u003eStyleName",
          "package": "yi",
          "partial": "To Style",
          "signature": "Token-\u003eStyleName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:tokenToStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Haskell",
          "name": "tokenToText",
          "package": "yi",
          "signature": "Token -\u003e Maybe String",
          "source": "src/Yi-Lexer-Haskell.html#tokenToText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Haskell",
          "module": "Yi.Lexer.Haskell",
          "name": "tokenToText",
          "normalized": "Token-\u003eMaybe String",
          "package": "yi",
          "partial": "To Text",
          "signature": "Token-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Haskell.html#v:tokenToText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JSON",
          "name": "JSON",
          "package": "yi",
          "source": "src/Yi-Lexer-JSON.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer JSON",
          "module": "Yi.Lexer.JSON",
          "name": "JSON",
          "package": "yi",
          "partial": "JSON",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JSON.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JSON",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-JSON.html#Token",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer JSON",
          "module": "Yi.Lexer.JSON",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JSON.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JSON",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-JSON.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer JSON",
          "module": "Yi.Lexer.JSON",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JSON.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JSON",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-JSON.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JSON",
          "module": "Yi.Lexer.JSON",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JSON.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Java",
          "name": "Java",
          "package": "yi",
          "source": "src/Yi-Lexer-Java.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Java",
          "module": "Yi.Lexer.Java",
          "name": "Java",
          "package": "yi",
          "partial": "Java",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Java.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Java",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Java.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Java",
          "module": "Yi.Lexer.Java",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Java.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Java",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Java.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Java",
          "module": "Yi.Lexer.Java",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Java.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "source": "src/Yi-Lexer-JavaScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "partial": "Java Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eHlState\u003c/code\u003e is 0 when outside of a multi-line comment and -1 when inside one.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "HlState",
          "package": "yi",
          "source": "src/Yi-Lexer-JavaScript.html#HlState",
          "type": "type"
        },
        "index": {
          "description": "HlState is when outside of multi-line comment and when inside one",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "HlState",
          "package": "yi",
          "partial": "Hl State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#t:HlState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe constructors for \u003ccode\u003eOperator\u003c/code\u003e have an apostrophe as a suffix because\n   e.g. \u003ccode\u003eLT\u003c/code\u003e is already used by \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "Operator",
          "package": "yi",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "data"
        },
        "index": {
          "description": "The constructors for Operator have an apostrophe as suffix because e.g LT is already used by Prelude",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Operator",
          "package": "yi",
          "partial": "Operator",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#t:Operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe constructors for \u003ccode\u003eReserved\u003c/code\u003e have an apostrophe as a suffix because\n   \u003ccode\u003eDefault\u003c/code\u003e is already used.  Also note that \u003ccode\u003eUndefined'\u003c/code\u003e is not intended as\n   some sort of \u003ca\u003ebackup\u003c/a\u003e reserved word for things we don't care about -- it\n   really means the \u003ca\u003eundefined\u003c/a\u003e built-in in JavaScript.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "Reserved",
          "package": "yi",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "data"
        },
        "index": {
          "description": "The constructors for Reserved have an apostrophe as suffix because Default is already used Also note that Undefined is not intended as some sort of backup reserved word for things we don care about it really means the undefined built-in in JavaScript",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Reserved",
          "package": "yi",
          "partial": "Reserved",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#t:Reserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "TT",
          "package": "yi",
          "source": "src/Yi-Lexer-JavaScript.html#TT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "TT",
          "package": "yi",
          "partial": "TT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#t:TT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe different tokens.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "data"
        },
        "index": {
          "description": "The different tokens",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Add'",
          "package": "yi",
          "signature": "Add'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Add'",
          "package": "yi",
          "partial": "Add'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Add-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "AddAssign'",
          "package": "yi",
          "signature": "AddAssign'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "AddAssign'",
          "package": "yi",
          "partial": "Add Assign'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:AddAssign-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "And'",
          "package": "yi",
          "signature": "And'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "And'",
          "package": "yi",
          "partial": "And'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:And-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Assign'",
          "package": "yi",
          "signature": "Assign'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Assign'",
          "package": "yi",
          "partial": "Assign'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Assign-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "BitAnd'",
          "package": "yi",
          "signature": "BitAnd'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "BitAnd'",
          "package": "yi",
          "partial": "Bit And'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:BitAnd-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "BitNot'",
          "package": "yi",
          "signature": "BitNot'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "BitNot'",
          "package": "yi",
          "partial": "Bit Not'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:BitNot-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "BitOr'",
          "package": "yi",
          "signature": "BitOr'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "BitOr'",
          "package": "yi",
          "partial": "Bit Or'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:BitOr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "BitXor'",
          "package": "yi",
          "signature": "BitXor'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "BitXor'",
          "package": "yi",
          "partial": "Bit Xor'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:BitXor-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Break'",
          "package": "yi",
          "signature": "Break'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Break'",
          "package": "yi",
          "partial": "Break'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Break-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Case'",
          "package": "yi",
          "signature": "Case'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Case'",
          "package": "yi",
          "partial": "Case'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Case-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Catch'",
          "package": "yi",
          "signature": "Catch'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Catch'",
          "package": "yi",
          "partial": "Catch'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Catch-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Comment",
          "package": "yi",
          "signature": "Comment !CommentType",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Comment",
          "package": "yi",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Const",
          "package": "yi",
          "signature": "Const !String",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Const",
          "package": "yi",
          "partial": "Const",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Const"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Continue'",
          "package": "yi",
          "signature": "Continue'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Continue'",
          "package": "yi",
          "partial": "Continue'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Continue-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Decrement'",
          "package": "yi",
          "signature": "Decrement'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Decrement'",
          "package": "yi",
          "partial": "Decrement'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Decrement-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Default'",
          "package": "yi",
          "signature": "Default'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Default'",
          "package": "yi",
          "partial": "Default'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Default-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Delete'",
          "package": "yi",
          "signature": "Delete'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Delete'",
          "package": "yi",
          "partial": "Delete'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Delete-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Divide'",
          "package": "yi",
          "signature": "Divide'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Divide'",
          "package": "yi",
          "partial": "Divide'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Divide-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "DivideAssign'",
          "package": "yi",
          "signature": "DivideAssign'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "DivideAssign'",
          "package": "yi",
          "partial": "Divide Assign'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:DivideAssign-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Do'",
          "package": "yi",
          "signature": "Do'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Do'",
          "package": "yi",
          "partial": "Do'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Do-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Else'",
          "package": "yi",
          "signature": "Else'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Else'",
          "package": "yi",
          "partial": "Else'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Else-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Equals'",
          "package": "yi",
          "signature": "Equals'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Equals'",
          "package": "yi",
          "partial": "Equals'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Equals-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "EqualsType'",
          "package": "yi",
          "signature": "EqualsType'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "EqualsType'",
          "package": "yi",
          "partial": "Equals Type'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:EqualsType-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "False'",
          "package": "yi",
          "signature": "False'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "False'",
          "package": "yi",
          "partial": "False'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:False-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Finally'",
          "package": "yi",
          "signature": "Finally'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Finally'",
          "package": "yi",
          "partial": "Finally'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Finally-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "For'",
          "package": "yi",
          "signature": "For'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "For'",
          "package": "yi",
          "partial": "For'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:For-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Function'",
          "package": "yi",
          "signature": "Function'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Function'",
          "package": "yi",
          "partial": "Function'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Function-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "GT'",
          "package": "yi",
          "signature": "GT'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "GT'",
          "package": "yi",
          "partial": "GT'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:GT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "GTE'",
          "package": "yi",
          "signature": "GTE'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "GTE'",
          "package": "yi",
          "partial": "GTE'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:GTE-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "If'",
          "package": "yi",
          "signature": "If'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "If'",
          "package": "yi",
          "partial": "If'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:If-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "In'",
          "package": "yi",
          "signature": "In'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "In'",
          "package": "yi",
          "partial": "In'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:In-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Increment'",
          "package": "yi",
          "signature": "Increment'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Increment'",
          "package": "yi",
          "partial": "Increment'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Increment-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "InstanceOf'",
          "package": "yi",
          "signature": "InstanceOf'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "InstanceOf'",
          "package": "yi",
          "partial": "Instance Of'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:InstanceOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "LT'",
          "package": "yi",
          "signature": "LT'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "LT'",
          "package": "yi",
          "partial": "LT'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:LT-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "LTE'",
          "package": "yi",
          "signature": "LTE'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "LTE'",
          "package": "yi",
          "partial": "LTE'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:LTE-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "LeftShift'",
          "package": "yi",
          "signature": "LeftShift'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "LeftShift'",
          "package": "yi",
          "partial": "Left Shift'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:LeftShift-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Modulo'",
          "package": "yi",
          "signature": "Modulo'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Modulo'",
          "package": "yi",
          "partial": "Modulo'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Modulo-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "ModuloAssign'",
          "package": "yi",
          "signature": "ModuloAssign'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "ModuloAssign'",
          "package": "yi",
          "partial": "Modulo Assign'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:ModuloAssign-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Multiply'",
          "package": "yi",
          "signature": "Multiply'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Multiply'",
          "package": "yi",
          "partial": "Multiply'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Multiply-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "MultiplyAssign'",
          "package": "yi",
          "signature": "MultiplyAssign'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "MultiplyAssign'",
          "package": "yi",
          "partial": "Multiply Assign'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:MultiplyAssign-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "New'",
          "package": "yi",
          "signature": "New'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "New'",
          "package": "yi",
          "partial": "New'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:New-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Not'",
          "package": "yi",
          "signature": "Not'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Not'",
          "package": "yi",
          "partial": "Not'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Not-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "NotEquals'",
          "package": "yi",
          "signature": "NotEquals'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "NotEquals'",
          "package": "yi",
          "partial": "Not Equals'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:NotEquals-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "NotEqualsType'",
          "package": "yi",
          "signature": "NotEqualsType'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "NotEqualsType'",
          "package": "yi",
          "partial": "Not Equals Type'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:NotEqualsType-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Null'",
          "package": "yi",
          "signature": "Null'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Null'",
          "package": "yi",
          "partial": "Null'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Null-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Number",
          "package": "yi",
          "signature": "Number !String",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Number",
          "package": "yi",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Op",
          "package": "yi",
          "signature": "Op !Operator",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Op",
          "package": "yi",
          "partial": "Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Or'",
          "package": "yi",
          "signature": "Or'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Or'",
          "package": "yi",
          "partial": "Or'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Or-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Qualify'",
          "package": "yi",
          "signature": "Qualify'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Qualify'",
          "package": "yi",
          "partial": "Qualify'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Qualify-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Res",
          "package": "yi",
          "signature": "Res !Reserved",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Res",
          "package": "yi",
          "partial": "Res",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Return'",
          "package": "yi",
          "signature": "Return'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Return'",
          "package": "yi",
          "partial": "Return'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Return-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Rex",
          "package": "yi",
          "signature": "Rex !String",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Rex",
          "package": "yi",
          "partial": "Rex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Rex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "RightShift'",
          "package": "yi",
          "signature": "RightShift'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "RightShift'",
          "package": "yi",
          "partial": "Right Shift'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:RightShift-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "RightShiftZ'",
          "package": "yi",
          "signature": "RightShiftZ'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "RightShiftZ'",
          "package": "yi",
          "partial": "Right Shift Z'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:RightShiftZ-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Special",
          "package": "yi",
          "signature": "Special !Char",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Special",
          "package": "yi",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Str",
          "package": "yi",
          "signature": "Str !String",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Str",
          "package": "yi",
          "partial": "Str",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Str"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Subtract'",
          "package": "yi",
          "signature": "Subtract'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Subtract'",
          "package": "yi",
          "partial": "Subtract'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Subtract-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "SubtractAssign'",
          "package": "yi",
          "signature": "SubtractAssign'",
          "source": "src/Yi-Lexer-JavaScript.html#Operator",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "SubtractAssign'",
          "package": "yi",
          "partial": "Subtract Assign'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:SubtractAssign-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Switch'",
          "package": "yi",
          "signature": "Switch'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Switch'",
          "package": "yi",
          "partial": "Switch'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Switch-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "This'",
          "package": "yi",
          "signature": "This'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "This'",
          "package": "yi",
          "partial": "This'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:This-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Throw'",
          "package": "yi",
          "signature": "Throw'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Throw'",
          "package": "yi",
          "partial": "Throw'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Throw-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "True'",
          "package": "yi",
          "signature": "True'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "True'",
          "package": "yi",
          "partial": "True'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:True-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Try'",
          "package": "yi",
          "signature": "Try'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Try'",
          "package": "yi",
          "partial": "Try'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Try-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "TypeOf'",
          "package": "yi",
          "signature": "TypeOf'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "TypeOf'",
          "package": "yi",
          "partial": "Type Of'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:TypeOf-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Undefined'",
          "package": "yi",
          "signature": "Undefined'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Undefined'",
          "package": "yi",
          "partial": "Undefined'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Undefined-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Unknown",
          "package": "yi",
          "signature": "Unknown",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Unknown",
          "package": "yi",
          "partial": "Unknown",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Unknown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "ValidName",
          "package": "yi",
          "signature": "ValidName !String",
          "source": "src/Yi-Lexer-JavaScript.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "ValidName",
          "package": "yi",
          "partial": "Valid Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:ValidName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Var'",
          "package": "yi",
          "signature": "Var'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Var'",
          "package": "yi",
          "partial": "Var'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Var-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "Void'",
          "package": "yi",
          "signature": "Void'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "Void'",
          "package": "yi",
          "partial": "Void'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:Void-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "While'",
          "package": "yi",
          "signature": "While'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "While'",
          "package": "yi",
          "partial": "While'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:While-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "With'",
          "package": "yi",
          "signature": "With'",
          "source": "src/Yi-Lexer-JavaScript.html#Reserved",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "With'",
          "package": "yi",
          "partial": "With'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:With-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-JavaScript.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInfix operators.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "infixOperators",
          "package": "yi",
          "signature": "[Operator]",
          "source": "src/Yi-Lexer-JavaScript.html#infixOperators",
          "type": "function"
        },
        "index": {
          "description": "Infix operators",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "infixOperators",
          "normalized": "[Operator]",
          "package": "yi",
          "partial": "Operators",
          "signature": "[Operator]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:infixOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.JavaScript",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-JavaScript.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePostfix operators.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "postfixOperators",
          "package": "yi",
          "signature": "[Operator]",
          "source": "src/Yi-Lexer-JavaScript.html#postfixOperators",
          "type": "function"
        },
        "index": {
          "description": "Postfix operators",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "postfixOperators",
          "normalized": "[Operator]",
          "package": "yi",
          "partial": "Operators",
          "signature": "[Operator]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:postfixOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrefix operators.  NOTE: Add' is also a valid prefix operator, but since\n   it's completely useless in the real world, we don't care about it here.\n   Doing this makes parsing much, much easier.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "prefixOperators",
          "package": "yi",
          "signature": "[Operator]",
          "source": "src/Yi-Lexer-JavaScript.html#prefixOperators",
          "type": "function"
        },
        "index": {
          "description": "Prefix operators NOTE Add is also valid prefix operator but since it completely useless in the real world we don care about it here Doing this makes parsing much much easier",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "prefixOperators",
          "normalized": "[Operator]",
          "package": "yi",
          "partial": "Operators",
          "signature": "[Operator]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:prefixOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTakes a \u003ccode\u003e\u003ca\u003eToken\u003c/a\u003e\u003c/code\u003e and returns a style to be used for that type of token.\n\u003c/p\u003e\u003cp\u003eTODO: The \u003ccode\u003e\u003ca\u003eelem\u003c/a\u003e\u003c/code\u003e check is potentially unnecessarily slow.  We could split\n   the Const constructor into two different ones, one for builtins and one for\n   others.\n\u003c/p\u003e",
          "module": "Yi.Lexer.JavaScript",
          "name": "tokenToStyle",
          "package": "yi",
          "signature": "Token -\u003e UIStyle -\u003e Style",
          "source": "src/Yi-Lexer-JavaScript.html#tokenToStyle",
          "type": "function"
        },
        "index": {
          "description": "Takes Token and returns style to be used for that type of token TODO The elem check is potentially unnecessarily slow We could split the Const constructor into two different ones one for builtins and one for others",
          "hierarchy": "Yi Lexer JavaScript",
          "module": "Yi.Lexer.JavaScript",
          "name": "tokenToStyle",
          "normalized": "Token-\u003eUIStyle-\u003eStyle",
          "package": "yi",
          "partial": "To Style",
          "signature": "Token-\u003eUIStyle-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-JavaScript.html#v:tokenToStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Latex",
          "package": "yi",
          "source": "src/Yi-Lexer-Latex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Latex",
          "package": "yi",
          "partial": "Latex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "HlState",
          "package": "yi",
          "source": "src/Yi-Lexer-Latex.html#HlState",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "HlState",
          "package": "yi",
          "partial": "Hl State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#t:HlState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Begin",
          "package": "yi",
          "signature": "Begin !String",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Begin",
          "package": "yi",
          "partial": "Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:Begin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Command",
          "package": "yi",
          "signature": "Command !String",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Command",
          "package": "yi",
          "partial": "Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:Command"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Comment",
          "package": "yi",
          "signature": "Comment",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Comment",
          "package": "yi",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "End",
          "package": "yi",
          "signature": "End !String",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "End",
          "package": "yi",
          "partial": "End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:End"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "NewCommand",
          "package": "yi",
          "signature": "NewCommand",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "NewCommand",
          "package": "yi",
          "partial": "New Command",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:NewCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Special",
          "package": "yi",
          "signature": "Special !Char",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Special",
          "package": "yi",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "Text",
          "package": "yi",
          "signature": "Text",
          "source": "src/Yi-Lexer-Latex.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "Text",
          "package": "yi",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:Text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Latex",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Latex.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Latex.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Latex",
          "name": "tokenToText",
          "package": "yi",
          "signature": "Token -\u003e Maybe [Char]",
          "source": "src/Yi-Lexer-Latex.html#tokenToText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Latex",
          "module": "Yi.Lexer.Latex",
          "name": "tokenToText",
          "normalized": "Token-\u003eMaybe[Char]",
          "package": "yi",
          "partial": "To Text",
          "signature": "Token-\u003eMaybe[Char]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Latex.html#v:tokenToText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "LiterateHaskell",
          "package": "yi",
          "source": "src/Yi-Lexer-LiterateHaskell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer LiterateHaskell",
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "LiterateHaskell",
          "package": "yi",
          "partial": "Literate Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-LiterateHaskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "HlState",
          "package": "yi",
          "source": "src/Yi-Lexer-LiterateHaskell.html#HlState",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer LiterateHaskell",
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "HlState",
          "package": "yi",
          "partial": "Hl State",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-LiterateHaskell.html#t:HlState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-LiterateHaskell.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer LiterateHaskell",
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-LiterateHaskell.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-LiterateHaskell.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer LiterateHaskell",
          "module": "Yi.Lexer.LiterateHaskell",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-LiterateHaskell.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "OCaml",
          "package": "yi",
          "source": "src/Yi-Lexer-OCaml.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "OCaml",
          "package": "yi",
          "partial": "OCaml",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "Token",
          "package": "yi",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "Token",
          "package": "yi",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "CharTok",
          "package": "yi",
          "signature": "CharTok",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "CharTok",
          "package": "yi",
          "partial": "Char Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:CharTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "Comment",
          "package": "yi",
          "signature": "Comment",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "Comment",
          "package": "yi",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "ConsIdent",
          "package": "yi",
          "signature": "ConsIdent",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "ConsIdent",
          "package": "yi",
          "partial": "Cons Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:ConsIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "ConsOperator",
          "package": "yi",
          "signature": "ConsOperator",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "ConsOperator",
          "package": "yi",
          "partial": "Cons Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:ConsOperator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "IndentReserved",
          "package": "yi",
          "signature": "IndentReserved",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "IndentReserved",
          "package": "yi",
          "partial": "Indent Reserved",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:IndentReserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "Number",
          "package": "yi",
          "signature": "Number",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "Number",
          "package": "yi",
          "partial": "Number",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:Number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "Operator",
          "package": "yi",
          "signature": "Operator",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "Operator",
          "package": "yi",
          "partial": "Operator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:Operator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "Reserved",
          "package": "yi",
          "signature": "Reserved",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "Reserved",
          "package": "yi",
          "partial": "Reserved",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:Reserved"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "ReservedOp",
          "package": "yi",
          "signature": "ReservedOp",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "ReservedOp",
          "package": "yi",
          "partial": "Reserved Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:ReservedOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "Special",
          "package": "yi",
          "signature": "Special Char",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "Special",
          "package": "yi",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "StringTok",
          "package": "yi",
          "signature": "StringTok",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "StringTok",
          "package": "yi",
          "partial": "String Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:StringTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "VarIdent",
          "package": "yi",
          "signature": "VarIdent",
          "source": "src/Yi-Lexer-OCaml.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "VarIdent",
          "package": "yi",
          "partial": "Var Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:VarIdent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.OCaml",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-OCaml.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-OCaml.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.OCaml",
          "name": "tokenToStyle",
          "package": "yi",
          "signature": "Token -\u003e StyleName",
          "source": "src/Yi-Lexer-OCaml.html#tokenToStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer OCaml",
          "module": "Yi.Lexer.OCaml",
          "name": "tokenToStyle",
          "normalized": "Token-\u003eStyleName",
          "package": "yi",
          "partial": "To Style",
          "signature": "Token-\u003eStyleName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-OCaml.html#v:tokenToStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.ObjectiveC",
          "name": "ObjectiveC",
          "package": "yi",
          "source": "src/Yi-Lexer-ObjectiveC.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer ObjectiveC",
          "module": "Yi.Lexer.ObjectiveC",
          "name": "ObjectiveC",
          "package": "yi",
          "partial": "Objective",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-ObjectiveC.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.ObjectiveC",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-ObjectiveC.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer ObjectiveC",
          "module": "Yi.Lexer.ObjectiveC",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-ObjectiveC.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.ObjectiveC",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-ObjectiveC.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer ObjectiveC",
          "module": "Yi.Lexer.ObjectiveC",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-ObjectiveC.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Ott",
          "name": "Ott",
          "package": "yi",
          "source": "src/Yi-Lexer-Ott.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Ott",
          "module": "Yi.Lexer.Ott",
          "name": "Ott",
          "package": "yi",
          "partial": "Ott",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Ott.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Ott",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Ott.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Ott",
          "module": "Yi.Lexer.Ott",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Ott.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Ott",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Ott.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Ott",
          "module": "Yi.Lexer.Ott",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Ott.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Perl",
          "name": "Perl",
          "package": "yi",
          "source": "src/Yi-Lexer-Perl.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Perl",
          "module": "Yi.Lexer.Perl",
          "name": "Perl",
          "package": "yi",
          "partial": "Perl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Perl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Perl",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Perl.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Perl",
          "module": "Yi.Lexer.Perl",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Perl.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Perl",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Perl.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Perl",
          "module": "Yi.Lexer.Perl",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Perl.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Python",
          "name": "Python",
          "package": "yi",
          "source": "src/Yi-Lexer-Python.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Python",
          "module": "Yi.Lexer.Python",
          "name": "Python",
          "package": "yi",
          "partial": "Python",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Python.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Python",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Python.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Python",
          "module": "Yi.Lexer.Python",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Python.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Python",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Python.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Python",
          "module": "Yi.Lexer.Python",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Python.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Ruby",
          "name": "Ruby",
          "package": "yi",
          "source": "src/Yi-Lexer-Ruby.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Ruby",
          "module": "Yi.Lexer.Ruby",
          "name": "Ruby",
          "package": "yi",
          "partial": "Ruby",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Ruby.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Ruby",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Ruby.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Ruby",
          "module": "Yi.Lexer.Ruby",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Ruby.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Ruby",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Ruby.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Ruby",
          "module": "Yi.Lexer.Ruby",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Ruby.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.SVNCommit",
          "name": "SVNCommit",
          "package": "yi",
          "source": "src/Yi-Lexer-SVNCommit.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer SVNCommit",
          "module": "Yi.Lexer.SVNCommit",
          "name": "SVNCommit",
          "package": "yi",
          "partial": "SVNCommit",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-SVNCommit.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.SVNCommit",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-SVNCommit.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer SVNCommit",
          "module": "Yi.Lexer.SVNCommit",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-SVNCommit.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.SVNCommit",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-SVNCommit.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer SVNCommit",
          "module": "Yi.Lexer.SVNCommit",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-SVNCommit.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Srmc",
          "name": "Srmc",
          "package": "yi",
          "source": "src/Yi-Lexer-Srmc.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Srmc",
          "module": "Yi.Lexer.Srmc",
          "name": "Srmc",
          "package": "yi",
          "partial": "Srmc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Srmc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Srmc",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Srmc.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Srmc",
          "module": "Yi.Lexer.Srmc",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Srmc.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Srmc",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Srmc.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Srmc",
          "module": "Yi.Lexer.Srmc",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Srmc.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Whitespace",
          "name": "Whitespace",
          "package": "yi",
          "source": "src/Yi-Lexer-Whitespace.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Lexer Whitespace",
          "module": "Yi.Lexer.Whitespace",
          "name": "Whitespace",
          "package": "yi",
          "partial": "Whitespace",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Whitespace.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eScan one token. Return (maybe) a token and a new state.\n\u003c/p\u003e",
          "module": "Yi.Lexer.Whitespace",
          "name": "alexScanToken",
          "package": "yi",
          "signature": "(AlexState HlState, AlexInput) -\u003e Maybe (Tok Token, (AlexState HlState, AlexInput))",
          "source": "src/Yi-Lexer-Whitespace.html#alexScanToken",
          "type": "function"
        },
        "index": {
          "description": "Scan one token Return maybe token and new state",
          "hierarchy": "Yi Lexer Whitespace",
          "module": "Yi.Lexer.Whitespace",
          "name": "alexScanToken",
          "normalized": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "package": "yi",
          "partial": "Scan Token",
          "signature": "(AlexState HlState,AlexInput)-\u003eMaybe(Tok Token,(AlexState HlState,AlexInput))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Whitespace.html#v:alexScanToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Lexer.Whitespace",
          "name": "initState",
          "package": "yi",
          "signature": "HlState",
          "source": "src/Yi-Lexer-Whitespace.html#initState",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Lexer Whitespace",
          "module": "Yi.Lexer.Whitespace",
          "name": "initState",
          "package": "yi",
          "partial": "State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Lexer-Whitespace.html#v:initState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is the main module of Yi, called with configuration from the user.\n Here we mainly process command line arguments.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Main",
          "name": "Main",
          "package": "yi",
          "source": "src/Yi-Main.html",
          "type": "module"
        },
        "index": {
          "description": "This is the main module of Yi called with configuration from the user Here we mainly process command line arguments",
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "Main",
          "package": "yi",
          "partial": "Main",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConfiguration information which can be set in the command-line, but not\n in the user's configuration file.\n\u003c/p\u003e",
          "module": "Yi.Main",
          "name": "ConsoleConfig",
          "package": "yi",
          "source": "src/Yi-Main.html#ConsoleConfig",
          "type": "data"
        },
        "index": {
          "description": "Configuration information which can be set in the command-line but not in the user configuration file",
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "ConsoleConfig",
          "package": "yi",
          "partial": "Console Config",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#t:ConsoleConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Main",
          "name": "Err",
          "package": "yi",
          "source": "src/Yi-Main.html#Err",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "Err",
          "package": "yi",
          "partial": "Err",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#t:Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Main",
          "name": "ConsoleConfig",
          "package": "yi",
          "signature": "ConsoleConfig",
          "source": "src/Yi-Main.html#ConsoleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "ConsoleConfig",
          "package": "yi",
          "partial": "Console Config",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#v:ConsoleConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Main",
          "name": "Err",
          "package": "yi",
          "signature": "Err String ExitCode",
          "source": "src/Yi-Main.html#Err",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "Err",
          "package": "yi",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#v:Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform the config with options\n\u003c/p\u003e",
          "module": "Yi.Main",
          "name": "do_args",
          "package": "yi",
          "signature": "Config -\u003e [String] -\u003e Either Err (Config, ConsoleConfig)",
          "source": "src/Yi-Main.html#do_args",
          "type": "function"
        },
        "index": {
          "description": "Transform the config with options",
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "do_args",
          "normalized": "Config-\u003e[String]-\u003eEither Err(Config,ConsoleConfig)",
          "package": "yi",
          "signature": "Config-\u003e[String]-\u003eEither Err(Config,ConsoleConfig)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#v:do_args"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Main",
          "name": "ghcOptions",
          "package": "yi",
          "signature": "[String]",
          "source": "src/Yi-Main.html#ConsoleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "ghcOptions",
          "normalized": "[String]",
          "package": "yi",
          "partial": "Options",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#v:ghcOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic main. This is the front end to the statically linked\n application, and the real front end, in a sense. \u003ccode\u003edynamic_main\u003c/code\u003e calls\n this after setting preferences passed from the boot loader.\n\u003c/p\u003e",
          "module": "Yi.Main",
          "name": "main",
          "package": "yi",
          "signature": "(Config, ConsoleConfig) -\u003e Maybe Editor -\u003e IO ()",
          "source": "src/Yi-Main.html#main",
          "type": "function"
        },
        "index": {
          "description": "Static main This is the front end to the statically linked application and the real front end in sense dynamic main calls this after setting preferences passed from the boot loader",
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "main",
          "normalized": "(Config,ConsoleConfig)-\u003eMaybe Editor-\u003eIO()",
          "package": "yi",
          "signature": "(Config,ConsoleConfig)-\u003eMaybe Editor-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Main",
          "name": "selfCheck",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Main.html#ConsoleConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Main",
          "module": "Yi.Main",
          "name": "selfCheck",
          "package": "yi",
          "partial": "Check",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Main.html#v:selfCheck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "MiniBuffer",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "MiniBuffer",
          "package": "yi",
          "partial": "Mini Buffer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTag a type with a documentation\n\u003c/p\u003e",
          "module": "Yi.MiniBuffer",
          "name": ":::",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html#%3A%3A%3A",
          "type": "newtype"
        },
        "index": {
          "description": "Tag type with documentation",
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": ":::",
          "package": "yi",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#t::::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "CommandArguments",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html#CommandArguments",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "CommandArguments",
          "package": "yi",
          "partial": "Command Arguments",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#t:CommandArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "FilePatternTag",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html#FilePatternTag",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "FilePatternTag",
          "package": "yi",
          "partial": "File Pattern Tag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#t:FilePatternTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "LineNumber",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html#LineNumber",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "LineNumber",
          "package": "yi",
          "partial": "Line Number",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#t:LineNumber"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "RegexTag",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html#RegexTag",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "RegexTag",
          "package": "yi",
          "partial": "Regex Tag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#t:RegexTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "ToKill",
          "package": "yi",
          "source": "src/Yi-MiniBuffer.html#ToKill",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "ToKill",
          "package": "yi",
          "partial": "To Kill",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#t:ToKill"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "CommandArguments",
          "package": "yi",
          "signature": "CommandArguments [String]",
          "source": "src/Yi-MiniBuffer.html#CommandArguments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "CommandArguments",
          "normalized": "CommandArguments[String]",
          "package": "yi",
          "partial": "Command Arguments",
          "signature": "CommandArguments[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:CommandArguments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "Doc",
          "package": "yi",
          "signature": "Doc",
          "source": "src/Yi-MiniBuffer.html#%3A%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "Doc",
          "package": "yi",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:Doc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "anyModeByName",
          "package": "yi",
          "signature": "String -\u003e YiM AnyMode",
          "source": "src/Yi-MiniBuffer.html#anyModeByName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "anyModeByName",
          "normalized": "String-\u003eYiM AnyMode",
          "package": "yi",
          "partial": "Mode By Name",
          "signature": "String-\u003eYiM AnyMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:anyModeByName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "anyModeByNameM",
          "package": "yi",
          "signature": "String -\u003e YiM (Maybe AnyMode)",
          "source": "src/Yi-MiniBuffer.html#anyModeByNameM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "anyModeByNameM",
          "normalized": "String-\u003eYiM(Maybe AnyMode)",
          "package": "yi",
          "partial": "Mode By Name",
          "signature": "String-\u003eYiM(Maybe AnyMode)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:anyModeByNameM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "anyModeName",
          "package": "yi",
          "signature": "AnyMode -\u003e String",
          "source": "src/Yi-MiniBuffer.html#anyModeName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "anyModeName",
          "normalized": "AnyMode-\u003eString",
          "package": "yi",
          "partial": "Mode Name",
          "signature": "AnyMode-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:anyModeName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "fromDoc",
          "package": "yi",
          "signature": "t",
          "source": "src/Yi-MiniBuffer.html#%3A%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "fromDoc",
          "package": "yi",
          "partial": "Doc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:fromDoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "getAllModeNames",
          "package": "yi",
          "signature": "YiM [String]",
          "source": "src/Yi-MiniBuffer.html#getAllModeNames",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "getAllModeNames",
          "normalized": "YiM[String]",
          "package": "yi",
          "partial": "All Mode Names",
          "signature": "YiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:getAllModeNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "infixComplete",
          "package": "yi",
          "signature": "(String -\u003e YiM [String]) -\u003e String -\u003e YiM String",
          "source": "src/Yi-MiniBuffer.html#infixComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "infixComplete",
          "normalized": "(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "Complete",
          "signature": "(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:infixComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "infixComplete'",
          "package": "yi",
          "signature": "Bool -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e YiM String",
          "source": "src/Yi-MiniBuffer.html#infixComplete%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "infixComplete'",
          "normalized": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "Complete'",
          "signature": "Bool-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:infixComplete-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns all the buffer names.\n\u003c/p\u003e",
          "module": "Yi.MiniBuffer",
          "name": "matchingBufferNames",
          "package": "yi",
          "signature": "String -\u003e YiM [String]",
          "source": "src/Yi-MiniBuffer.html#matchingBufferNames",
          "type": "function"
        },
        "index": {
          "description": "Returns all the buffer names",
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "matchingBufferNames",
          "normalized": "String-\u003eYiM[String]",
          "package": "yi",
          "partial": "Buffer Names",
          "signature": "String-\u003eYiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:matchingBufferNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "mkCompleteFn",
          "package": "yi",
          "signature": "(String -\u003e (String -\u003e Maybe String) -\u003e [String] -\u003e EditorM String) -\u003e (String -\u003e String -\u003e Maybe String) -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e YiM String",
          "source": "src/Yi-MiniBuffer.html#mkCompleteFn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "mkCompleteFn",
          "normalized": "(String-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String)-\u003e(String-\u003eString-\u003eMaybe String)-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "Complete Fn",
          "signature": "(String-\u003e(String-\u003eMaybe String)-\u003e[String]-\u003eEditorM String)-\u003e(String-\u003eString-\u003eMaybe String)-\u003e(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:mkCompleteFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "noHint",
          "package": "yi",
          "signature": "String -\u003e YiM [String]",
          "source": "src/Yi-MiniBuffer.html#noHint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "noHint",
          "normalized": "String-\u003eYiM[String]",
          "package": "yi",
          "partial": "Hint",
          "signature": "String-\u003eYiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:noHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "noPossibilities",
          "package": "yi",
          "signature": "String -\u003e YiM [String]",
          "source": "src/Yi-MiniBuffer.html#noPossibilities",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "noPossibilities",
          "normalized": "String-\u003eYiM[String]",
          "package": "yi",
          "partial": "Possibilities",
          "signature": "String-\u003eYiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:noPossibilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "simpleComplete",
          "package": "yi",
          "signature": "(String -\u003e YiM [String]) -\u003e String -\u003e YiM String",
          "source": "src/Yi-MiniBuffer.html#simpleComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "simpleComplete",
          "normalized": "(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "Complete",
          "signature": "(String-\u003eYiM[String])-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:simpleComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen a minibuffer window with the given prompt and keymap\n The third argument is an action to perform after the minibuffer\n is opened such as move to the first occurence of a searched for\n string. If you don't need this just supply \u003ccode\u003ereturn ()\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.MiniBuffer",
          "name": "spawnMinibufferE",
          "package": "yi",
          "signature": "String -\u003e KeymapEndo -\u003e EditorM BufferRef",
          "source": "src/Yi-MiniBuffer.html#spawnMinibufferE",
          "type": "function"
        },
        "index": {
          "description": "Open minibuffer window with the given prompt and keymap The third argument is an action to perform after the minibuffer is opened such as move to the first occurence of searched for string If you don need this just supply return",
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "spawnMinibufferE",
          "normalized": "String-\u003eKeymapEndo-\u003eEditorM BufferRef",
          "package": "yi",
          "partial": "Minibuffer",
          "signature": "String-\u003eKeymapEndo-\u003eEditorM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:spawnMinibufferE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen a minibuffer, given a finite number of suggestions.\n\u003c/p\u003e",
          "module": "Yi.MiniBuffer",
          "name": "withMinibufferFin",
          "package": "yi",
          "signature": "String -\u003e [String] -\u003e (String -\u003e YiM ()) -\u003e YiM ()",
          "source": "src/Yi-MiniBuffer.html#withMinibufferFin",
          "type": "function"
        },
        "index": {
          "description": "Open minibuffer given finite number of suggestions",
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "withMinibufferFin",
          "normalized": "String-\u003e[String]-\u003e(String-\u003eYiM())-\u003eYiM()",
          "package": "yi",
          "partial": "Minibuffer Fin",
          "signature": "String-\u003e[String]-\u003e(String-\u003eYiM())-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:withMinibufferFin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.MiniBuffer",
          "name": "withMinibufferFree",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e YiM ()) -\u003e YiM ()",
          "source": "src/Yi-MiniBuffer.html#withMinibufferFree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "withMinibufferFree",
          "normalized": "String-\u003e(String-\u003eYiM())-\u003eYiM()",
          "package": "yi",
          "partial": "Minibuffer Free",
          "signature": "String-\u003e(String-\u003eYiM())-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:withMinibufferFree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ewithMinibufferGen proposal getHint prompt completer act\u003c/code\u003e: open a minibuffer\n with \u003ccode\u003eprompt\u003c/code\u003e, and initial content \u003ccode\u003eproposal\u003c/code\u003e. Once a string \u003ccode\u003es\u003c/code\u003e is obtained,\n run \u003ccode\u003eact s\u003c/code\u003e. \u003ccode\u003ecompleter\u003c/code\u003e can be used to complete inputs by returning an\n incrementally better match, and getHint can give an immediate feedback to the\n user on the current input.\n\u003c/p\u003e",
          "module": "Yi.MiniBuffer",
          "name": "withMinibufferGen",
          "package": "yi",
          "signature": "String -\u003e (String -\u003e YiM [String]) -\u003e String -\u003e (String -\u003e YiM String) -\u003e (String -\u003e YiM ()) -\u003e YiM ()",
          "source": "src/Yi-MiniBuffer.html#withMinibufferGen",
          "type": "function"
        },
        "index": {
          "description": "withMinibufferGen proposal getHint prompt completer act open minibuffer with prompt and initial content proposal Once string is obtained run act completer can be used to complete inputs by returning an incrementally better match and getHint can give an immediate feedback to the user on the current input",
          "hierarchy": "Yi MiniBuffer",
          "module": "Yi.MiniBuffer",
          "name": "withMinibufferGen",
          "normalized": "String-\u003e(String-\u003eYiM[String])-\u003eString-\u003e(String-\u003eYiM String)-\u003e(String-\u003eYiM())-\u003eYiM()",
          "package": "yi",
          "partial": "Minibuffer Gen",
          "signature": "String-\u003e(String-\u003eYiM[String])-\u003eString-\u003e(String-\u003eYiM String)-\u003e(String-\u003eYiM())-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-MiniBuffer.html#v:withMinibufferGen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eVarious high-level functions to further classify.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Misc",
          "name": "Misc",
          "package": "yi",
          "source": "src/Yi-Misc.html",
          "type": "module"
        },
        "index": {
          "description": "Various high-level functions to further classify",
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "Misc",
          "package": "yi",
          "partial": "Misc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Misc",
          "name": "adjBlock",
          "package": "yi",
          "signature": "Int -\u003e BufferM ()",
          "source": "src/Yi-Misc.html#adjBlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "adjBlock",
          "normalized": "Int-\u003eBufferM()",
          "package": "yi",
          "partial": "Block",
          "signature": "Int-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:adjBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA simple wrapper to adjust the current indentation using\n the mode specific indentation function but according to the\n given indent behaviour.\n\u003c/p\u003e",
          "module": "Yi.Misc",
          "name": "adjIndent",
          "package": "yi",
          "signature": "IndentBehaviour -\u003e BufferM ()",
          "source": "src/Yi-Misc.html#adjIndent",
          "type": "function"
        },
        "index": {
          "description": "simple wrapper to adjust the current indentation using the mode specific indentation function but according to the given indent behaviour",
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "adjIndent",
          "normalized": "IndentBehaviour-\u003eBufferM()",
          "package": "yi",
          "partial": "Indent",
          "signature": "IndentBehaviour-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:adjIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Misc",
          "name": "completeFile",
          "package": "yi",
          "signature": "String -\u003e String -\u003e YiM String",
          "source": "src/Yi-Misc.html#completeFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "completeFile",
          "normalized": "String-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "File",
          "signature": "String-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:completeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor use as the hint when opening a file using the minibuffer.\n We essentially return all the files in the given directory which\n have the given prefix.\n\u003c/p\u003e",
          "module": "Yi.Misc",
          "name": "findFileHint",
          "package": "yi",
          "signature": "String -\u003e String -\u003e YiM [String]",
          "source": "src/Yi-Misc.html#findFileHint",
          "type": "function"
        },
        "index": {
          "description": "For use as the hint when opening file using the minibuffer We essentially return all the files in the given directory which have the given prefix",
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "findFileHint",
          "normalized": "String-\u003eString-\u003eYiM[String]",
          "package": "yi",
          "partial": "File Hint",
          "signature": "String-\u003eString-\u003eYiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:findFileHint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a possible starting path (which if not given defaults to\n   the current directory) and a fragment of a path we find all\n   files within the given (or current) directory which can complete\n   the given path fragment.\n   We return a pair of both directory plus the filenames on their own\n   that is without their directories. The reason for this is that if\n   we return all of the filenames then we get a \u003ccode\u003ehint\u003c/code\u003e which is way too\n   long to be particularly useful.\n\u003c/p\u003e",
          "module": "Yi.Misc",
          "name": "getAppropriateFiles",
          "package": "yi",
          "signature": "Maybe String -\u003e String -\u003e YiM (String, [String])",
          "source": "src/Yi-Misc.html#getAppropriateFiles",
          "type": "function"
        },
        "index": {
          "description": "Given possible starting path which if not given defaults to the current directory and fragment of path we find all files within the given or current directory which can complete the given path fragment We return pair of both directory plus the filenames on their own that is without their directories The reason for this is that if we return all of the filenames then we get hint which is way too long to be particularly useful",
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "getAppropriateFiles",
          "normalized": "Maybe String-\u003eString-\u003eYiM(String,[String])",
          "package": "yi",
          "partial": "Appropriate Files",
          "signature": "Maybe String-\u003eString-\u003eYiM(String,[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:getAppropriateFiles"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a path, trim the file name bit if it exists.  If no path\n   given, return current directory.\n\u003c/p\u003e",
          "module": "Yi.Misc",
          "name": "getFolder",
          "package": "yi",
          "signature": "Maybe String -\u003e IO String",
          "source": "src/Yi-Misc.html#getFolder",
          "type": "function"
        },
        "index": {
          "description": "Given path trim the file name bit if it exists If no path given return current directory",
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "getFolder",
          "normalized": "Maybe String-\u003eIO String",
          "package": "yi",
          "partial": "Folder",
          "signature": "Maybe String-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:getFolder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Misc",
          "name": "matchFile",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Maybe String",
          "source": "src/Yi-Misc.html#matchFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "matchFile",
          "normalized": "String-\u003eString-\u003eMaybe String",
          "package": "yi",
          "partial": "File",
          "signature": "String-\u003eString-\u003eMaybe String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:matchFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a possible path and a prefix, return matching file names.\n\u003c/p\u003e",
          "module": "Yi.Misc",
          "name": "matchingFileNames",
          "package": "yi",
          "signature": "Maybe String -\u003e String -\u003e YiM [String]",
          "source": "src/Yi-Misc.html#matchingFileNames",
          "type": "function"
        },
        "index": {
          "description": "Given possible path and prefix return matching file names",
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "matchingFileNames",
          "normalized": "Maybe String-\u003eString-\u003eYiM[String]",
          "package": "yi",
          "partial": "File Names",
          "signature": "Maybe String-\u003eString-\u003eYiM[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:matchingFileNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Misc",
          "name": "onCharLetterCode",
          "package": "yi",
          "signature": "(Int -\u003e Int) -\u003e Char -\u003e Char",
          "source": "src/Yi-Misc.html#onCharLetterCode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "onCharLetterCode",
          "normalized": "(Int-\u003eInt)-\u003eChar-\u003eChar",
          "package": "yi",
          "partial": "Char Letter Code",
          "signature": "(Int-\u003eInt)-\u003eChar-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:onCharLetterCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Misc",
          "name": "printFileInfoE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Misc.html#printFileInfoE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "printFileInfoE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "File Info",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:printFileInfoE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Misc",
          "name": "rot13Char",
          "package": "yi",
          "signature": "Char -\u003e Char",
          "source": "src/Yi-Misc.html#rot13Char",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Misc",
          "module": "Yi.Misc",
          "name": "rot13Char",
          "normalized": "Char-\u003eChar",
          "package": "yi",
          "partial": "Char",
          "signature": "Char-\u003eChar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Misc.html#v:rot13Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Abella",
          "name": "Abella",
          "package": "yi",
          "source": "src/Yi-Mode-Abella.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "Abella",
          "package": "yi",
          "partial": "Abella",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStart Abella in a buffer\n\u003c/p\u003e",
          "module": "Yi.Mode.Abella",
          "name": "abella",
          "package": "yi",
          "signature": "CommandArguments -\u003e YiM BufferRef",
          "source": "src/Yi-Mode-Abella.html#abella",
          "type": "function"
        },
        "index": {
          "description": "Start Abella in buffer",
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abella",
          "normalized": "CommandArguments-\u003eYiM BufferRef",
          "package": "yi",
          "signature": "CommandArguments-\u003eYiM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abella"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Abella",
          "name": "abellaEval",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Abella.html#abellaEval",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaEval",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Eval",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaEval"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Abella",
          "name": "abellaEvalFromProofPoint",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Abella.html#abellaEvalFromProofPoint",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaEvalFromProofPoint",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Eval From Proof Point",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaEvalFromProofPoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn Abella's buffer; create it if necessary.\n Show it in another window.\n\u003c/p\u003e",
          "module": "Yi.Mode.Abella",
          "name": "abellaGet",
          "package": "yi",
          "signature": "YiM BufferRef",
          "source": "src/Yi-Mode-Abella.html#abellaGet",
          "type": "function"
        },
        "index": {
          "description": "Return Abella buffer create it if necessary Show it in another window",
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaGet",
          "package": "yi",
          "partial": "Get",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Abella",
          "name": "abellaModeEmacs",
          "package": "yi",
          "signature": "TokenBasedMode Token",
          "source": "src/Yi-Mode-Abella.html#abellaModeEmacs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaModeEmacs",
          "package": "yi",
          "partial": "Mode Emacs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaModeEmacs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Abella",
          "name": "abellaModeVim",
          "package": "yi",
          "signature": "TokenBasedMode Token",
          "source": "src/Yi-Mode-Abella.html#abellaModeVim",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaModeVim",
          "package": "yi",
          "partial": "Mode Vim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaModeVim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend a command to Abella\n\u003c/p\u003e",
          "module": "Yi.Mode.Abella",
          "name": "abellaSend",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Mode-Abella.html#abellaSend",
          "type": "function"
        },
        "index": {
          "description": "Send command to Abella",
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaSend",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Send",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaSend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Abella",
          "name": "abellaUndo",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Abella.html#abellaUndo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Abella",
          "module": "Yi.Mode.Abella",
          "name": "abellaUndo",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Undo",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Abella.html#v:abellaUndo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Buffers",
          "name": "Buffers",
          "package": "yi",
          "source": "src/Yi-Mode-Buffers.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode Buffers",
          "module": "Yi.Mode.Buffers",
          "name": "Buffers",
          "package": "yi",
          "partial": "Buffers",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Buffers.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Buffers",
          "name": "listBuffers",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Buffers.html#listBuffers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Buffers",
          "module": "Yi.Mode.Buffers",
          "name": "listBuffers",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Buffers",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Buffers.html#v:listBuffers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Compilation",
          "name": "Compilation",
          "package": "yi",
          "source": "src/Yi-Mode-Compilation.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode Compilation",
          "module": "Yi.Mode.Compilation",
          "name": "Compilation",
          "package": "yi",
          "partial": "Compilation",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Compilation.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Compilation",
          "name": "mode",
          "package": "yi",
          "signature": "Mode (Tree (Tok Token))",
          "source": "src/Yi-Mode-Compilation.html#mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Compilation",
          "module": "Yi.Mode.Compilation",
          "name": "mode",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Compilation.html#v:mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "Dollarify",
          "package": "yi",
          "source": "src/Yi-Mode-Haskell-Dollarify.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "Dollarify",
          "package": "yi",
          "partial": "Dollarify",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "QueuedUpdate",
          "package": "yi",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#QueuedUpdate",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "QueuedUpdate",
          "package": "yi",
          "partial": "Queued Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#t:QueuedUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "QueuedUpdate",
          "package": "yi",
          "signature": "QueuedUpdate",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#QueuedUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "QueuedUpdate",
          "package": "yi",
          "partial": "Queued Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:QueuedUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "closeParen",
          "package": "yi",
          "signature": "Token",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#closeParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "closeParen",
          "package": "yi",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:closeParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarify",
          "package": "yi",
          "signature": "Tree TT -\u003e BufferM ()",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarify",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarify",
          "normalized": "Tree TT-\u003eBufferM()",
          "package": "yi",
          "signature": "Tree TT-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyExpr",
          "package": "yi",
          "signature": "Expr TT -\u003e [QueuedUpdate]",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyExpr",
          "normalized": "Expr TT-\u003e[QueuedUpdate]",
          "package": "yi",
          "partial": "Expr",
          "signature": "Expr TT-\u003e[QueuedUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyExprP",
          "package": "yi",
          "signature": "[Exp TT] -\u003e [QueuedUpdate]",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyExprP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyExprP",
          "normalized": "[Exp TT]-\u003e[QueuedUpdate]",
          "package": "yi",
          "partial": "Expr",
          "signature": "[Exp TT]-\u003e[QueuedUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyExprP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyP",
          "package": "yi",
          "signature": "Tree TT -\u003e BufferM ()",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyP",
          "normalized": "Tree TT-\u003eBufferM()",
          "package": "yi",
          "signature": "Tree TT-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyTop",
          "package": "yi",
          "signature": "Tree TT -\u003e [QueuedUpdate]",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyTop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyTop",
          "normalized": "Tree TT-\u003e[QueuedUpdate]",
          "package": "yi",
          "partial": "Top",
          "signature": "Tree TT-\u003e[QueuedUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyTop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyTopP",
          "package": "yi",
          "signature": "Exp TT -\u003e [QueuedUpdate]",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyTopP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyTopP",
          "normalized": "Exp TT-\u003e[QueuedUpdate]",
          "package": "yi",
          "partial": "Top",
          "signature": "Exp TT-\u003e[QueuedUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyTopP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyWithin",
          "package": "yi",
          "signature": "Tree TT -\u003e BufferM ()",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyWithin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyWithin",
          "normalized": "Tree TT-\u003eBufferM()",
          "package": "yi",
          "partial": "Within",
          "signature": "Tree TT-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyWithin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyWithinP",
          "package": "yi",
          "signature": "Exp TT -\u003e BufferM ()",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#dollarifyWithinP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "dollarifyWithinP",
          "normalized": "Exp TT-\u003eBufferM()",
          "package": "yi",
          "partial": "Within",
          "signature": "Exp TT-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:dollarifyWithinP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "findLargestWithin",
          "package": "yi",
          "signature": "Region -\u003e [Tree TT] -\u003e Tree TT",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#findLargestWithin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "findLargestWithin",
          "normalized": "Region-\u003e[Tree TT]-\u003eTree TT",
          "package": "yi",
          "partial": "Largest Within",
          "signature": "Region-\u003e[Tree TT]-\u003eTree TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:findLargestWithin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "findLargestWithinP",
          "package": "yi",
          "signature": "Region -\u003e [Exp TT] -\u003e Exp TT",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#findLargestWithinP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "findLargestWithinP",
          "normalized": "Region-\u003e[Exp TT]-\u003eExp TT",
          "package": "yi",
          "partial": "Largest Within",
          "signature": "Region-\u003e[Exp TT]-\u003eExp TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:findLargestWithinP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isCollapsible",
          "package": "yi",
          "signature": "Expr TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isCollapsible",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isCollapsible",
          "normalized": "Expr TT-\u003eBool",
          "package": "yi",
          "partial": "Collapsible",
          "signature": "Expr TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isCollapsible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isCollapsibleP",
          "package": "yi",
          "signature": "[Exp TT] -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isCollapsibleP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isCollapsibleP",
          "normalized": "[Exp TT]-\u003eBool",
          "package": "yi",
          "partial": "Collapsible",
          "signature": "[Exp TT]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isCollapsibleP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isNormalParen",
          "package": "yi",
          "signature": "Tree TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isNormalParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isNormalParen",
          "normalized": "Tree TT-\u003eBool",
          "package": "yi",
          "partial": "Normal Paren",
          "signature": "Tree TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isNormalParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isNormalParenP",
          "package": "yi",
          "signature": "Exp TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isNormalParenP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isNormalParenP",
          "normalized": "Exp TT-\u003eBool",
          "package": "yi",
          "partial": "Normal Paren",
          "signature": "Exp TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isNormalParenP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isSimple",
          "package": "yi",
          "signature": "Tree TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isSimple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isSimple",
          "normalized": "Tree TT-\u003eBool",
          "package": "yi",
          "partial": "Simple",
          "signature": "Tree TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isSimpleP",
          "package": "yi",
          "signature": "Exp TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isSimpleP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isSimpleP",
          "normalized": "Exp TT-\u003eBool",
          "package": "yi",
          "partial": "Simple",
          "signature": "Exp TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isSimpleP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isTuple",
          "package": "yi",
          "signature": "Tree TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isTuple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isTuple",
          "normalized": "Tree TT-\u003eBool",
          "package": "yi",
          "partial": "Tuple",
          "signature": "Tree TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isTupleP",
          "package": "yi",
          "signature": "Exp TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#isTupleP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "isTupleP",
          "normalized": "Exp TT-\u003eBool",
          "package": "yi",
          "partial": "Tuple",
          "signature": "Exp TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:isTupleP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "openParen",
          "package": "yi",
          "signature": "Token",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#openParen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "openParen",
          "package": "yi",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:openParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "qDelete",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#QueuedUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "qDelete",
          "package": "yi",
          "partial": "Delete",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:qDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "qInsert",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#QueuedUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "qInsert",
          "package": "yi",
          "partial": "Insert",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:qInsert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "qUpdatePoint",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#QueuedUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "qUpdatePoint",
          "package": "yi",
          "partial": "Update Point",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:qUpdatePoint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "queueDelete",
          "package": "yi",
          "signature": "TT -\u003e QueuedUpdate",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#queueDelete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "queueDelete",
          "normalized": "TT-\u003eQueuedUpdate",
          "package": "yi",
          "partial": "Delete",
          "signature": "TT-\u003eQueuedUpdate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:queueDelete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "queueReplaceWith",
          "package": "yi",
          "signature": "String -\u003e TT -\u003e QueuedUpdate",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#queueReplaceWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "queueReplaceWith",
          "normalized": "String-\u003eTT-\u003eQueuedUpdate",
          "package": "yi",
          "partial": "Replace With",
          "signature": "String-\u003eTT-\u003eQueuedUpdate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:queueReplaceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "runQ",
          "package": "yi",
          "signature": "[QueuedUpdate] -\u003e BufferM ()",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#runQ",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "runQ",
          "normalized": "[QueuedUpdate]-\u003eBufferM()",
          "package": "yi",
          "signature": "[QueuedUpdate]-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:runQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "safeLast",
          "package": "yi",
          "signature": "[a] -\u003e Maybe a",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#safeLast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "safeLast",
          "normalized": "[a]-\u003eMaybe a",
          "package": "yi",
          "partial": "Last",
          "signature": "[a]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:safeLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "safeLastP",
          "package": "yi",
          "signature": "[a] -\u003e Maybe a",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#safeLastP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "safeLastP",
          "normalized": "[a]-\u003eMaybe a",
          "package": "yi",
          "partial": "Last",
          "signature": "[a]-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:safeLastP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "selectedTree",
          "package": "yi",
          "signature": "Expr TT -\u003e Region -\u003e Maybe (Tree TT)",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#selectedTree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "selectedTree",
          "normalized": "Expr TT-\u003eRegion-\u003eMaybe(Tree TT)",
          "package": "yi",
          "partial": "Tree",
          "signature": "Expr TT-\u003eRegion-\u003eMaybe(Tree TT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:selectedTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "selectedTreeP",
          "package": "yi",
          "signature": "[Exp TT] -\u003e Region -\u003e Maybe (Exp TT)",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#selectedTreeP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "selectedTreeP",
          "normalized": "[Exp TT]-\u003eRegion-\u003eMaybe(Exp TT)",
          "package": "yi",
          "partial": "Tree",
          "signature": "[Exp TT]-\u003eRegion-\u003eMaybe(Exp TT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:selectedTreeP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "stripComments",
          "package": "yi",
          "signature": "Expr TT -\u003e Expr TT",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#stripComments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "stripComments",
          "normalized": "Expr TT-\u003eExpr TT",
          "package": "yi",
          "partial": "Comments",
          "signature": "Expr TT-\u003eExpr TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:stripComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "stripCommentsP",
          "package": "yi",
          "signature": "[Exp TT] -\u003e [Exp TT]",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#stripCommentsP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "stripCommentsP",
          "normalized": "[Exp TT]-\u003e[Exp TT]",
          "package": "yi",
          "partial": "Comments",
          "signature": "[Exp TT]-\u003e[Exp TT]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:stripCommentsP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "within",
          "package": "yi",
          "signature": "Region -\u003e Tree TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#within",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "within",
          "normalized": "Region-\u003eTree TT-\u003eBool",
          "package": "yi",
          "signature": "Region-\u003eTree TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:within"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "withinP",
          "package": "yi",
          "signature": "Region -\u003e Exp TT -\u003e Bool",
          "source": "src/Yi-Mode-Haskell-Dollarify.html#withinP",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell Dollarify",
          "module": "Yi.Mode.Haskell.Dollarify",
          "name": "withinP",
          "normalized": "Region-\u003eExp TT-\u003eBool",
          "package": "yi",
          "signature": "Region-\u003eExp TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell-Dollarify.html#v:withinP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHaskell-specific modes and commands.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Mode.Haskell",
          "name": "Haskell",
          "package": "yi",
          "source": "src/Yi-Mode-Haskell.html",
          "type": "module"
        },
        "index": {
          "description": "Haskell-specific modes and commands",
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "Haskell",
          "package": "yi",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ca\u003eClever\u003c/a\u003e haskell mode, using the paren-matching syntax.\n\u003c/p\u003e",
          "module": "Yi.Mode.Haskell",
          "name": "cleverMode",
          "package": "yi",
          "signature": "Mode (Tree (Tok Token))",
          "source": "src/Yi-Mode-Haskell.html#cleverMode",
          "type": "function"
        },
        "index": {
          "description": "Clever haskell mode using the paren-matching syntax",
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "cleverMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:cleverMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell",
          "name": "fastMode",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-Haskell.html#fastMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "fastMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:fastMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn GHCi's buffer; create it if necessary.\n Show it in another window.\n\u003c/p\u003e",
          "module": "Yi.Mode.Haskell",
          "name": "ghciGet",
          "package": "yi",
          "signature": "YiM BufferRef",
          "source": "src/Yi-Mode-Haskell.html#ghciGet",
          "type": "function"
        },
        "index": {
          "description": "Return GHCi buffer create it if necessary Show it in another window",
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "ghciGet",
          "package": "yi",
          "partial": "Get",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:ghciGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell",
          "name": "ghciInferType",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Haskell.html#ghciInferType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "ghciInferType",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Infer Type",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:ghciInferType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoad current buffer in GHCi\n\u003c/p\u003e",
          "module": "Yi.Mode.Haskell",
          "name": "ghciLoadBuffer",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Haskell.html#ghciLoadBuffer",
          "type": "function"
        },
        "index": {
          "description": "Load current buffer in GHCi",
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "ghciLoadBuffer",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Load Buffer",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:ghciLoadBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend a command to GHCi\n\u003c/p\u003e",
          "module": "Yi.Mode.Haskell",
          "name": "ghciSend",
          "package": "yi",
          "signature": "String -\u003e YiM ()",
          "source": "src/Yi-Mode-Haskell.html#ghciSend",
          "type": "function"
        },
        "index": {
          "description": "Send command to GHCi",
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "ghciSend",
          "normalized": "String-\u003eYiM()",
          "package": "yi",
          "partial": "Send",
          "signature": "String-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:ghciSend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell",
          "name": "haskellAbstract",
          "package": "yi",
          "signature": "Mode (tree TT)",
          "source": "src/Yi-Mode-Haskell.html#haskellAbstract",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "haskellAbstract",
          "package": "yi",
          "partial": "Abstract",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:haskellAbstract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Haskell",
          "name": "literateMode",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-Haskell.html#literateMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "literateMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:literateMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExperimental Haskell mode, using a rather precise parser for the syntax.\n\u003c/p\u003e",
          "module": "Yi.Mode.Haskell",
          "name": "preciseMode",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-Haskell.html#preciseMode",
          "type": "function"
        },
        "index": {
          "description": "Experimental Haskell mode using rather precise parser for the syntax",
          "hierarchy": "Yi Mode Haskell",
          "module": "Yi.Mode.Haskell",
          "name": "preciseMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Haskell.html#v:preciseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA simple text mode; it does very little besides define a comment syntax.\n We have it as a separate mode so users can bind the commands to this mode specifically.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Mode.IReader",
          "name": "IReader",
          "package": "yi",
          "source": "src/Yi-Mode-IReader.html",
          "type": "module"
        },
        "index": {
          "description": "simple text mode it does very little besides define comment syntax We have it as separate mode so users can bind the commands to this mode specifically",
          "hierarchy": "Yi Mode IReader",
          "module": "Yi.Mode.IReader",
          "name": "IReader",
          "package": "yi",
          "partial": "IReader",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-IReader.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.IReader",
          "name": "abstract",
          "package": "yi",
          "signature": "forall syntax.  Mode syntax",
          "source": "src/Yi-Mode-IReader.html#abstract",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode IReader",
          "module": "Yi.Mode.IReader",
          "name": "abstract",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-IReader.html#v:abstract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.IReader",
          "name": "ireadMode",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-IReader.html#ireadMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode IReader",
          "module": "Yi.Mode.IReader",
          "name": "ireadMode",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Mode",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-IReader.html#v:ireadMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.IReader",
          "name": "ireaderMode",
          "package": "yi",
          "signature": "Mode syntax",
          "source": "src/Yi-Mode-IReader.html#ireaderMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode IReader",
          "module": "Yi.Mode.IReader",
          "name": "ireaderMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-IReader.html#v:ireaderMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "Interactive",
          "package": "yi",
          "source": "src/Yi-Mode-Interactive.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "Interactive",
          "package": "yi",
          "partial": "Interactive",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend the type command to the process\n\u003c/p\u003e",
          "module": "Yi.Mode.Interactive",
          "name": "feedCommand",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-Mode-Interactive.html#feedCommand",
          "type": "function"
        },
        "index": {
          "description": "Send the type command to the process",
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "feedCommand",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Command",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:feedCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "getInput",
          "package": "yi",
          "signature": "BufferM String",
          "source": "src/Yi-Mode-Interactive.html#getInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "getInput",
          "package": "yi",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:getInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "getInputRegion",
          "package": "yi",
          "signature": "BufferM Region",
          "source": "src/Yi-Mode-Interactive.html#getInputRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "getInputRegion",
          "package": "yi",
          "partial": "Input Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:getInputRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe GHCi prompt always begins with \u003ca\u003e\u003e\u003c/a\u003e; this goes to just before it, or if one is already at the start\n of the prompt, goes to the beginning of the line. (If at the beginning of the line, this pushes you forward to it.)\n\u003c/p\u003e",
          "module": "Yi.Mode.Interactive",
          "name": "ghciHome",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Mode-Interactive.html#ghciHome",
          "type": "function"
        },
        "index": {
          "description": "The GHCi prompt always begins with this goes to just before it or if one is already at the start of the prompt goes to the beginning of the line If at the beginning of the line this pushes you forward to it",
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "ghciHome",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Home",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:ghciHome"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "interactHistoryFinish",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Mode-Interactive.html#interactHistoryFinish",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "interactHistoryFinish",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "History Finish",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:interactHistoryFinish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "interactHistoryMove",
          "package": "yi",
          "signature": "Int -\u003e EditorM ()",
          "source": "src/Yi-Mode-Interactive.html#interactHistoryMove",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "interactHistoryMove",
          "normalized": "Int-\u003eEditorM()",
          "package": "yi",
          "partial": "History Move",
          "signature": "Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:interactHistoryMove"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "interactHistoryStart",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Mode-Interactive.html#interactHistoryStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "interactHistoryStart",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "History Start",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:interactHistoryStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "interactId",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Mode-Interactive.html#interactId",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "interactId",
          "package": "yi",
          "partial": "Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:interactId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpen a new buffer for interaction with a process.\n\u003c/p\u003e",
          "module": "Yi.Mode.Interactive",
          "name": "interactive",
          "package": "yi",
          "signature": "String -\u003e [String] -\u003e YiM BufferRef",
          "source": "src/Yi-Mode-Interactive.html#interactive",
          "type": "function"
        },
        "index": {
          "description": "Open new buffer for interaction with process",
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "interactive",
          "normalized": "String-\u003e[String]-\u003eYiM BufferRef",
          "package": "yi",
          "signature": "String-\u003e[String]-\u003eYiM BufferRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:interactive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "mode",
          "package": "yi",
          "signature": "Mode (Tree (Tok Token))",
          "source": "src/Yi-Mode-Interactive.html#mode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "mode",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSend command, recieve reply\n\u003c/p\u003e",
          "module": "Yi.Mode.Interactive",
          "name": "queryReply",
          "package": "yi",
          "signature": "BufferRef -\u003e String -\u003e YiM String",
          "source": "src/Yi-Mode-Interactive.html#queryReply",
          "type": "function"
        },
        "index": {
          "description": "Send command recieve reply",
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "queryReply",
          "normalized": "BufferRef-\u003eString-\u003eYiM String",
          "package": "yi",
          "partial": "Reply",
          "signature": "BufferRef-\u003eString-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:queryReply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Interactive",
          "name": "setInput",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Mode-Interactive.html#setInput",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Interactive",
          "module": "Yi.Mode.Interactive",
          "name": "setInput",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Input",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Interactive.html#v:setInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "source": "src/Yi-Mode-JavaScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode JavaScript",
          "module": "Yi.Mode.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "partial": "Java Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-JavaScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHooks for the JavaScript mode.\n\u003c/p\u003e",
          "module": "Yi.Mode.JavaScript",
          "name": "hooks",
          "package": "yi",
          "signature": "Mode (Tree TT) -\u003e Mode (Tree TT)",
          "source": "src/Yi-Mode-JavaScript.html#hooks",
          "type": "function"
        },
        "index": {
          "description": "Hooks for the JavaScript mode",
          "hierarchy": "Yi Mode JavaScript",
          "module": "Yi.Mode.JavaScript",
          "name": "hooks",
          "normalized": "Mode(Tree TT)-\u003eMode(Tree TT)",
          "package": "yi",
          "signature": "Mode(Tree TT)-\u003eMode(Tree TT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-JavaScript.html#v:hooks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.JavaScript",
          "name": "javaScriptMode",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-JavaScript.html#javaScriptMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode JavaScript",
          "module": "Yi.Mode.JavaScript",
          "name": "javaScriptMode",
          "package": "yi",
          "partial": "Script Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-JavaScript.html#v:javaScriptMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Latex",
          "name": "Latex",
          "package": "yi",
          "source": "src/Yi-Mode-Latex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Mode Latex",
          "module": "Yi.Mode.Latex",
          "name": "Latex",
          "package": "yi",
          "partial": "Latex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Latex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Mode.Latex",
          "name": "fastMode",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-Latex.html#fastMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Mode Latex",
          "module": "Yi.Mode.Latex",
          "name": "fastMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Latex.html#v:fastMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esyntax-based latex mode\n\u003c/p\u003e",
          "module": "Yi.Mode.Latex",
          "name": "latexMode2",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-Latex.html#latexMode2",
          "type": "function"
        },
        "index": {
          "description": "syntax-based latex mode",
          "hierarchy": "Yi Mode Latex",
          "module": "Yi.Mode.Latex",
          "name": "latexMode2",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Latex.html#v:latexMode2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esyntax-based latex mode\n\u003c/p\u003e",
          "module": "Yi.Mode.Latex",
          "name": "latexMode3",
          "package": "yi",
          "signature": "Mode (Tree TT)",
          "source": "src/Yi-Mode-Latex.html#latexMode3",
          "type": "function"
        },
        "index": {
          "description": "syntax-based latex mode",
          "hierarchy": "Yi Mode Latex",
          "module": "Yi.Mode.Latex",
          "name": "latexMode3",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Mode-Latex.html#v:latexMode3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "Modes",
          "package": "yi",
          "source": "src/Yi-Modes.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "Modes",
          "package": "yi",
          "partial": "Modes",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "TokenBasedMode",
          "package": "yi",
          "source": "src/Yi-Modes.html#TokenBasedMode",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "TokenBasedMode",
          "package": "yi",
          "partial": "Token Based Mode",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#t:TokenBasedMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen applied to an extensions list, creates a \u003ccode\u003e\u003ca\u003emodeApplies\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Yi.Modes",
          "name": "anyExtension",
          "package": "yi",
          "signature": "[String] -\u003e FilePath -\u003e String -\u003e Bool",
          "source": "src/Yi-Modes.html#anyExtension",
          "type": "function"
        },
        "index": {
          "description": "When applied to an extensions list creates modeApplies function",
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "anyExtension",
          "normalized": "[String]-\u003eFilePath-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Extension",
          "signature": "[String]-\u003eFilePath-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:anyExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a list of mode hooks to a list of AnyModes\n\u003c/p\u003e",
          "module": "Yi.Modes",
          "name": "applyModeHooks",
          "package": "yi",
          "signature": "[(AnyMode -\u003e Bool, BufferM ())] -\u003e [AnyMode] -\u003e [AnyMode]",
          "source": "src/Yi-Modes.html#applyModeHooks",
          "type": "function"
        },
        "index": {
          "description": "Apply list of mode hooks to list of AnyModes",
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "applyModeHooks",
          "normalized": "[(AnyMode-\u003eBool,BufferM())]-\u003e[AnyMode]-\u003e[AnyMode]",
          "package": "yi",
          "partial": "Mode Hooks",
          "signature": "[(AnyMode-\u003eBool,BufferM())]-\u003e[AnyMode]-\u003e[AnyMode]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:applyModeHooks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "cMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#cMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "cMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:cMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "cabalMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#cabalMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "cabalMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:cabalMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "cppMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#cppMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "cppMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:cppMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhen applied to an extensions list and regular expression pattern, creates\n a \u003ccode\u003e\u003ca\u003emodeApplies\u003c/a\u003e\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Yi.Modes",
          "name": "extensionOrContentsMatch",
          "package": "yi",
          "signature": "[String] -\u003e String -\u003e FilePath -\u003e String -\u003e Bool",
          "source": "src/Yi-Modes.html#extensionOrContentsMatch",
          "type": "function"
        },
        "index": {
          "description": "When applied to an extensions list and regular expression pattern creates modeApplies function",
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "extensionOrContentsMatch",
          "normalized": "[String]-\u003eString-\u003eFilePath-\u003eString-\u003eBool",
          "package": "yi",
          "partial": "Or Contents Match",
          "signature": "[String]-\u003eString-\u003eFilePath-\u003eString-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:extensionOrContentsMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "fundamentalMode",
          "package": "yi",
          "signature": "Mode syntax",
          "source": "src/Yi-Modes.html#fundamentalMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "fundamentalMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:fundamentalMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "gitCommitMode",
          "package": "yi",
          "signature": "Mode (Tree (Tok Token))",
          "source": "src/Yi-Modes.html#gitCommitMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "gitCommitMode",
          "package": "yi",
          "partial": "Commit Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:gitCommitMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "gnuMakeMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#gnuMakeMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "gnuMakeMode",
          "package": "yi",
          "partial": "Make Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:gnuMakeMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds a hook to all matching hooks in a list\n\u003c/p\u003e",
          "module": "Yi.Modes",
          "name": "hookModes",
          "package": "yi",
          "signature": "(AnyMode -\u003e Bool) -\u003e BufferM () -\u003e [AnyMode] -\u003e [AnyMode]",
          "source": "src/Yi-Modes.html#hookModes",
          "type": "function"
        },
        "index": {
          "description": "Adds hook to all matching hooks in list",
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "hookModes",
          "normalized": "(AnyMode-\u003eBool)-\u003eBufferM()-\u003e[AnyMode]-\u003e[AnyMode]",
          "package": "yi",
          "partial": "Modes",
          "signature": "(AnyMode-\u003eBool)-\u003eBufferM()-\u003e[AnyMode]-\u003e[AnyMode]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:hookModes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "javaMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#javaMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "javaMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:javaMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "jsonMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#jsonMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "jsonMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:jsonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "linearSyntaxMode",
          "package": "yi",
          "signature": "lexerState -\u003e ((AlexState lexerState, AlexInput) -\u003e Maybe (Tok t, (AlexState lexerState, AlexInput))) -\u003e (t -\u003e StyleName) -\u003e Mode (Tree (Tok t))",
          "source": "src/Yi-Modes.html#linearSyntaxMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "linearSyntaxMode",
          "normalized": "a-\u003e((AlexState a,AlexInput)-\u003eMaybe(Tok b,(AlexState a,AlexInput)))-\u003e(b-\u003eStyleName)-\u003eMode(Tree(Tok b))",
          "package": "yi",
          "partial": "Syntax Mode",
          "signature": "lexerState-\u003e((AlexState lexerState,AlexInput)-\u003eMaybe(Tok t,(AlexState lexerState,AlexInput)))-\u003e(t-\u003eStyleName)-\u003eMode(Tree(Tok t))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:linearSyntaxMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCheck whether a mode of the same name is already in modeTable and returns the\n original mode, if it isn't the case.\n\u003c/p\u003e",
          "module": "Yi.Modes",
          "name": "lookupMode",
          "package": "yi",
          "signature": "AnyMode -\u003e YiM AnyMode",
          "source": "src/Yi-Modes.html#lookupMode",
          "type": "function"
        },
        "index": {
          "description": "Check whether mode of the same name is already in modeTable and returns the original mode if it isn the case",
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "lookupMode",
          "normalized": "AnyMode-\u003eYiM AnyMode",
          "package": "yi",
          "partial": "Mode",
          "signature": "AnyMode-\u003eYiM AnyMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:lookupMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "objectiveCMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#objectiveCMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "objectiveCMode",
          "package": "yi",
          "partial": "CMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:objectiveCMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "ocamlMode",
          "package": "yi",
          "signature": "TokenBasedMode Token",
          "source": "src/Yi-Modes.html#ocamlMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "ocamlMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:ocamlMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "ottMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#ottMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "ottMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:ottMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "perlMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#perlMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "perlMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:perlMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "pythonMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#pythonMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "pythonMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:pythonMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "removeAnnots",
          "package": "yi",
          "signature": "Mode a -\u003e Mode a",
          "source": "src/Yi-Modes.html#removeAnnots",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "removeAnnots",
          "normalized": "Mode a-\u003eMode a",
          "package": "yi",
          "partial": "Annots",
          "signature": "Mode a-\u003eMode a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:removeAnnots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "rubyMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#rubyMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "rubyMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:rubyMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "srmcMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#srmcMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "srmcMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:srmcMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "svnCommitMode",
          "package": "yi",
          "signature": "StyleBasedMode",
          "source": "src/Yi-Modes.html#svnCommitMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "svnCommitMode",
          "package": "yi",
          "partial": "Commit Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:svnCommitMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Modes",
          "name": "whitespaceMode",
          "package": "yi",
          "signature": "TokenBasedMode StyleName",
          "source": "src/Yi-Modes.html#whitespaceMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Modes",
          "module": "Yi.Modes",
          "name": "whitespaceMode",
          "package": "yi",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Modes.html#v:whitespaceMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "Monad",
          "package": "yi",
          "source": "src/Yi-Monad.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "Monad",
          "package": "yi",
          "partial": "Monad",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "Ref",
          "package": "yi",
          "source": "src/Yi-Monad.html#Ref",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "Ref",
          "package": "yi",
          "partial": "Ref",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#t:Ref"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets specific component of the state, using a projection function\n supplied.\n\u003c/p\u003e",
          "module": "Yi.Monad",
          "name": "gets",
          "package": "yi",
          "signature": "(s -\u003e a) -\u003e m a",
          "type": "function"
        },
        "index": {
          "description": "Gets specific component of the state using projection function supplied",
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "gets",
          "normalized": "(a-\u003eb)-\u003ec b",
          "package": "yi",
          "signature": "(s-\u003ea)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:gets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "getsA",
          "package": "yi",
          "signature": "Accessor s p -\u003e (p -\u003e a) -\u003e m a",
          "source": "src/Yi-Monad.html#getsA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "getsA",
          "normalized": "Accessor a b-\u003e(b-\u003ec)-\u003ed c",
          "package": "yi",
          "signature": "Accessor s p-\u003e(p-\u003ea)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:getsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombination of the Control.Monad.State \u003ccode\u003e\u003ca\u003emodify\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003egets\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Monad",
          "name": "getsAndModify",
          "package": "yi",
          "signature": "(s -\u003e (s, a)) -\u003e m a",
          "source": "src/Yi-Monad.html#getsAndModify",
          "type": "function"
        },
        "index": {
          "description": "Combination of the Control.Monad.State modify and gets",
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "getsAndModify",
          "normalized": "(a-\u003e(a,b))-\u003ec b",
          "package": "yi",
          "partial": "And Modify",
          "signature": "(s-\u003e(s,a))-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:getsAndModify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "maybeM",
          "package": "yi",
          "signature": "(x -\u003e m ()) -\u003e Maybe x -\u003e m ()",
          "source": "src/Yi-Monad.html#maybeM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "maybeM",
          "normalized": "(a-\u003eb())-\u003eMaybe a-\u003eb()",
          "package": "yi",
          "signature": "(x-\u003em())-\u003eMaybe x-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:maybeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "modifiesRef",
          "package": "yi",
          "signature": "(r -\u003e ref a) -\u003e (a -\u003e a) -\u003e m ()",
          "source": "src/Yi-Monad.html#modifiesRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "modifiesRef",
          "normalized": "(a-\u003eb c)-\u003e(c-\u003ec)-\u003ed()",
          "package": "yi",
          "partial": "Ref",
          "signature": "(r-\u003eref a)-\u003e(a-\u003ea)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:modifiesRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "modifiesThenReadsRef",
          "package": "yi",
          "signature": "(r -\u003e IORef a) -\u003e (a -\u003e a) -\u003e m a",
          "source": "src/Yi-Monad.html#modifiesThenReadsRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "modifiesThenReadsRef",
          "normalized": "(a-\u003eIORef b)-\u003e(b-\u003eb)-\u003ec b",
          "package": "yi",
          "partial": "Then Reads Ref",
          "signature": "(r-\u003eIORef a)-\u003e(a-\u003ea)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:modifiesThenReadsRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "modifyRef",
          "package": "yi",
          "signature": "ref a -\u003e (a -\u003e a) -\u003e m ()",
          "source": "src/Yi-Monad.html#modifyRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "modifyRef",
          "normalized": "a b-\u003e(b-\u003eb)-\u003ec()",
          "package": "yi",
          "partial": "Ref",
          "signature": "ref a-\u003e(a-\u003ea)-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:modifyRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "readRef",
          "package": "yi",
          "signature": "ref a -\u003e m a",
          "source": "src/Yi-Monad.html#readRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "readRef",
          "normalized": "a b-\u003ec b",
          "package": "yi",
          "partial": "Ref",
          "signature": "ref a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:readRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "readsRef",
          "package": "yi",
          "signature": "(r -\u003e ref a) -\u003e m a",
          "source": "src/Yi-Monad.html#readsRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "readsRef",
          "normalized": "(a-\u003eb c)-\u003ed c",
          "package": "yi",
          "partial": "Ref",
          "signature": "(r-\u003eref a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:readsRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRerun the monad until the boolean result is false, collecting list of results.\n\u003c/p\u003e",
          "module": "Yi.Monad",
          "name": "repeatUntilM",
          "package": "yi",
          "signature": "m (Bool, a) -\u003e m [a]",
          "source": "src/Yi-Monad.html#repeatUntilM",
          "type": "function"
        },
        "index": {
          "description": "Rerun the monad until the boolean result is false collecting list of results",
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "repeatUntilM",
          "normalized": "a(Bool,b)-\u003ea[b]",
          "package": "yi",
          "partial": "Until",
          "signature": "m(Bool,a)-\u003em[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:repeatUntilM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "whenM",
          "package": "yi",
          "signature": "m Bool -\u003e m () -\u003e m ()",
          "source": "src/Yi-Monad.html#whenM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "whenM",
          "normalized": "a Bool-\u003ea()-\u003ea()",
          "package": "yi",
          "signature": "m Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:whenM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "with",
          "package": "yi",
          "signature": "(yi -\u003e component) -\u003e (component -\u003e IO a) -\u003e m a",
          "source": "src/Yi-Monad.html#with",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "with",
          "normalized": "(a-\u003eb)-\u003e(b-\u003eIO c)-\u003ed c",
          "package": "yi",
          "signature": "(yi-\u003ecomponent)-\u003e(component-\u003eIO a)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:with"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "writeRef",
          "package": "yi",
          "signature": "ref a -\u003e a -\u003e m ()",
          "source": "src/Yi-Monad.html#writeRef",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "writeRef",
          "normalized": "a b-\u003eb-\u003ec()",
          "package": "yi",
          "partial": "Ref",
          "signature": "ref a-\u003ea-\u003em()",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:writeRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Monad",
          "name": "writesRef",
          "package": "yi",
          "signature": "(r -\u003e IORef a) -\u003e a -\u003e m ()",
          "source": "src/Yi-Monad.html#writesRef",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Monad",
          "module": "Yi.Monad",
          "name": "writesRef",
          "normalized": "(a-\u003eIORef b)-\u003eb-\u003ec()",
          "package": "yi",
          "partial": "Ref",
          "signature": "(r-\u003eIORef a)-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Monad.html#v:writesRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Paths",
          "name": "Paths",
          "package": "yi",
          "source": "src/Yi-Paths.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "Paths",
          "package": "yi",
          "partial": "Paths",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet articles.db database of locations to visit (for Yi.IReader.)\n\u003c/p\u003e",
          "module": "Yi.Paths",
          "name": "getArticleDbFilename",
          "package": "yi",
          "signature": "m FilePath",
          "source": "src/Yi-Paths.html#getArticleDbFilename",
          "type": "function"
        },
        "index": {
          "description": "Get articles.db database of locations to visit for Yi.IReader",
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getArticleDbFilename",
          "package": "yi",
          "partial": "Article Db Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getArticleDbFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Paths",
          "name": "getConfigDir",
          "package": "yi",
          "signature": "m FilePath",
          "source": "src/Yi-Paths.html#getConfigDir",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getConfigDir",
          "package": "yi",
          "partial": "Config Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getConfigDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet Yi master configuration script.\n\u003c/p\u003e",
          "module": "Yi.Paths",
          "name": "getConfigFilename",
          "package": "yi",
          "signature": "m FilePath",
          "source": "src/Yi-Paths.html#getConfigFilename",
          "type": "function"
        },
        "index": {
          "description": "Get Yi master configuration script",
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getConfigFilename",
          "package": "yi",
          "partial": "Config Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getConfigFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Paths",
          "name": "getConfigModules",
          "package": "yi",
          "signature": "m FilePath",
          "source": "src/Yi-Paths.html#getConfigModules",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getConfigModules",
          "package": "yi",
          "partial": "Config Modules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getConfigModules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a path relative to application configuration directory,\n   this function finds a path to a given configuration file.\n\u003c/p\u003e",
          "module": "Yi.Paths",
          "name": "getConfigPath",
          "package": "yi",
          "signature": "FilePath -\u003e m FilePath",
          "source": "src/Yi-Paths.html#getConfigPath",
          "type": "function"
        },
        "index": {
          "description": "Given path relative to application configuration directory this function finds path to given configuration file",
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getConfigPath",
          "normalized": "FilePath-\u003ea FilePath",
          "package": "yi",
          "partial": "Config Path",
          "signature": "FilePath-\u003em FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getConfigPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a path relative to application data directory,\n   this function finds a path to a given data file.\n\u003c/p\u003e",
          "module": "Yi.Paths",
          "name": "getDataPath",
          "package": "yi",
          "signature": "FilePath -\u003e m FilePath",
          "source": "src/Yi-Paths.html#getDataPath",
          "type": "function"
        },
        "index": {
          "description": "Given path relative to application data directory this function finds path to given data file",
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getDataPath",
          "normalized": "FilePath-\u003ea FilePath",
          "package": "yi",
          "partial": "Data Path",
          "signature": "FilePath-\u003em FilePath",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getDataPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet path to environment file that defines namespace used by Yi\n   command evaluator.\n\u003c/p\u003e",
          "module": "Yi.Paths",
          "name": "getEvaluatorContextFilename",
          "package": "yi",
          "signature": "m FilePath",
          "source": "src/Yi-Paths.html#getEvaluatorContextFilename",
          "type": "function"
        },
        "index": {
          "description": "Get path to environment file that defines namespace used by Yi command evaluator",
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getEvaluatorContextFilename",
          "package": "yi",
          "partial": "Evaluator Context Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getEvaluatorContextFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet path to Yi history that stores state between runs.\n\u003c/p\u003e",
          "module": "Yi.Paths",
          "name": "getPersistentStateFilename",
          "package": "yi",
          "signature": "m FilePath",
          "source": "src/Yi-Paths.html#getPersistentStateFilename",
          "type": "function"
        },
        "index": {
          "description": "Get path to Yi history that stores state between runs",
          "hierarchy": "Yi Paths",
          "module": "Yi.Paths",
          "name": "getPersistentStateFilename",
          "package": "yi",
          "partial": "Persistent State Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Paths.html#v:getPersistentStateFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module implements persistence across different Yi runs.\n   It includes minibuffer command history, marks, VimTagStack etc.\n   Warning: Current version will _not_ check whether two or more instances\n   of Yi are run at the same time.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.PersistentState",
          "name": "PersistentState",
          "package": "yi",
          "source": "src/Yi-PersistentState.html",
          "type": "module"
        },
        "index": {
          "description": "This module implements persistence across different Yi runs It includes minibuffer command history marks VimTagStack etc Warning Current version will not check whether two or more instances of Yi are run at the same time",
          "hierarchy": "Yi PersistentState",
          "module": "Yi.PersistentState",
          "name": "PersistentState",
          "package": "yi",
          "partial": "Persistent State",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-PersistentState.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLoads a persistent state, and sets Yi state variables accordingly.\n\u003c/p\u003e",
          "module": "Yi.PersistentState",
          "name": "loadPersistentState",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-PersistentState.html#loadPersistentState",
          "type": "function"
        },
        "index": {
          "description": "Loads persistent state and sets Yi state variables accordingly",
          "hierarchy": "Yi PersistentState",
          "module": "Yi.PersistentState",
          "name": "loadPersistentState",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Persistent State",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-PersistentState.html#v:loadPersistentState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.PersistentState",
          "name": "maxHistoryEntries",
          "package": "yi",
          "signature": "Field Int",
          "source": "src/Yi-PersistentState.html#maxHistoryEntries",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi PersistentState",
          "module": "Yi.PersistentState",
          "name": "maxHistoryEntries",
          "package": "yi",
          "partial": "History Entries",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-PersistentState.html#v:maxHistoryEntries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHere is a persistent history saving part.\n   We assume each command is a single line.\n   To add new components, one has to:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e add new field in \u003ccode\u003ePersistentState\u003c/code\u003e structure, \n   * add write and read parts in \u003ccode\u003eloadPersistentState\u003c/code\u003e/\u003ccode\u003esavePersistentState\u003c/code\u003e,\n   * add a trimming code in \u003ccode\u003esavePersistentState\u003c/code\u003e to prevent blowing up\n     of save file.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Yi.PersistentState",
          "name": "savePersistentState",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-PersistentState.html#savePersistentState",
          "type": "function"
        },
        "index": {
          "description": "Here is persistent history saving part We assume each command is single line To add new components one has to add new field in PersistentState structure add write and read parts in loadPersistentState savePersistentState add trimming code in savePersistentState to prevent blowing up of save file",
          "hierarchy": "Yi PersistentState",
          "module": "Yi.PersistentState",
          "name": "savePersistentState",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Persistent State",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-PersistentState.html#v:savePersistentState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Prelude",
          "package": "yi",
          "source": "src/Yi-Prelude.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Prelude",
          "package": "yi",
          "partial": "Prelude",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003eBinary\u003c/code\u003e class provides \u003ccode\u003e\u003ca\u003eput\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eget\u003c/a\u003e\u003c/code\u003e, methods to encode and\n decode a Haskell value to a lazy ByteString. It mirrors the Read and\n Show classes for textual representation of Haskell types, and is\n suitable for serialising Haskell values to disk, over the network.\n\u003c/p\u003e\u003cp\u003eFor parsing and generating simple external binary formats (e.g. C\n structures), Binary may be used, but in general is not suitable\n for complex protocols. Instead use the Put and Get primitives\n directly.\n\u003c/p\u003e\u003cp\u003eInstances of Binary should satisfy the following property:\n\u003c/p\u003e\u003cpre\u003e decode . encode == id\n\u003c/pre\u003e\u003cp\u003eThat is, the \u003ccode\u003e\u003ca\u003eget\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eput\u003c/a\u003e\u003c/code\u003e methods should be the inverse of each\n other. A range of instances are provided for basic Haskell types. \n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Binary",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The Binary class provides put and get methods to encode and decode Haskell value to lazy ByteString It mirrors the Read and Show classes for textual representation of Haskell types and is suitable for serialising Haskell values to disk over the network For parsing and generating simple external binary formats e.g structures Binary may be used but in general is not suitable for complex protocols Instead use the Put and Get primitives directly Instances of Binary should satisfy the following property decode encode id That is the get and put methods should be the inverse of each other range of instances are provided for basic Haskell types",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Binary",
          "package": "yi",
          "partial": "Binary",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Binary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class is used to name the upper and lower limits of a\n type.  \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e is not a superclass of \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e since types that are not\n totally ordered may also have upper and lower bounds.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e class may be derived for any enumeration type;\n \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e is the first constructor listed in the \u003ccode\u003edata\u003c/code\u003e declaration\n and \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e is the last.\n \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e may also be derived for single-constructor datatypes whose\n constituent types are in \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Bounded",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The Bounded class is used to name the upper and lower limits of type Ord is not superclass of Bounded since types that are not totally ordered may also have upper and lower bounds The Bounded class may be derived for any enumeration type minBound is the first constructor listed in the data declaration and maxBound is the last Bounded may also be derived for single-constructor datatypes whose constituent types are in Bounded",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Bounded",
          "package": "yi",
          "partial": "Bounded",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Bounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe character type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e is an enumeration whose values represent\nUnicode (or equivalently ISO/IEC 10646) characters (see\n\u003ca\u003ehttp://www.unicode.org/\u003c/a\u003e for details).  This set extends the ISO 8859-1\n(Latin-1) character set (the first 256 characters), which is itself an extension\nof the ASCII character set (the first 128 characters).  A character literal in\nHaskell has type \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTo convert a \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e to or from the corresponding \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e value defined\nby Unicode, use \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from the\n\u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e class respectively (or equivalently \u003ccode\u003eord\u003c/code\u003e and \u003ccode\u003echr\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Char",
          "package": "yi",
          "type": "data"
        },
        "index": {
          "description": "The character type Char is an enumeration whose values represent Unicode or equivalently ISO IEC characters see http www.unicode.org for details This set extends the ISO Latin-1 character set the first characters which is itself an extension of the ASCII character set the first characters character literal in Haskell has type Char To convert Char to or from the corresponding Int value defined by Unicode use toEnum and fromEnum from the Enum class respectively or equivalently ord and chr",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Char",
          "package": "yi",
          "partial": "Char",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDouble-precision floating point numbers.\n It is desirable that this type be at least equal in range and precision\n to the IEEE double-precision type.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Double",
          "package": "yi",
          "type": "data"
        },
        "index": {
          "description": "Double-precision floating point numbers It is desirable that this type be at least equal in range and precision to the IEEE double-precision type",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Double",
          "package": "yi",
          "partial": "Double",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Double"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type represents values with two possibilities: a value of\ntype \u003ccode\u003e\u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e a b\u003c/code\u003e is either \u003ccode\u003e\u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e or \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e b\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type is sometimes used to represent a value which is\neither correct or an error; by convention, the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e constructor is\nused to hold an error value and the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e constructor is used to\nhold a correct value (mnemonic: \"right\" also means \"correct\").\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Either",
          "package": "yi",
          "type": "data"
        },
        "index": {
          "description": "The Either type represents values with two possibilities value of type Either is either Left or Right The Either type is sometimes used to represent value which is either correct or an error by convention the Left constructor is used to hold an error value and the Right constructor is used to hold correct value mnemonic right also means correct",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Either",
          "package": "yi",
          "partial": "Either",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Either"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Endom",
          "package": "yi",
          "source": "src/Yi-Prelude.html#Endom",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Endom",
          "package": "yi",
          "partial": "Endom",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Endom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e defines operations on sequentially ordered types.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eenumFrom\u003c/code\u003e... methods are used in Haskell's translation of\n arithmetic sequences.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e may be derived for any enumeration type (types\n whose constructors have no fields).  The nullary constructors are\n assumed to be numbered left-to-right by \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e from \u003ccode\u003e0\u003c/code\u003e through \u003ccode\u003en-1\u003c/code\u003e.\n See Chapter 10 of the \u003cem\u003eHaskell Report\u003c/em\u003e for more details.\n\u003c/p\u003e\u003cp\u003eFor any type that is an instance of class \u003ccode\u003e\u003ca\u003eBounded\u003c/a\u003e\u003c/code\u003e as well as \u003ccode\u003e\u003ca\u003eEnum\u003c/a\u003e\u003c/code\u003e,\n the following should hold:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The calls \u003ccode\u003e\u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003emaxBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003epred\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eminBound\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e should result in\n   a runtime error.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e should give a runtime error if the \n   result value is not representable in the result type.\n   For example, \u003ccode\u003e\u003ccode\u003e\u003ca\u003etoEnum\u003c/a\u003e\u003c/code\u003e 7 :: \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e is an error.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eenumFrom\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eenumFromThen\u003c/a\u003e\u003c/code\u003e should be defined with an implicit bound,\n   thus:\n\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e    enumFrom     x   = enumFromTo     x maxBound\n    enumFromThen x y = enumFromThenTo x y bound\n      where\n        bound | fromEnum y \u003e= fromEnum x = maxBound\n              | otherwise                = minBound\n\u003c/pre\u003e",
          "module": "Yi.Prelude",
          "name": "Enum",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "Class Enum defines operations on sequentially ordered types The enumFrom methods are used in Haskell translation of arithmetic sequences Instances of Enum may be derived for any enumeration type types whose constructors have no fields The nullary constructors are assumed to be numbered left-to-right by fromEnum from through n-1 See Chapter of the Haskell Report for more details For any type that is an instance of class Bounded as well as Enum the following should hold The calls succ maxBound and pred minBound should result in runtime error fromEnum and toEnum should give runtime error if the result value is not representable in the result type For example toEnum Bool is an error enumFrom and enumFromThen should be defined with an implicit bound thus enumFrom enumFromTo maxBound enumFromThen enumFromThenTo bound where bound fromEnum fromEnum maxBound otherwise minBound",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Enum",
          "package": "yi",
          "partial": "Enum",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Enum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e class defines equality (\u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e) and inequality (\u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e).\n All the basic datatypes exported by the \u003ca\u003ePrelude\u003c/a\u003e are instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e,\n and \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e may be derived for any datatype whose constituents are also\n instances of \u003ccode\u003e\u003ca\u003eEq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: either \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e/=\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Eq",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The Eq class defines equality and inequality All the basic datatypes exported by the Prelude are instances of Eq and Eq may be derived for any datatype whose constituents are also instances of Eq Minimal complete definition either or",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Eq",
          "package": "yi",
          "partial": "Eq",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Eq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFractional numbers, supporting real division.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003efromRational\u003c/a\u003e\u003c/code\u003e and (\u003ccode\u003e\u003ca\u003erecip\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e/\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Fractional",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "Fractional numbers supporting real division Minimal complete definition fromRational and recip or",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Fractional",
          "package": "yi",
          "partial": "Fractional",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Fractional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e class is used for types that can be mapped over.\nInstances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e fmap id  ==  id\n fmap (f . g)  ==  fmap f . fmap g\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\nsatisfy these laws.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Functor",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The Functor class is used for types that can be mapped over Instances of Functor should satisfy the following laws fmap id id fmap fmap fmap The instances of Functor for lists Maybe and IO satisfy these laws",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Functor",
          "package": "yi",
          "partial": "Functor",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Functor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA value of type \u003ccode\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e is a computation which, when performed,\ndoes some I/O before returning a value of type \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThere is really only one way to \"perform\" an I/O action: bind it to\n\u003ccode\u003eMain.main\u003c/code\u003e in your program.  When your program is run, the I/O will\nbe performed.  It isn't possible to perform I/O from an arbitrary\nfunction, unless that function is itself in the \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e monad and called\nat some point, directly or indirectly, from \u003ccode\u003eMain.main\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e is a monad, so \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e actions can be combined using either the do-notation\nor the \u003ccode\u003e\u003e\u003e\u003c/code\u003e and \u003ccode\u003e\u003e\u003e=\u003c/code\u003e operations from the \u003ccode\u003eMonad\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "IO",
          "package": "yi",
          "type": "data"
        },
        "index": {
          "description": "value of type IO is computation which when performed does some before returning value of type There is really only one way to perform an action bind it to Main.main in your program When your program is run the will be performed It isn possible to perform from an arbitrary function unless that function is itself in the IO monad and called at some point directly or indirectly from Main.main IO is monad so IO actions can be combined using either the do-notation or the and operations from the Monad class",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "IO",
          "package": "yi",
          "partial": "IO",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:IO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default value. If a function tries to get a copy of the state, but the state\n   hasn't yet been created, \u003ccode\u003e\u003ca\u003einitial\u003c/a\u003e\u003c/code\u003e will be called to supply *some* value. The value\n   of initial will probably be something like Nothing,  [], \"\", or \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e - compare \n   the \u003ccode\u003emempty\u003c/code\u003e of \u003ca\u003eData.Monoid\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Initializable",
          "package": "yi",
          "source": "src/Yi-Prelude.html#Initializable",
          "type": "class"
        },
        "index": {
          "description": "The default value If function tries to get copy of the state but the state hasn yet been created initial will be called to supply some value The value of initial will probably be something like Nothing or empty compare the mempty of Data.Monoid",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Initializable",
          "package": "yi",
          "partial": "Initializable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Initializable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArbitrary-precision integers.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Integer",
          "package": "yi",
          "type": "data"
        },
        "index": {
          "description": "Arbitrary-precision integers",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Integer",
          "package": "yi",
          "partial": "Integer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Integer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIntegral numbers, supporting integer division.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003equotRem\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003etoInteger\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Integral",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "Integral numbers supporting integer division Minimal complete definition quotRem and toInteger",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Integral",
          "package": "yi",
          "partial": "Integral",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Integral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type encapsulates an optional value.  A value of type\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e either contains a value of type \u003ccode\u003ea\u003c/code\u003e (represented as \u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e a\u003c/code\u003e), \n or it is empty (represented as \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e).  Using \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e is a good way to \n deal with errors or exceptional cases without resorting to drastic\n measures such as \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e type is also a monad.  It is a simple kind of error\n monad, where all errors are represented by \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.  A richer\n error monad can be built using the \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e type.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Maybe",
          "package": "yi",
          "type": "data"
        },
        "index": {
          "description": "The Maybe type encapsulates an optional value value of type Maybe either contains value of type represented as Just or it is empty represented as Nothing Using Maybe is good way to deal with errors or exceptional cases without resorting to drastic measures such as error The Maybe type is also monad It is simple kind of error monad where all errors are represented by Nothing richer error monad can be built using the Either type",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Maybe",
          "package": "yi",
          "partial": "Maybe",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Maybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e class defines the basic operations over a \u003cem\u003emonad\u003c/em\u003e,\na concept from a branch of mathematics known as \u003cem\u003ecategory theory\u003c/em\u003e.\nFrom the perspective of a Haskell programmer, however, it is best to\nthink of a monad as an \u003cem\u003eabstract datatype\u003c/em\u003e of actions.\nHaskell's \u003ccode\u003edo\u003c/code\u003e expressions provide a convenient syntax for writing\nmonadic expressions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereturn\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e should satisfy the following laws:\n\u003c/p\u003e\u003cpre\u003e return a \u003e\u003e= k  ==  k a\n m \u003e\u003e= return  ==  m\n m \u003e\u003e= (\\x -\u003e k x \u003e\u003e= h)  ==  (m \u003e\u003e= k) \u003e\u003e= h\n\u003c/pre\u003e\u003cp\u003eInstances of both \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e should additionally satisfy the law:\n\u003c/p\u003e\u003cpre\u003e fmap f xs  ==  xs \u003e\u003e= return . f\n\u003c/pre\u003e\u003cp\u003eThe instances of \u003ccode\u003e\u003ca\u003eMonad\u003c/a\u003e\u003c/code\u003e for lists, \u003ccode\u003e\u003ca\u003eMaybe\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eIO\u003c/a\u003e\u003c/code\u003e\ndefined in the \u003ca\u003ePrelude\u003c/a\u003e satisfy these laws.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Monad",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The Monad class defines the basic operations over monad concept from branch of mathematics known as category theory From the perspective of Haskell programmer however it is best to think of monad as an abstract datatype of actions Haskell do expressions provide convenient syntax for writing monadic expressions Minimal complete definition and return Instances of Monad should satisfy the following laws return return Instances of both Monad and Functor should additionally satisfy the law fmap xs xs return The instances of Monad for lists Maybe and IO defined in the Prelude satisfy these laws",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Monad",
          "package": "yi",
          "partial": "Monad",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Monad"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBasic numeric class.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: all except \u003ccode\u003e\u003ca\u003enegate\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e(-)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Num",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "Basic numeric class Minimal complete definition all except negate or",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Num",
          "package": "yi",
          "partial": "Num",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Num"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e class is used for totally ordered datatypes.\n\u003c/p\u003e\u003cp\u003eInstances of \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e can be derived for any user-defined\n datatype whose constituent types are in \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e.  The declared order\n of the constructors in the data declaration determines the ordering\n in derived \u003ccode\u003e\u003ca\u003eOrd\u003c/a\u003e\u003c/code\u003e instances.  The \u003ccode\u003e\u003ca\u003eOrdering\u003c/a\u003e\u003c/code\u003e datatype allows a single\n comparison to determine the precise ordering of two objects.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: either \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003e\u003c=\u003c/a\u003e\u003c/code\u003e.\n Using \u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e can be more efficient for complex types.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Ord",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The Ord class is used for totally ordered datatypes Instances of Ord can be derived for any user-defined datatype whose constituent types are in Ord The declared order of the constructors in the data declaration determines the ordering in derived Ord instances The Ordering datatype allows single comparison to determine the precise ordering of two objects Minimal complete definition either compare or Using compare can be more efficient for complex types",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Ord",
          "package": "yi",
          "partial": "Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Ord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParsing of \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003es, producing values.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e (or, for GHC only, \u003ccode\u003e\u003ca\u003ereadPrec\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e make the following assumptions, which\n derived instances of \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e obey:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e If the constructor is defined to be an infix operator, then the\n   derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance will parse only infix applications of\n   the constructor (not the prefix form).\n\u003c/li\u003e\u003cli\u003e Associativity is not used to reduce the occurrence of parentheses,\n   although precedence may be.\n\u003c/li\u003e\u003cli\u003e If the constructor is defined using record syntax, the derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e\n   will parse only the record-syntax form, and furthermore, the fields\n   must be given in the same order as the original declaration.\n\u003c/li\u003e\u003cli\u003e The derived \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance allows arbitrary Haskell whitespace\n   between tokens of the input string.  Extra parentheses are also\n   allowed.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eFor example, given the declarations\n\u003c/p\u003e\u003cpre\u003e infixr 5 :^:\n data Tree a =  Leaf a  |  Tree a :^: Tree a\n\u003c/pre\u003e\u003cp\u003ethe derived instance of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e in Haskell 98 is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Read a) =\u003e Read (Tree a) where\n\n         readsPrec d r =  readParen (d \u003e app_prec)\n                          (\\r -\u003e [(Leaf m,t) |\n                                  (\"Leaf\",s) \u003c- lex r,\n                                  (m,t) \u003c- readsPrec (app_prec+1) s]) r\n\n                       ++ readParen (d \u003e up_prec)\n                          (\\r -\u003e [(u:^:v,w) |\n                                  (u,s) \u003c- readsPrec (up_prec+1) r,\n                                  (\":^:\",t) \u003c- lex s,\n                                  (v,w) \u003c- readsPrec (up_prec+1) t]) r\n\n           where app_prec = 10\n                 up_prec = 5\n\u003c/pre\u003e\u003cp\u003eNote that right-associativity of \u003ccode\u003e:^:\u003c/code\u003e is unused.\n\u003c/p\u003e\u003cp\u003eThe derived instance in GHC is equivalent to\n\u003c/p\u003e\u003cpre\u003e instance (Read a) =\u003e Read (Tree a) where\n\n         readPrec = parens $ (prec app_prec $ do\n                                  Ident \"Leaf\" \u003c- lexP\n                                  m \u003c- step readPrec\n                                  return (Leaf m))\n\n                      +++ (prec up_prec $ do\n                                  u \u003c- step readPrec\n                                  Symbol \":^:\" \u003c- lexP\n                                  v \u003c- step readPrec\n                                  return (u :^: v))\n\n           where app_prec = 10\n                 up_prec = 5\n\n         readListPrec = readListPrecDefault\n\u003c/pre\u003e",
          "module": "Yi.Prelude",
          "name": "Read",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "Parsing of String producing values Minimal complete definition readsPrec or for GHC only readPrec Derived instances of Read make the following assumptions which derived instances of Show obey If the constructor is defined to be an infix operator then the derived Read instance will parse only infix applications of the constructor not the prefix form Associativity is not used to reduce the occurrence of parentheses although precedence may be If the constructor is defined using record syntax the derived Read will parse only the record-syntax form and furthermore the fields must be given in the same order as the original declaration The derived Read instance allows arbitrary Haskell whitespace between tokens of the input string Extra parentheses are also allowed For example given the declarations infixr data Tree Leaf Tree Tree the derived instance of Read in Haskell is equivalent to instance Read Read Tree where readsPrec readParen app prec Leaf Leaf lex readsPrec app prec readParen up prec readsPrec up prec lex readsPrec up prec where app prec up prec Note that right-associativity of is unused The derived instance in GHC is equivalent to instance Read Read Tree where readPrec parens prec app prec do Ident Leaf lexP step readPrec return Leaf prec up prec do step readPrec Symbol lexP step readPrec return where app prec up prec readListPrec readListPrecDefault",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Read",
          "package": "yi",
          "partial": "Read",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "ReaderT",
          "package": "yi",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "ReaderT",
          "package": "yi",
          "partial": "Reader",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:ReaderT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Real",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Real",
          "package": "yi",
          "partial": "Real",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Real"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracting components of fractions.\n\u003c/p\u003e\u003cp\u003eMinimal complete definition: \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "RealFrac",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "Extracting components of fractions Minimal complete definition properFraction",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "RealFrac",
          "package": "yi",
          "partial": "Real Frac",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:RealFrac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Rope",
          "package": "yi",
          "source": "src/Data-Rope.html#Rope",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Rope",
          "package": "yi",
          "partial": "Rope",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Rope"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "SemiNum",
          "package": "yi",
          "source": "src/Yi-Prelude.html#SemiNum",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "SemiNum",
          "package": "yi",
          "partial": "Semi Num",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:SemiNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e is a list of characters.  String constants in Haskell are values\n of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "String",
          "package": "yi",
          "type": "type"
        },
        "index": {
          "description": "String is list of characters String constants in Haskell are values of type String",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "String",
          "package": "yi",
          "partial": "String",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe class \u003ccode\u003e\u003ca\u003eTypeable\u003c/a\u003e\u003c/code\u003e allows a concrete representation of a type to\n be calculated.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "Typeable",
          "package": "yi",
          "type": "class"
        },
        "index": {
          "description": "The class Typeable allows concrete representation of type to be calculated",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Typeable",
          "package": "yi",
          "partial": "Typeable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#t:Typeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(~-)",
          "package": "yi",
          "signature": "absolute -\u003e absolute -\u003e relative",
          "source": "src/Yi-Prelude.html#~-",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(~-) ~-",
          "normalized": "a-\u003ea-\u003eb",
          "package": "yi",
          "signature": "absolute-\u003eabsolute-\u003erelative",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-126--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrict (call-by-value) application, defined in terms of \u003ccode\u003e\u003ca\u003eseq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "($!)",
          "package": "yi",
          "signature": "(a -\u003e b) -\u003e a -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Strict call-by-value application defined in terms of seq",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "($!) $!",
          "normalized": "(a-\u003eb)-\u003ea-\u003eb",
          "package": "yi",
          "signature": "(a-\u003eb)-\u003ea-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-36--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(*)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(*) *",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(+)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(+) +",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(+~)",
          "package": "yi",
          "signature": "absolute -\u003e relative -\u003e absolute",
          "source": "src/Yi-Prelude.html#%2B~",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(+~) +~",
          "normalized": "a-\u003eb-\u003ea",
          "package": "yi",
          "signature": "absolute-\u003erelative-\u003eabsolute",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-43--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend two lists, i.e.,\n\u003c/p\u003e\u003cpre\u003e [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]\n [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]\n\u003c/pre\u003e\u003cp\u003eIf the first list is not finite, the result is the first list.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "(++)",
          "package": "yi",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Append two lists i.e x1 xm y1 yn x1 xm y1 yn x1 xm y1 x1 xm y1 If the first list is not finite the result is the first list",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(++) ++",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "yi",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(-)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(-) -",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(-~)",
          "package": "yi",
          "signature": "absolute -\u003e relative -\u003e absolute",
          "source": "src/Yi-Prelude.html#-~",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(-~) -~",
          "normalized": "a-\u003eb-\u003ea",
          "package": "yi",
          "signature": "absolute-\u003erelative-\u003eabsolute",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-45--126-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efractional division\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "(/)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "fractional division",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(/) /",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(/=)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(/=) /=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-47--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(\u003c)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003c) \u003c",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(\u003c=)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003c=) \u003c=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-60--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRight-to-left Kleisli composition of monads. \u003ccode\u003e(\u003ccode\u003e\u003ca\u003e\u003e=\u003e\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e, with the arguments flipped\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "(\u003c=\u003c)",
          "package": "yi",
          "signature": "(b -\u003e m c) -\u003e (a -\u003e m b) -\u003e a -\u003e m c",
          "type": "function"
        },
        "index": {
          "description": "Right-to-left Kleisli composition of monads with the arguments flipped",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003c=\u003c) \u003c=\u003c",
          "normalized": "(a-\u003eb c)-\u003e(d-\u003eb a)-\u003ed-\u003eb c",
          "package": "yi",
          "signature": "(b-\u003em c)-\u003e(a-\u003em b)-\u003ea-\u003em c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-60--61--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(\u003c\u003e)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Yi-Prelude.html#%3C%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003e\u003e\u003e=\u003c/a\u003e\u003c/code\u003e, but with the arguments interchanged.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "(=\u003c\u003c)",
          "package": "yi",
          "signature": "(a -\u003e m b) -\u003e m a -\u003e m b",
          "type": "function"
        },
        "index": {
          "description": "Same as but with the arguments interchanged",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(=\u003c\u003c) =\u003c\u003c",
          "normalized": "(a-\u003eb c)-\u003eb a-\u003eb c",
          "package": "yi",
          "signature": "(a-\u003em b)-\u003em a-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-61--60--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(==)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(==) ==",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(\u003e)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003e) \u003e",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "(\u003e=)",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Bool",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003e=) \u003e=",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "yi",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, discarding any value produced\n by the first, like sequencing operators (such as the semicolon)\n in imperative languages.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "(\u003e\u003e)",
          "package": "yi",
          "signature": "m a -\u003e m b -\u003e m b",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions discarding any value produced by the first like sequencing operators such as the semicolon in imperative languages",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003e\u003e) \u003e\u003e",
          "normalized": "a b-\u003ea c-\u003ea c",
          "package": "yi",
          "signature": "m a-\u003em b-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSequentially compose two actions, passing any value produced\n by the first as an argument to the second.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "(\u003e\u003e=)",
          "package": "yi",
          "signature": "m a -\u003e (a -\u003e m b) -\u003e m b",
          "type": "method"
        },
        "index": {
          "description": "Sequentially compose two actions passing any value produced by the first as an argument to the second",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "(\u003e\u003e=) \u003e\u003e=",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003ea c",
          "package": "yi",
          "signature": "m a-\u003e(a-\u003em b)-\u003em b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:-62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Just",
          "package": "yi",
          "signature": "Just a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Just",
          "package": "yi",
          "partial": "Just",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:Just"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Left",
          "package": "yi",
          "signature": "Left a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Left",
          "package": "yi",
          "partial": "Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:Left"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Nothing",
          "package": "yi",
          "signature": "Nothing",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Nothing",
          "package": "yi",
          "partial": "Nothing",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:Nothing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "ReaderT",
          "package": "yi",
          "signature": "ReaderT",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "ReaderT",
          "package": "yi",
          "partial": "Reader",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:ReaderT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "Right",
          "package": "yi",
          "signature": "Right b",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "Right",
          "package": "yi",
          "partial": "Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:Right"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbsolute value.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "abs",
          "package": "yi",
          "signature": "a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Absolute value",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "abs",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:abs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAppend two strings by merging the two finger trees.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "append",
          "package": "yi",
          "signature": "Rope -\u003e Rope -\u003e Rope",
          "source": "src/Data-Rope.html#append",
          "type": "function"
        },
        "index": {
          "description": "Append two strings by merging the two finger trees",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "append",
          "normalized": "Rope-\u003eRope-\u003eRope",
          "package": "yi",
          "signature": "Rope-\u003eRope-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:append"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the least integer not less than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "ceiling",
          "package": "yi",
          "signature": "a -\u003e b",
          "type": "method"
        },
        "index": {
          "description": "ceiling returns the least integer not less than",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "ceiling",
          "normalized": "a-\u003eb",
          "package": "yi",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:ceiling"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "compare",
          "package": "yi",
          "signature": "a -\u003e a -\u003e Ordering",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "compare",
          "normalized": "a-\u003ea-\u003eOrdering",
          "package": "yi",
          "signature": "a-\u003ea-\u003eOrdering",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:compare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "concat",
          "package": "yi",
          "signature": "[Rope] -\u003e Rope",
          "source": "src/Data-Rope.html#concat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "concat",
          "normalized": "[Rope]-\u003eRope",
          "package": "yi",
          "signature": "[Rope]-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCount the number of newlines in the strings. (This information cached, so O(1) amortized runtime.)\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "countNewLines",
          "package": "yi",
          "signature": "Rope -\u003e Int",
          "source": "src/Data-Rope.html#countNewLines",
          "type": "function"
        },
        "index": {
          "description": "Count the number of newlines in the strings This information cached so amortized runtime",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "countNewLines",
          "normalized": "Rope-\u003eInt",
          "package": "yi",
          "partial": "New Lines",
          "signature": "Rope-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:countNewLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "discard",
          "package": "yi",
          "signature": "f a -\u003e f ()",
          "source": "src/Yi-Prelude.html#discard",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "discard",
          "normalized": "a b-\u003ea()",
          "package": "yi",
          "signature": "f a-\u003ef()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:discard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger division truncated toward negative infinity\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "div",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "integer division truncated toward negative infinity",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "div",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:div"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimultaneous \u003ccode\u003e\u003ca\u003ediv\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emod\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "divMod",
          "package": "yi",
          "signature": "a -\u003e a -\u003e (a, a)",
          "type": "method"
        },
        "index": {
          "description": "simultaneous div and mod",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "divMod",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "yi",
          "partial": "Mod",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:divMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "drop",
          "package": "yi",
          "signature": "Int -\u003e Rope -\u003e Rope",
          "source": "src/Data-Rope.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "drop",
          "normalized": "Int-\u003eRope-\u003eRope",
          "package": "yi",
          "signature": "Int-\u003eRope-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead nothing, and return \u003ccode\u003e\u003ca\u003einitial\u003c/a\u003e\u003c/code\u003e. Use with \u003ccode\u003e\u003ca\u003edummyPut\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "dummyGet",
          "package": "yi",
          "signature": "Get a",
          "source": "src/Yi-Prelude.html#dummyGet",
          "type": "function"
        },
        "index": {
          "description": "Read nothing and return initial Use with dummyPut",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "dummyGet",
          "package": "yi",
          "partial": "Get",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:dummyGet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrite nothing. Use with \u003ccode\u003e\u003ca\u003edummyGet\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "dummyPut",
          "package": "yi",
          "signature": "a -\u003e Put",
          "source": "src/Yi-Prelude.html#dummyPut",
          "type": "function"
        },
        "index": {
          "description": "Write nothing Use with dummyGet",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "dummyPut",
          "normalized": "a-\u003ePut",
          "package": "yi",
          "partial": "Put",
          "signature": "a-\u003ePut",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:dummyPut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "empty",
          "package": "yi",
          "signature": "Rope",
          "source": "src/Data-Rope.html#empty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "empty",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n..]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "enumFrom",
          "package": "yi",
          "signature": "a -\u003e [a]",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "enumFrom",
          "normalized": "a-\u003e[a]",
          "package": "yi",
          "partial": "From",
          "signature": "a-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:enumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n,n'..]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "enumFromThen",
          "package": "yi",
          "signature": "a -\u003e a -\u003e [a]",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "enumFromThen",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "yi",
          "partial": "From Then",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:enumFromThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n,n'..m]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "enumFromThenTo",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a -\u003e [a]",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "enumFromThenTo",
          "normalized": "a-\u003ea-\u003ea-\u003e[a]",
          "package": "yi",
          "partial": "From Then To",
          "signature": "a-\u003ea-\u003ea-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:enumFromThenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in Haskell's translation of \u003ccode\u003e[n..m]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "enumFromTo",
          "package": "yi",
          "signature": "a -\u003e a -\u003e [a]",
          "type": "method"
        },
        "index": {
          "description": "Used in Haskell translation of n..m",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "enumFromTo",
          "normalized": "a-\u003ea-\u003e[a]",
          "package": "yi",
          "partial": "From To",
          "signature": "a-\u003ea-\u003e[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:enumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLift an accessor to a traversable structure. (This can be seen as a\n generalization of fmap)\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "every",
          "package": "yi",
          "signature": "Accessor whole part -\u003e Accessor (t whole) (t part)",
          "source": "src/Yi-Prelude.html#every",
          "type": "function"
        },
        "index": {
          "description": "Lift an accessor to traversable structure This can be seen as generalization of fmap",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "every",
          "normalized": "Accessor a b-\u003eAccessor(c a)(c b)",
          "package": "yi",
          "signature": "Accessor whole part-\u003eAccessor(t whole)(t part)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:every"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFail with a message.  This operation is not part of the\n mathematical definition of a monad, but is invoked on pattern-match\n failure in a \u003ccode\u003edo\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "fail",
          "package": "yi",
          "signature": "String -\u003e m a",
          "type": "method"
        },
        "index": {
          "description": "Fail with message This operation is not part of the mathematical definition of monad but is invoked on pattern-match failure in do expression",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fail",
          "normalized": "String-\u003ea b",
          "package": "yi",
          "signature": "String-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinds the first element satisfying the predicate, and returns a zipper pointing at it.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "findPL",
          "package": "yi",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e Maybe (PointedList a)",
          "source": "src/Yi-Prelude.html#findPL",
          "type": "function"
        },
        "index": {
          "description": "Finds the first element satisfying the predicate and returns zipper pointing at it",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "findPL",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003eMaybe(PointedList a)",
          "package": "yi",
          "partial": "PL",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003eMaybe(PointedList a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:findPL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the greatest integer not greater than \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "floor",
          "package": "yi",
          "signature": "a -\u003e b",
          "type": "method"
        },
        "index": {
          "description": "floor returns the greatest integer not greater than",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "floor",
          "normalized": "a-\u003eb",
          "package": "yi",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:floor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "fmap",
          "package": "yi",
          "signature": "(a -\u003e b) -\u003e f a -\u003e f b",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fmap",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec b",
          "package": "yi",
          "signature": "(a-\u003eb)-\u003ef a-\u003ef b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fmap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "focusA",
          "package": "yi",
          "signature": "Accessor (PointedList a) a",
          "source": "src/Yi-Prelude.html#focusA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "focusA",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:focusA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert to an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n It is implementation-dependent what \u003ccode\u003e\u003ca\u003efromEnum\u003c/a\u003e\u003c/code\u003e returns when\n applied to a value that is too large to fit in an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "fromEnum",
          "package": "yi",
          "signature": "a -\u003e Int",
          "type": "method"
        },
        "index": {
          "description": "Convert to an Int It is implementation-dependent what fromEnum returns when applied to value that is too large to fit in an Int",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fromEnum",
          "normalized": "a-\u003eInt",
          "package": "yi",
          "partial": "Enum",
          "signature": "a-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fromEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from an \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e.\n An integer literal represents the application of the function\n \u003ccode\u003e\u003ca\u003efromInteger\u003c/a\u003e\u003c/code\u003e to the appropriate value of type \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e,\n so such literals have type \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eNum\u003c/a\u003e\u003c/code\u003e a) =\u003e a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "fromInteger",
          "package": "yi",
          "signature": "Integer -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Conversion from an Integer An integer literal represents the application of the function fromInteger to the appropriate value of type Integer so such literals have type Num",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fromInteger",
          "normalized": "Integer-\u003ea",
          "package": "yi",
          "partial": "Integer",
          "signature": "Integer-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fromInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003egeneral coercion from integral types\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "fromIntegral",
          "package": "yi",
          "signature": "a -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "general coercion from integral types",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fromIntegral",
          "normalized": "a-\u003eb",
          "package": "yi",
          "partial": "Integral",
          "signature": "a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fromIntegral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConversion from a \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e (that is \u003ccode\u003e\u003ccode\u003e\u003ca\u003eRatio\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n A floating literal stands for an application of \u003ccode\u003e\u003ca\u003efromRational\u003c/a\u003e\u003c/code\u003e\n to a value of type \u003ccode\u003e\u003ca\u003eRational\u003c/a\u003e\u003c/code\u003e, so such literals have type\n \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eFractional\u003c/a\u003e\u003c/code\u003e a) =\u003e a\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "fromRational",
          "package": "yi",
          "signature": "Rational -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Conversion from Rational that is Ratio Integer floating literal stands for an application of fromRational to value of type Rational so such literals have type Fractional",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fromRational",
          "normalized": "Rational-\u003ea",
          "package": "yi",
          "partial": "Rational",
          "signature": "Rational-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fromRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "fromString",
          "package": "yi",
          "signature": "String -\u003e Rope",
          "source": "src/Data-Rope.html#fromString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fromString",
          "normalized": "String-\u003eRope",
          "package": "yi",
          "partial": "String",
          "signature": "String-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fromString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the first component of a pair.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "fst",
          "package": "yi",
          "signature": "(a, b) -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Extract the first component of pair",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fst",
          "normalized": "(a,b)-\u003ea",
          "package": "yi",
          "signature": "(a,b)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "fst3",
          "package": "yi",
          "signature": "(a, b, c) -\u003e a",
          "source": "src/Yi-Prelude.html#fst3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "fst3",
          "normalized": "(a,b,c)-\u003ea",
          "package": "yi",
          "signature": "(a,b,c)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:fst3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "getA",
          "package": "yi",
          "signature": "T r a -\u003e m a",
          "source": "src/Yi-Prelude.html#getA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "getA",
          "normalized": "T a b-\u003ec b",
          "package": "yi",
          "signature": "T r a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:getA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlternative to groupBy.\n\u003c/p\u003e\u003cpre\u003e groupBy' (\\a b -\u003e abs (a - b) \u003c= 1) [1,2,3] = [[1,2,3]]\n\u003c/pre\u003e\u003cp\u003ewhereas\n\u003c/p\u003e\u003cpre\u003e groupBy (\\a b -\u003e abs (a - b) \u003c= 1) [1,2,3] = [[1,2],[3]]\n\u003c/pre\u003e\u003cp\u003eTODO: Check in ghc 6.12 release if groupBy == groupBy'.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "groupBy'",
          "package": "yi",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [[a]]",
          "source": "src/Yi-Prelude.html#groupBy%27",
          "type": "function"
        },
        "index": {
          "description": "Alternative to groupBy groupBy abs whereas groupBy abs TODO Check in ghc release if groupBy groupBy",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "groupBy'",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "package": "yi",
          "partial": "By'",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:groupBy-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the first element of a list, which must be non-empty.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "head",
          "package": "yi",
          "signature": "[a] -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Extract the first element of list which must be non-empty",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "head",
          "normalized": "[a]-\u003ea",
          "package": "yi",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all the elements of a list except the last one.\n The list must be non-empty.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "init",
          "package": "yi",
          "signature": "[a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Return all the elements of list except the last one The list must be non-empty",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "init",
          "normalized": "[a]-\u003e[a]",
          "package": "yi",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:init"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "initial",
          "package": "yi",
          "signature": "a",
          "source": "src/Yi-Prelude.html#initial",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "initial",
          "package": "yi",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:initial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "io",
          "package": "yi",
          "signature": "IO a -\u003e m a",
          "source": "src/Yi-Prelude.html#io",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "io",
          "normalized": "IO a-\u003eb a",
          "package": "yi",
          "signature": "IO a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:io"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the last element of a list, which must be finite and non-empty.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "last",
          "package": "yi",
          "signature": "[a] -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Extract the last element of list which must be finite and non-empty",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "last",
          "normalized": "[a]-\u003ea",
          "package": "yi",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:last"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the length of the string. (This information cached, so O(1) amortized runtime.)\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "length",
          "package": "yi",
          "signature": "Rope -\u003e Int",
          "source": "src/Data-Rope.html#length",
          "type": "function"
        },
        "index": {
          "description": "Get the length of the string This information cached so amortized runtime",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "length",
          "normalized": "Rope-\u003eInt",
          "package": "yi",
          "signature": "Rope-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "list",
          "package": "yi",
          "signature": "b -\u003e (a -\u003e [a] -\u003e b) -\u003e [a] -\u003e b",
          "source": "src/Yi-Prelude.html#list",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "list",
          "normalized": "a-\u003e(b-\u003e[b]-\u003ea)-\u003e[b]-\u003ea",
          "package": "yi",
          "signature": "b-\u003e(a-\u003e[a]-\u003eb)-\u003e[a]-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:list"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e \u003ccode\u003ekey assocs\u003c/code\u003e looks up a key in an association list.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "lookup",
          "package": "yi",
          "signature": "a -\u003e [(a, b)] -\u003e Maybe b",
          "type": "function"
        },
        "index": {
          "description": "lookup key assocs looks up key in an association list",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "lookup",
          "normalized": "a-\u003e[(a,b)]-\u003eMaybe b",
          "package": "yi",
          "signature": "a-\u003e[(a,b)]-\u003eMaybe b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs Map.adjust, but the combining function is applied strictly.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "mapAdjust'",
          "package": "yi",
          "signature": "(a -\u003e a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Yi-Prelude.html#mapAdjust%27",
          "type": "function"
        },
        "index": {
          "description": "As Map.adjust but the combining function is applied strictly",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "mapAdjust'",
          "normalized": "(a-\u003ea)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "yi",
          "partial": "Adjust'",
          "signature": "(a-\u003ea)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:mapAdjust-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs Map.alter, but the newly inserted element is forced with the map.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "mapAlter'",
          "package": "yi",
          "signature": "(Maybe a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Yi-Prelude.html#mapAlter%27",
          "type": "function"
        },
        "index": {
          "description": "As Map.alter but the newly inserted element is forced with the map",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "mapAlter'",
          "normalized": "(Maybe a-\u003eMaybe a)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "yi",
          "partial": "Alter'",
          "signature": "(Maybe a-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:mapAlter-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneralisation of \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e to arbitrary foldables.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "mapFromFoldable",
          "package": "yi",
          "signature": "t (k, a) -\u003e Map k a",
          "source": "src/Yi-Prelude.html#mapFromFoldable",
          "type": "function"
        },
        "index": {
          "description": "Generalisation of fromList to arbitrary foldables",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "mapFromFoldable",
          "normalized": "a(b,c)-\u003eMap b c",
          "package": "yi",
          "partial": "From Foldable",
          "signature": "t(k,a)-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:mapFromFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "max",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "max",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:max"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "maxBound",
          "package": "yi",
          "signature": "a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "maxBound",
          "package": "yi",
          "partial": "Bound",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:maxBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "min",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "min",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:min"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "minBound",
          "package": "yi",
          "signature": "a",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "minBound",
          "package": "yi",
          "partial": "Bound",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:minBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger modulus, satisfying\n\u003c/p\u003e\u003cpre\u003e (x `div` y)*y + (x `mod` y) == x\n\u003c/pre\u003e",
          "module": "Yi.Prelude",
          "name": "mod",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "integer modulus satisfying div mod",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "mod",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "modA",
          "package": "yi",
          "signature": "T r a -\u003e (a -\u003e a) -\u003e m ()",
          "source": "src/Yi-Prelude.html#modA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "modA",
          "normalized": "T a b-\u003e(b-\u003eb)-\u003ec()",
          "package": "yi",
          "signature": "T r a-\u003e(a-\u003ea)-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:modA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUnary negation.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "negate",
          "package": "yi",
          "signature": "a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Unary negation",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "negate",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:negate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e, but with O(n*log(n)) behaviour.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "nubSet",
          "package": "yi",
          "signature": "[a] -\u003e [a]",
          "source": "src/Yi-Prelude.html#nubSet",
          "type": "function"
        },
        "index": {
          "description": "As nub but with log behaviour",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "nubSet",
          "normalized": "[a]-\u003e[a]",
          "package": "yi",
          "partial": "Set",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:nubSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest whether a list is empty.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "null",
          "package": "yi",
          "signature": "[a] -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "Test whether list is empty",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "null",
          "normalized": "[a]-\u003eBool",
          "package": "yi",
          "signature": "[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe predecessor of a value.  For numeric types, \u003ccode\u003e\u003ca\u003epred\u003c/a\u003e\u003c/code\u003e subtracts 1.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "pred",
          "package": "yi",
          "signature": "a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "the predecessor of value For numeric types pred subtracts",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "pred",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:pred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e function outputs a value of any printable type to the\n standard output device.\n Printable types are those that are instances of class \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e; \u003ccode\u003e\u003ca\u003eprint\u003c/a\u003e\u003c/code\u003e\n converts values to strings for output using the \u003ccode\u003e\u003ca\u003eshow\u003c/a\u003e\u003c/code\u003e operation and\n adds a newline.\n\u003c/p\u003e\u003cp\u003eFor example, a program to print the first 20 integers and their\n powers of 2 could be written as:\n\u003c/p\u003e\u003cpre\u003e main = print ([(n, 2^n) | n \u003c- [0..19]])\n\u003c/pre\u003e",
          "module": "Yi.Prelude",
          "name": "print",
          "package": "yi",
          "signature": "a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "The print function outputs value of any printable type to the standard output device Printable types are those that are instances of class Show print converts values to strings for output using the show operation and adds newline For example program to print the first integers and their powers of could be written as main print",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "print",
          "normalized": "a-\u003eIO()",
          "package": "yi",
          "signature": "a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:print"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e takes a real fractional number \u003ccode\u003ex\u003c/code\u003e\n and returns a pair \u003ccode\u003e(n,f)\u003c/code\u003e such that \u003ccode\u003ex = n+f\u003c/code\u003e, and:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003en\u003c/code\u003e is an integral number with the same sign as \u003ccode\u003ex\u003c/code\u003e; and\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003ef\u003c/code\u003e is a fraction with the same type and sign as \u003ccode\u003ex\u003c/code\u003e,\n   and with absolute value less than \u003ccode\u003e1\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe default definitions of the \u003ccode\u003e\u003ca\u003eceiling\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003efloor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003etruncate\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eround\u003c/a\u003e\u003c/code\u003e functions are in terms of \u003ccode\u003e\u003ca\u003eproperFraction\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "properFraction",
          "package": "yi",
          "signature": "a -\u003e (b, a)",
          "type": "method"
        },
        "index": {
          "description": "The function properFraction takes real fractional number and returns pair such that and is an integral number with the same sign as and is fraction with the same type and sign as and with absolute value less than The default definitions of the ceiling floor truncate and round functions are in terms of properFraction",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "properFraction",
          "normalized": "a-\u003e(b,a)",
          "package": "yi",
          "partial": "Fraction",
          "signature": "a-\u003e(b,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:properFraction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "putA",
          "package": "yi",
          "signature": "T r a -\u003e a -\u003e m ()",
          "source": "src/Yi-Prelude.html#putA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "putA",
          "normalized": "T a b-\u003eb-\u003ec()",
          "package": "yi",
          "signature": "T r a-\u003ea-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:putA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe same as \u003ccode\u003e\u003ca\u003eputStr\u003c/a\u003e\u003c/code\u003e, but adds a newline character.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "putStrLn",
          "package": "yi",
          "signature": "String -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "The same as putStr but adds newline character",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "putStrLn",
          "normalized": "String-\u003eIO()",
          "package": "yi",
          "partial": "Str Ln",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:putStrLn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger division truncated toward zero\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "quot",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "integer division truncated toward zero",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "quot",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:quot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esimultaneous \u003ccode\u003e\u003ca\u003equot\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erem\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "quotRem",
          "package": "yi",
          "signature": "a -\u003e a -\u003e (a, a)",
          "type": "method"
        },
        "index": {
          "description": "simultaneous quot and rem",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "quotRem",
          "normalized": "a-\u003ea-\u003e(a,a)",
          "package": "yi",
          "partial": "Rem",
          "signature": "a-\u003ea-\u003e(a,a)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:quotRem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eread\u003c/a\u003e\u003c/code\u003e function reads input from a string, which must be\n completely consumed by the input process.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "read",
          "package": "yi",
          "signature": "String -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "The read function reads input from string which must be completely consumed by the input process",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "read",
          "normalized": "String-\u003ea",
          "package": "yi",
          "signature": "String-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:read"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "readFile",
          "package": "yi",
          "signature": "FilePath -\u003e IO Rope",
          "source": "src/Data-Rope.html#readFile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "readFile",
          "normalized": "FilePath-\u003eIO Rope",
          "package": "yi",
          "partial": "File",
          "signature": "FilePath-\u003eIO Rope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:readFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe method \u003ccode\u003e\u003ca\u003ereadList\u003c/a\u003e\u003c/code\u003e is provided to allow the programmer to\n give a specialised way of parsing lists of values.\n For example, this is used by the predefined \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e instance of\n the \u003ccode\u003e\u003ca\u003eChar\u003c/a\u003e\u003c/code\u003e type, where values of type \u003ccode\u003e\u003ca\u003eString\u003c/a\u003e\u003c/code\u003e should be are\n expected to use double quotes, rather than square brackets.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "readList",
          "package": "yi",
          "signature": "ReadS [a]",
          "type": "method"
        },
        "index": {
          "description": "The method readList is provided to allow the programmer to give specialised way of parsing lists of values For example this is used by the predefined Read instance of the Char type where values of type String should be are expected to use double quotes rather than square brackets",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "readList",
          "normalized": "ReadS[a]",
          "package": "yi",
          "partial": "List",
          "signature": "ReadS[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:readList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eattempts to parse a value from the front of the string, returning\n a list of (parsed value, remaining string) pairs.  If there is no\n successful parse, the returned list is empty.\n\u003c/p\u003e\u003cp\u003eDerived instances of \u003ccode\u003e\u003ca\u003eRead\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eShow\u003c/a\u003e\u003c/code\u003e satisfy the following:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(x,\"\")\u003c/code\u003e is an element of\n   \u003ccode\u003e(\u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e d (\u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e d x \"\"))\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThat is, \u003ccode\u003e\u003ca\u003ereadsPrec\u003c/a\u003e\u003c/code\u003e parses the string produced by\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e, and delivers the value that\n \u003ccode\u003e\u003ca\u003eshowsPrec\u003c/a\u003e\u003c/code\u003e started with.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "readsPrec",
          "package": "yi",
          "signature": "readsPrec",
          "type": "method"
        },
        "index": {
          "description": "attempts to parse value from the front of the string returning list of parsed value remaining string pairs If there is no successful parse the returned list is empty Derived instances of Read and Show satisfy the following is an element of readsPrec showsPrec That is readsPrec parses the string produced by showsPrec and delivers the value that showsPrec started with",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "readsPrec",
          "package": "yi",
          "partial": "Prec",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:readsPrec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ereciprocal fraction\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "recip",
          "package": "yi",
          "signature": "a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "reciprocal fraction",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "recip",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:recip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger remainder, satisfying\n\u003c/p\u003e\u003cpre\u003e (x `quot` y)*y + (x `rem` y) == x\n\u003c/pre\u003e",
          "module": "Yi.Prelude",
          "name": "rem",
          "package": "yi",
          "signature": "a -\u003e a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "integer remainder satisfying quot rem",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "rem",
          "normalized": "a-\u003ea-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:rem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e \u003ccode\u003en x\u003c/code\u003e is a list of length \u003ccode\u003en\u003c/code\u003e with \u003ccode\u003ex\u003c/code\u003e the value of\n every element.\n It is an instance of the more general \u003ccode\u003e\u003ca\u003egenericReplicate\u003c/a\u003e\u003c/code\u003e,\n in which \u003ccode\u003en\u003c/code\u003e may be of any integral type.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "replicate",
          "package": "yi",
          "signature": "Int -\u003e a -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "replicate is list of length with the value of every element It is an instance of the more general genericReplicate in which may be of any integral type",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003e[a]",
          "package": "yi",
          "signature": "Int-\u003ea-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInject a value into the monadic type.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "return",
          "package": "yi",
          "signature": "a -\u003e m a",
          "type": "method"
        },
        "index": {
          "description": "Inject value into the monadic type",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "return",
          "normalized": "a-\u003eb a",
          "package": "yi",
          "signature": "a-\u003em a",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "reverse",
          "package": "yi",
          "signature": "Rope -\u003e Rope",
          "source": "src/Data-Rope.html#reverse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "reverse",
          "normalized": "Rope-\u003eRope",
          "package": "yi",
          "signature": "Rope-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eround\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the nearest integer to \u003ccode\u003ex\u003c/code\u003e;\n   the even integer if \u003ccode\u003ex\u003c/code\u003e is equidistant between two integers\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "round",
          "package": "yi",
          "signature": "a -\u003e b",
          "type": "method"
        },
        "index": {
          "description": "round returns the nearest integer to the even integer if is equidistant between two integers",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "round",
          "normalized": "a-\u003eb",
          "package": "yi",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:round"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "runReaderT",
          "package": "yi",
          "signature": "r -\u003e m a",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "runReaderT",
          "normalized": "a-\u003eb c",
          "package": "yi",
          "partial": "Reader",
          "signature": "r-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:runReaderT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluates its first argument to head normal form, and then returns its second\n \targument as the result. \n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "seq",
          "package": "yi",
          "signature": "a -\u003e b -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Evaluates its first argument to head normal form and then returns its second argument as the result",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "seq",
          "normalized": "a-\u003eb-\u003eb",
          "package": "yi",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSign of a number.\n The functions \u003ccode\u003e\u003ca\u003eabs\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e should satisfy the law:\n\u003c/p\u003e\u003cpre\u003e abs x * signum x == x\n\u003c/pre\u003e\u003cp\u003eFor real numbers, the \u003ccode\u003e\u003ca\u003esignum\u003c/a\u003e\u003c/code\u003e is either \u003ccode\u003e-1\u003c/code\u003e (negative), \u003ccode\u003e0\u003c/code\u003e (zero)\n or \u003ccode\u003e1\u003c/code\u003e (positive).\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "signum",
          "package": "yi",
          "signature": "a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Sign of number The functions abs and signum should satisfy the law abs signum For real numbers the signum is either negative zero or positive",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "signum",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:signum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "singleton",
          "package": "yi",
          "signature": "a -\u003e [a]",
          "source": "src/Yi-Prelude.html#singleton",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "singleton",
          "normalized": "a-\u003e[a]",
          "package": "yi",
          "signature": "a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the second component of a pair.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "snd",
          "package": "yi",
          "signature": "(a, b) -\u003e b",
          "type": "function"
        },
        "index": {
          "description": "Extract the second component of pair",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "snd",
          "normalized": "(a,b)-\u003eb",
          "package": "yi",
          "signature": "(a,b)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:snd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "snd3",
          "package": "yi",
          "signature": "(a, b, c) -\u003e b",
          "source": "src/Yi-Prelude.html#snd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "snd3",
          "normalized": "(a,b,c)-\u003eb",
          "package": "yi",
          "signature": "(a,b,c)-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:snd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "split",
          "package": "yi",
          "signature": "Word8 -\u003e Rope -\u003e [Rope]",
          "source": "src/Data-Rope.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "split",
          "normalized": "Word-\u003eRope-\u003e[Rope]",
          "package": "yi",
          "signature": "Word-\u003eRope-\u003e[Rope]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the string at the specified position.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "splitAt",
          "package": "yi",
          "signature": "Int -\u003e Rope -\u003e (Rope, Rope)",
          "source": "src/Data-Rope.html#splitAt",
          "type": "function"
        },
        "index": {
          "description": "Split the string at the specified position",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "splitAt",
          "normalized": "Int-\u003eRope-\u003e(Rope,Rope)",
          "package": "yi",
          "partial": "At",
          "signature": "Int-\u003eRope-\u003e(Rope,Rope)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit the rope on a chunk, so that the desired\n   position lies within the first chunk of the second rope.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "splitAtChunkBefore",
          "package": "yi",
          "signature": "Int -\u003e Rope -\u003e (Rope, Rope)",
          "source": "src/Data-Rope.html#splitAtChunkBefore",
          "type": "function"
        },
        "index": {
          "description": "Split the rope on chunk so that the desired position lies within the first chunk of the second rope",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "splitAtChunkBefore",
          "normalized": "Int-\u003eRope-\u003e(Rope,Rope)",
          "package": "yi",
          "partial": "At Chunk Before",
          "signature": "Int-\u003eRope-\u003e(Rope,Rope)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:splitAtChunkBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit before the specified line. Lines are indexed from 0.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "splitAtLine",
          "package": "yi",
          "signature": "Int -\u003e Rope -\u003e (Rope, Rope)",
          "source": "src/Data-Rope.html#splitAtLine",
          "type": "function"
        },
        "index": {
          "description": "Split before the specified line Lines are indexed from",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "splitAtLine",
          "normalized": "Int-\u003eRope-\u003e(Rope,Rope)",
          "package": "yi",
          "partial": "At Line",
          "signature": "Int-\u003eRope-\u003e(Rope,Rope)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:splitAtLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe successor of a value.  For numeric types, \u003ccode\u003e\u003ca\u003esucc\u003c/a\u003e\u003c/code\u003e adds 1.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "succ",
          "package": "yi",
          "signature": "a -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "the successor of value For numeric types succ adds",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "succ",
          "normalized": "a-\u003ea",
          "package": "yi",
          "signature": "a-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:succ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a function which moves the focus from index A to index B, return a function which swaps the elements at indexes A and B and then moves the focus. See Yi.Editor.swapWinWithFirstE for an example.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "swapFocus",
          "package": "yi",
          "signature": "(PointedList a -\u003e PointedList a) -\u003e PointedList a -\u003e PointedList a",
          "source": "src/Yi-Prelude.html#swapFocus",
          "type": "function"
        },
        "index": {
          "description": "Given function which moves the focus from index to index return function which swaps the elements at indexes and and then moves the focus See Yi.Editor.swapWinWithFirstE for an example",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "swapFocus",
          "normalized": "(PointedList a-\u003ePointedList a)-\u003ePointedList a-\u003ePointedList a",
          "package": "yi",
          "partial": "Focus",
          "signature": "(PointedList a-\u003ePointedList a)-\u003ePointedList a-\u003ePointedList a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:swapFocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract the elements after the head of a list, which must be non-empty.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "tail",
          "package": "yi",
          "signature": "[a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Extract the elements after the head of list which must be non-empty",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "tail",
          "normalized": "[a]-\u003e[a]",
          "package": "yi",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "take",
          "package": "yi",
          "signature": "Int -\u003e Rope -\u003e Rope",
          "source": "src/Data-Rope.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "take",
          "normalized": "Int-\u003eRope-\u003eRope",
          "package": "yi",
          "signature": "Int-\u003eRope-\u003eRope",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "toEnum",
          "package": "yi",
          "signature": "Int -\u003e a",
          "type": "method"
        },
        "index": {
          "description": "Convert from an Int",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "toEnum",
          "normalized": "Int-\u003ea",
          "package": "yi",
          "partial": "Enum",
          "signature": "Int-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:toEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econversion to \u003ccode\u003e\u003ca\u003eInteger\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "toInteger",
          "package": "yi",
          "signature": "a -\u003e Integer",
          "type": "method"
        },
        "index": {
          "description": "conversion to Integer",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "toInteger",
          "normalized": "a-\u003eInteger",
          "package": "yi",
          "partial": "Integer",
          "signature": "a-\u003eInteger",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:toInteger"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe rational equivalent of its real argument with full precision\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "toRational",
          "package": "yi",
          "signature": "a -\u003e Rational",
          "type": "method"
        },
        "index": {
          "description": "the rational equivalent of its real argument with full precision",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "toRational",
          "normalized": "a-\u003eRational",
          "package": "yi",
          "partial": "Rational",
          "signature": "a-\u003eRational",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:toRational"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "toReverseString",
          "package": "yi",
          "signature": "Rope -\u003e String",
          "source": "src/Data-Rope.html#toReverseString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "toReverseString",
          "normalized": "Rope-\u003eString",
          "package": "yi",
          "partial": "Reverse String",
          "signature": "Rope-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:toReverseString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "toString",
          "package": "yi",
          "signature": "Rope -\u003e String",
          "source": "src/Data-Rope.html#toString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "toString",
          "normalized": "Rope-\u003eString",
          "package": "yi",
          "partial": "String",
          "signature": "Rope-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:toString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Prelude",
          "name": "trd3",
          "package": "yi",
          "signature": "(a, b, c) -\u003e c",
          "source": "src/Yi-Prelude.html#trd3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "trd3",
          "normalized": "(a,b,c)-\u003ec",
          "package": "yi",
          "signature": "(a,b,c)-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:trd3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etruncate\u003c/a\u003e\u003c/code\u003e x\u003c/code\u003e returns the integer nearest \u003ccode\u003ex\u003c/code\u003e between zero and \u003ccode\u003ex\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "truncate",
          "package": "yi",
          "signature": "a -\u003e b",
          "type": "method"
        },
        "index": {
          "description": "truncate returns the integer nearest between zero and",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "truncate",
          "normalized": "a-\u003eb",
          "package": "yi",
          "signature": "a-\u003eb",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:truncate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA special case of \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e.\n It is expected that compilers will recognize this and insert error\n messages which are more appropriate to the context in which \u003ccode\u003e\u003ca\u003eundefined\u003c/a\u003e\u003c/code\u003e\n appears. \n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "undefined",
          "package": "yi",
          "signature": "a",
          "type": "function"
        },
        "index": {
          "description": "special case of error It is expected that compilers will recognize this and insert error messages which are more appropriate to the context in which undefined appears",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "undefined",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:undefined"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e is an inverse operation to \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e.\n It joins lines, after appending a terminating newline to each.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "unlines",
          "package": "yi",
          "signature": "[String] -\u003e String",
          "type": "function"
        },
        "index": {
          "description": "unlines is an inverse operation to lines It joins lines after appending terminating newline to each",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "unlines",
          "normalized": "[String]-\u003eString",
          "package": "yi",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:unlines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConditional execution of monadic expressions. For example, \n\u003c/p\u003e\u003cpre\u003e       when debug (putStr \"Debugging\\n\")\n\u003c/pre\u003e\u003cp\u003ewill output the string \u003ccode\u003eDebugging\\n\u003c/code\u003e if the Boolean value \u003ccode\u003edebug\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e,\nand otherwise do nothing.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "when",
          "package": "yi",
          "signature": "Bool -\u003e m () -\u003e m ()",
          "type": "function"
        },
        "index": {
          "description": "Conditional execution of monadic expressions For example when debug putStr Debugging will output the string Debugging if the Boolean value debug is True and otherwise do nothing",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "when",
          "normalized": "Bool-\u003ea()-\u003ea()",
          "package": "yi",
          "signature": "Bool-\u003em()-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:when"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe computation \u003ccode\u003e\u003ca\u003ewriteFile\u003c/a\u003e\u003c/code\u003e \u003ccode\u003efile str\u003c/code\u003e function writes the string \u003ccode\u003estr\u003c/code\u003e,\n to the file \u003ccode\u003efile\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Prelude",
          "name": "writeFile",
          "package": "yi",
          "signature": "FilePath -\u003e String -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "The computation writeFile file str function writes the string str to the file file",
          "hierarchy": "Yi Prelude",
          "module": "Yi.Prelude",
          "name": "writeFile",
          "normalized": "FilePath-\u003eString-\u003eIO()",
          "package": "yi",
          "partial": "File",
          "signature": "FilePath-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Prelude.html#v:writeFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "Process",
          "package": "yi",
          "source": "src/Yi-Process.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "Process",
          "package": "yi",
          "partial": "Process",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "SubprocessId",
          "package": "yi",
          "source": "src/Yi-Process.html#SubprocessId",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "SubprocessId",
          "package": "yi",
          "partial": "Subprocess Id",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#t:SubprocessId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "SubprocessInfo",
          "package": "yi",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "SubprocessInfo",
          "package": "yi",
          "partial": "Subprocess Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#t:SubprocessInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "SubprocessInfo",
          "package": "yi",
          "signature": "SubprocessInfo",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "SubprocessInfo",
          "package": "yi",
          "partial": "Subprocess Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:SubprocessInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "bufRef",
          "package": "yi",
          "signature": "BufferRef",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "bufRef",
          "package": "yi",
          "partial": "Ref",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:bufRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "createSubprocess",
          "package": "yi",
          "signature": "FilePath -\u003e [String] -\u003e BufferRef -\u003e IO SubprocessInfo",
          "source": "src/Yi-Process.html#createSubprocess",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "createSubprocess",
          "normalized": "FilePath-\u003e[String]-\u003eBufferRef-\u003eIO SubprocessInfo",
          "package": "yi",
          "partial": "Subprocess",
          "signature": "FilePath-\u003e[String]-\u003eBufferRef-\u003eIO SubprocessInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:createSubprocess"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "hErr",
          "package": "yi",
          "signature": "Handle",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "hErr",
          "package": "yi",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:hErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "hIn",
          "package": "yi",
          "signature": "Handle",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "hIn",
          "package": "yi",
          "partial": "In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:hIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "hOut",
          "package": "yi",
          "signature": "Handle",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "hOut",
          "package": "yi",
          "partial": "Out",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:hOut"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Posix.popen compatibility mapping.\n Based on PosixCompat, originally written by Derek Elkins for lambdabot\n TODO: this will probably be called readProcess in the new process package (2.0)\n\u003c/p\u003e",
          "module": "Yi.Process",
          "name": "popen",
          "package": "yi",
          "signature": "FilePath -\u003e [String] -\u003e Maybe String -\u003e IO (String, String, ExitCode)",
          "source": "src/Yi-Process.html#popen",
          "type": "function"
        },
        "index": {
          "description": "Posix.popen compatibility mapping Based on PosixCompat originally written by Derek Elkins for lambdabot TODO this will probably be called readProcess in the new process package",
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "popen",
          "normalized": "FilePath-\u003e[String]-\u003eMaybe String-\u003eIO(String,String,ExitCode)",
          "package": "yi",
          "signature": "FilePath-\u003e[String]-\u003eMaybe String-\u003eIO(String,String,ExitCode)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:popen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "procArgs",
          "package": "yi",
          "signature": "[String]",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "procArgs",
          "normalized": "[String]",
          "package": "yi",
          "partial": "Args",
          "signature": "[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:procArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "procCmd",
          "package": "yi",
          "signature": "FilePath",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "procCmd",
          "package": "yi",
          "partial": "Cmd",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:procCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "procHandle",
          "package": "yi",
          "signature": "ProcessHandle",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "procHandle",
          "package": "yi",
          "partial": "Handle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:procHandle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "readAvailable",
          "package": "yi",
          "signature": "Handle -\u003e IO String",
          "source": "src/Yi-Process.html#readAvailable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "readAvailable",
          "normalized": "Handle-\u003eIO String",
          "package": "yi",
          "partial": "Available",
          "signature": "Handle-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:readAvailable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a command. This looks up a program name in $PATH, but then calls it\n directly with the argument.\n\u003c/p\u003e",
          "module": "Yi.Process",
          "name": "runProgCommand",
          "package": "yi",
          "signature": "String -\u003e [String] -\u003e IO (String, String, ExitCode)",
          "source": "src/Yi-Process.html#runProgCommand",
          "type": "function"
        },
        "index": {
          "description": "Run command This looks up program name in PATH but then calls it directly with the argument",
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "runProgCommand",
          "normalized": "String-\u003e[String]-\u003eIO(String,String,ExitCode)",
          "package": "yi",
          "partial": "Prog Command",
          "signature": "String-\u003e[String]-\u003eIO(String,String,ExitCode)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:runProgCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "runShellCommand",
          "package": "yi",
          "signature": "String -\u003e IO (String, String, ExitCode)",
          "source": "src/Yi-Process.html#runShellCommand",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "runShellCommand",
          "normalized": "String-\u003eIO(String,String,ExitCode)",
          "package": "yi",
          "partial": "Shell Command",
          "signature": "String-\u003eIO(String,String,ExitCode)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:runShellCommand"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Process",
          "name": "separateStdErr",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Process.html#SubprocessInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "separateStdErr",
          "package": "yi",
          "partial": "Std Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:separateStdErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a command using the system shell, returning stdout, stderr and exit code\n\u003c/p\u003e",
          "module": "Yi.Process",
          "name": "shellFileName",
          "package": "yi",
          "signature": "IO String",
          "source": "src/Yi-Process.html#shellFileName",
          "type": "function"
        },
        "index": {
          "description": "Run command using the system shell returning stdout stderr and exit code",
          "hierarchy": "Yi Process",
          "module": "Yi.Process",
          "name": "shellFileName",
          "package": "yi",
          "partial": "File Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Process.html#v:shellFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eemacs-style rectangle manipulation functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Rectangle",
          "name": "Rectangle",
          "package": "yi",
          "source": "src/Yi-Rectangle.html",
          "type": "module"
        },
        "index": {
          "description": "emacs-style rectangle manipulation functions",
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "Rectangle",
          "package": "yi",
          "partial": "Rectangle",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Rectangle",
          "name": "alignRegion",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Rectangle.html#alignRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "alignRegion",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Region",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:alignRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAlign each line of the region on the given regex.\n Fails if it is not found in any line.\n\u003c/p\u003e",
          "module": "Yi.Rectangle",
          "name": "alignRegionOn",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Rectangle.html#alignRegionOn",
          "type": "function"
        },
        "index": {
          "description": "Align each line of the region on the given regex Fails if it is not found in any line",
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "alignRegionOn",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Region On",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:alignRegionOn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the selected region as a rectangle.\n Returns the region extended to lines, plus the start and end columns of the rectangle.\n\u003c/p\u003e",
          "module": "Yi.Rectangle",
          "name": "getRectangle",
          "package": "yi",
          "signature": "BufferM (Region, Int, Int)",
          "source": "src/Yi-Rectangle.html#getRectangle",
          "type": "function"
        },
        "index": {
          "description": "Get the selected region as rectangle Returns the region extended to lines plus the start and end columns of the rectangle",
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "getRectangle",
          "normalized": "BufferM(Region,Int,Int)",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "BufferM(Region,Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:getRectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Rectangle",
          "name": "killRectangle",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Rectangle.html#killRectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "killRectangle",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:killRectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a list at the boundaries given\n\u003c/p\u003e",
          "module": "Yi.Rectangle",
          "name": "multiSplit",
          "package": "yi",
          "signature": "[Int] -\u003e [a] -\u003e [[a]]",
          "source": "src/Yi-Rectangle.html#multiSplit",
          "type": "function"
        },
        "index": {
          "description": "Split list at the boundaries given",
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "multiSplit",
          "normalized": "[Int]-\u003e[a]-\u003e[[a]]",
          "package": "yi",
          "partial": "Split",
          "signature": "[Int]-\u003e[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:multiSplit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Rectangle",
          "name": "onRectangle",
          "package": "yi",
          "signature": "(Int -\u003e Int -\u003e String -\u003e String) -\u003e BufferM ()",
          "source": "src/Yi-Rectangle.html#onRectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "onRectangle",
          "normalized": "(Int-\u003eInt-\u003eString-\u003eString)-\u003eBufferM()",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "(Int-\u003eInt-\u003eString-\u003eString)-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:onRectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Rectangle",
          "name": "openRectangle",
          "package": "yi",
          "signature": "BufferM ()",
          "source": "src/Yi-Rectangle.html#openRectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "openRectangle",
          "normalized": "BufferM()",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "BufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:openRectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Rectangle",
          "name": "stringRectangle",
          "package": "yi",
          "signature": "String -\u003e BufferM ()",
          "source": "src/Yi-Rectangle.html#stringRectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "stringRectangle",
          "normalized": "String-\u003eBufferM()",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "String-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:stringRectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Rectangle",
          "name": "yankRectangle",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Rectangle.html#yankRectangle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Rectangle",
          "module": "Yi.Rectangle",
          "name": "yankRectangle",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Rectangle",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Rectangle.html#v:yankRectangle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "Regex",
          "package": "yi",
          "source": "src/Yi-Regex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "Regex",
          "package": "yi",
          "partial": "Regex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "SearchExp",
          "package": "yi",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "SearchExp",
          "package": "yi",
          "partial": "Search Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#t:SearchExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "SearchOption",
          "package": "yi",
          "source": "src/Yi-Regex.html#SearchOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "SearchOption",
          "package": "yi",
          "partial": "Search Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#t:SearchOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompile for matching that ignores char case\n\u003c/p\u003e",
          "module": "[\"Yi.Regex\",\"Yi.Search\"]",
          "name": "IgnoreCase",
          "package": "yi",
          "signature": "IgnoreCase",
          "source": "src/Yi-Regex.html#SearchOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:IgnoreCase\",\"http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:IgnoreCase\"]"
        },
        "index": {
          "description": "Compile for matching that ignores char case",
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "IgnoreCase",
          "package": "yi",
          "partial": "Ignore Case",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:IgnoreCase"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompile for newline-insensitive matching\n\u003c/p\u003e",
          "module": "[\"Yi.Regex\",\"Yi.Search\"]",
          "name": "NoNewLine",
          "package": "yi",
          "signature": "NoNewLine",
          "source": "src/Yi-Regex.html#SearchOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:NoNewLine\",\"http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:NoNewLine\"]"
        },
        "index": {
          "description": "Compile for newline-insensitive matching",
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "NoNewLine",
          "package": "yi",
          "partial": "No New Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:NoNewLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTreat the input not as a regex but as a literal string to search for.\n\u003c/p\u003e",
          "module": "[\"Yi.Regex\",\"Yi.Search\"]",
          "name": "QuoteRegex",
          "package": "yi",
          "signature": "QuoteRegex",
          "source": "src/Yi-Regex.html#SearchOption",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:QuoteRegex\",\"http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:QuoteRegex\"]"
        },
        "index": {
          "description": "Treat the input not as regex but as literal string to search for",
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "QuoteRegex",
          "package": "yi",
          "partial": "Quote Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:QuoteRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "SearchExp",
          "package": "yi",
          "signature": "SearchExp",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "SearchExp",
          "package": "yi",
          "partial": "Search Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:SearchExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe regular expression that matches nothing.\n\u003c/p\u003e",
          "module": "Yi.Regex",
          "name": "emptyRegex",
          "package": "yi",
          "signature": "Regex",
          "source": "src/Yi-Regex.html#emptyRegex",
          "type": "function"
        },
        "index": {
          "description": "The regular expression that matches nothing",
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "emptyRegex",
          "package": "yi",
          "partial": "Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:emptyRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "emptySearch",
          "package": "yi",
          "signature": "SearchExp",
          "source": "src/Yi-Regex.html#emptySearch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "emptySearch",
          "package": "yi",
          "partial": "Search",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:emptySearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "makeSearchOptsM",
          "package": "yi",
          "signature": "[SearchOption] -\u003e String -\u003e Either String SearchExp",
          "source": "src/Yi-Regex.html#makeSearchOptsM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "makeSearchOptsM",
          "normalized": "[SearchOption]-\u003eString-\u003eEither String SearchExp",
          "package": "yi",
          "partial": "Search Opts",
          "signature": "[SearchOption]-\u003eString-\u003eEither String SearchExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:makeSearchOptsM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn an escaped (for parseRegex use) version of the string.\n\u003c/p\u003e",
          "module": "Yi.Regex",
          "name": "regexEscapeString",
          "package": "yi",
          "signature": "String -\u003e String",
          "source": "src/Yi-Regex.html#regexEscapeString",
          "type": "function"
        },
        "index": {
          "description": "Return an escaped for parseRegex use version of the string",
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "regexEscapeString",
          "normalized": "String-\u003eString",
          "package": "yi",
          "partial": "Escape String",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:regexEscapeString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "seBackCompiled",
          "package": "yi",
          "signature": "Regex",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "seBackCompiled",
          "package": "yi",
          "partial": "Back Compiled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:seBackCompiled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "seCompiled",
          "package": "yi",
          "signature": "Regex",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "seCompiled",
          "package": "yi",
          "partial": "Compiled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:seCompiled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "seInput",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "seInput",
          "package": "yi",
          "partial": "Input",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:seInput"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "seOptions",
          "package": "yi",
          "signature": "[SearchOption]",
          "source": "src/Yi-Regex.html#SearchExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "seOptions",
          "normalized": "[SearchOption]",
          "package": "yi",
          "partial": "Options",
          "signature": "[SearchOption]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:seOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "searchRegex",
          "package": "yi",
          "signature": "Direction -\u003e SearchExp -\u003e Regex",
          "source": "src/Yi-Regex.html#searchRegex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "searchRegex",
          "normalized": "Direction-\u003eSearchExp-\u003eRegex",
          "package": "yi",
          "partial": "Regex",
          "signature": "Direction-\u003eSearchExp-\u003eRegex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:searchRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Regex",
          "name": "searchString",
          "package": "yi",
          "signature": "SearchExp -\u003e String",
          "source": "src/Yi-Regex.html#searchString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Regex",
          "module": "Yi.Regex",
          "name": "searchString",
          "normalized": "SearchExp-\u003eString",
          "package": "yi",
          "partial": "String",
          "signature": "SearchExp-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Regex.html#v:searchString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the Region ADT\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Region",
          "name": "Region",
          "package": "yi",
          "source": "src/Yi-Region.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the Region ADT",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "Region",
          "package": "yi",
          "partial": "Region",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe region data type. \nThe region is semi open: it includes the start but not the end bound. This allows simpler region-manipulation algorithms.\n Invariant : regionStart r \u003c= regionEnd r\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "Region",
          "package": "yi",
          "source": "src/Yi-Region.html#Region",
          "type": "data"
        },
        "index": {
          "description": "The region data type The region is semi open it includes the start but not the end bound This allows simpler region-manipulation algorithms Invariant regionStart regionEnd",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "Region",
          "package": "yi",
          "partial": "Region",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#t:Region"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty region\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "emptyRegion",
          "package": "yi",
          "signature": "Region",
          "source": "src/Yi-Region.html#emptyRegion",
          "type": "function"
        },
        "index": {
          "description": "The empty region",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "emptyRegion",
          "package": "yi",
          "partial": "Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:emptyRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "fmapRegion",
          "package": "yi",
          "signature": "(Point -\u003e Point) -\u003e Region -\u003e Region",
          "source": "src/Yi-Region.html#fmapRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "fmapRegion",
          "normalized": "(Point-\u003ePoint)-\u003eRegion-\u003eRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "(Point-\u003ePoint)-\u003eRegion-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:fmapRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if the given point is inside the given region.\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "inRegion",
          "package": "yi",
          "signature": "Point -\u003e Region -\u003e Bool",
          "source": "src/Yi-Region.html#inRegion",
          "type": "function"
        },
        "index": {
          "description": "True if the given point is inside the given region",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "inRegion",
          "normalized": "Point-\u003eRegion-\u003eBool",
          "package": "yi",
          "partial": "Region",
          "signature": "Point-\u003eRegion-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:inRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns if a region (1st arg) is  included in another (2nd arg)\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "includedRegion",
          "package": "yi",
          "signature": "Region -\u003e Region -\u003e Bool",
          "source": "src/Yi-Region.html#includedRegion",
          "type": "function"
        },
        "index": {
          "description": "Returns if region st arg is included in another nd arg",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "includedRegion",
          "normalized": "Region-\u003eRegion-\u003eBool",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eRegion-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:includedRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the intersection of two regions\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "intersectRegion",
          "package": "yi",
          "signature": "Region -\u003e Region -\u003e Region",
          "source": "src/Yi-Region.html#intersectRegion",
          "type": "function"
        },
        "index": {
          "description": "Take the intersection of two regions",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "intersectRegion",
          "normalized": "Region-\u003eRegion-\u003eRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eRegion-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:intersectRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstruct a region from its bounds, emacs style:\n the right bound is excluded\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "mkRegion",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e Region",
          "source": "src/Yi-Region.html#mkRegion",
          "type": "function"
        },
        "index": {
          "description": "Construct region from its bounds emacs style the right bound is excluded",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "mkRegion",
          "normalized": "Point-\u003ePoint-\u003eRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "Point-\u003ePoint-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:mkRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "mkRegion'",
          "package": "yi",
          "signature": "Direction -\u003e Point -\u003e Point -\u003e Region",
          "source": "src/Yi-Region.html#mkRegion%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "mkRegion'",
          "normalized": "Direction-\u003ePoint-\u003ePoint-\u003eRegion",
          "package": "yi",
          "partial": "Region'",
          "signature": "Direction-\u003ePoint-\u003ePoint-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:mkRegion-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "mkSizeRegion",
          "package": "yi",
          "signature": "Point -\u003e Size -\u003e Region",
          "source": "src/Yi-Region.html#mkSizeRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "mkSizeRegion",
          "normalized": "Point-\u003eSize-\u003eRegion",
          "package": "yi",
          "partial": "Size Region",
          "signature": "Point-\u003eSize-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:mkSizeRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrue if the given point is inside the given region or at the end of it.\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "nearRegion",
          "package": "yi",
          "signature": "Point -\u003e Region -\u003e Bool",
          "source": "src/Yi-Region.html#nearRegion",
          "type": "function"
        },
        "index": {
          "description": "True if the given point is inside the given region or at the end of it",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "nearRegion",
          "normalized": "Point-\u003eRegion-\u003eBool",
          "package": "yi",
          "partial": "Region",
          "signature": "Point-\u003eRegion-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:nearRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionDirection",
          "package": "yi",
          "signature": "Region -\u003e Direction",
          "source": "src/Yi-Region.html#regionDirection",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionDirection",
          "normalized": "Region-\u003eDirection",
          "package": "yi",
          "partial": "Direction",
          "signature": "Region-\u003eDirection",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionDirection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionEnd",
          "package": "yi",
          "signature": "Region -\u003e Point",
          "source": "src/Yi-Region.html#regionEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionEnd",
          "normalized": "Region-\u003ePoint",
          "package": "yi",
          "partial": "End",
          "signature": "Region-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionFirst",
          "package": "yi",
          "signature": "Region -\u003e Point",
          "source": "src/Yi-Region.html#regionFirst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionFirst",
          "normalized": "Region-\u003ePoint",
          "package": "yi",
          "partial": "First",
          "signature": "Region-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionIsEmpty",
          "package": "yi",
          "signature": "Region -\u003e Bool",
          "source": "src/Yi-Region.html#regionIsEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionIsEmpty",
          "normalized": "Region-\u003eBool",
          "package": "yi",
          "partial": "Is Empty",
          "signature": "Region-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionIsEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionLast",
          "package": "yi",
          "signature": "Region -\u003e Point",
          "source": "src/Yi-Region.html#regionLast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionLast",
          "normalized": "Region-\u003ePoint",
          "package": "yi",
          "partial": "Last",
          "signature": "Region-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionLast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionSize",
          "package": "yi",
          "signature": "Region -\u003e Size",
          "source": "src/Yi-Region.html#regionSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionSize",
          "normalized": "Region-\u003eSize",
          "package": "yi",
          "partial": "Size",
          "signature": "Region-\u003eSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionStart",
          "package": "yi",
          "signature": "Region -\u003e Point",
          "source": "src/Yi-Region.html#regionStart",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionStart",
          "normalized": "Region-\u003ePoint",
          "package": "yi",
          "partial": "Start",
          "signature": "Region-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Region",
          "name": "regionsOverlap",
          "package": "yi",
          "signature": "Bool -\u003e Region -\u003e Region -\u003e Bool",
          "source": "src/Yi-Region.html#regionsOverlap",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "regionsOverlap",
          "normalized": "Bool-\u003eRegion-\u003eRegion-\u003eBool",
          "package": "yi",
          "partial": "Overlap",
          "signature": "Bool-\u003eRegion-\u003eRegion-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:regionsOverlap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTake the union of two regions (including what is between them)\n\u003c/p\u003e",
          "module": "Yi.Region",
          "name": "unionRegion",
          "package": "yi",
          "signature": "Region -\u003e Region -\u003e Region",
          "source": "src/Yi-Region.html#unionRegion",
          "type": "function"
        },
        "index": {
          "description": "Take the union of two regions including what is between them",
          "hierarchy": "Yi Region",
          "module": "Yi.Region",
          "name": "unionRegion",
          "normalized": "Region-\u003eRegion-\u003eRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "Region-\u003eRegion-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Region.html#v:unionRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSearch/Replace functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Search",
          "name": "Search",
          "package": "yi",
          "source": "src/Yi-Search.html",
          "type": "module"
        },
        "index": {
          "description": "Search Replace functions",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "Search",
          "package": "yi",
          "partial": "Search",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGlobal searching. Search for regex and move point to that position.\n \u003ccode\u003eNothing\u003c/code\u003e means reuse the last regular expression. \u003ccode\u003eJust s\u003c/code\u003e means use\n \u003ccode\u003es\u003c/code\u003e as the new regular expression. Direction of search can be\n specified as either \u003ccode\u003eBackward\u003c/code\u003e or \u003ccode\u003eForward\u003c/code\u003e (forwards in the buffer).\n Arguments to modify the compiled regular expression can be supplied\n as well.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "SearchMatch",
          "package": "yi",
          "source": "src/Yi-Search.html#SearchMatch",
          "type": "type"
        },
        "index": {
          "description": "Global searching Search for regex and move point to that position Nothing means reuse the last regular expression Just means use as the new regular expression Direction of search can be specified as either Backward or Forward forwards in the buffer Arguments to modify the compiled regular expression can be supplied as well",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "SearchMatch",
          "package": "yi",
          "partial": "Search Match",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#t:SearchMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "SearchOption",
          "package": "yi",
          "source": "src/Yi-Regex.html#SearchOption",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "SearchOption",
          "package": "yi",
          "partial": "Search Option",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#t:SearchOption"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "SearchResult",
          "package": "yi",
          "source": "src/Yi-Search.html#SearchResult",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "SearchResult",
          "package": "yi",
          "partial": "Search Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#t:SearchResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "PatternFound",
          "package": "yi",
          "signature": "PatternFound",
          "source": "src/Yi-Search.html#SearchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "PatternFound",
          "package": "yi",
          "partial": "Pattern Found",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:PatternFound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "PatternNotFound",
          "package": "yi",
          "signature": "PatternNotFound",
          "source": "src/Yi-Search.html#SearchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "PatternNotFound",
          "package": "yi",
          "partial": "Pattern Not Found",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:PatternNotFound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "SearchWrapped",
          "package": "yi",
          "signature": "SearchWrapped",
          "source": "src/Yi-Search.html#SearchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "SearchWrapped",
          "package": "yi",
          "partial": "Search Wrapped",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:SearchWrapped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo a search, placing cursor at first char of pattern, if found.\n Keymaps may implement their own regex language. How do we provide for this?\n Also, what's happening with ^ not matching sol?\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "continueSearch",
          "package": "yi",
          "signature": "(SearchExp, Direction) -\u003e BufferM SearchResult",
          "source": "src/Yi-Search.html#continueSearch",
          "type": "function"
        },
        "index": {
          "description": "Do search placing cursor at first char of pattern if found Keymaps may implement their own regex language How do we provide for this Also what happening with not matching sol",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "continueSearch",
          "normalized": "(SearchExp,Direction)-\u003eBufferM SearchResult",
          "package": "yi",
          "partial": "Search",
          "signature": "(SearchExp,Direction)-\u003eBufferM SearchResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:continueSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "doSearch",
          "package": "yi",
          "signature": "Maybe String-\u003e [SearchOption]-\u003e Direction-\u003e EditorM SearchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "doSearch",
          "normalized": "Maybe String-\u003e[SearchOption]-\u003eDirection-\u003eEditorM SearchResult",
          "package": "yi",
          "partial": "Search",
          "signature": "Maybe String-\u003e[SearchOption]-\u003eDirection-\u003eEditorM SearchResult",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:doSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn contents of regex register\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "getRegexE",
          "package": "yi",
          "signature": "EditorM (Maybe SearchExp)",
          "source": "src/Yi-Search.html#getRegexE",
          "type": "function"
        },
        "index": {
          "description": "Return contents of regex register",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "getRegexE",
          "package": "yi",
          "partial": "Regex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:getRegexE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchAddE",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Search.html#isearchAddE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchAddE",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Add",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchAddE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchCancelE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#isearchCancelE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchCancelE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Cancel",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchCancelE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchDelE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#isearchDelE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchDelE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Del",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchDelE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchFinishE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#isearchFinishE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchFinishE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Finish",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchFinishE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchHistory",
          "package": "yi",
          "signature": "Int -\u003e EditorM ()",
          "source": "src/Yi-Search.html#isearchHistory",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchHistory",
          "normalized": "Int-\u003eEditorM()",
          "package": "yi",
          "partial": "History",
          "signature": "Int-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchHistory"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchInitE",
          "package": "yi",
          "signature": "Direction -\u003e EditorM ()",
          "source": "src/Yi-Search.html#isearchInitE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchInitE",
          "normalized": "Direction-\u003eEditorM()",
          "package": "yi",
          "partial": "Init",
          "signature": "Direction-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchInitE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchIsEmpty",
          "package": "yi",
          "signature": "EditorM Bool",
          "source": "src/Yi-Search.html#isearchIsEmpty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchIsEmpty",
          "package": "yi",
          "partial": "Is Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchIsEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchNextE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#isearchNextE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchNextE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Next",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchNextE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchPrevE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#isearchPrevE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchPrevE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Prev",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchPrevE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "isearchWordE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#isearchWordE",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "isearchWordE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Word",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:isearchWordE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a SearchExp that matches exactly its argument\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "makeSimpleSearch",
          "package": "yi",
          "signature": "String -\u003e SearchExp",
          "source": "src/Yi-Search.html#makeSimpleSearch",
          "type": "function"
        },
        "index": {
          "description": "Create SearchExp that matches exactly its argument",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "makeSimpleSearch",
          "normalized": "String-\u003eSearchExp",
          "package": "yi",
          "partial": "Simple Search",
          "signature": "String-\u003eSearchExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:makeSimpleSearch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExit from query/replace.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "qrFinish",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#qrFinish",
          "type": "function"
        },
        "index": {
          "description": "Exit from query replace",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "qrFinish",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Finish",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:qrFinish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the next match and select it.\n Point is end, mark is beginning.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "qrNext",
          "package": "yi",
          "signature": "Window -\u003e BufferRef -\u003e SearchExp -\u003e EditorM ()",
          "source": "src/Yi-Search.html#qrNext",
          "type": "function"
        },
        "index": {
          "description": "Find the next match and select it Point is end mark is beginning",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "qrNext",
          "normalized": "Window-\u003eBufferRef-\u003eSearchExp-\u003eEditorM()",
          "package": "yi",
          "partial": "Next",
          "signature": "Window-\u003eBufferRef-\u003eSearchExp-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:qrNext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace all the remaining occurrences.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "qrReplaceAll",
          "package": "yi",
          "signature": "Window -\u003e BufferRef -\u003e SearchExp -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-Search.html#qrReplaceAll",
          "type": "function"
        },
        "index": {
          "description": "Replace all the remaining occurrences",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "qrReplaceAll",
          "normalized": "Window-\u003eBufferRef-\u003eSearchExp-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Replace All",
          "signature": "Window-\u003eBufferRef-\u003eSearchExp-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:qrReplaceAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "qrReplaceOne",
          "package": "yi",
          "signature": "Window -\u003e BufferRef -\u003e SearchExp -\u003e String -\u003e EditorM ()",
          "source": "src/Yi-Search.html#qrReplaceOne",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "qrReplaceOne",
          "normalized": "Window-\u003eBufferRef-\u003eSearchExp-\u003eString-\u003eEditorM()",
          "package": "yi",
          "partial": "Replace One",
          "signature": "Window-\u003eBufferRef-\u003eSearchExp-\u003eString-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:qrReplaceOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReplace a string by another everywhere in the document\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "replaceString",
          "package": "yi",
          "signature": "String -\u003e String -\u003e BufferM Int",
          "source": "src/Yi-Search.html#replaceString",
          "type": "function"
        },
        "index": {
          "description": "Replace string by another everywhere in the document",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "replaceString",
          "normalized": "String-\u003eString-\u003eBufferM Int",
          "package": "yi",
          "partial": "String",
          "signature": "String-\u003eString-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:replaceString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClear the regex \u003ccode\u003eregister\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "resetRegexE",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Search.html#resetRegexE",
          "type": "function"
        },
        "index": {
          "description": "Clear the regex register",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "resetRegexE",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Regex",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:resetRegexE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Search",
          "name": "searchAndRepRegion",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Bool -\u003e Region -\u003e EditorM Bool",
          "source": "src/Yi-Search.html#searchAndRepRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "searchAndRepRegion",
          "normalized": "String-\u003eString-\u003eBool-\u003eRegion-\u003eEditorM Bool",
          "package": "yi",
          "partial": "And Rep Region",
          "signature": "String-\u003eString-\u003eBool-\u003eRegion-\u003eEditorM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:searchAndRepRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch and replace in the given region.\n If the input boolean is True, then the replace is done globally, otherwise only the first match is replaced.\n Returns the number of replacements done.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "searchAndRepRegion0",
          "package": "yi",
          "signature": "SearchExp -\u003e String -\u003e Bool -\u003e Region -\u003e BufferM Int",
          "source": "src/Yi-Search.html#searchAndRepRegion0",
          "type": "function"
        },
        "index": {
          "description": "Search and replace in the given region If the input boolean is True then the replace is done globally otherwise only the first match is replaced Returns the number of replacements done",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "searchAndRepRegion0",
          "normalized": "SearchExp-\u003eString-\u003eBool-\u003eRegion-\u003eBufferM Int",
          "package": "yi",
          "partial": "And Rep Region",
          "signature": "SearchExp-\u003eString-\u003eBool-\u003eRegion-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:searchAndRepRegion0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch and replace in the region defined by the given unit.\n The rest is as in \u003ccode\u003e\u003ca\u003esearchAndRepRegion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "searchAndRepUnit",
          "package": "yi",
          "signature": "String -\u003e String -\u003e Bool -\u003e TextUnit -\u003e EditorM Bool",
          "source": "src/Yi-Search.html#searchAndRepUnit",
          "type": "function"
        },
        "index": {
          "description": "Search and replace in the region defined by the given unit The rest is as in searchAndRepRegion",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "searchAndRepUnit",
          "normalized": "String-\u003eString-\u003eBool-\u003eTextUnit-\u003eEditorM Bool",
          "package": "yi",
          "partial": "And Rep Unit",
          "signature": "String-\u003eString-\u003eBool-\u003eTextUnit-\u003eEditorM Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:searchAndRepUnit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet up a search.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "searchInit",
          "package": "yi",
          "signature": "String -\u003e Direction -\u003e [SearchOption] -\u003e EditorM (SearchExp, Direction)",
          "source": "src/Yi-Search.html#searchInit",
          "type": "function"
        },
        "index": {
          "description": "Set up search",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "searchInit",
          "normalized": "String-\u003eDirection-\u003e[SearchOption]-\u003eEditorM(SearchExp,Direction)",
          "package": "yi",
          "partial": "Init",
          "signature": "String-\u003eDirection-\u003e[SearchOption]-\u003eEditorM(SearchExp,Direction)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:searchInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch and Replace all within the current region.\n Note the region is the final argument since we might perform\n the same search and replace over multiple regions however we are\n unlikely to perform several search and replaces over the same region\n since the first such may change the bounds of the region.\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "searchReplaceRegionB",
          "package": "yi",
          "signature": "String-\u003e String-\u003e Region-\u003e BufferM Int",
          "type": "function"
        },
        "index": {
          "description": "Search and Replace all within the current region Note the region is the final argument since we might perform the same search and replace over multiple regions however we are unlikely to perform several search and replaces over the same region since the first such may change the bounds of the region",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "searchReplaceRegionB",
          "normalized": "String-\u003eString-\u003eRegion-\u003eBufferM Int",
          "package": "yi",
          "partial": "Replace Region",
          "signature": "String-\u003eString-\u003eRegion-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:searchReplaceRegionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePeform a search and replace on the selection\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "searchReplaceSelectionB",
          "package": "yi",
          "signature": "String-\u003e String-\u003e BufferM Int",
          "type": "function"
        },
        "index": {
          "description": "Peform search and replace on the selection",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "searchReplaceSelectionB",
          "normalized": "String-\u003eString-\u003eBufferM Int",
          "package": "yi",
          "partial": "Replace Selection",
          "signature": "String-\u003eString-\u003eBufferM Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:searchReplaceSelectionB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut regex into regex \u003ccode\u003eregister\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Search",
          "name": "setRegexE",
          "package": "yi",
          "signature": "SearchExp -\u003e EditorM ()",
          "source": "src/Yi-Search.html#setRegexE",
          "type": "function"
        },
        "index": {
          "description": "Put regex into regex register",
          "hierarchy": "Yi Search",
          "module": "Yi.Search",
          "name": "setRegexE",
          "normalized": "SearchExp-\u003eEditorM()",
          "package": "yi",
          "partial": "Regex",
          "signature": "SearchExp-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Search.html#v:setRegexE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets.Haskell",
          "name": "Haskell",
          "package": "yi",
          "source": "src/Yi-Snippets-Haskell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Snippets Haskell",
          "module": "Yi.Snippets.Haskell",
          "name": "Haskell",
          "package": "yi",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets-Haskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets.Haskell",
          "name": "hsClass",
          "package": "yi",
          "signature": "SnippetCmd ()",
          "source": "src/Yi-Snippets-Haskell.html#hsClass",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets Haskell",
          "module": "Yi.Snippets.Haskell",
          "name": "hsClass",
          "normalized": "SnippetCmd()",
          "package": "yi",
          "partial": "Class",
          "signature": "SnippetCmd()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets-Haskell.html#v:hsClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets.Haskell",
          "name": "hsFunction",
          "package": "yi",
          "signature": "SnippetCmd ()",
          "source": "src/Yi-Snippets-Haskell.html#hsFunction",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets Haskell",
          "module": "Yi.Snippets.Haskell",
          "name": "hsFunction",
          "normalized": "SnippetCmd()",
          "package": "yi",
          "partial": "Function",
          "signature": "SnippetCmd()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets-Haskell.html#v:hsFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "Snippets",
          "package": "yi",
          "source": "src/Yi-Snippets.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "Snippets",
          "package": "yi",
          "partial": "Snippets",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "BufferMarks",
          "package": "yi",
          "source": "src/Yi-Snippets.html#BufferMarks",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "BufferMarks",
          "package": "yi",
          "partial": "Buffer Marks",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:BufferMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "DependentMarks",
          "package": "yi",
          "source": "src/Yi-Snippets.html#DependentMarks",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "DependentMarks",
          "package": "yi",
          "partial": "Dependent Marks",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:DependentMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "MarkInfo",
          "package": "yi",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "MarkInfo",
          "package": "yi",
          "partial": "Mark Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:MarkInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "MkSnippetCmd",
          "package": "yi",
          "source": "src/Yi-Snippets.html#MkSnippetCmd",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "MkSnippetCmd",
          "package": "yi",
          "partial": "Mk Snippet Cmd",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:MkSnippetCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "SnippetCmd",
          "package": "yi",
          "source": "src/Yi-Snippets.html#SnippetCmd",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "SnippetCmd",
          "package": "yi",
          "partial": "Snippet Cmd",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:SnippetCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "SnippetMark",
          "package": "yi",
          "source": "src/Yi-Snippets.html#SnippetMark",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "SnippetMark",
          "package": "yi",
          "partial": "Snippet Mark",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:SnippetMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "SupertabExt",
          "package": "yi",
          "source": "src/Yi-Snippets.html#SupertabExt",
          "type": "newtype"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "SupertabExt",
          "package": "yi",
          "partial": "Supertab Ext",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#t:SupertabExt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "(&)",
          "package": "yi",
          "signature": "a -\u003e b -\u003e SnippetCmd c",
          "source": "src/Yi-Snippets.html#%26",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "(&) &",
          "normalized": "a-\u003eb-\u003eSnippetCmd c",
          "package": "yi",
          "signature": "a-\u003eb-\u003eSnippetCmd c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:-38-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "(&\u003e)",
          "package": "yi",
          "signature": "a -\u003e (b -\u003e c) -\u003e SnippetCmd d",
          "source": "src/Yi-Snippets.html#%26%3E",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "(&\u003e) &\u003e",
          "normalized": "a-\u003e(b-\u003ec)-\u003eSnippetCmd d",
          "package": "yi",
          "signature": "a-\u003e(b-\u003ec)-\u003eSnippetCmd d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:-38--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "BufferMarks",
          "package": "yi",
          "signature": "BufferMarks",
          "source": "src/Yi-Snippets.html#BufferMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "BufferMarks",
          "package": "yi",
          "partial": "Buffer Marks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:BufferMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "DependentMark",
          "package": "yi",
          "signature": "DependentMark !Int",
          "source": "src/Yi-Snippets.html#SnippetMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "DependentMark",
          "package": "yi",
          "partial": "Dependent Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:DependentMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "DependentMarkInfo",
          "package": "yi",
          "signature": "DependentMarkInfo",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "DependentMarkInfo",
          "package": "yi",
          "partial": "Dependent Mark Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:DependentMarkInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "DependentMarks",
          "package": "yi",
          "signature": "DependentMarks",
          "source": "src/Yi-Snippets.html#DependentMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "DependentMarks",
          "package": "yi",
          "partial": "Dependent Marks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:DependentMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "SimpleMark",
          "package": "yi",
          "signature": "SimpleMark !Int",
          "source": "src/Yi-Snippets.html#SnippetMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "SimpleMark",
          "package": "yi",
          "partial": "Simple Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:SimpleMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "SimpleMarkInfo",
          "package": "yi",
          "signature": "SimpleMarkInfo",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "SimpleMarkInfo",
          "package": "yi",
          "partial": "Simple Mark Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:SimpleMarkInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "Supertab",
          "package": "yi",
          "signature": "Supertab (String -\u003e Maybe (BufferM ()))",
          "source": "src/Yi-Snippets.html#SupertabExt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "Supertab",
          "normalized": "Supertab(String-\u003eMaybe(BufferM()))",
          "package": "yi",
          "partial": "Supertab",
          "signature": "Supertab(String-\u003eMaybe(BufferM()))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:Supertab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "ValuedMark",
          "package": "yi",
          "signature": "ValuedMark !Int String",
          "source": "src/Yi-Snippets.html#SnippetMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "ValuedMark",
          "package": "yi",
          "partial": "Valued Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:ValuedMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "ValuedMarkInfo",
          "package": "yi",
          "signature": "ValuedMarkInfo",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "ValuedMarkInfo",
          "package": "yi",
          "partial": "Valued Mark Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:ValuedMarkInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "adjMarkRegion",
          "package": "yi",
          "signature": "MarkInfo -\u003e BufferM Region",
          "source": "src/Yi-Snippets.html#adjMarkRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "adjMarkRegion",
          "normalized": "MarkInfo-\u003eBufferM Region",
          "package": "yi",
          "partial": "Mark Region",
          "signature": "MarkInfo-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:adjMarkRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "allOverlappingMarks",
          "package": "yi",
          "signature": "Bool -\u003e MarkInfo -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#allOverlappingMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "allOverlappingMarks",
          "normalized": "Bool-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Overlapping Marks",
          "signature": "Bool-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:allOverlappingMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "bufferMarkers",
          "package": "yi",
          "signature": "MarkInfo -\u003e [Mark]",
          "source": "src/Yi-Snippets.html#bufferMarkers",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "bufferMarkers",
          "normalized": "MarkInfo-\u003e[Mark]",
          "package": "yi",
          "partial": "Markers",
          "signature": "MarkInfo-\u003e[Mark]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:bufferMarkers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "bufferMarks",
          "package": "yi",
          "signature": "[MarkInfo]",
          "source": "src/Yi-Snippets.html#BufferMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "bufferMarks",
          "normalized": "[MarkInfo]",
          "package": "yi",
          "partial": "Marks",
          "signature": "[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:bufferMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "cursor",
          "package": "yi",
          "signature": "Int -\u003e SnippetMark",
          "source": "src/Yi-Snippets.html#cursor",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "cursor",
          "normalized": "Int-\u003eSnippetMark",
          "package": "yi",
          "signature": "Int-\u003eSnippetMark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:cursor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "cursorWith",
          "package": "yi",
          "signature": "Int -\u003e String -\u003e SnippetMark",
          "source": "src/Yi-Snippets.html#cursorWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "cursorWith",
          "normalized": "Int-\u003eString-\u003eSnippetMark",
          "package": "yi",
          "partial": "With",
          "signature": "Int-\u003eString-\u003eSnippetMark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:cursorWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "dep",
          "package": "yi",
          "signature": "Int -\u003e SnippetMark",
          "source": "src/Yi-Snippets.html#dep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "dep",
          "normalized": "Int-\u003eSnippetMark",
          "package": "yi",
          "signature": "Int-\u003eSnippetMark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:dep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "dependentOverlappingMarks",
          "package": "yi",
          "signature": "Bool -\u003e MarkInfo -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#dependentOverlappingMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "dependentOverlappingMarks",
          "normalized": "Bool-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Overlapping Marks",
          "signature": "Bool-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:dependentOverlappingMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "dependentSiblings",
          "package": "yi",
          "signature": "MarkInfo -\u003e [[MarkInfo]] -\u003e [MarkInfo]",
          "source": "src/Yi-Snippets.html#dependentSiblings",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "dependentSiblings",
          "normalized": "MarkInfo-\u003e[[MarkInfo]]-\u003e[MarkInfo]",
          "package": "yi",
          "partial": "Siblings",
          "signature": "MarkInfo-\u003e[[MarkInfo]]-\u003e[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:dependentSiblings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "endMark",
          "package": "yi",
          "signature": "Mark",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "endMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:endMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "findEditedMarks",
          "package": "yi",
          "signature": "[Update] -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#findEditedMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "findEditedMarks",
          "normalized": "[Update]-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Edited Marks",
          "signature": "[Update]-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:findEditedMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "findOverlappingMarks",
          "package": "yi",
          "signature": "([[MarkInfo]] -\u003e [MarkInfo]) -\u003e Bool -\u003e Region -\u003e MarkInfo -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#findOverlappingMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "findOverlappingMarks",
          "normalized": "([[MarkInfo]]-\u003e[MarkInfo])-\u003eBool-\u003eRegion-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Overlapping Marks",
          "signature": "([[MarkInfo]]-\u003e[MarkInfo])-\u003eBool-\u003eRegion-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:findOverlappingMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "findOverlappingMarksWith",
          "package": "yi",
          "signature": "(MarkInfo -\u003e BufferM Region) -\u003e ([[MarkInfo]] -\u003e [MarkInfo]) -\u003e Bool -\u003e Region -\u003e MarkInfo -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#findOverlappingMarksWith",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "findOverlappingMarksWith",
          "normalized": "(MarkInfo-\u003eBufferM Region)-\u003e([[MarkInfo]]-\u003e[MarkInfo])-\u003eBool-\u003eRegion-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Overlapping Marks With",
          "signature": "(MarkInfo-\u003eBufferM Region)-\u003e([[MarkInfo]]-\u003e[MarkInfo])-\u003eBool-\u003eRegion-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:findOverlappingMarksWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert snippet description list into a SuperTab extension\n\u003c/p\u003e",
          "module": "Yi.Snippets",
          "name": "fromSnippets",
          "package": "yi",
          "signature": "Bool -\u003e [(String, SnippetCmd ())] -\u003e SupertabExt",
          "source": "src/Yi-Snippets.html#fromSnippets",
          "type": "function"
        },
        "index": {
          "description": "Convert snippet description list into SuperTab extension",
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "fromSnippets",
          "normalized": "Bool-\u003e[(String,SnippetCmd())]-\u003eSupertabExt",
          "package": "yi",
          "partial": "Snippets",
          "signature": "Bool-\u003e[(String,SnippetCmd())]-\u003eSupertabExt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:fromSnippets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "isDependentMark",
          "package": "yi",
          "signature": "MarkInfo -\u003e Bool",
          "source": "src/Yi-Snippets.html#isDependentMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "isDependentMark",
          "normalized": "MarkInfo-\u003eBool",
          "package": "yi",
          "partial": "Dependent Mark",
          "signature": "MarkInfo-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:isDependentMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "isDependentMarker",
          "package": "yi",
          "signature": "Mark -\u003e m Bool",
          "source": "src/Yi-Snippets.html#isDependentMarker",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "isDependentMarker",
          "normalized": "Mark-\u003ea Bool",
          "package": "yi",
          "partial": "Dependent Marker",
          "signature": "Mark-\u003em Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:isDependentMarker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "markRegion",
          "package": "yi",
          "signature": "MarkInfo -\u003e BufferM Region",
          "source": "src/Yi-Snippets.html#markRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "markRegion",
          "normalized": "MarkInfo-\u003eBufferM Region",
          "package": "yi",
          "partial": "Region",
          "signature": "MarkInfo-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:markRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "markText",
          "package": "yi",
          "signature": "MarkInfo -\u003e BufferM String",
          "source": "src/Yi-Snippets.html#markText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "markText",
          "normalized": "MarkInfo-\u003eBufferM String",
          "package": "yi",
          "partial": "Text",
          "signature": "MarkInfo-\u003eBufferM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:markText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "marks",
          "package": "yi",
          "signature": "[[MarkInfo]]",
          "source": "src/Yi-Snippets.html#DependentMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "marks",
          "normalized": "[[MarkInfo]]",
          "package": "yi",
          "signature": "[[MarkInfo]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:marks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "mkMark",
          "package": "yi",
          "signature": "t BufferM Mark",
          "source": "src/Yi-Snippets.html#mkMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "mkMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:mkMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "mkSnippetCmd",
          "package": "yi",
          "signature": "a -\u003e SnippetCmd b",
          "source": "src/Yi-Snippets.html#mkSnippetCmd",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "mkSnippetCmd",
          "normalized": "a-\u003eSnippetCmd b",
          "package": "yi",
          "partial": "Snippet Cmd",
          "signature": "a-\u003eSnippetCmd b",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:mkSnippetCmd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "moveToNextBufferMark",
          "package": "yi",
          "signature": "Bool -\u003e BufferM ()",
          "source": "src/Yi-Snippets.html#moveToNextBufferMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "moveToNextBufferMark",
          "normalized": "Bool-\u003eBufferM()",
          "package": "yi",
          "partial": "To Next Buffer Mark",
          "signature": "Bool-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:moveToNextBufferMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "nextBufferMark",
          "package": "yi",
          "signature": "Bool -\u003e BufferM (Maybe MarkInfo)",
          "source": "src/Yi-Snippets.html#nextBufferMark",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "nextBufferMark",
          "normalized": "Bool-\u003eBufferM(Maybe MarkInfo)",
          "package": "yi",
          "partial": "Buffer Mark",
          "signature": "Bool-\u003eBufferM(Maybe MarkInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:nextBufferMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "overlappingMarks",
          "package": "yi",
          "signature": "Bool -\u003e Bool -\u003e MarkInfo -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#overlappingMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "overlappingMarks",
          "normalized": "Bool-\u003eBool-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Marks",
          "signature": "Bool-\u003eBool-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:overlappingMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "regionsOverlappingMarks",
          "package": "yi",
          "signature": "Bool -\u003e Region -\u003e MarkInfo -\u003e BufferM [MarkInfo]",
          "source": "src/Yi-Snippets.html#regionsOverlappingMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "regionsOverlappingMarks",
          "normalized": "Bool-\u003eRegion-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "package": "yi",
          "partial": "Overlapping Marks",
          "signature": "Bool-\u003eRegion-\u003eMarkInfo-\u003eBufferM[MarkInfo]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:regionsOverlappingMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "runSnippet",
          "package": "yi",
          "signature": "Bool -\u003e SnippetCmd a -\u003e BufferM a",
          "source": "src/Yi-Snippets.html#runSnippet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "runSnippet",
          "normalized": "Bool-\u003eSnippetCmd a-\u003eBufferM a",
          "package": "yi",
          "partial": "Snippet",
          "signature": "Bool-\u003eSnippetCmd a-\u003eBufferM a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:runSnippet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "safeDeleteMarkB",
          "package": "yi",
          "signature": "Mark -\u003e BufferM ()",
          "source": "src/Yi-Snippets.html#safeDeleteMarkB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "safeDeleteMarkB",
          "normalized": "Mark-\u003eBufferM()",
          "package": "yi",
          "partial": "Delete Mark",
          "signature": "Mark-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:safeDeleteMarkB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "safeMarkRegion",
          "package": "yi",
          "signature": "MarkInfo -\u003e BufferM Region",
          "source": "src/Yi-Snippets.html#safeMarkRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "safeMarkRegion",
          "normalized": "MarkInfo-\u003eBufferM Region",
          "package": "yi",
          "partial": "Mark Region",
          "signature": "MarkInfo-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:safeMarkRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "setMarkText",
          "package": "yi",
          "signature": "String -\u003e MarkInfo -\u003e BufferM ()",
          "source": "src/Yi-Snippets.html#setMarkText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "setMarkText",
          "normalized": "String-\u003eMarkInfo-\u003eBufferM()",
          "package": "yi",
          "partial": "Mark Text",
          "signature": "String-\u003eMarkInfo-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:setMarkText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "snippet",
          "package": "yi",
          "signature": "a -\u003e SnippetCmd b",
          "source": "src/Yi-Snippets.html#snippet",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "snippet",
          "normalized": "a-\u003eSnippetCmd b",
          "package": "yi",
          "signature": "a-\u003eSnippetCmd b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:snippet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "startMark",
          "package": "yi",
          "signature": "Mark",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "startMark",
          "package": "yi",
          "partial": "Mark",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:startMark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "superTab",
          "package": "yi",
          "signature": "Bool -\u003e SupertabExt -\u003e m ()",
          "source": "src/Yi-Snippets.html#superTab",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "superTab",
          "normalized": "Bool-\u003eSupertabExt-\u003ea()",
          "package": "yi",
          "partial": "Tab",
          "signature": "Bool-\u003eSupertabExt-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:superTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "text",
          "package": "yi",
          "signature": "String -\u003e SnippetCmd ()",
          "source": "src/Yi-Snippets.html#text",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "text",
          "normalized": "String-\u003eSnippetCmd()",
          "package": "yi",
          "signature": "String-\u003eSnippetCmd()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "updateDependents",
          "package": "yi",
          "signature": "MarkInfo -\u003e BufferM ()",
          "source": "src/Yi-Snippets.html#updateDependents",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "updateDependents",
          "normalized": "MarkInfo-\u003eBufferM()",
          "package": "yi",
          "partial": "Dependents",
          "signature": "MarkInfo-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:updateDependents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "updateDependents'",
          "package": "yi",
          "signature": "MarkInfo -\u003e [[MarkInfo]] -\u003e BufferM ()",
          "source": "src/Yi-Snippets.html#updateDependents%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "updateDependents'",
          "normalized": "MarkInfo-\u003e[[MarkInfo]]-\u003eBufferM()",
          "package": "yi",
          "partial": "Dependents'",
          "signature": "MarkInfo-\u003e[[MarkInfo]]-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:updateDependents-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "updateUpdatedMarks",
          "package": "yi",
          "signature": "[Update] -\u003e BufferM ()",
          "source": "src/Yi-Snippets.html#updateUpdatedMarks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "updateUpdatedMarks",
          "normalized": "[Update]-\u003eBufferM()",
          "package": "yi",
          "partial": "Updated Marks",
          "signature": "[Update]-\u003eBufferM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:updateUpdatedMarks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "userIndex",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Snippets.html#MarkInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "userIndex",
          "package": "yi",
          "partial": "Index",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:userIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Snippets",
          "name": "withSimpleRegion",
          "package": "yi",
          "signature": "MarkInfo -\u003e (Region -\u003e BufferM Region) -\u003e BufferM Region",
          "source": "src/Yi-Snippets.html#withSimpleRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Snippets",
          "module": "Yi.Snippets",
          "name": "withSimpleRegion",
          "normalized": "MarkInfo-\u003e(Region-\u003eBufferM Region)-\u003eBufferM Region",
          "package": "yi",
          "partial": "Simple Region",
          "signature": "MarkInfo-\u003e(Region-\u003eBufferM Region)-\u003eBufferM Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Snippets.html#v:withSimpleRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eString manipulation utilities\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.String",
          "name": "String",
          "package": "yi",
          "source": "src/Yi-String.html",
          "type": "module"
        },
        "index": {
          "description": "String manipulation utilities",
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "String",
          "package": "yi",
          "partial": "String",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "capitalize",
          "package": "yi",
          "signature": "String -\u003e String",
          "source": "src/Yi-String.html#capitalize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "capitalize",
          "normalized": "String-\u003eString",
          "package": "yi",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:capitalize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "capitalizeFirst",
          "package": "yi",
          "signature": "String -\u003e String",
          "source": "src/Yi-String.html#capitalizeFirst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "capitalizeFirst",
          "normalized": "String-\u003eString",
          "package": "yi",
          "partial": "First",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:capitalizeFirst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemove any trailing strings matching \u003cem\u003eirs\u003c/em\u003e (input record separator)\n from input string. Like perl's chomp(1).\n\u003c/p\u003e",
          "module": "Yi.String",
          "name": "chomp",
          "package": "yi",
          "signature": "String -\u003e String -\u003e String",
          "source": "src/Yi-String.html#chomp",
          "type": "function"
        },
        "index": {
          "description": "Remove any trailing strings matching irs input record separator from input string Like perl chomp",
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "chomp",
          "normalized": "String-\u003eString-\u003eString",
          "package": "yi",
          "signature": "String-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:chomp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTrim spaces at beginning \u003cem\u003eand\u003c/em\u003e end\n\u003c/p\u003e",
          "module": "Yi.String",
          "name": "dropSpace",
          "package": "yi",
          "signature": "String -\u003e String",
          "source": "src/Yi-String.html#dropSpace",
          "type": "function"
        },
        "index": {
          "description": "Trim spaces at beginning and end",
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "dropSpace",
          "normalized": "String-\u003eString",
          "package": "yi",
          "partial": "Space",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:dropSpace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "fillText",
          "package": "yi",
          "signature": "Int -\u003e String -\u003e [String]",
          "source": "src/Yi-String.html#fillText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "fillText",
          "normalized": "Int-\u003eString-\u003e[String]",
          "package": "yi",
          "partial": "Text",
          "signature": "Int-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:fillText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "isBlank",
          "package": "yi",
          "signature": "String -\u003e Bool",
          "source": "src/Yi-String.html#isBlank",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "isBlank",
          "normalized": "String-\u003eBool",
          "package": "yi",
          "partial": "Blank",
          "signature": "String-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:isBlank"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSplit a String in lines. Unlike \u003ccode\u003e\u003ca\u003elines\u003c/a\u003e\u003c/code\u003e, this does not\n remove any empty line at the end.\n\u003c/p\u003e",
          "module": "Yi.String",
          "name": "lines'",
          "package": "yi",
          "signature": "String -\u003e [String]",
          "source": "src/Yi-String.html#lines%27",
          "type": "function"
        },
        "index": {
          "description": "Split String in lines Unlike lines this does not remove any empty line at the end",
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "lines'",
          "normalized": "String-\u003e[String]",
          "package": "yi",
          "signature": "String-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:lines-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA helper function for creating functions suitable for\n \u003ccode\u003emodifySelectionB\u003c/code\u003e and \u003ccode\u003emodifyRegionB\u003c/code\u003e.\n To be used when the desired function should map across\n the lines of a region.\n\u003c/p\u003e",
          "module": "Yi.String",
          "name": "mapLines",
          "package": "yi",
          "signature": "(String -\u003e String) -\u003e String -\u003e String",
          "source": "src/Yi-String.html#mapLines",
          "type": "function"
        },
        "index": {
          "description": "helper function for creating functions suitable for modifySelectionB and modifyRegionB To be used when the desired function should map across the lines of region",
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "mapLines",
          "normalized": "(String-\u003eString)-\u003eString-\u003eString",
          "package": "yi",
          "partial": "Lines",
          "signature": "(String-\u003eString)-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:mapLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "onLines",
          "package": "yi",
          "signature": "([String] -\u003e [String]) -\u003e String -\u003e String",
          "source": "src/Yi-String.html#onLines",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "onLines",
          "normalized": "([String]-\u003e[String])-\u003eString-\u003eString",
          "package": "yi",
          "partial": "Lines",
          "signature": "([String]-\u003e[String])-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:onLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "padLeft",
          "package": "yi",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Yi-String.html#padLeft",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "padLeft",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "yi",
          "partial": "Left",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:padLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.String",
          "name": "padRight",
          "package": "yi",
          "signature": "Int -\u003e String -\u003e String",
          "source": "src/Yi-String.html#padRight",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "padRight",
          "normalized": "Int-\u003eString-\u003eString",
          "package": "yi",
          "partial": "Right",
          "signature": "Int-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:padRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003elines'\u003c/a\u003e\u003c/code\u003e. In contrast to \u003ccode\u003e\u003ca\u003eunlines\u003c/a\u003e\u003c/code\u003e, this does\n not add an empty line at the end.\n\u003c/p\u003e",
          "module": "Yi.String",
          "name": "unlines'",
          "package": "yi",
          "signature": "[String] -\u003e String",
          "source": "src/Yi-String.html#unlines%27",
          "type": "function"
        },
        "index": {
          "description": "Inverse of lines In contrast to unlines this does not add an empty line at the end",
          "hierarchy": "Yi String",
          "module": "Yi.String",
          "name": "unlines'",
          "normalized": "[String]-\u003eString",
          "package": "yi",
          "signature": "[String]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-String.html#v:unlines-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style.Library",
          "name": "Library",
          "package": "yi",
          "source": "src/Yi-Style-Library.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Style Library",
          "module": "Yi.Style.Library",
          "name": "Library",
          "package": "yi",
          "partial": "Library",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style-Library.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style.Library",
          "name": "Theme",
          "package": "yi",
          "source": "src/Yi-Style-Library.html#Theme",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Style Library",
          "module": "Yi.Style.Library",
          "name": "Theme",
          "package": "yi",
          "partial": "Theme",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style-Library.html#t:Theme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Theme inspired by the darkblue colorscheme of Vim.\n\u003c/p\u003e",
          "module": "Yi.Style.Library",
          "name": "darkBlueTheme",
          "package": "yi",
          "signature": "Theme",
          "source": "src/Yi-Style-Library.html#darkBlueTheme",
          "type": "function"
        },
        "index": {
          "description": "Theme inspired by the darkblue colorscheme of Vim",
          "hierarchy": "Yi Style Library",
          "module": "Yi.Style.Library",
          "name": "darkBlueTheme",
          "package": "yi",
          "partial": "Blue Theme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style-Library.html#v:darkBlueTheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract theme that provides useful defaults.\n\u003c/p\u003e",
          "module": "Yi.Style.Library",
          "name": "defaultTheme",
          "package": "yi",
          "signature": "Theme",
          "source": "src/Yi-Style-Library.html#defaultTheme",
          "type": "function"
        },
        "index": {
          "description": "Abstract theme that provides useful defaults",
          "hierarchy": "Yi Style Library",
          "module": "Yi.Style.Library",
          "name": "defaultTheme",
          "package": "yi",
          "partial": "Theme",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style-Library.html#v:defaultTheme"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eColors and friends.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Style",
          "name": "Style",
          "package": "yi",
          "source": "src/Yi-Style.html",
          "type": "module"
        },
        "index": {
          "description": "Colors and friends",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "Style",
          "package": "yi",
          "partial": "Style",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVisual text attributes to be applied during layout.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "Attributes",
          "package": "yi",
          "source": "src/Yi-Style.html#Attributes",
          "type": "data"
        },
        "index": {
          "description": "Visual text attributes to be applied during layout",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "Attributes",
          "package": "yi",
          "partial": "Attributes",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#t:Attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "Color",
          "package": "yi",
          "source": "src/Yi-Style.html#Color",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "Color",
          "package": "yi",
          "partial": "Color",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#t:Color"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe style is used to transform attributes by modifying\n   one or more of the visual text attributes.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "Style",
          "package": "yi",
          "source": "src/Yi-Style.html#Style",
          "type": "type"
        },
        "index": {
          "description": "The style is used to transform attributes by modifying one or more of the visual text attributes",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "Style",
          "package": "yi",
          "partial": "Style",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#t:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA StyleName determines what style to use, taking into account the\n set of rendering preferences given by a \u003ccode\u003e\u003ca\u003eUIStyle\u003c/a\u003e\u003c/code\u003e.  Typically, style\n names will be \u003ccode\u003e\u003ca\u003eStyle\u003c/a\u003e\u003c/code\u003e-valued field names of \u003ccode\u003e\u003ca\u003eUIStyle\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "StyleName",
          "package": "yi",
          "source": "src/Yi-Style.html#StyleName",
          "type": "type"
        },
        "index": {
          "description": "StyleName determines what style to use taking into account the set of rendering preferences given by UIStyle Typically style names will be Style valued field names of UIStyle",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "StyleName",
          "package": "yi",
          "partial": "Style Name",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#t:StyleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe UI type\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "UIStyle",
          "package": "yi",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "data"
        },
        "index": {
          "description": "The UI type",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "UIStyle",
          "package": "yi",
          "partial": "UIStyle",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#t:UIStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "Attributes",
          "package": "yi",
          "signature": "Attributes",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "Attributes",
          "package": "yi",
          "partial": "Attributes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:Attributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe system-default color of the engine used.\n e.g. in Gtk this should pick whatever the user has chosen as default color \n (background or forground depending on usage) for the text.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "Default",
          "package": "yi",
          "signature": "Default",
          "source": "src/Yi-Style.html#Color",
          "type": "function"
        },
        "index": {
          "description": "The system-default color of the engine used e.g in Gtk this should pick whatever the user has chosen as default color background or forground depending on usage for the text",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "Default",
          "package": "yi",
          "partial": "Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "RGB",
          "package": "yi",
          "signature": "RGB !Word8 !Word8 !Word8",
          "source": "src/Yi-Style.html#Color",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "RGB",
          "package": "yi",
          "partial": "RGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:RGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "UIStyle",
          "package": "yi",
          "signature": "UIStyle",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "UIStyle",
          "package": "yi",
          "partial": "UIStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:UIStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "background",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "background",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:background"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eground attributes for the main text views\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "baseAttributes",
          "package": "yi",
          "signature": "Attributes",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "ground attributes for the main text views",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "baseAttributes",
          "package": "yi",
          "partial": "Attributes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:baseAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "black",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#black",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "black",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:black"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadditional only for block comments\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "blockCommentStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "additional only for block comments",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "blockCommentStyle",
          "package": "yi",
          "partial": "Comment Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:blockCommentStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "blue",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#blue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "blue",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:blue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "bold",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "bold",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:bold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "brightwhite",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#brightwhite",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "brightwhite",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:brightwhite"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "brown",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#brown",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "brown",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:brown"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuiltin things, e.g. Array in JavaScript\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "builtinStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "builtin things e.g Array in JavaScript",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "builtinStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:builtinStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert a color to its text specification, as to be accepted by XParseColor\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "colorToText",
          "package": "yi",
          "signature": "Color -\u003e String",
          "source": "src/Yi-Style.html#colorToText",
          "type": "function"
        },
        "index": {
          "description": "Convert color to its text specification as to be accepted by XParseColor",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "colorToText",
          "normalized": "Color-\u003eString",
          "package": "yi",
          "partial": "To Text",
          "signature": "Color-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:colorToText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eall comments\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "commentStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "all comments",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "commentStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:commentStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "cyan",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#cyan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "cyan",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:cyan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "darkblue",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#darkblue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "darkblue",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:darkblue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "darkcyan",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#darkcyan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "darkcyan",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:darkcyan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "darkgreen",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#darkgreen",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "darkgreen",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:darkgreen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "darkred",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#darkred",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "darkred",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:darkred"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "dataConstructorStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "data constructor",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "dataConstructorStyle",
          "package": "yi",
          "partial": "Constructor Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:dataConstructorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity transform.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "defaultStyle",
          "package": "yi",
          "signature": "StyleName",
          "source": "src/Yi-Style.html#defaultStyle",
          "type": "function"
        },
        "index": {
          "description": "The identity transform",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "defaultStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:defaultStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "emptyAttributes",
          "package": "yi",
          "signature": "Attributes",
          "source": "src/Yi-Style.html#emptyAttributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "emptyAttributes",
          "package": "yi",
          "partial": "Attributes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:emptyAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty file marker colours\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "eofStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "empty file marker colours",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "eofStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:eofStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindicates errors in text\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "errorStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "indicates errors in text",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "errorStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:errorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "foreground",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "foreground",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:foreground"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "green",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#green",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "green",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:green"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "grey",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#grey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "grey",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:grey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esearch matches\u003cem\u003eparen matches\u003c/em\u003eother hints\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "hintStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "search matches paren matches other hints",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "hintStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:hintStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estyle of import names\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "importStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "style of import names",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "importStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:importStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "italic",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "italic",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:italic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplied to language keywords\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "keywordStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "applied to language keywords",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "keywordStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:keywordStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "lightGrey",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#lightGrey",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "lightGrey",
          "package": "yi",
          "partial": "Grey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:lightGrey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadditional style for long strings\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "longStringStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "additional style for long strings",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "longStringStyle",
          "package": "yi",
          "partial": "String Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:longStringStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "magenta",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#magenta",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "magenta",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:magenta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estuff that's passed to the shell in a Makefile\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "makeFileAction",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "stuff that passed to the shell in Makefile",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "makeFileAction",
          "package": "yi",
          "partial": "File Action",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:makeFileAction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emakefile rule headers\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "makeFileRuleHead",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "makefile rule headers",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "makeFileRuleHead",
          "package": "yi",
          "partial": "File Rule Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:makeFileRuleHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eground attributes for the modeline\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "modelineAttributes",
          "package": "yi",
          "signature": "Attributes",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "ground attributes for the modeline",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "modelineAttributes",
          "package": "yi",
          "partial": "Attributes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:modelineAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etransformation of modeline in focus\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "modelineFocusStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "transformation of modeline in focus",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "modelineFocusStyle",
          "package": "yi",
          "partial": "Focus Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:modelineFocusStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enumbers\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "numberStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "numbers",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "numberStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:numberStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix operators\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "operatorStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "infix operators",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "operatorStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:operatorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epreprocessor directive (often in Haskell or C)\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "preprocessorStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "preprocessor directive often in Haskell or",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "preprocessorStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:preprocessorStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "purple",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#purple",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "purple",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:purple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStyle of a quotation (e.g. in template haskell)    \n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "quoteStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "Style of quotation e.g in template haskell",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "quoteStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:quoteStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "red",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#red",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "red",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:red"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eregular expressions\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "regexStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "regular expressions",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "regexStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:regexStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe text should be show as \u003ca\u003eactive\u003c/a\u003e or \u003ca\u003eselected\u003c/a\u003e.\n This can be implemented by reverse video on the terminal.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "reverseAttr",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "description": "The text should be show as active or selected This can be implemented by reverse video on the terminal",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "reverseAttr",
          "package": "yi",
          "partial": "Attr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:reverseAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe selected portion\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "selectedStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "the selected portion",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "selectedStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:selectedStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstant strings\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "stringStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "constant strings",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "stringStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:stringStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ecurrent search match\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "strongHintStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "current search match",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "strongHintStyle",
          "package": "yi",
          "partial": "Hint Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:strongHintStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eground attributes for the tabbar\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "tabBarAttributes",
          "package": "yi",
          "signature": "Attributes",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "ground attributes for the tabbar",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "tabBarAttributes",
          "package": "yi",
          "partial": "Bar Attributes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:tabBarAttributes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea tab that currently holds the focus\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "tabInFocusStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "tab that currently holds the focus",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "tabInFocusStyle",
          "package": "yi",
          "partial": "In Focus Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:tabInFocusStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea tab that does not have the current focus\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "tabNotFocusedStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "tab that does not have the current focus",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "tabNotFocusedStyle",
          "package": "yi",
          "partial": "Not Focused Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:tabNotFocusedStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype name (such as class in an OO language)\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "typeStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "type name such as class in an OO language",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "typeStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:typeStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "underline",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Style.html#Attributes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "underline",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:underline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eany standard variable (identifier)\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "variableStyle",
          "package": "yi",
          "signature": "Style",
          "source": "src/Yi-Style.html#UIStyle",
          "type": "function"
        },
        "index": {
          "description": "any standard variable identifier",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "variableStyle",
          "package": "yi",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:variableStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "white",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#white",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "white",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:white"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA style that sets the font to bold\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "withBd",
          "package": "yi",
          "signature": "Bool -\u003e Style",
          "source": "src/Yi-Style.html#withBd",
          "type": "function"
        },
        "index": {
          "description": "style that sets the font to bold",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "withBd",
          "normalized": "Bool-\u003eStyle",
          "package": "yi",
          "partial": "Bd",
          "signature": "Bool-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:withBd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA style that sets the background.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "withBg",
          "package": "yi",
          "signature": "Color -\u003e Style",
          "source": "src/Yi-Style.html#withBg",
          "type": "function"
        },
        "index": {
          "description": "style that sets the background",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "withBg",
          "normalized": "Color-\u003eStyle",
          "package": "yi",
          "partial": "Bg",
          "signature": "Color-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:withBg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA style that sets the foreground.\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "withFg",
          "package": "yi",
          "signature": "Color -\u003e Style",
          "source": "src/Yi-Style.html#withFg",
          "type": "function"
        },
        "index": {
          "description": "style that sets the foreground",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "withFg",
          "normalized": "Color-\u003eStyle",
          "package": "yi",
          "partial": "Fg",
          "signature": "Color-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:withFg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA style that sets the style to italics\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "withItlc",
          "package": "yi",
          "signature": "Bool -\u003e Style",
          "source": "src/Yi-Style.html#withItlc",
          "type": "function"
        },
        "index": {
          "description": "style that sets the style to italics",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "withItlc",
          "normalized": "Bool-\u003eStyle",
          "package": "yi",
          "partial": "Itlc",
          "signature": "Bool-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:withItlc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA style that sets the style to underlined\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "withReverse",
          "package": "yi",
          "signature": "Bool -\u003e Style",
          "source": "src/Yi-Style.html#withReverse",
          "type": "function"
        },
        "index": {
          "description": "style that sets the style to underlined",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "withReverse",
          "normalized": "Bool-\u003eStyle",
          "package": "yi",
          "partial": "Reverse",
          "signature": "Bool-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:withReverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA style that sets the style to underlined\n\u003c/p\u003e",
          "module": "Yi.Style",
          "name": "withUnderline",
          "package": "yi",
          "signature": "Bool -\u003e Style",
          "source": "src/Yi-Style.html#withUnderline",
          "type": "function"
        },
        "index": {
          "description": "style that sets the style to underlined",
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "withUnderline",
          "normalized": "Bool-\u003eStyle",
          "package": "yi",
          "partial": "Underline",
          "signature": "Bool-\u003eStyle",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:withUnderline"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Style",
          "name": "yellow",
          "package": "yi",
          "signature": "Color",
          "source": "src/Yi-Style.html#yellow",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Style",
          "module": "Yi.Style",
          "name": "yellow",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Style.html#v:yellow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines implementations of syntax-awareness drivers.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Syntax.Driver",
          "name": "Driver",
          "package": "yi",
          "source": "src/Yi-Syntax-Driver.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines implementations of syntax-awareness drivers",
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "Driver",
          "package": "yi",
          "partial": "Driver",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "Cache",
          "package": "yi",
          "source": "src/Yi-Syntax-Driver.html#Cache",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "Cache",
          "package": "yi",
          "partial": "Cache",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#t:Cache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "Path",
          "package": "yi",
          "source": "src/Yi-Syntax-Driver.html#Path",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "Path",
          "package": "yi",
          "partial": "Path",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#t:Path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "Cache",
          "package": "yi",
          "signature": "Cache",
          "source": "src/Yi-Syntax-Driver.html#Cache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "Cache",
          "package": "yi",
          "partial": "Cache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:Cache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "cachedStates",
          "package": "yi",
          "signature": "[state]",
          "source": "src/Yi-Syntax-Driver.html#Cache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "cachedStates",
          "normalized": "[a]",
          "package": "yi",
          "partial": "States",
          "signature": "[state]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:cachedStates"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "focused",
          "package": "yi",
          "signature": "(Map WindowRef (tree (Tok tt)))",
          "source": "src/Yi-Syntax-Driver.html#Cache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "focused",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:focused"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "mkHighlighter",
          "package": "yi",
          "signature": "(Scanner Point Char -\u003e Scanner state (tree (Tok tt))) -\u003e Highlighter (Cache state tree tt) (tree (Tok tt))",
          "source": "src/Yi-Syntax-Driver.html#mkHighlighter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "mkHighlighter",
          "normalized": "(Scanner Point Char-\u003eScanner a(b(Tok c)))-\u003eHighlighter(Cache a b c)(b(Tok c))",
          "package": "yi",
          "partial": "Highlighter",
          "signature": "(Scanner Point Char-\u003eScanner state(tree(Tok tt)))-\u003eHighlighter(Cache state tree tt)(tree(Tok tt))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:mkHighlighter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "path",
          "package": "yi",
          "signature": "Map WindowRef Path",
          "source": "src/Yi-Syntax-Driver.html#Cache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "path",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "root",
          "package": "yi",
          "signature": "tree (Tok tt)",
          "source": "src/Yi-Syntax-Driver.html#Cache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "root",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:root"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "unzipFM",
          "package": "yi",
          "signature": "[(k, (u, v))] -\u003e (Map k u, Map k v)",
          "source": "src/Yi-Syntax-Driver.html#unzipFM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "unzipFM",
          "normalized": "[(a,(b,c))]-\u003e(Map a b,Map a c)",
          "package": "yi",
          "partial": "FM",
          "signature": "[(k,(u,v))]-\u003e(Map k u,Map k v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:unzipFM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Driver",
          "name": "zipWithFM",
          "package": "yi",
          "signature": "(u -\u003e v -\u003e w) -\u003e v -\u003e Map k u -\u003e Map k v -\u003e [(k, w)]",
          "source": "src/Yi-Syntax-Driver.html#zipWithFM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Driver",
          "module": "Yi.Syntax.Driver",
          "name": "zipWithFM",
          "normalized": "(a-\u003eb-\u003ec)-\u003eb-\u003eMap d a-\u003eMap d b-\u003e[(d,c)]",
          "package": "yi",
          "partial": "With FM",
          "signature": "(u-\u003ev-\u003ew)-\u003ev-\u003eMap k u-\u003eMap k v-\u003e[(k,w)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Driver.html#v:zipWithFM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "Haskell",
          "package": "yi",
          "source": "src/Yi-Syntax-Haskell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Haskell",
          "package": "yi",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExp can be expression or declaration\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "Exp",
          "package": "yi",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "data"
        },
        "index": {
          "description": "Exp can be expression or declaration",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Exp",
          "package": "yi",
          "partial": "Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#t:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PImport",
          "package": "yi",
          "source": "src/Yi-Syntax-Haskell.html#PImport",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PImport",
          "package": "yi",
          "partial": "PImport",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#t:PImport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PModule",
          "package": "yi",
          "source": "src/Yi-Syntax-Haskell.html#PModule",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PModule",
          "package": "yi",
          "partial": "PModule",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#t:PModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PModuleDecl",
          "package": "yi",
          "source": "src/Yi-Syntax-Haskell.html#PModuleDecl",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PModuleDecl",
          "package": "yi",
          "partial": "PModule Decl",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#t:PModuleDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "Tree",
          "package": "yi",
          "source": "src/Yi-Syntax-Haskell.html#Tree",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Tree",
          "package": "yi",
          "partial": "Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "Bin",
          "package": "yi",
          "signature": "Bin (Exp t) (Exp t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Bin",
          "package": "yi",
          "partial": "Bin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Bin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA block of things separated by layout\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "Block",
          "package": "yi",
          "signature": "Block [Exp t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "block of things separated by layout",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Block",
          "normalized": "Block[Exp a]",
          "package": "yi",
          "partial": "Block",
          "signature": "Block[Exp t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "Body",
          "package": "yi",
          "signature": "Body",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Body",
          "package": "yi",
          "partial": "Body",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Body"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "Context",
          "package": "yi",
          "signature": "Context (Exp t) (Exp t) (PAtom t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Context",
          "package": "yi",
          "partial": "Context",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData constructor\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "DC",
          "package": "yi",
          "signature": "DC (Exp t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Data constructor",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "DC",
          "package": "yi",
          "partial": "DC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:DC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "Expr",
          "package": "yi",
          "signature": "Expr [Exp t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Expr",
          "normalized": "Expr[Exp a]",
          "package": "yi",
          "partial": "Expr",
          "signature": "Expr[Exp t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eModule identifier\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "Modid",
          "package": "yi",
          "signature": "Modid t [t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Module identifier",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Modid",
          "normalized": "Modid a[a]",
          "package": "yi",
          "partial": "Modid",
          "signature": "Modid t[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Modid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn optional\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "Opt",
          "package": "yi",
          "signature": "Opt (Maybe (Exp t))",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "An optional",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Opt",
          "package": "yi",
          "partial": "Opt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Opt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn atom is a token followed by many comments\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "PAtom",
          "package": "yi",
          "signature": "PAtom t [t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "An atom is token followed by many comments",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PAtom",
          "normalized": "PAtom a[a]",
          "package": "yi",
          "partial": "PAtom",
          "signature": "PAtom t[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PAtom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PClass",
          "package": "yi",
          "signature": "PClass",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PClass",
          "package": "yi",
          "partial": "PClass",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PClass"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData declaration\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "PData",
          "package": "yi",
          "signature": "PData",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Data declaration",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PData",
          "package": "yi",
          "partial": "PData",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PData'",
          "package": "yi",
          "signature": "PData'",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PData'",
          "package": "yi",
          "partial": "PData'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PData-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PError",
          "package": "yi",
          "signature": "PError",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PError",
          "package": "yi",
          "partial": "PError",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRighthandside of functions with |\n the PAtom in PGuard' does not contain any comments\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "PGuard",
          "package": "yi",
          "signature": "PGuard [PGuard t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Righthandside of functions with the PAtom in PGuard does not contain any comments",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PGuard",
          "normalized": "PGuard[PGuard a]",
          "package": "yi",
          "partial": "PGuard",
          "signature": "PGuard[PGuard t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PGuard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PGuard'",
          "package": "yi",
          "signature": "PGuard' (PAtom t) (Exp t) (PAtom t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PGuard'",
          "package": "yi",
          "partial": "PGuard'",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PGuard-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PImport",
          "package": "yi",
          "signature": "PImport",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PImport",
          "package": "yi",
          "partial": "PImport",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PImport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PIn",
          "package": "yi",
          "signature": "PIn t [Exp t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PIn",
          "normalized": "PIn a[Exp a]",
          "package": "yi",
          "partial": "PIn",
          "signature": "PIn t[Exp t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elet expression\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "PLet",
          "package": "yi",
          "signature": "PLet (PAtom t) (Exp t) (Exp t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "let expression",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PLet",
          "package": "yi",
          "partial": "PLet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PLet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PModule",
          "package": "yi",
          "signature": "PModule",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PModule",
          "package": "yi",
          "partial": "PModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "PModuleDecl",
          "package": "yi",
          "signature": "PModuleDecl",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PModuleDecl",
          "package": "yi",
          "partial": "PModule Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PModuleDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType declaration\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "PType",
          "package": "yi",
          "signature": "PType",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type declaration",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PType",
          "package": "yi",
          "partial": "PType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWhere clause\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "PWhere",
          "package": "yi",
          "signature": "PWhere (PAtom t) (Exp t) (Exp t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Where clause",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "PWhere",
          "package": "yi",
          "partial": "PWhere",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:PWhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA parenthesized, bracked or braced\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "Paren",
          "package": "yi",
          "signature": "Paren (PAtom t) [Exp t] (PAtom t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "parenthesized bracked or braced",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "Paren",
          "normalized": "Paren(PAtom a)[Exp a](PAtom a)",
          "package": "yi",
          "partial": "Paren",
          "signature": "Paren(PAtom t)[Exp t](PAtom t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "ProgMod",
          "package": "yi",
          "signature": "ProgMod",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "ProgMod",
          "package": "yi",
          "partial": "Prog Mod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:ProgMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRighthandside of functions with =\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "RHS",
          "package": "yi",
          "signature": "RHS (PAtom t) (Exp t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Righthandside of functions with",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "RHS",
          "package": "yi",
          "partial": "RHS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:RHS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType constructor\n data constructor same as with the TC constructor\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "TC",
          "package": "yi",
          "signature": "TC (Exp t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type constructor data constructor same as with the TC constructor",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "TC",
          "package": "yi",
          "partial": "TC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:TC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType signature \n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "TS",
          "package": "yi",
          "signature": "TS t [Exp t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Type signature",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "TS",
          "normalized": "TS a[Exp a]",
          "package": "yi",
          "partial": "TS",
          "signature": "TS t[Exp t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:TS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "as",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "as",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:as"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe module declaration part\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "body",
          "package": "yi",
          "signature": "PModule t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The module declaration part",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "body",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:body"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "btype",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "btype",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:btype"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "cHead",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "cHead",
          "package": "yi",
          "partial": "Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:cHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "cKeyword",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "cKeyword",
          "package": "yi",
          "partial": "Keyword",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:cKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn wrapper for errors\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "commentList",
          "package": "yi",
          "signature": "[t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "An wrapper for errors",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "commentList",
          "normalized": "[a]",
          "package": "yi",
          "partial": "List",
          "signature": "[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:commentList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "comments",
          "package": "yi",
          "signature": "[t]",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "comments",
          "normalized": "[a]",
          "package": "yi",
          "signature": "[t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:comments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "content",
          "package": "yi",
          "signature": "Block t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "content",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:content"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass declaration\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "cwhere",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Class declaration",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "cwhere",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:cwhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "dEqual",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "dEqual",
          "package": "yi",
          "partial": "Equal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:dEqual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eData declaration RHS\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "dataCons",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "Data declaration RHS",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "dataCons",
          "package": "yi",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:dataCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "dataKeyword",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "dataKeyword",
          "package": "yi",
          "partial": "Keyword",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:dataKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "dataRhs",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "dataRhs",
          "package": "yi",
          "partial": "Rhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:dataRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "dtypeCons",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "dtypeCons",
          "package": "yi",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:dtypeCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "equal",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "equal",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:equal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "errorTok",
          "package": "yi",
          "signature": "t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "errorTok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:errorTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "exports",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "exports",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:exports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe body of the module\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "extraContent",
          "package": "yi",
          "signature": "Block t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "The body of the module",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "extraContent",
          "package": "yi",
          "partial": "Content",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:extraContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "importKeyword",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "importKeyword",
          "package": "yi",
          "partial": "Keyword",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:importKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "imports",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "imports",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:imports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "indentScanner",
          "package": "yi",
          "signature": "Scanner (AlexState lexState) TT -\u003e Scanner (State Token lexState) TT",
          "source": "src/Yi-Syntax-Haskell.html#indentScanner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "indentScanner",
          "normalized": "Scanner(AlexState a)TT-\u003eScanner(State Token a)TT",
          "package": "yi",
          "partial": "Scanner",
          "signature": "Scanner(AlexState lexState)TT-\u003eScanner(State Token lexState)TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:indentScanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "marker",
          "package": "yi",
          "signature": "t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "marker",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:marker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "modDecl",
          "package": "yi",
          "signature": "PModuleDecl t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "modDecl",
          "package": "yi",
          "partial": "Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:modDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "moduleKeyword",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "moduleKeyword",
          "package": "yi",
          "partial": "Keyword",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:moduleKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "name",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "name",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "name'",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "name'",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:name-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parser\n\u003c/p\u003e",
          "module": "Yi.Syntax.Haskell",
          "name": "parse",
          "package": "yi",
          "signature": "P TT (Tree TT)",
          "source": "src/Yi-Syntax-Haskell.html#parse",
          "type": "function"
        },
        "index": {
          "description": "The parser",
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "parse",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "progMod",
          "package": "yi",
          "signature": "Maybe (PModule t)",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "progMod",
          "package": "yi",
          "partial": "Mod",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:progMod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "qual",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "qual",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:qual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "specification",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "specification",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:specification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "typeCons",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "typeCons",
          "package": "yi",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:typeCons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "typeKeyword",
          "package": "yi",
          "signature": "PAtom t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "typeKeyword",
          "package": "yi",
          "partial": "Keyword",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:typeKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Haskell",
          "name": "whereKeyword",
          "package": "yi",
          "signature": "Exp t",
          "source": "src/Yi-Syntax-Haskell.html#Exp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Haskell",
          "module": "Yi.Syntax.Haskell",
          "name": "whereKeyword",
          "package": "yi",
          "partial": "Keyword",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Haskell.html#v:whereKeyword"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "partial": "Java Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Array",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Array",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Array",
          "package": "yi",
          "partial": "Array",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "BList",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#BList",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "BList",
          "package": "yi",
          "partial": "BList",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:BList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Block",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Block",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Block",
          "package": "yi",
          "partial": "Block",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Expr",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Expr",
          "package": "yi",
          "partial": "Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances of \u003ccode\u003eFailable\u003c/code\u003e can represent failure.  This is a useful class for\n   future work, since then we can make stroking much easier.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "Failable",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Failable",
          "type": "class"
        },
        "index": {
          "description": "Instances of Failable can represent failure This is useful class for future work since then we can make stroking much easier",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Failable",
          "package": "yi",
          "partial": "Failable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Failable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ForContent",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#ForContent",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ForContent",
          "package": "yi",
          "partial": "For Content",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:ForContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "KeyValue",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#KeyValue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "KeyValue",
          "package": "yi",
          "partial": "Key Value",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:KeyValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ParExpr",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#ParExpr",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ParExpr",
          "package": "yi",
          "partial": "Par Expr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:ParExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Parameters",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Parameters",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Parameters",
          "package": "yi",
          "partial": "Parameters",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Parameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Semicolon",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Semicolon",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Semicolon",
          "package": "yi",
          "partial": "Semicolon",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Semicolon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Statement",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Statement",
          "package": "yi",
          "partial": "Statement",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Statement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInstances of \u003ccode\u003eStrokable\u003c/code\u003e are datatypes which can be syntax highlighted.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "Strokable",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Strokable",
          "type": "class"
        },
        "index": {
          "description": "Instances of Strokable are datatypes which can be syntax highlighted",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Strokable",
          "package": "yi",
          "partial": "Strokable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Strokable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Tree",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#Tree",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Tree",
          "package": "yi",
          "partial": "Tree",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRepresents either a variable name or a variable name assigned to an\n   expression.  \u003ccode\u003eAssBeg\u003c/code\u003e is a variable name \u003cem\u003emaybe\u003c/em\u003e followed by an assignment.\n   \u003ccode\u003eAssRst\u003c/code\u003e is an equals sign and an expression.  \u003ccode\u003e(AssBeg \u003ccode\u003ex\u003c/code\u003e (Just (AssRst\n   '=' '5')))\u003c/code\u003e means \u003ccode\u003ex = 5\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "VarDecAss",
          "package": "yi",
          "source": "src/Yi-Syntax-JavaScript.html#VarDecAss",
          "type": "data"
        },
        "index": {
          "description": "Represents either variable name or variable name assigned to an expression AssBeg is variable name maybe followed by an assignment AssRst is an equals sign and an expression AssBeg Just AssRst means",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "VarDecAss",
          "package": "yi",
          "partial": "Var Dec Ass",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#t:VarDecAss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ArrCont",
          "package": "yi",
          "signature": "ArrCont (Expr t) (Maybe (Array t))",
          "source": "src/Yi-Syntax-JavaScript.html#Array",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ArrCont",
          "package": "yi",
          "partial": "Arr Cont",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ArrCont"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ArrErr",
          "package": "yi",
          "signature": "ArrErr t",
          "source": "src/Yi-Syntax-JavaScript.html#Array",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ArrErr",
          "package": "yi",
          "partial": "Arr Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ArrErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ArrRest",
          "package": "yi",
          "signature": "ArrRest t (Array t) (Maybe (Array t))",
          "source": "src/Yi-Syntax-JavaScript.html#Array",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ArrRest",
          "package": "yi",
          "partial": "Arr Rest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ArrRest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "AssBeg",
          "package": "yi",
          "signature": "AssBeg t (Maybe (VarDecAss t))",
          "source": "src/Yi-Syntax-JavaScript.html#VarDecAss",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "AssBeg",
          "package": "yi",
          "partial": "Ass Beg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:AssBeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "AssErr",
          "package": "yi",
          "signature": "AssErr t",
          "source": "src/Yi-Syntax-JavaScript.html#VarDecAss",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "AssErr",
          "package": "yi",
          "partial": "Ass Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:AssErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "AssRst",
          "package": "yi",
          "signature": "AssRst t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#VarDecAss",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "AssRst",
          "package": "yi",
          "partial": "Ass Rst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:AssRst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Block",
          "package": "yi",
          "signature": "Block t (BList (Statement t)) t",
          "source": "src/Yi-Syntax-JavaScript.html#Block",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Block",
          "package": "yi",
          "partial": "Block",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:Block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "BlockErr",
          "package": "yi",
          "signature": "BlockErr t",
          "source": "src/Yi-Syntax-JavaScript.html#Block",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "BlockErr",
          "package": "yi",
          "partial": "Block Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:BlockErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "BlockOne",
          "package": "yi",
          "signature": "BlockOne (Statement t)",
          "source": "src/Yi-Syntax-JavaScript.html#Block",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "BlockOne",
          "package": "yi",
          "partial": "Block One",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:BlockOne"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Comm",
          "package": "yi",
          "signature": "Comm t",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Comm",
          "package": "yi",
          "partial": "Comm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:Comm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "DoWhile",
          "package": "yi",
          "signature": "DoWhile t (Block t) t (ParExpr t) (Semicolon t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "DoWhile",
          "package": "yi",
          "partial": "Do While",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:DoWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Else",
          "package": "yi",
          "signature": "Else t (Block t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Else",
          "package": "yi",
          "partial": "Else",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:Else"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Expr",
          "package": "yi",
          "signature": "Expr (Expr t) (Semicolon t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Expr",
          "package": "yi",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprAnonFun",
          "package": "yi",
          "signature": "ExprAnonFun t (Parameters t) (Block t)",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprAnonFun",
          "package": "yi",
          "partial": "Expr Anon Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprAnonFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprArr",
          "package": "yi",
          "signature": "ExprArr t (Maybe (Array t)) t (Maybe (Expr t))",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprArr",
          "package": "yi",
          "partial": "Expr Arr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprArr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprCond",
          "package": "yi",
          "signature": "ExprCond t (Expr t) t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprCond",
          "package": "yi",
          "partial": "Expr Cond",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprCond"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprErr",
          "package": "yi",
          "signature": "ExprErr t",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprErr",
          "package": "yi",
          "partial": "Expr Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprFunCall",
          "package": "yi",
          "signature": "ExprFunCall t (ParExpr t) (Maybe (Expr t))",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprFunCall",
          "package": "yi",
          "partial": "Expr Fun Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprFunCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprNew",
          "package": "yi",
          "signature": "ExprNew t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprNew",
          "package": "yi",
          "partial": "Expr New",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprObj",
          "package": "yi",
          "signature": "ExprObj t (BList (KeyValue t)) t",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprObj",
          "package": "yi",
          "partial": "Expr Obj",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprObj"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprParen",
          "package": "yi",
          "signature": "ExprParen t (Expr t) t (Maybe (Expr t))",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprParen",
          "package": "yi",
          "partial": "Expr Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprPrefix",
          "package": "yi",
          "signature": "ExprPrefix t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprPrefix",
          "package": "yi",
          "partial": "Expr Prefix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprSimple",
          "package": "yi",
          "signature": "ExprSimple t (Maybe (Expr t))",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprSimple",
          "package": "yi",
          "partial": "Expr Simple",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprSimple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprTypeOf",
          "package": "yi",
          "signature": "ExprTypeOf t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ExprTypeOf",
          "package": "yi",
          "partial": "Expr Type Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ExprTypeOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "For",
          "package": "yi",
          "signature": "For t t (Expr t) (ForContent t) t (Block t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "For",
          "package": "yi",
          "partial": "For",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:For"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ForErr",
          "package": "yi",
          "signature": "ForErr t",
          "source": "src/Yi-Syntax-JavaScript.html#ForContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ForErr",
          "package": "yi",
          "partial": "For Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ForErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ForIn",
          "package": "yi",
          "signature": "ForIn t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#ForContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ForIn",
          "package": "yi",
          "partial": "For In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ForIn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ForNormal",
          "package": "yi",
          "signature": "ForNormal t (Expr t) t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#ForContent",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ForNormal",
          "package": "yi",
          "partial": "For Normal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ForNormal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "FunDecl",
          "package": "yi",
          "signature": "FunDecl t t (Parameters t) (Block t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "FunDecl",
          "package": "yi",
          "partial": "Fun Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:FunDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "If",
          "package": "yi",
          "signature": "If t (ParExpr t) (Block t) (Maybe (Statement t))",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "If",
          "package": "yi",
          "partial": "If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:If"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "KeyValue",
          "package": "yi",
          "signature": "KeyValue t t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#KeyValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "KeyValue",
          "package": "yi",
          "partial": "Key Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:KeyValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "KeyValueErr",
          "package": "yi",
          "signature": "KeyValueErr t",
          "source": "src/Yi-Syntax-JavaScript.html#KeyValue",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "KeyValueErr",
          "package": "yi",
          "partial": "Key Value Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:KeyValueErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "OpExpr",
          "package": "yi",
          "signature": "OpExpr t (Expr t)",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "OpExpr",
          "package": "yi",
          "partial": "Op Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:OpExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ParErr",
          "package": "yi",
          "signature": "ParErr t",
          "source": "src/Yi-Syntax-JavaScript.html#Parameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ParErr",
          "package": "yi",
          "partial": "Par Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ParErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ParExpr",
          "package": "yi",
          "signature": "ParExpr t (BList (Expr t)) t",
          "source": "src/Yi-Syntax-JavaScript.html#ParExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ParExpr",
          "package": "yi",
          "partial": "Par Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ParExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "ParExprErr",
          "package": "yi",
          "signature": "ParExprErr t",
          "source": "src/Yi-Syntax-JavaScript.html#ParExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "ParExprErr",
          "package": "yi",
          "partial": "Par Expr Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:ParExprErr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Parameters",
          "package": "yi",
          "signature": "Parameters t (BList t) t",
          "source": "src/Yi-Syntax-JavaScript.html#Parameters",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Parameters",
          "package": "yi",
          "partial": "Parameters",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:Parameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "PostExpr",
          "package": "yi",
          "signature": "PostExpr t",
          "source": "src/Yi-Syntax-JavaScript.html#Expr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "PostExpr",
          "package": "yi",
          "partial": "Post Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:PostExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "Return",
          "package": "yi",
          "signature": "Return t (Maybe (Expr t)) (Semicolon t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "Return",
          "package": "yi",
          "partial": "Return",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:Return"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "VarDecl",
          "package": "yi",
          "signature": "VarDecl t (BList (VarDecAss t)) (Semicolon t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "VarDecl",
          "package": "yi",
          "partial": "Var Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:VarDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "While",
          "package": "yi",
          "signature": "While t (ParExpr t) (Block t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "While",
          "package": "yi",
          "partial": "While",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:While"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "With",
          "package": "yi",
          "signature": "With t (ParExpr t) (Block t)",
          "source": "src/Yi-Syntax-JavaScript.html#Statement",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "With",
          "package": "yi",
          "partial": "With",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:With"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral recovery parser, inserts an error token.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "anything",
          "package": "yi",
          "signature": "P s TT",
          "source": "src/Yi-Syntax-JavaScript.html#anything",
          "type": "function"
        },
        "index": {
          "description": "General recovery parser inserts an error token",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "anything",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:anything"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses both empty and non-empty arrays.  Should probably be split up into\n   further parts to allow for the separation of \u003ccode\u003e[]\u003c/code\u003e and \u003ccode\u003e[1, 2, 3]\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "array",
          "package": "yi",
          "signature": "P TT (Expr TT)",
          "source": "src/Yi-Syntax-JavaScript.html#array",
          "type": "function"
        },
        "index": {
          "description": "Parses both empty and non-empty arrays Should probably be split up into further parts to allow for the separation of and",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "array",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:array"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for \u003ca\u003eblocks\u003c/a\u003e, i.e. a bunch of statements wrapped in curly brackets\n   \u003cem\u003eor\u003c/em\u003e just a single statement.\n\u003c/p\u003e\u003cp\u003eNote that this works for JavaScript 1.8 \u003ca\u003elambda\u003c/a\u003e style function bodies as\n   well, e.g. \u003ca\u003efunction hello() 5\u003c/a\u003e, since expressions are also statements and\n   we don't require a trailing semi-colon.\n\u003c/p\u003e\u003cp\u003eTODO: function hello() var x; is not a valid program.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "block",
          "package": "yi",
          "signature": "P TT (Block TT)",
          "source": "src/Yi-Syntax-JavaScript.html#block",
          "type": "function"
        },
        "index": {
          "description": "Parser for blocks i.e bunch of statements wrapped in curly brackets or just single statement Note that this works for JavaScript lambda style function bodies as well e.g function hello since expressions are also statements and we don require trailing semi-colon TODO function hello var is not valid program",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "block",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses any boolean.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "boolean",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#boolean",
          "type": "function"
        },
        "index": {
          "description": "Parses any boolean",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "boolean",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:boolean"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a comment.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "comment",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#comment",
          "type": "function"
        },
        "index": {
          "description": "Parses comment",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "comment",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError stroker.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "error",
          "package": "yi",
          "signature": "TT -\u003e Endo [Stroke]",
          "source": "src/Yi-Syntax-JavaScript.html#error",
          "type": "function"
        },
        "index": {
          "description": "Error stroker",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "error",
          "normalized": "TT-\u003eEndo[Stroke]",
          "package": "yi",
          "signature": "TT-\u003eEndo[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "errorToken",
          "package": "yi",
          "signature": "TT",
          "source": "src/Yi-Syntax-JavaScript.html#errorToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "errorToken",
          "package": "yi",
          "partial": "Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:errorToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for expressions.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "expression",
          "package": "yi",
          "signature": "P TT (Expr TT)",
          "source": "src/Yi-Syntax-JavaScript.html#expression",
          "type": "function"
        },
        "index": {
          "description": "Parser for expressions",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "expression",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:expression"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of \u003ccode\u003eTT\u003c/code\u003e, if any of them is an error, returns an error stroker,\n   otherwise a normal stroker.  Using e.g. existentials, we could make this\n   more general and have support for heterogeneous lists of elements which\n   implement Failable, but I haven't had the time to fix this.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "failStroker",
          "package": "yi",
          "signature": "[TT] -\u003e TT -\u003e Endo [Stroke]",
          "source": "src/Yi-Syntax-JavaScript.html#failStroker",
          "type": "function"
        },
        "index": {
          "description": "Given list of TT if any of them is an error returns an error stroker otherwise normal stroker Using e.g existentials we could make this more general and have support for heterogeneous lists of elements which implement Failable but haven had the time to fix this",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "failStroker",
          "normalized": "[TT]-\u003eTT-\u003eEndo[Stroke]",
          "package": "yi",
          "partial": "Stroker",
          "signature": "[TT]-\u003eTT-\u003eEndo[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:failStroker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "firstTok",
          "package": "yi",
          "signature": "f t -\u003e t",
          "source": "src/Yi-Syntax-JavaScript.html#firstTok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "firstTok",
          "normalized": "a b-\u003eb",
          "package": "yi",
          "partial": "Tok",
          "signature": "f t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:firstTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "fromBlock",
          "package": "yi",
          "signature": "Block t -\u003e [Statement t]",
          "source": "src/Yi-Syntax-JavaScript.html#fromBlock",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "fromBlock",
          "normalized": "Block a-\u003e[Statement a]",
          "package": "yi",
          "partial": "Block",
          "signature": "Block t-\u003e[Statement t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:fromBlock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBetter name for \u003ccode\u003e\u003ca\u003etokT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "fromTT",
          "package": "yi",
          "signature": "Tok t -\u003e t",
          "source": "src/Yi-Syntax-JavaScript.html#fromTT",
          "type": "function"
        },
        "index": {
          "description": "Better name for tokT",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "fromTT",
          "normalized": "Tok a-\u003ea",
          "package": "yi",
          "partial": "TT",
          "signature": "Tok t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:fromTT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main stroking function.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "getStrokes",
          "package": "yi",
          "signature": "Tree TT -\u003e Point -\u003e Point -\u003e Point -\u003e [Stroke]",
          "source": "src/Yi-Syntax-JavaScript.html#getStrokes",
          "type": "function"
        },
        "index": {
          "description": "The main stroking function",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "getStrokes",
          "normalized": "Tree TT-\u003ePoint-\u003ePoint-\u003ePoint-\u003e[Stroke]",
          "package": "yi",
          "partial": "Strokes",
          "signature": "Tree TT-\u003ePoint-\u003ePoint-\u003ePoint-\u003e[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:getStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "hasFailed",
          "package": "yi",
          "signature": "f t -\u003e Bool",
          "source": "src/Yi-Syntax-JavaScript.html#hasFailed",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "hasFailed",
          "normalized": "a b-\u003eBool",
          "package": "yi",
          "partial": "Failed",
          "signature": "f t-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:hasFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWeighted recovery.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "hate",
          "package": "yi",
          "signature": "Int -\u003e P s a -\u003e P s a",
          "source": "src/Yi-Syntax-JavaScript.html#hate",
          "type": "function"
        },
        "index": {
          "description": "Weighted recovery",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "hate",
          "normalized": "Int-\u003eP a b-\u003eP a b",
          "package": "yi",
          "signature": "Int-\u003eP s a-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:hate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a infix operator.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "inOp",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#inOp",
          "type": "function"
        },
        "index": {
          "description": "Parses infix operator",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "inOp",
          "package": "yi",
          "partial": "Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:inOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "isError",
          "package": "yi",
          "signature": "TT -\u003e Bool",
          "source": "src/Yi-Syntax-JavaScript.html#isError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "isError",
          "normalized": "TT-\u003eBool",
          "package": "yi",
          "partial": "Error",
          "signature": "TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:isError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a new style and a stroke, return a stroke with the new style appended\n   to the old one.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "modStroke",
          "package": "yi",
          "signature": "StyleName -\u003e Stroke -\u003e Stroke",
          "source": "src/Yi-Syntax-JavaScript.html#modStroke",
          "type": "function"
        },
        "index": {
          "description": "Given new style and stroke return stroke with the new style appended to the old one",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "modStroke",
          "normalized": "StyleName-\u003eStroke-\u003eStroke",
          "package": "yi",
          "partial": "Stroke",
          "signature": "StyleName-\u003eStroke-\u003eStroke",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:modStroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of tokens to check for errors (\u003ccode\u003exs\u003c/code\u003e) and a list of tokens to\n   stroke (\u003ccode\u003exs'\u003c/code\u003e), returns normal strokes for \u003ccode\u003exs'\u003c/code\u003e if there were no errors.\n   Otherwise returns error strokes for \u003ccode\u003exs'\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "nError",
          "package": "yi",
          "signature": "[TT] -\u003e [TT] -\u003e Endo [Stroke]",
          "source": "src/Yi-Syntax-JavaScript.html#nError",
          "type": "function"
        },
        "index": {
          "description": "Given list of tokens to check for errors xs and list of tokens to stroke xs returns normal strokes for xs if there were no errors Otherwise returns error strokes for xs",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "nError",
          "normalized": "[TT]-\u003e[TT]-\u003eEndo[Stroke]",
          "package": "yi",
          "partial": "Error",
          "signature": "[TT]-\u003e[TT]-\u003eEndo[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:nError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses any valid identifier.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "name",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#name",
          "type": "function"
        },
        "index": {
          "description": "Parses any valid identifier",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "name",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal stroker.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "normal",
          "package": "yi",
          "signature": "TT -\u003e Endo [Stroke]",
          "source": "src/Yi-Syntax-JavaScript.html#normal",
          "type": "function"
        },
        "index": {
          "description": "Normal stroker",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "normal",
          "normalized": "TT-\u003eEndo[Stroke]",
          "package": "yi",
          "signature": "TT-\u003eEndo[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:normal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses any valid number.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "numTok",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#numTok",
          "type": "function"
        },
        "index": {
          "description": "Parses any valid number",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "numTok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:numTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "one",
          "package": "yi",
          "signature": "(t -\u003e a) -\u003e t -\u003e Endo [a]",
          "source": "src/Yi-Syntax-JavaScript.html#one",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "one",
          "normalized": "(a-\u003eb)-\u003ea-\u003eEndo[b]",
          "package": "yi",
          "signature": "(t-\u003ea)-\u003et-\u003eEndo[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:one"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe basic idea here is to parse \u003ca\u003ethe rest\u003c/a\u003e of expressions, e.g. \u003ccode\u003e+ 3\u003c/code\u003e in \u003ccode\u003ex\n   + 3\u003c/code\u003e or \u003ccode\u003e[i]\u003c/code\u003e in \u003ccode\u003ex[i]\u003c/code\u003e.  Anything which is useful in such a scenario goes\n   here.  TODO: This accepts [], but shouldn't, since x[] is invalid.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "opExpr",
          "package": "yi",
          "signature": "P TT (Expr TT)",
          "source": "src/Yi-Syntax-JavaScript.html#opExpr",
          "type": "function"
        },
        "index": {
          "description": "The basic idea here is to parse the rest of expressions e.g in or in Anything which is useful in such scenario goes here TODO This accepts but shouldn since is invalid",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "opExpr",
          "package": "yi",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:opExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses any literal.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "opTok",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#opTok",
          "type": "function"
        },
        "index": {
          "description": "Parses any literal",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "opTok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:opTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses an operator.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "oper",
          "package": "yi",
          "signature": "Operator -\u003e P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#oper",
          "type": "function"
        },
        "index": {
          "description": "Parses an operator",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "oper",
          "normalized": "Operator-\u003eP TT TT",
          "package": "yi",
          "signature": "Operator-\u003eP TT TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:oper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "parExpr",
          "package": "yi",
          "signature": "P TT (ParExpr TT)",
          "source": "src/Yi-Syntax-JavaScript.html#parExpr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "parExpr",
          "package": "yi",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:parExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a comma-separated list of valid identifiers.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "parameters",
          "package": "yi",
          "signature": "P TT (Parameters TT)",
          "source": "src/Yi-Syntax-JavaScript.html#parameters",
          "type": "function"
        },
        "index": {
          "description": "Parses comma-separated list of valid identifiers",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "parameters",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:parameters"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMain parser.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "parse",
          "package": "yi",
          "signature": "P TT (Tree TT)",
          "source": "src/Yi-Syntax-JavaScript.html#parse",
          "type": "function"
        },
        "index": {
          "description": "Main parser",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "parse",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "plz",
          "package": "yi",
          "signature": "P TT (f TT) -\u003e P TT (f TT)",
          "source": "src/Yi-Syntax-JavaScript.html#plz",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "plz",
          "normalized": "P TT(a TT)-\u003eP TT(a TT)",
          "package": "yi",
          "signature": "P TT(f TT)-\u003eP TT(f TT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:plz"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpects an expression.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "plzExpr",
          "package": "yi",
          "signature": "P TT (Expr TT)",
          "source": "src/Yi-Syntax-JavaScript.html#plzExpr",
          "type": "function"
        },
        "index": {
          "description": "Expects an expression",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "plzExpr",
          "package": "yi",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:plzExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpects a special token.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "plzSpc",
          "package": "yi",
          "signature": "Char -\u003e P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#plzSpc",
          "type": "function"
        },
        "index": {
          "description": "Expects special token",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "plzSpc",
          "normalized": "Char-\u003eP TT TT",
          "package": "yi",
          "partial": "Spc",
          "signature": "Char-\u003eP TT TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:plzSpc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpects a token x, recovers with \u003ccode\u003e\u003ca\u003eerrorToken\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "plzTok",
          "package": "yi",
          "signature": "P TT TT -\u003e P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#plzTok",
          "type": "function"
        },
        "index": {
          "description": "Expects token recovers with errorToken",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "plzTok",
          "normalized": "P TT TT-\u003eP TT TT",
          "package": "yi",
          "partial": "Tok",
          "signature": "P TT TT-\u003eP TT TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:plzTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a postfix operator.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "postOp",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#postOp",
          "type": "function"
        },
        "index": {
          "description": "Parses postfix operator",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "postOp",
          "package": "yi",
          "partial": "Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:postOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a prefix operator.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "preOp",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#preOp",
          "type": "function"
        },
        "index": {
          "description": "Parses prefix operator",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "preOp",
          "package": "yi",
          "partial": "Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:preOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a reserved word.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "res",
          "package": "yi",
          "signature": "Reserved -\u003e P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#res",
          "type": "function"
        },
        "index": {
          "description": "Parses reserved word",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "res",
          "normalized": "Reserved-\u003eP TT TT",
          "package": "yi",
          "signature": "Reserved-\u003eP TT TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:res"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a semicolon if it's there.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "semicolon",
          "package": "yi",
          "signature": "P TT (Maybe TT)",
          "source": "src/Yi-Syntax-JavaScript.html#semicolon",
          "type": "function"
        },
        "index": {
          "description": "Parses semicolon if it there",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "semicolon",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:semicolon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses any literal.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "simpleTok",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#simpleTok",
          "type": "function"
        },
        "index": {
          "description": "Parses any literal",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "simpleTok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:simpleTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses a special token.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "spc",
          "package": "yi",
          "signature": "Char -\u003e P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#spc",
          "type": "function"
        },
        "index": {
          "description": "Parses special token",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "spc",
          "normalized": "Char-\u003eP TT TT",
          "package": "yi",
          "signature": "Char-\u003eP TT TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:spc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for statements such as \u003ca\u003ereturn\u003c/a\u003e, \u003ca\u003ewhile\u003c/a\u003e, \u003ca\u003edo-while\u003c/a\u003e, \u003ca\u003efor\u003c/a\u003e, etc.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "statement",
          "package": "yi",
          "signature": "P TT (Statement TT)",
          "source": "src/Yi-Syntax-JavaScript.html#statement",
          "type": "function"
        },
        "index": {
          "description": "Parser for statements such as return while do-while for etc",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "statement",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:statement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParser for expressions which may be statements.  In reality, any expression\n   is also a valid statement, but this is a slight compromise to get rid of\n   the massive performance loss which is introduced when allowing JavaScript\n   objects to be valid statements.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "stmtExpr",
          "package": "yi",
          "signature": "P TT (Expr TT)",
          "source": "src/Yi-Syntax-JavaScript.html#stmtExpr",
          "type": "function"
        },
        "index": {
          "description": "Parser for expressions which may be statements In reality any expression is also valid statement but this is slight compromise to get rid of the massive performance loss which is introduced when allowing JavaScript objects to be valid statements",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "stmtExpr",
          "package": "yi",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:stmtExpr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParses any string.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "strTok",
          "package": "yi",
          "signature": "P TT TT",
          "source": "src/Yi-Syntax-JavaScript.html#strTok",
          "type": "function"
        },
        "index": {
          "description": "Parses any string",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "strTok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:strTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "stupid",
          "package": "yi",
          "signature": "t -\u003e f t",
          "source": "src/Yi-Syntax-JavaScript.html#stupid",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "stupid",
          "normalized": "a-\u003eb a",
          "package": "yi",
          "signature": "t-\u003ef t",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:stupid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.JavaScript",
          "name": "toStrokes",
          "package": "yi",
          "signature": "a -\u003e Endo [Stroke]",
          "source": "src/Yi-Syntax-JavaScript.html#toStrokes",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "toStrokes",
          "normalized": "a-\u003eEndo[Stroke]",
          "package": "yi",
          "partial": "Strokes",
          "signature": "a-\u003eEndo[Stroke]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:toStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBetter name for \u003ccode\u003e\u003ca\u003etokFromT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "toTT",
          "package": "yi",
          "signature": "t -\u003e Tok t",
          "source": "src/Yi-Syntax-JavaScript.html#toTT",
          "type": "function"
        },
        "index": {
          "description": "Better name for tokFromT",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "toTT",
          "normalized": "a-\u003eTok a",
          "package": "yi",
          "partial": "TT",
          "signature": "t-\u003eTok t",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:toTT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003eTT\u003c/code\u003e, return a \u003ccode\u003eStroke\u003c/code\u003e for it.\n\u003c/p\u003e",
          "module": "Yi.Syntax.JavaScript",
          "name": "tokenToStroke",
          "package": "yi",
          "signature": "TT -\u003e Stroke",
          "source": "src/Yi-Syntax-JavaScript.html#tokenToStroke",
          "type": "function"
        },
        "index": {
          "description": "Given TT return Stroke for it",
          "hierarchy": "Yi Syntax JavaScript",
          "module": "Yi.Syntax.JavaScript",
          "name": "tokenToStroke",
          "normalized": "TT-\u003eStroke",
          "package": "yi",
          "partial": "To Stroke",
          "signature": "TT-\u003eStroke",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-JavaScript.html#v:tokenToStroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Latex",
          "package": "yi",
          "source": "src/Yi-Syntax-Latex.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Latex",
          "package": "yi",
          "partial": "Latex",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Expr",
          "package": "yi",
          "source": "src/Yi-Syntax-Latex.html#Expr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Expr",
          "package": "yi",
          "partial": "Expr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "TT",
          "package": "yi",
          "source": "src/Yi-Syntax-Latex.html#TT",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "TT",
          "package": "yi",
          "partial": "TT",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#t:TT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Tree",
          "package": "yi",
          "source": "src/Yi-Syntax-Latex.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Tree",
          "package": "yi",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Atom",
          "package": "yi",
          "signature": "Atom t",
          "source": "src/Yi-Syntax-Latex.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Atom",
          "package": "yi",
          "partial": "Atom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Error",
          "package": "yi",
          "signature": "Error t",
          "source": "src/Yi-Syntax-Latex.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Error",
          "package": "yi",
          "partial": "Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Expr",
          "package": "yi",
          "signature": "Expr (Expr t)",
          "source": "src/Yi-Syntax-Latex.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Expr",
          "package": "yi",
          "partial": "Expr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "Paren",
          "package": "yi",
          "signature": "Paren t (Tree t) t",
          "source": "src/Yi-Syntax-Latex.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "Paren",
          "package": "yi",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "getStrokes",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e Point -\u003e Tree TT -\u003e [Stroke]",
          "source": "src/Yi-Syntax-Latex.html#getStrokes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "getStrokes",
          "normalized": "Point-\u003ePoint-\u003ePoint-\u003eTree TT-\u003e[Stroke]",
          "package": "yi",
          "partial": "Strokes",
          "signature": "Point-\u003ePoint-\u003ePoint-\u003eTree TT-\u003e[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:getStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "isBegin",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Syntax-Latex.html#isBegin",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "isBegin",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Begin",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:isBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "isEnd",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Syntax-Latex.html#isEnd",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "isEnd",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "End",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:isEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "isErrorTok",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Syntax-Latex.html#isErrorTok",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "isErrorTok",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Error Tok",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:isErrorTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "isNoise",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Syntax-Latex.html#isNoise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "isNoise",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Noise",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:isNoise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "isSpecial",
          "package": "yi",
          "signature": "[Char] -\u003e Token -\u003e Bool",
          "source": "src/Yi-Syntax-Latex.html#isSpecial",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "isSpecial",
          "normalized": "[Char]-\u003eToken-\u003eBool",
          "package": "yi",
          "partial": "Special",
          "signature": "[Char]-\u003eToken-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:isSpecial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "modStroke",
          "package": "yi",
          "signature": "StyleName -\u003e Stroke -\u003e Stroke",
          "source": "src/Yi-Syntax-Latex.html#modStroke",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "modStroke",
          "normalized": "StyleName-\u003eStroke-\u003eStroke",
          "package": "yi",
          "partial": "Stroke",
          "signature": "StyleName-\u003eStroke-\u003eStroke",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:modStroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "parse",
          "package": "yi",
          "signature": "P TT (Tree TT)",
          "source": "src/Yi-Syntax-Latex.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "parse",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "tokenToAnnot",
          "package": "yi",
          "signature": "TT -\u003e Maybe (Span String)",
          "source": "src/Yi-Syntax-Latex.html#tokenToAnnot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "tokenToAnnot",
          "normalized": "TT-\u003eMaybe(Span String)",
          "package": "yi",
          "partial": "To Annot",
          "signature": "TT-\u003eMaybe(Span String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:tokenToAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "tokenToStroke",
          "package": "yi",
          "signature": "TT -\u003e Stroke",
          "source": "src/Yi-Syntax-Latex.html#tokenToStroke",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "tokenToStroke",
          "normalized": "TT-\u003eStroke",
          "package": "yi",
          "partial": "To Stroke",
          "signature": "TT-\u003eStroke",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:tokenToStroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Latex",
          "name": "tokenToStyle",
          "package": "yi",
          "signature": "Token -\u003e StyleName",
          "source": "src/Yi-Syntax-Latex.html#tokenToStyle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Latex",
          "module": "Yi.Syntax.Latex",
          "name": "tokenToStyle",
          "normalized": "Token-\u003eStyleName",
          "package": "yi",
          "partial": "To Style",
          "signature": "Token-\u003eStyleName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Latex.html#v:tokenToStyle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Layout",
          "name": "Layout",
          "package": "yi",
          "source": "src/Yi-Syntax-Layout.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Syntax Layout",
          "module": "Yi.Syntax.Layout",
          "name": "Layout",
          "package": "yi",
          "partial": "Layout",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Layout.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Layout",
          "name": "State",
          "package": "yi",
          "source": "src/Yi-Syntax-Layout.html#State",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Layout",
          "module": "Yi.Syntax.Layout",
          "name": "State",
          "package": "yi",
          "partial": "State",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Layout.html#t:State"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTransform a scanner into a scanner that also adds opening,\n closing and \u003ca\u003enext\u003c/a\u003e tokens to indicate layout.  \n\u003c/p\u003e",
          "module": "Yi.Syntax.Layout",
          "name": "layoutHandler",
          "package": "yi",
          "signature": "(t -\u003e Bool) -\u003e [(t, t)] -\u003e (Tok t -\u003e Bool) -\u003e (t, t, t) -\u003e (Tok t -\u003e Bool) -\u003e Scanner (AlexState lexState) (Tok t) -\u003e Scanner (State t lexState) (Tok t)",
          "source": "src/Yi-Syntax-Layout.html#layoutHandler",
          "type": "function"
        },
        "index": {
          "description": "Transform scanner into scanner that also adds opening closing and next tokens to indicate layout",
          "hierarchy": "Yi Syntax Layout",
          "module": "Yi.Syntax.Layout",
          "name": "layoutHandler",
          "normalized": "(a-\u003eBool)-\u003e[(a,a)]-\u003e(Tok a-\u003eBool)-\u003e(a,a,a)-\u003e(Tok a-\u003eBool)-\u003eScanner(AlexState b)(Tok a)-\u003eScanner(State a b)(Tok a)",
          "package": "yi",
          "partial": "Handler",
          "signature": "(t-\u003eBool)-\u003e[(t,t)]-\u003e(Tok t-\u003eBool)-\u003e(t,t,t)-\u003e(Tok t-\u003eBool)-\u003eScanner(AlexState lexState)(Tok t)-\u003eScanner(State t lexState)(Tok t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Layout.html#v:layoutHandler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.OnlineTree",
          "name": "OnlineTree",
          "package": "yi",
          "source": "src/Yi-Syntax-OnlineTree.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "OnlineTree",
          "package": "yi",
          "partial": "Online Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.OnlineTree",
          "name": "Tree",
          "package": "yi",
          "source": "src/Yi-Syntax-OnlineTree.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "Tree",
          "package": "yi",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.OnlineTree",
          "name": "Bin",
          "package": "yi",
          "signature": "Bin (Tree a) (Tree a)",
          "source": "src/Yi-Syntax-OnlineTree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "Bin",
          "package": "yi",
          "partial": "Bin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#v:Bin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.OnlineTree",
          "name": "Leaf",
          "package": "yi",
          "signature": "Leaf a",
          "source": "src/Yi-Syntax-OnlineTree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "Leaf",
          "package": "yi",
          "partial": "Leaf",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#v:Leaf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.OnlineTree",
          "name": "Tip",
          "package": "yi",
          "signature": "Tip",
          "source": "src/Yi-Syntax-OnlineTree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "Tip",
          "package": "yi",
          "partial": "Tip",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#v:Tip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.OnlineTree",
          "name": "manyToks",
          "package": "yi",
          "signature": "P (Tok t) (Tree (Tok t))",
          "source": "src/Yi-Syntax-OnlineTree.html#manyToks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "manyToks",
          "package": "yi",
          "partial": "Toks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#v:manyToks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Yi.Syntax.OnlineTree\",\"Yi.Syntax.Tree\"]",
          "name": "tokAtOrBefore",
          "package": "yi",
          "signature": "Point -\u003e t (Tok t1) -\u003e Maybe (Tok t1)",
          "source": "src/Yi-Syntax-Tree.html#tokAtOrBefore",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#v:tokAtOrBefore\",\"http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:tokAtOrBefore\"]"
        },
        "index": {
          "hierarchy": "Yi Syntax OnlineTree",
          "module": "Yi.Syntax.OnlineTree",
          "name": "tokAtOrBefore",
          "normalized": "Point-\u003ea(Tok a)-\u003eMaybe(Tok a)",
          "package": "yi",
          "partial": "At Or Before",
          "signature": "Point-\u003et(Tok t)-\u003eMaybe(Tok t)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-OnlineTree.html#v:tokAtOrBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParser for haskell that takes in account only parenthesis and layout\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Syntax.Paren",
          "name": "Paren",
          "package": "yi",
          "source": "src/Yi-Syntax-Paren.html",
          "type": "module"
        },
        "index": {
          "description": "Parser for haskell that takes in account only parenthesis and layout",
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Paren",
          "package": "yi",
          "partial": "Paren",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Expr",
          "package": "yi",
          "source": "src/Yi-Syntax-Paren.html#Expr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Expr",
          "package": "yi",
          "partial": "Expr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#t:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Tree",
          "package": "yi",
          "source": "src/Yi-Syntax-Paren.html#Tree",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Tree",
          "package": "yi",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Atom",
          "package": "yi",
          "signature": "Atom t",
          "source": "src/Yi-Syntax-Paren.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Atom",
          "package": "yi",
          "partial": "Atom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:Atom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Block",
          "package": "yi",
          "signature": "Block [Tree t]",
          "source": "src/Yi-Syntax-Paren.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Block",
          "normalized": "Block[Tree a]",
          "package": "yi",
          "partial": "Block",
          "signature": "Block[Tree t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:Block"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Error",
          "package": "yi",
          "signature": "Error t",
          "source": "src/Yi-Syntax-Paren.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Error",
          "package": "yi",
          "partial": "Error",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Expr",
          "package": "yi",
          "signature": "Expr [Tree t]",
          "source": "src/Yi-Syntax-Paren.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Expr",
          "normalized": "Expr[Tree a]",
          "package": "yi",
          "partial": "Expr",
          "signature": "Expr[Tree t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:Expr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "Paren",
          "package": "yi",
          "signature": "Paren t (Expr t) t",
          "source": "src/Yi-Syntax-Paren.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "Paren",
          "package": "yi",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a special error token. (e.g. fill in where there is no correct token to parse)\n Note that the position of the token has to be correct for correct computation of \n node spans.\n\u003c/p\u003e",
          "module": "Yi.Syntax.Paren",
          "name": "errTok",
          "package": "yi",
          "signature": "Parser (Tok t) (Tok Token)",
          "source": "src/Yi-Syntax-Paren.html#errTok",
          "type": "function"
        },
        "index": {
          "description": "Create special error token e.g fill in where there is no correct token to parse Note that the position of the token has to be correct for correct computation of node spans",
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "errTok",
          "package": "yi",
          "partial": "Tok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:errTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch the given list, and return the 1st tree after the given\n point on the given line.  This is the tree that will be moved if\n something is inserted at the point.  Precondition: point is in the\n given line.  \n\u003c/p\u003e",
          "module": "Yi.Syntax.Paren",
          "name": "getIndentingSubtree",
          "package": "yi",
          "signature": "Tree TT -\u003e Point -\u003e Int -\u003e Maybe (Tree TT)",
          "source": "src/Yi-Syntax-Paren.html#getIndentingSubtree",
          "type": "function"
        },
        "index": {
          "description": "Search the given list and return the st tree after the given point on the given line This is the tree that will be moved if something is inserted at the point Precondition point is in the given line",
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "getIndentingSubtree",
          "normalized": "Tree TT-\u003ePoint-\u003eInt-\u003eMaybe(Tree TT)",
          "package": "yi",
          "partial": "Indenting Subtree",
          "signature": "Tree TT-\u003ePoint-\u003eInt-\u003eMaybe(Tree TT)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:getIndentingSubtree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "getStrokes",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e Point -\u003e Tree TT -\u003e [Stroke]",
          "source": "src/Yi-Syntax-Paren.html#getStrokes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "getStrokes",
          "normalized": "Point-\u003ePoint-\u003ePoint-\u003eTree TT-\u003e[Stroke]",
          "package": "yi",
          "partial": "Strokes",
          "signature": "Point-\u003ePoint-\u003ePoint-\u003eTree TT-\u003e[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:getStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a tree, return (first offset, number of lines).\n\u003c/p\u003e",
          "module": "Yi.Syntax.Paren",
          "name": "getSubtreeSpan",
          "package": "yi",
          "signature": "Tree TT -\u003e (Point, Int)",
          "source": "src/Yi-Syntax-Paren.html#getSubtreeSpan",
          "type": "function"
        },
        "index": {
          "description": "Given tree return first offset number of lines",
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "getSubtreeSpan",
          "normalized": "Tree TT-\u003e(Point,Int)",
          "package": "yi",
          "partial": "Subtree Span",
          "signature": "Tree TT-\u003e(Point,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:getSubtreeSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "ignoredToken",
          "package": "yi",
          "signature": "TT -\u003e Bool",
          "source": "src/Yi-Syntax-Paren.html#ignoredToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "ignoredToken",
          "normalized": "TT-\u003eBool",
          "package": "yi",
          "partial": "Token",
          "signature": "TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:ignoredToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "indentScanner",
          "package": "yi",
          "signature": "Scanner (AlexState lexState) TT -\u003e Scanner (State Token lexState) TT",
          "source": "src/Yi-Syntax-Paren.html#indentScanner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "indentScanner",
          "normalized": "Scanner(AlexState a)TT-\u003eScanner(State Token a)TT",
          "package": "yi",
          "partial": "Scanner",
          "signature": "Scanner(AlexState lexState)TT-\u003eScanner(State Token lexState)TT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:indentScanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "isBrace",
          "package": "yi",
          "signature": "TT -\u003e Bool",
          "source": "src/Yi-Syntax-Paren.html#isBrace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "isBrace",
          "normalized": "TT-\u003eBool",
          "package": "yi",
          "partial": "Brace",
          "signature": "TT-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:isBrace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "isNoise",
          "package": "yi",
          "signature": "Token -\u003e Bool",
          "source": "src/Yi-Syntax-Paren.html#isNoise",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "isNoise",
          "normalized": "Token-\u003eBool",
          "package": "yi",
          "partial": "Noise",
          "signature": "Token-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:isNoise"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "modStroke",
          "package": "yi",
          "signature": "StyleName -\u003e Stroke -\u003e Stroke",
          "source": "src/Yi-Syntax-Paren.html#modStroke",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "modStroke",
          "normalized": "StyleName-\u003eStroke-\u003eStroke",
          "package": "yi",
          "partial": "Stroke",
          "signature": "StyleName-\u003eStroke-\u003eStroke",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:modStroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "parse",
          "package": "yi",
          "signature": "P TT (Tree TT)",
          "source": "src/Yi-Syntax-Paren.html#parse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "parse",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "parse'",
          "package": "yi",
          "signature": "(TT -\u003e Token) -\u003e (Token -\u003e TT) -\u003e P TT [Tree TT]",
          "source": "src/Yi-Syntax-Paren.html#parse%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "parse'",
          "normalized": "(TT-\u003eToken)-\u003e(Token-\u003eTT)-\u003eP TT[Tree TT]",
          "package": "yi",
          "signature": "(TT-\u003eToken)-\u003e(Token-\u003eTT)-\u003eP TT[Tree TT]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:parse-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "tokenToAnnot",
          "package": "yi",
          "signature": "TT -\u003e Maybe (Span String)",
          "source": "src/Yi-Syntax-Paren.html#tokenToAnnot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "tokenToAnnot",
          "normalized": "TT-\u003eMaybe(Span String)",
          "package": "yi",
          "partial": "To Annot",
          "signature": "TT-\u003eMaybe(Span String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:tokenToAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Paren",
          "name": "tokenToStroke",
          "package": "yi",
          "signature": "TT -\u003e Stroke",
          "source": "src/Yi-Syntax-Paren.html#tokenToStroke",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Paren",
          "module": "Yi.Syntax.Paren",
          "name": "tokenToStroke",
          "normalized": "TT-\u003eStroke",
          "package": "yi",
          "partial": "To Stroke",
          "signature": "TT-\u003eStroke",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Paren.html#v:tokenToStroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Strokes.Haskell",
          "name": "Haskell",
          "package": "yi",
          "source": "src/Yi-Syntax-Strokes-Haskell.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Syntax Strokes Haskell",
          "module": "Yi.Syntax.Strokes.Haskell",
          "name": "Haskell",
          "package": "yi",
          "partial": "Haskell",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Strokes-Haskell.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Strokes.Haskell",
          "name": "getStrokes",
          "package": "yi",
          "signature": "Point -\u003e Point -\u003e Point -\u003e Tree TT -\u003e [Stroke]",
          "source": "src/Yi-Syntax-Strokes-Haskell.html#getStrokes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Strokes Haskell",
          "module": "Yi.Syntax.Strokes.Haskell",
          "name": "getStrokes",
          "normalized": "Point-\u003ePoint-\u003ePoint-\u003eTree TT-\u003e[Stroke]",
          "package": "yi",
          "partial": "Strokes",
          "signature": "Point-\u003ePoint-\u003ePoint-\u003eTree TT-\u003e[Stroke]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Strokes-Haskell.html#v:getStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Strokes.Haskell",
          "name": "tokenToAnnot",
          "package": "yi",
          "signature": "TT -\u003e Maybe (Span String)",
          "source": "src/Yi-Syntax-Strokes-Haskell.html#tokenToAnnot",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Strokes Haskell",
          "module": "Yi.Syntax.Strokes.Haskell",
          "name": "tokenToAnnot",
          "normalized": "TT-\u003eMaybe(Span String)",
          "package": "yi",
          "partial": "To Annot",
          "signature": "TT-\u003eMaybe(Span String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Strokes-Haskell.html#v:tokenToAnnot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneric syntax tree handling functions\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "Tree",
          "package": "yi",
          "source": "src/Yi-Syntax-Tree.html",
          "type": "module"
        },
        "index": {
          "description": "Generic syntax tree handling functions",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "Tree",
          "package": "yi",
          "partial": "Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "IsTree",
          "package": "yi",
          "source": "src/Yi-Syntax-Tree.html#IsTree",
          "type": "class"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "IsTree",
          "package": "yi",
          "partial": "Is Tree",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#t:IsTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "allToks",
          "package": "yi",
          "signature": "t a -\u003e [a]",
          "source": "src/Yi-Syntax-Tree.html#allToks",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "allToks",
          "normalized": "a b-\u003e[b]",
          "package": "yi",
          "partial": "Toks",
          "signature": "t a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:allToks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "emptyNode",
          "package": "yi",
          "signature": "tree t",
          "source": "src/Yi-Syntax-Tree.html#emptyNode",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "emptyNode",
          "package": "yi",
          "partial": "Node",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:emptyNode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch the tree in pre-order starting at a given node, until finding a leaf which is at\n or after the given point. An effort is also made to return a leaf as close as possible to \u003ccode\u003ep\u003c/code\u003e.\n TODO: rename to fromLeafToLeafAt\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "fromLeafToLeafAfter",
          "package": "yi",
          "signature": "Point -\u003e Node (tree (Tok a)) -\u003e Node (tree (Tok a))",
          "source": "src/Yi-Syntax-Tree.html#fromLeafToLeafAfter",
          "type": "function"
        },
        "index": {
          "description": "Search the tree in pre-order starting at given node until finding leaf which is at or after the given point An effort is also made to return leaf as close as possible to TODO rename to fromLeafToLeafAt",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "fromLeafToLeafAfter",
          "normalized": "Point-\u003eNode(a(Tok b))-\u003eNode(a(Tok b))",
          "package": "yi",
          "partial": "Leaf To Leaf After",
          "signature": "Point-\u003eNode(tree(Tok a))-\u003eNode(tree(Tok a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:fromLeafToLeafAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven an approximate path to a leaf at the end of the region, return:\n (path to leaf at the end of the region,path from focused node to the leaf, small node encompassing the region)\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "fromNodeToFinal",
          "package": "yi",
          "signature": "Region -\u003e Node (tree (Tok a)) -\u003e Node (tree (Tok a))",
          "source": "src/Yi-Syntax-Tree.html#fromNodeToFinal",
          "type": "function"
        },
        "index": {
          "description": "Given an approximate path to leaf at the end of the region return path to leaf at the end of the region path from focused node to the leaf small node encompassing the region",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "fromNodeToFinal",
          "normalized": "Region-\u003eNode(a(Tok b))-\u003eNode(a(Tok b))",
          "package": "yi",
          "partial": "Node To Final",
          "signature": "Region-\u003eNode(tree(Tok a))-\u003eNode(tree(Tok a))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:fromNodeToFinal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn all subtrees in a tree, in preorder.\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "getAllSubTrees",
          "package": "yi",
          "signature": "tree t -\u003e [tree t]",
          "source": "src/Yi-Syntax-Tree.html#getAllSubTrees",
          "type": "function"
        },
        "index": {
          "description": "Return all subtrees in tree in preorder",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "getAllSubTrees",
          "normalized": "a b-\u003e[a b]",
          "package": "yi",
          "partial": "All Sub Trees",
          "signature": "tree t-\u003e[tree t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:getAllSubTrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the 1st token of a subtree.\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "getFirstElement",
          "package": "yi",
          "signature": "t a -\u003e Maybe a",
          "source": "src/Yi-Syntax-Tree.html#getFirstElement",
          "type": "function"
        },
        "index": {
          "description": "Return the st token of subtree",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "getFirstElement",
          "normalized": "a b-\u003eMaybe b",
          "package": "yi",
          "partial": "First Element",
          "signature": "t a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:getFirstElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "getFirstOffset",
          "package": "yi",
          "signature": "t (Tok t1) -\u003e Point",
          "source": "src/Yi-Syntax-Tree.html#getFirstOffset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "getFirstOffset",
          "normalized": "a(Tok a)-\u003ePoint",
          "package": "yi",
          "partial": "First Offset",
          "signature": "t(Tok t)-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:getFirstOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the last token of a subtree.\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "getLastElement",
          "package": "yi",
          "signature": "t a -\u003e Maybe a",
          "source": "src/Yi-Syntax-Tree.html#getLastElement",
          "type": "function"
        },
        "index": {
          "description": "Return the last token of subtree",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "getLastElement",
          "normalized": "a b-\u003eMaybe b",
          "package": "yi",
          "partial": "Last Element",
          "signature": "t a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:getLastElement"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "getLastOffset",
          "package": "yi",
          "signature": "t (Tok t1) -\u003e Point",
          "source": "src/Yi-Syntax-Tree.html#getLastOffset",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "getLastOffset",
          "normalized": "a(Tok a)-\u003ePoint",
          "package": "yi",
          "partial": "Last Offset",
          "signature": "t(Tok t)-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:getLastOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSearch the given list, and return the last tree before the given\n point; with path to the root. (Root is at the start of the path)\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "getLastPath",
          "package": "yi",
          "signature": "[tree (Tok t)] -\u003e Point -\u003e Maybe [tree (Tok t)]",
          "source": "src/Yi-Syntax-Tree.html#getLastPath",
          "type": "function"
        },
        "index": {
          "description": "Search the given list and return the last tree before the given point with path to the root Root is at the start of the path",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "getLastPath",
          "normalized": "[a(Tok b)]-\u003ePoint-\u003eMaybe[a(Tok b)]",
          "package": "yi",
          "partial": "Last Path",
          "signature": "[tree(Tok t)]-\u003ePoint-\u003eMaybe[tree(Tok t)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:getLastPath"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "sepBy",
          "package": "yi",
          "signature": "f a -\u003e f v -\u003e f [a]",
          "source": "src/Yi-Syntax-Tree.html#sepBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "sepBy",
          "normalized": "a b-\u003ea c-\u003ea[b]",
          "package": "yi",
          "partial": "By",
          "signature": "f a-\u003ef v-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:sepBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "sepBy1",
          "package": "yi",
          "signature": "f a -\u003e f v -\u003e f [a]",
          "source": "src/Yi-Syntax-Tree.html#sepBy1",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "sepBy1",
          "normalized": "a b-\u003ea c-\u003ea[b]",
          "package": "yi",
          "partial": "By",
          "signature": "f a-\u003ef v-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:sepBy1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "subtreeRegion",
          "package": "yi",
          "signature": "t (Tok t1) -\u003e Region",
          "source": "src/Yi-Syntax-Tree.html#subtreeRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "subtreeRegion",
          "normalized": "a(Tok a)-\u003eRegion",
          "package": "yi",
          "partial": "Region",
          "signature": "t(Tok t)-\u003eRegion",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:subtreeRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDirect subtrees of a tree\n\u003c/p\u003e",
          "module": "Yi.Syntax.Tree",
          "name": "subtrees",
          "package": "yi",
          "signature": "tree t -\u003e [tree t]",
          "source": "src/Yi-Syntax-Tree.html#subtrees",
          "type": "method"
        },
        "index": {
          "description": "Direct subtrees of tree",
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "subtrees",
          "normalized": "a b-\u003e[a b]",
          "package": "yi",
          "signature": "tree t-\u003e[tree t]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:subtrees"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "tokenBasedAnnots",
          "package": "yi",
          "signature": "(a1 -\u003e Maybe a) -\u003e t1 a1 -\u003e t -\u003e [a]",
          "source": "src/Yi-Syntax-Tree.html#tokenBasedAnnots",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "tokenBasedAnnots",
          "normalized": "(a-\u003eMaybe a)-\u003eb a-\u003eb-\u003e[a]",
          "package": "yi",
          "partial": "Based Annots",
          "signature": "(a-\u003eMaybe a)-\u003et a-\u003et-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:tokenBasedAnnots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "tokenBasedStrokes",
          "package": "yi",
          "signature": "(a -\u003e b) -\u003e t3 a -\u003e t -\u003e t2 -\u003e t1 -\u003e [b]",
          "source": "src/Yi-Syntax-Tree.html#tokenBasedStrokes",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "tokenBasedStrokes",
          "normalized": "(a-\u003eb)-\u003ec a-\u003ec-\u003ec-\u003ec-\u003e[b]",
          "package": "yi",
          "partial": "Based Strokes",
          "signature": "(a-\u003eb)-\u003et a-\u003et-\u003et-\u003et-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:tokenBasedStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "toksAfter",
          "package": "yi",
          "signature": "t -\u003e t1 a -\u003e [a]",
          "source": "src/Yi-Syntax-Tree.html#toksAfter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "toksAfter",
          "normalized": "a-\u003ea b-\u003e[b]",
          "package": "yi",
          "partial": "After",
          "signature": "t-\u003et a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:toksAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "toksInRegion",
          "package": "yi",
          "signature": "Region -\u003e t1 (Tok t) -\u003e [Tok t]",
          "source": "src/Yi-Syntax-Tree.html#toksInRegion",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "toksInRegion",
          "normalized": "Region-\u003ea(Tok a)-\u003e[Tok a]",
          "package": "yi",
          "partial": "In Region",
          "signature": "Region-\u003et(Tok t)-\u003e[Tok t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:toksInRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax.Tree",
          "name": "uniplate",
          "package": "yi",
          "signature": "tree t -\u003e ([tree t], [tree t] -\u003e tree t)",
          "source": "src/Yi-Syntax-Tree.html#uniplate",
          "type": "method"
        },
        "index": {
          "hierarchy": "Yi Syntax Tree",
          "module": "Yi.Syntax.Tree",
          "name": "uniplate",
          "normalized": "a b-\u003e([a b],[a b]-\u003ea b)",
          "package": "yi",
          "signature": "tree t-\u003e([tree t],[tree t]-\u003etree t)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax-Tree.html#v:uniplate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a common interface for syntax-awareness.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Syntax",
          "name": "Syntax",
          "package": "yi",
          "source": "src/Yi-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines common interface for syntax-awareness",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Syntax",
          "package": "yi",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Cache",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Cache",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Cache",
          "package": "yi",
          "partial": "Cache",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Cache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "ExtHL",
          "package": "yi",
          "source": "src/Yi-Syntax.html#ExtHL",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "ExtHL",
          "package": "yi",
          "partial": "Ext HL",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:ExtHL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main type of syntax highlighters.  This record type combines all\n the required functions, and is parametrized on the type of the internal\n state.\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "Highlighter",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Highlighter",
          "type": "data"
        },
        "index": {
          "description": "The main type of syntax highlighters This record type combines all the required functions and is parametrized on the type of the internal state",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Highlighter",
          "package": "yi",
          "partial": "Highlighter",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Highlighter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Length",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Length",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Length",
          "package": "yi",
          "partial": "Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA point in a buffer\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "Point",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Point",
          "type": "newtype"
        },
        "index": {
          "description": "point in buffer",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Point",
          "package": "yi",
          "partial": "Point",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Point"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Scanner",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Scanner",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Scanner",
          "package": "yi",
          "partial": "Scanner",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Scanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of a buffer region\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "Size",
          "package": "yi",
          "source": "src/Yi-Buffer-Basic.html#Size",
          "type": "newtype"
        },
        "index": {
          "description": "Size of buffer region",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Size",
          "package": "yi",
          "partial": "Size",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Span",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Span",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Span",
          "package": "yi",
          "partial": "Span",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Stroke",
          "package": "yi",
          "source": "src/Yi-Syntax.html#Stroke",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Stroke",
          "package": "yi",
          "partial": "Stroke",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#t:Stroke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "ExtHL",
          "package": "yi",
          "signature": "forall cache . ExtHL (Highlighter cache syntax)",
          "source": "src/Yi-Syntax.html#ExtHL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "ExtHL",
          "package": "yi",
          "partial": "Ext HL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:ExtHL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Scanner",
          "package": "yi",
          "signature": "Scanner",
          "source": "src/Yi-Syntax.html#Scanner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Scanner",
          "package": "yi",
          "partial": "Scanner",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:Scanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "Span",
          "package": "yi",
          "signature": "Span",
          "source": "src/Yi-Syntax.html#Span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "Span",
          "package": "yi",
          "partial": "Span",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:Span"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "SynHL",
          "package": "yi",
          "signature": "SynHL",
          "source": "src/Yi-Syntax.html#Highlighter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "SynHL",
          "package": "yi",
          "partial": "Syn HL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:SynHL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "emptyFileScan",
          "package": "yi",
          "signature": "Scanner Point Char",
          "source": "src/Yi-Syntax.html#emptyFileScan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "emptyFileScan",
          "package": "yi",
          "partial": "File Scan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:emptyFileScan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efocus at a given point, and return the coresponding node. (hint -- the root can always be returned, at the cost of performance.)\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "hlFocus",
          "package": "yi",
          "signature": "Map WindowRef Region -\u003e cache -\u003e cache",
          "source": "src/Yi-Syntax.html#Highlighter",
          "type": "function"
        },
        "index": {
          "description": "focus at given point and return the coresponding node hint the root can always be returned at the cost of performance",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "hlFocus",
          "normalized": "Map WindowRef Region-\u003ea-\u003ea",
          "package": "yi",
          "partial": "Focus",
          "signature": "Map WindowRef Region-\u003ecache-\u003ecache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:hlFocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "hlGetTree",
          "package": "yi",
          "signature": "cache -\u003e WindowRef -\u003e syntax",
          "source": "src/Yi-Syntax.html#Highlighter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "hlGetTree",
          "normalized": "a-\u003eWindowRef-\u003eb",
          "package": "yi",
          "partial": "Get Tree",
          "signature": "cache-\u003eWindowRef-\u003esyntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:hlGetTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "hlRun",
          "package": "yi",
          "signature": "Scanner Point Char -\u003e Point -\u003e cache -\u003e cache",
          "source": "src/Yi-Syntax.html#Highlighter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "hlRun",
          "normalized": "Scanner Point Char-\u003ePoint-\u003ea-\u003ea",
          "package": "yi",
          "partial": "Run",
          "signature": "Scanner Point Char-\u003ePoint-\u003ecache-\u003ecache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:hlRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe start state for the highlighter.\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "hlStartState",
          "package": "yi",
          "signature": "cache",
          "source": "src/Yi-Syntax.html#Highlighter",
          "type": "function"
        },
        "index": {
          "description": "The start state for the highlighter",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "hlStartState",
          "package": "yi",
          "partial": "Start State",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:hlStartState"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis takes as input a scanner that returns the \u003ca\u003efull\u003c/a\u003e result at\n each element in the list; perhaps in a different form for the\n purpose of incremental-lazy eval.\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "mkHighlighter",
          "package": "yi",
          "signature": "(Scanner Point Char -\u003e Scanner state result) -\u003e Highlighter (Cache state result) result",
          "source": "src/Yi-Syntax.html#mkHighlighter",
          "type": "function"
        },
        "index": {
          "description": "This takes as input scanner that returns the full result at each element in the list perhaps in different form for the purpose of incremental-lazy eval",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "mkHighlighter",
          "normalized": "(Scanner Point Char-\u003eScanner a b)-\u003eHighlighter(Cache a b)b",
          "package": "yi",
          "partial": "Highlighter",
          "signature": "(Scanner Point Char-\u003eScanner state result)-\u003eHighlighter(Cache state result)result",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:mkHighlighter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "noHighlighter",
          "package": "yi",
          "signature": "Highlighter () syntax",
          "source": "src/Yi-Syntax.html#noHighlighter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "noHighlighter",
          "normalized": "Highlighter()a",
          "package": "yi",
          "partial": "Highlighter",
          "signature": "Highlighter()syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:noHighlighter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "scanEmpty",
          "package": "yi",
          "signature": "a",
          "source": "src/Yi-Syntax.html#Scanner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "scanEmpty",
          "package": "yi",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:scanEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitial state\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "scanInit",
          "package": "yi",
          "signature": "st",
          "source": "src/Yi-Syntax.html#Scanner",
          "type": "function"
        },
        "index": {
          "description": "Initial state",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "scanInit",
          "package": "yi",
          "partial": "Init",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:scanInit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHow far did the scanner look to produce this intermediate state?\n The state can be reused as long as nothing changes before that point.\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "scanLooked",
          "package": "yi",
          "signature": "st -\u003e Point",
          "source": "src/Yi-Syntax.html#Scanner",
          "type": "function"
        },
        "index": {
          "description": "How far did the scanner look to produce this intermediate state The state can be reused as long as nothing changes before that point",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "scanLooked",
          "normalized": "a-\u003ePoint",
          "package": "yi",
          "partial": "Looked",
          "signature": "st-\u003ePoint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:scanLooked"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRunning function returns a list of results and intermediate states.\n Note: the state is the state \u003cem\u003ebefore\u003c/em\u003e producing the result in the second component.\n\u003c/p\u003e",
          "module": "Yi.Syntax",
          "name": "scanRun",
          "package": "yi",
          "signature": "st -\u003e [(st, a)]",
          "source": "src/Yi-Syntax.html#Scanner",
          "type": "function"
        },
        "index": {
          "description": "Running function returns list of results and intermediate states Note the state is the state before producing the result in the second component",
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "scanRun",
          "normalized": "a-\u003e[(a,b)]",
          "package": "yi",
          "partial": "Run",
          "signature": "st-\u003e[(st,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:scanRun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "skipScanner",
          "package": "yi",
          "signature": "Int -\u003e Scanner st a -\u003e Scanner st a",
          "source": "src/Yi-Syntax.html#skipScanner",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "skipScanner",
          "normalized": "Int-\u003eScanner a b-\u003eScanner a b",
          "package": "yi",
          "partial": "Scanner",
          "signature": "Int-\u003eScanner st a-\u003eScanner st a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:skipScanner"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "spanBegin",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Syntax.html#Span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "spanBegin",
          "package": "yi",
          "partial": "Begin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:spanBegin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "spanContents",
          "package": "yi",
          "signature": "a",
          "source": "src/Yi-Syntax.html#Span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "spanContents",
          "package": "yi",
          "partial": "Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:spanContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Syntax",
          "name": "spanEnd",
          "package": "yi",
          "signature": "Point",
          "source": "src/Yi-Syntax.html#Span",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Syntax",
          "module": "Yi.Syntax",
          "name": "spanEnd",
          "package": "yi",
          "partial": "End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Syntax.html#v:spanEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tab",
          "name": "Tab",
          "package": "yi",
          "source": "src/Yi-Tab.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "Tab",
          "package": "yi",
          "partial": "Tab",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tab, containing a collection of windows.\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "Tab",
          "package": "yi",
          "source": "src/Yi-Tab.html#Tab",
          "type": "data"
        },
        "index": {
          "description": "tab containing collection of windows",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "Tab",
          "package": "yi",
          "partial": "Tab",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#t:Tab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tab",
          "name": "TabRef",
          "package": "yi",
          "source": "src/Yi-Tab.html#TabRef",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "TabRef",
          "package": "yi",
          "partial": "Tab Ref",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#t:TabRef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eForces all windows in the tab\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "forceTab",
          "package": "yi",
          "signature": "Tab -\u003e Tab",
          "source": "src/Yi-Tab.html#forceTab",
          "type": "function"
        },
        "index": {
          "description": "Forces all windows in the tab",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "forceTab",
          "normalized": "Tab-\u003eTab",
          "package": "yi",
          "partial": "Tab",
          "signature": "Tab-\u003eTab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:forceTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a tab from multiple windows\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "makeTab",
          "package": "yi",
          "signature": "TabRef -\u003e PointedList Window -\u003e Tab",
          "source": "src/Yi-Tab.html#makeTab",
          "type": "function"
        },
        "index": {
          "description": "Make tab from multiple windows",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "makeTab",
          "normalized": "TabRef-\u003ePointedList Window-\u003eTab",
          "package": "yi",
          "partial": "Tab",
          "signature": "TabRef-\u003ePointedList Window-\u003eTab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:makeTab"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a tab from one window\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "makeTab1",
          "package": "yi",
          "signature": "TabRef -\u003e Window -\u003e Tab",
          "source": "src/Yi-Tab.html#makeTab1",
          "type": "function"
        },
        "index": {
          "description": "Make tab from one window",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "makeTab1",
          "normalized": "TabRef-\u003eWindow-\u003eTab",
          "package": "yi",
          "partial": "Tab",
          "signature": "TabRef-\u003eWindow-\u003eTab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:makeTab1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA specialised version of \u003ca\u003efmap\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "mapWindows",
          "package": "yi",
          "signature": "(Window -\u003e Window) -\u003e Tab -\u003e Tab",
          "source": "src/Yi-Tab.html#mapWindows",
          "type": "function"
        },
        "index": {
          "description": "specialised version of fmap",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "mapWindows",
          "normalized": "(Window-\u003eWindow)-\u003eTab-\u003eTab",
          "package": "yi",
          "partial": "Windows",
          "signature": "(Window-\u003eWindow)-\u003eTab-\u003eTab",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:mapWindows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGets / sets the position of the divider with the given reference. The caller must ensure that the DividerRef is valid, otherwise an error will (might!) occur.\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tabDividerPositionA",
          "package": "yi",
          "signature": "DividerRef -\u003e Accessor Tab DividerPosition",
          "source": "src/Yi-Tab.html#tabDividerPositionA",
          "type": "function"
        },
        "index": {
          "description": "Gets sets the position of the divider with the given reference The caller must ensure that the DividerRef is valid otherwise an error will might occur",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabDividerPositionA",
          "normalized": "DividerRef-\u003eAccessor Tab DividerPosition",
          "package": "yi",
          "partial": "Divider Position",
          "signature": "DividerRef-\u003eAccessor Tab DividerPosition",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabDividerPositionA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tab",
          "name": "tabFocus",
          "package": "yi",
          "signature": "Tab -\u003e Window",
          "source": "src/Yi-Tab.html#tabFocus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabFocus",
          "normalized": "Tab-\u003eWindow",
          "package": "yi",
          "partial": "Focus",
          "signature": "Tab-\u003eWindow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabFocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFolds over the windows in the tab\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tabFoldl",
          "package": "yi",
          "signature": "(a -\u003e Window -\u003e a) -\u003e a -\u003e Tab -\u003e a",
          "source": "src/Yi-Tab.html#tabFoldl",
          "type": "function"
        },
        "index": {
          "description": "Folds over the windows in the tab",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabFoldl",
          "normalized": "(a-\u003eWindow-\u003ea)-\u003ea-\u003eTab-\u003ea",
          "package": "yi",
          "partial": "Foldl",
          "signature": "(a-\u003eWindow-\u003ea)-\u003ea-\u003eTab-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabFoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCurrent layout. Invariant: must be the layout generated by \u003ccode\u003etabLayoutManager\u003c/code\u003e, up to changing the \u003ccode\u003e\u003ca\u003edivPos\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tabLayout",
          "package": "yi",
          "signature": "Tab -\u003e Layout WindowRef",
          "source": "src/Yi-Tab.html#tabLayout",
          "type": "function"
        },
        "index": {
          "description": "Current layout Invariant must be the layout generated by tabLayoutManager up to changing the divPos",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabLayout",
          "normalized": "Tab-\u003eLayout WindowRef",
          "package": "yi",
          "partial": "Layout",
          "signature": "Tab-\u003eLayout WindowRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for the layout manager. When setting, will trigger a relayout if the layout manager has changed.\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tabLayoutManagerA",
          "package": "yi",
          "signature": "Accessor Tab AnyLayoutManager",
          "source": "src/Yi-Tab.html#tabLayoutManagerA",
          "type": "function"
        },
        "index": {
          "description": "Accessor for the layout manager When setting will trigger relayout if the layout manager has changed",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabLayoutManagerA",
          "package": "yi",
          "partial": "Layout Manager",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabLayoutManagerA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a list of all mini windows associated with the given tab\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tabMiniWindows",
          "package": "yi",
          "signature": "Tab -\u003e [Window]",
          "source": "src/Yi-Tab.html#tabMiniWindows",
          "type": "function"
        },
        "index": {
          "description": "Returns list of all mini windows associated with the given tab",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabMiniWindows",
          "normalized": "Tab-\u003e[Window]",
          "package": "yi",
          "partial": "Mini Windows",
          "signature": "Tab-\u003e[Window]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabMiniWindows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAccessor for the windows. If the windows (but not the focus) have changed when setting, then a relayout will be triggered to preserve the internal invariant.\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tabWindowsA",
          "package": "yi",
          "signature": "Accessor Tab (PointedList Window)",
          "source": "src/Yi-Tab.html#tabWindowsA",
          "type": "function"
        },
        "index": {
          "description": "Accessor for the windows If the windows but not the focus have changed when setting then relayout will be triggered to preserve the internal invariant",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tabWindowsA",
          "package": "yi",
          "partial": "Windows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tabWindowsA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor UI sync; fixes #304\n\u003c/p\u003e",
          "module": "Yi.Tab",
          "name": "tkey",
          "package": "yi",
          "signature": "Tab -\u003e TabRef",
          "source": "src/Yi-Tab.html#tkey",
          "type": "function"
        },
        "index": {
          "description": "For UI sync fixes",
          "hierarchy": "Yi Tab",
          "module": "Yi.Tab",
          "name": "tkey",
          "normalized": "Tab-\u003eTabRef",
          "package": "yi",
          "signature": "Tab-\u003eTabRef",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tab.html#v:tkey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA module for CTags integration\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.Tag",
          "name": "Tag",
          "package": "yi",
          "source": "src/Yi-Tag.html",
          "type": "module"
        },
        "index": {
          "description": "module for CTags integration",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "Tag",
          "package": "yi",
          "partial": "Tag",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tag",
          "name": "Tag",
          "package": "yi",
          "source": "src/Yi-Tag.html#Tag",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "Tag",
          "package": "yi",
          "partial": "Tag",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#t:Tag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tag",
          "name": "TagTable",
          "package": "yi",
          "source": "src/Yi-Tag.html#TagTable",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "TagTable",
          "package": "yi",
          "partial": "Tag Table",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#t:TagTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tag",
          "name": "TagTable",
          "package": "yi",
          "signature": "TagTable",
          "source": "src/Yi-Tag.html#TagTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "TagTable",
          "package": "yi",
          "partial": "Tag Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:TagTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtends the string to the longest certain length\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "completeTag",
          "package": "yi",
          "signature": "TagTable -\u003e String -\u003e String",
          "source": "src/Yi-Tag.html#completeTag",
          "type": "function"
        },
        "index": {
          "description": "Extends the string to the longest certain length",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "completeTag",
          "normalized": "TagTable-\u003eString-\u003eString",
          "package": "yi",
          "partial": "Tag",
          "signature": "TagTable-\u003eString-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:completeTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the currently registered tag table\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "getTags",
          "package": "yi",
          "signature": "EditorM (Maybe TagTable)",
          "source": "src/Yi-Tag.html#getTags",
          "type": "function"
        },
        "index": {
          "description": "Get the currently registered tag table",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "getTags",
          "package": "yi",
          "partial": "Tags",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:getTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tag",
          "name": "getTagsFileList",
          "package": "yi",
          "signature": "EditorM [FilePath]",
          "source": "src/Yi-Tag.html#getTagsFileList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "getTagsFileList",
          "normalized": "EditorM[FilePath]",
          "package": "yi",
          "partial": "Tags File List",
          "signature": "EditorM[FilePath]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:getTagsFileList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGives all the possible expanded tags that could match a given \u003ccode\u003eprefix\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "hintTags",
          "package": "yi",
          "signature": "TagTable -\u003e String -\u003e [String]",
          "source": "src/Yi-Tag.html#hintTags",
          "type": "function"
        },
        "index": {
          "description": "Gives all the possible expanded tags that could match given prefix",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "hintTags",
          "normalized": "TagTable-\u003eString-\u003e[String]",
          "package": "yi",
          "partial": "Tags",
          "signature": "TagTable-\u003eString-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:hintTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRead in a tag file from the system\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "importTagTable",
          "package": "yi",
          "signature": "FilePath -\u003e IO TagTable",
          "source": "src/Yi-Tag.html#importTagTable",
          "type": "function"
        },
        "index": {
          "description": "Read in tag file from the system",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "importTagTable",
          "normalized": "FilePath-\u003eIO TagTable",
          "package": "yi",
          "partial": "Tag Table",
          "signature": "FilePath-\u003eIO TagTable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:importTagTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFind the location of a tag using the tag table.\n Returns a full path and line number\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "lookupTag",
          "package": "yi",
          "signature": "Tag -\u003e TagTable -\u003e Maybe (FilePath, Int)",
          "source": "src/Yi-Tag.html#lookupTag",
          "type": "function"
        },
        "index": {
          "description": "Find the location of tag using the tag table Returns full path and line number",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "lookupTag",
          "normalized": "Tag-\u003eTagTable-\u003eMaybe(FilePath,Int)",
          "package": "yi",
          "partial": "Tag",
          "signature": "Tag-\u003eTagTable-\u003eMaybe(FilePath,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:lookupTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReset the TagTable\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "resetTags",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-Tag.html#resetTags",
          "type": "function"
        },
        "index": {
          "description": "Reset the TagTable",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "resetTags",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Tags",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:resetTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet a new TagTable\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "setTags",
          "package": "yi",
          "signature": "TagTable -\u003e EditorM ()",
          "source": "src/Yi-Tag.html#setTags",
          "type": "function"
        },
        "index": {
          "description": "Set new TagTable",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "setTags",
          "normalized": "TagTable-\u003eEditorM()",
          "package": "yi",
          "partial": "Tags",
          "signature": "TagTable-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:setTags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Tag",
          "name": "setTagsFileList",
          "package": "yi",
          "signature": "String -\u003e EditorM ()",
          "source": "src/Yi-Tag.html#setTagsFileList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "setTagsFileList",
          "normalized": "String-\u003eEditorM()",
          "package": "yi",
          "partial": "Tags File List",
          "signature": "String-\u003eEditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:setTagsFileList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epath to the tag file directory\n tags are relative to this path\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "tagBaseDir",
          "package": "yi",
          "signature": "FilePath",
          "source": "src/Yi-Tag.html#TagTable",
          "type": "function"
        },
        "index": {
          "description": "path to the tag file directory tags are relative to this path",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "tagBaseDir",
          "package": "yi",
          "partial": "Base Dir",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:tagBaseDir"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emap from tags to files\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "tagFileMap",
          "package": "yi",
          "signature": "Map Tag (FilePath, Int)",
          "source": "src/Yi-Tag.html#TagTable",
          "type": "function"
        },
        "index": {
          "description": "map from tags to files",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "tagFileMap",
          "normalized": "Map Tag(FilePath,Int)",
          "package": "yi",
          "partial": "File Map",
          "signature": "Map Tag(FilePath,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:tagFileMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal name of the tag file\n TODO: reload if this file is changed\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "tagFileName",
          "package": "yi",
          "signature": "FilePath",
          "source": "src/Yi-Tag.html#TagTable",
          "type": "function"
        },
        "index": {
          "description": "local name of the tag file TODO reload if this file is changed",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "tagFileName",
          "package": "yi",
          "partial": "File Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:tagFileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etrie to speed up tag hinting\n\u003c/p\u003e",
          "module": "Yi.Tag",
          "name": "tagTrie",
          "package": "yi",
          "signature": "Trie",
          "source": "src/Yi-Tag.html#TagTable",
          "type": "function"
        },
        "index": {
          "description": "trie to speed up tag hinting",
          "hierarchy": "Yi Tag",
          "module": "Yi.Tag",
          "name": "tagTrie",
          "package": "yi",
          "partial": "Trie",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Tag.html#v:tagTrie"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.TextCompletion",
          "name": "TextCompletion",
          "package": "yi",
          "source": "src/Yi-TextCompletion.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "TextCompletion",
          "package": "yi",
          "partial": "Text Completion",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.TextCompletion",
          "name": "completeWordB",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-TextCompletion.html#completeWordB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "completeWordB",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Word",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:completeWordB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTry to complete the current word with occurences found elsewhere in the\n editor. Further calls try other options. \n\u003c/p\u003e",
          "module": "Yi.TextCompletion",
          "name": "mkWordComplete",
          "package": "yi",
          "signature": "YiM String -\u003e (String -\u003e YiM [String]) -\u003e ([String] -\u003e YiM ()) -\u003e (String -\u003e String -\u003e Bool) -\u003e YiM String",
          "source": "src/Yi-TextCompletion.html#mkWordComplete",
          "type": "function"
        },
        "index": {
          "description": "Try to complete the current word with occurences found elsewhere in the editor Further calls try other options",
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "mkWordComplete",
          "normalized": "YiM String-\u003e(String-\u003eYiM[String])-\u003e([String]-\u003eYiM())-\u003e(String-\u003eString-\u003eBool)-\u003eYiM String",
          "package": "yi",
          "partial": "Word Complete",
          "signature": "YiM String-\u003e(String-\u003eYiM[String])-\u003e([String]-\u003eYiM())-\u003e(String-\u003eString-\u003eBool)-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:mkWordComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSwitch out of completion mode.\n\u003c/p\u003e",
          "module": "Yi.TextCompletion",
          "name": "resetComplete",
          "package": "yi",
          "signature": "EditorM ()",
          "source": "src/Yi-TextCompletion.html#resetComplete",
          "type": "function"
        },
        "index": {
          "description": "Switch out of completion mode",
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "resetComplete",
          "normalized": "EditorM()",
          "package": "yi",
          "partial": "Complete",
          "signature": "EditorM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:resetComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.TextCompletion",
          "name": "wordComplete",
          "package": "yi",
          "signature": "YiM ()",
          "source": "src/Yi-TextCompletion.html#wordComplete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "wordComplete",
          "normalized": "YiM()",
          "package": "yi",
          "partial": "Complete",
          "signature": "YiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:wordComplete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.TextCompletion",
          "name": "wordComplete'",
          "package": "yi",
          "signature": "Bool -\u003e YiM ()",
          "source": "src/Yi-TextCompletion.html#wordComplete%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "wordComplete'",
          "normalized": "Bool-\u003eYiM()",
          "package": "yi",
          "partial": "Complete'",
          "signature": "Bool-\u003eYiM()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:wordComplete-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.TextCompletion",
          "name": "wordCompleteString",
          "package": "yi",
          "signature": "YiM String",
          "source": "src/Yi-TextCompletion.html#wordCompleteString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "wordCompleteString",
          "package": "yi",
          "partial": "Complete String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:wordCompleteString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.TextCompletion",
          "name": "wordCompleteString'",
          "package": "yi",
          "signature": "Bool -\u003e YiM String",
          "source": "src/Yi-TextCompletion.html#wordCompleteString%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi TextCompletion",
          "module": "Yi.TextCompletion",
          "name": "wordCompleteString'",
          "normalized": "Bool-\u003eYiM String",
          "package": "yi",
          "partial": "Complete String'",
          "signature": "Bool-\u003eYiM String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-TextCompletion.html#v:wordCompleteString-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Batch",
          "name": "Batch",
          "package": "yi",
          "source": "src/Yi-UI-Batch.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi UI Batch",
          "module": "Yi.UI.Batch",
          "name": "Batch",
          "package": "yi",
          "partial": "Batch",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Batch.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise the ui\n\u003c/p\u003e",
          "module": "Yi.UI.Batch",
          "name": "start",
          "package": "yi",
          "signature": "UIBoot",
          "source": "src/Yi-UI-Batch.html#start",
          "type": "function"
        },
        "index": {
          "description": "Initialise the ui",
          "hierarchy": "Yi UI Batch",
          "module": "Yi.UI.Batch",
          "name": "start",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Batch.html#v:start"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Common",
          "name": "Common",
          "package": "yi",
          "source": "src/Yi-UI-Common.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "Common",
          "package": "yi",
          "partial": "Common",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecord presenting a frontend's interface.\n\u003c/p\u003e\u003cp\u003eThe functions \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e are both run by the editor's main loop, \nin response to user actions and so on. Their relation is a little subtle, and\nis discussed here:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e to see some code, look at the function \u003ccode\u003erefreshEditor\u003c/code\u003e in \u003ca\u003eYi.Core\u003c/a\u003e. \n    This is the only place where \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e are used.\n\u003c/li\u003e\u003cli\u003e the function \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e is responsible for updating the \u003ccode\u003e\u003ca\u003eEditor\u003c/a\u003e\u003c/code\u003e with the \n    width and height of the windows. Some frontends, such as Pango, need to\n    modify their internal state to do this, and will consequently change \n    their display. This is expected. \n\u003c/li\u003e\u003cli\u003e the function \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e should cause the UI to update its display with \n    the information given in the \u003ccode\u003e\u003ca\u003eEditor\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e the functionalities of \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e overlap to some extent, in\n    the sense that both may cause the frontend to update its display. The Yi core\n    provides the following guarantees which the frontend may take advantage of:\n\u003c/li\u003e\u003cli\u003e in the main editor loop (i.e. in the \u003ccode\u003erefreshEditor\u003c/code\u003e function), \n        \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e will be run (possibly multiple times) and then \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e will\n        be run. This guarantee will hold even in the case of threading (the\n        function \u003ccode\u003erefreshEditor\u003c/code\u003e will always be run atomically, using \u003ccode\u003eMVar\u003c/code\u003es).\n\u003c/li\u003e\u003cli\u003e between the last run of \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e and the run of \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e, some changes\n        may be made to the \u003ccode\u003e\u003ca\u003eEditor\u003c/a\u003e\u003c/code\u003e. However, the text, text attributes, and \n        (displayed) window region of all windows will remain the same. However,\n        the cursor location may change.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis guarantee allows frontends which calculate rendering of the text\n        during the \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e stage to avoid recalculating the render again during\n        \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e. Pango is an example of such a frontend.\n\u003c/p\u003e\u003cp\u003eThe Yi core provides no guarantee about the OS thread from which the functions\n\u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e are called from. In particular, subprocesses (e.g. compilation, \nghci) will run \u003ccode\u003e\u003ca\u003elayout\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erefresh\u003c/a\u003e\u003c/code\u003e from new OS threads (see \u003ccode\u003estartSubprocessWatchers\u003c/code\u003e\nin \u003ca\u003eYi.Core\u003c/a\u003e). The frontend must be preparaed for this: for instance, Gtk-based frontends\nshould wrap GUI updates in \u003ccode\u003epostGUIAsync\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "UI",
          "package": "yi",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "data"
        },
        "index": {
          "description": "Record presenting frontend interface The functions layout and refresh are both run by the editor main loop in response to user actions and so on Their relation is little subtle and is discussed here to see some code look at the function refreshEditor in Yi.Core This is the only place where layout and refresh are used the function layout is responsible for updating the Editor with the width and height of the windows Some frontends such as Pango need to modify their internal state to do this and will consequently change their display This is expected the function refresh should cause the UI to update its display with the information given in the Editor the functionalities of layout and refresh overlap to some extent in the sense that both may cause the frontend to update its display The Yi core provides the following guarantees which the frontend may take advantage of in the main editor loop i.e in the refreshEditor function layout will be run possibly multiple times and then refresh will be run This guarantee will hold even in the case of threading the function refreshEditor will always be run atomically using MVar between the last run of layout and the run of refresh some changes may be made to the Editor However the text text attributes and displayed window region of all windows will remain the same However the cursor location may change This guarantee allows frontends which calculate rendering of the text during the layout stage to avoid recalculating the render again during refresh Pango is an example of such frontend The Yi core provides no guarantee about the OS thread from which the functions layout and refresh are called from In particular subprocesses e.g compilation ghci will run layout and refresh from new OS threads see startSubprocessWatchers in Yi.Core The frontend must be preparaed for this for instance Gtk-based frontends should wrap GUI updates in postGUIAsync",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "UI",
          "package": "yi",
          "partial": "UI",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#t:UI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Common",
          "name": "UI",
          "package": "yi",
          "signature": "UI",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "UI",
          "package": "yi",
          "partial": "UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:UI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Common",
          "name": "dummyUI",
          "package": "yi",
          "signature": "UI",
          "source": "src/Yi-UI-Common.html#dummyUI",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "dummyUI",
          "package": "yi",
          "partial": "UI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:dummyUI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClean up, and also terminate if given \u003ccode\u003etrue\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "end",
          "package": "yi",
          "signature": "Bool -\u003e IO ()",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "Clean up and also terminate if given true",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "end",
          "normalized": "Bool-\u003eIO()",
          "package": "yi",
          "signature": "Bool-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:end"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSet window width and height\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "layout",
          "package": "yi",
          "signature": "Editor -\u003e IO Editor",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "Set window width and height",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "layout",
          "normalized": "Editor-\u003eIO Editor",
          "package": "yi",
          "signature": "Editor-\u003eIO Editor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMain loop\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "main",
          "package": "yi",
          "signature": "IO ()",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "Main loop",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "main",
          "normalized": "IO()",
          "package": "yi",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:main"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRefresh the UI with the given state\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "refresh",
          "package": "yi",
          "signature": "Editor -\u003e IO ()",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "Refresh the UI with the given state",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "refresh",
          "normalized": "Editor-\u003eIO()",
          "package": "yi",
          "signature": "Editor-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:refresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReload cabal project views\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "reloadProject",
          "package": "yi",
          "signature": "FilePath -\u003e IO ()",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "Reload cabal project views",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "reloadProject",
          "normalized": "FilePath-\u003eIO()",
          "package": "yi",
          "partial": "Project",
          "signature": "FilePath-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:reloadProject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSuspend (or minimize) the program\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "suspend",
          "package": "yi",
          "signature": "IO ()",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "Suspend or minimize the program",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "suspend",
          "normalized": "IO()",
          "package": "yi",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:suspend"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUser force-refresh (in case the screen has been messed up from outside)\n\u003c/p\u003e",
          "module": "Yi.UI.Common",
          "name": "userForceRefresh",
          "package": "yi",
          "signature": "IO ()",
          "source": "src/Yi-UI-Common.html#UI",
          "type": "function"
        },
        "index": {
          "description": "User force-refresh in case the screen has been messed up from outside",
          "hierarchy": "Yi UI Common",
          "module": "Yi.UI.Common",
          "name": "userForceRefresh",
          "normalized": "IO()",
          "package": "yi",
          "partial": "Force Refresh",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Common.html#v:userForceRefresh"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "TabBar",
          "package": "yi",
          "source": "src/Yi-UI-TabBar.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "TabBar",
          "package": "yi",
          "partial": "Tab Bar",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "TabBarDescr",
          "package": "yi",
          "source": "src/Yi-UI-TabBar.html#TabBarDescr",
          "type": "type"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "TabBarDescr",
          "package": "yi",
          "partial": "Tab Bar Descr",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#t:TabBarDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA TabDescr describes the properties of a UI tab independent of the particular GUI in use. \n\u003c/p\u003e",
          "module": "Yi.UI.TabBar",
          "name": "TabDescr",
          "package": "yi",
          "source": "src/Yi-UI-TabBar.html#TabDescr",
          "type": "data"
        },
        "index": {
          "description": "TabDescr describes the properties of UI tab independent of the particular GUI in use",
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "TabDescr",
          "package": "yi",
          "partial": "Tab Descr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#t:TabDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "TabDescr",
          "package": "yi",
          "signature": "TabDescr",
          "source": "src/Yi-UI-TabBar.html#TabDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "TabDescr",
          "package": "yi",
          "partial": "Tab Descr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#v:TabDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "tabAbbrevTitle",
          "package": "yi",
          "signature": "String -\u003e String",
          "source": "src/Yi-UI-TabBar.html#tabAbbrevTitle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "tabAbbrevTitle",
          "normalized": "String-\u003eString",
          "package": "yi",
          "partial": "Abbrev Title",
          "signature": "String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#v:tabAbbrevTitle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "tabBarDescr",
          "package": "yi",
          "signature": "Editor -\u003e TabBarDescr",
          "source": "src/Yi-UI-TabBar.html#tabBarDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "tabBarDescr",
          "normalized": "Editor-\u003eTabBarDescr",
          "package": "yi",
          "partial": "Bar Descr",
          "signature": "Editor-\u003eTabBarDescr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#v:tabBarDescr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "tabInFocus",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-UI-TabBar.html#TabDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "tabInFocus",
          "package": "yi",
          "partial": "In Focus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#v:tabInFocus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.TabBar",
          "name": "tabText",
          "package": "yi",
          "signature": "String",
          "source": "src/Yi-UI-TabBar.html#TabDescr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI TabBar",
          "module": "Yi.UI.TabBar",
          "name": "tabText",
          "package": "yi",
          "partial": "Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-TabBar.html#v:tabText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUtilities shared by various UIs\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.UI.Utils",
          "name": "Utils",
          "package": "yi",
          "source": "src/Yi-UI-Utils.html",
          "type": "module"
        },
        "index": {
          "description": "Utilities shared by various UIs",
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "Utils",
          "package": "yi",
          "partial": "Utils",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Utils",
          "name": "applyHeights",
          "package": "yi",
          "signature": "[Int] -\u003e t Window -\u003e t Window",
          "source": "src/Yi-UI-Utils.html#applyHeights",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "applyHeights",
          "normalized": "[Int]-\u003ea Window-\u003ea Window",
          "package": "yi",
          "partial": "Heights",
          "signature": "[Int]-\u003et Window-\u003et Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:applyHeights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrange a list of items in columns over maximum \u003ccode\u003emaxNumberOfLines\u003c/code\u003e lines\n\u003c/p\u003e",
          "module": "Yi.UI.Utils",
          "name": "arrangeItems",
          "package": "yi",
          "signature": "[String] -\u003e Int -\u003e Int -\u003e [String]",
          "source": "src/Yi-UI-Utils.html#arrangeItems",
          "type": "function"
        },
        "index": {
          "description": "Arrange list of items in columns over maximum maxNumberOfLines lines",
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "arrangeItems",
          "normalized": "[String]-\u003eInt-\u003eInt-\u003e[String]",
          "package": "yi",
          "partial": "Items",
          "signature": "[String]-\u003eInt-\u003eInt-\u003e[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:arrangeItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eArrange a list of items in columns over \u003ccode\u003enumberOfLines\u003c/code\u003e lines.\n\u003c/p\u003e",
          "module": "Yi.UI.Utils",
          "name": "arrangeItems'",
          "package": "yi",
          "signature": "[String] -\u003e Int -\u003e Int -\u003e (Int, [String])",
          "source": "src/Yi-UI-Utils.html#arrangeItems%27",
          "type": "function"
        },
        "index": {
          "description": "Arrange list of items in columns over numberOfLines lines",
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "arrangeItems'",
          "normalized": "[String]-\u003eInt-\u003eInt-\u003e(Int,[String])",
          "package": "yi",
          "partial": "Items'",
          "signature": "[String]-\u003eInt-\u003eInt-\u003e(Int,[String])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:arrangeItems-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Utils",
          "name": "attributesPictureAndSelB",
          "package": "yi",
          "signature": "UIStyle -\u003e Maybe SearchExp -\u003e Region -\u003e BufferM [(Point, Attributes)]",
          "source": "src/Yi-UI-Utils.html#attributesPictureAndSelB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "attributesPictureAndSelB",
          "normalized": "UIStyle-\u003eMaybe SearchExp-\u003eRegion-\u003eBufferM[(Point,Attributes)]",
          "package": "yi",
          "partial": "Picture And Sel",
          "signature": "UIStyle-\u003eMaybe SearchExp-\u003eRegion-\u003eBufferM[(Point,Attributes)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:attributesPictureAndSelB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Utils",
          "name": "attributesPictureB",
          "package": "yi",
          "signature": "UIStyle -\u003e Maybe SearchExp -\u003e Region -\u003e [[Span StyleName]] -\u003e BufferM [(Point, Attributes)]",
          "source": "src/Yi-UI-Utils.html#attributesPictureB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "attributesPictureB",
          "normalized": "UIStyle-\u003eMaybe SearchExp-\u003eRegion-\u003e[[Span StyleName]]-\u003eBufferM[(Point,Attributes)]",
          "package": "yi",
          "partial": "Picture",
          "signature": "UIStyle-\u003eMaybe SearchExp-\u003eRegion-\u003e[[Span StyleName]]-\u003eBufferM[(Point,Attributes)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:attributesPictureB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Utils",
          "name": "indexedAnnotatedStreamB",
          "package": "yi",
          "signature": "Point -\u003e BufferM [(Point, Char)]",
          "source": "src/Yi-UI-Utils.html#indexedAnnotatedStreamB",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "indexedAnnotatedStreamB",
          "normalized": "Point-\u003eBufferM[(Point,Char)]",
          "package": "yi",
          "partial": "Annotated Stream",
          "signature": "Point-\u003eBufferM[(Point,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:indexedAnnotatedStreamB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Utils",
          "name": "paintPicture",
          "package": "yi",
          "signature": "a -\u003e [[Span (Endo a)]] -\u003e [(Point, a)]",
          "source": "src/Yi-UI-Utils.html#paintPicture",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "paintPicture",
          "normalized": "a-\u003e[[Span(Endo a)]]-\u003e[(Point,a)]",
          "package": "yi",
          "partial": "Picture",
          "signature": "a-\u003e[[Span(Endo a)]]-\u003e[(Point,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:paintPicture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePaint the given stroke-picture on top of an existing picture\n\u003c/p\u003e",
          "module": "Yi.UI.Utils",
          "name": "paintStrokes",
          "package": "yi",
          "signature": "(a -\u003e a) -\u003e a -\u003e [(Point, a -\u003e a)] -\u003e [(Point, a)] -\u003e [(Point, a)]",
          "source": "src/Yi-UI-Utils.html#paintStrokes",
          "type": "function"
        },
        "index": {
          "description": "Paint the given stroke-picture on top of an existing picture",
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "paintStrokes",
          "normalized": "(a-\u003ea)-\u003ea-\u003e[(Point,a-\u003ea)]-\u003e[(Point,a)]-\u003e[(Point,a)]",
          "package": "yi",
          "partial": "Strokes",
          "signature": "(a-\u003ea)-\u003ea-\u003e[(Point,a-\u003ea)]-\u003e[(Point,a)]-\u003e[(Point,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:paintStrokes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.UI.Utils",
          "name": "spliceAnnots",
          "package": "yi",
          "signature": "[(Point, Char)] -\u003e [Span String] -\u003e [(Point, Char)]",
          "source": "src/Yi-UI-Utils.html#spliceAnnots",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "spliceAnnots",
          "normalized": "[(Point,Char)]-\u003e[Span String]-\u003e[(Point,Char)]",
          "package": "yi",
          "partial": "Annots",
          "signature": "[(Point,Char)]-\u003e[Span String]-\u003e[(Point,Char)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:spliceAnnots"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTurn a sequence of (from,style,to) strokes into a sequence\n   of picture points (from,style), taking special care to\n   ensure that the points are strictly increasing and introducing\n   padding segments where neccessary.\n   Precondition: Strokes are ordered and not overlapping.\n\u003c/p\u003e",
          "module": "Yi.UI.Utils",
          "name": "strokePicture",
          "package": "yi",
          "signature": "[Span (Endo a)] -\u003e [(Point, a -\u003e a)]",
          "source": "src/Yi-UI-Utils.html#strokePicture",
          "type": "function"
        },
        "index": {
          "description": "Turn sequence of from style to strokes into sequence of picture points from style taking special care to ensure that the points are strictly increasing and introducing padding segments where neccessary Precondition Strokes are ordered and not overlapping",
          "hierarchy": "Yi UI Utils",
          "module": "Yi.UI.Utils",
          "name": "strokePicture",
          "normalized": "[Span(Endo a)]-\u003e[(Point,a-\u003ea)]",
          "package": "yi",
          "partial": "Picture",
          "signature": "[Span(Endo a)]-\u003e[(Point,a-\u003ea)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Utils.html#v:strokePicture"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines a user interface implemented using vty.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi.UI.Vty",
          "name": "Vty",
          "package": "yi",
          "source": "src/Yi-UI-Vty.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines user interface implemented using vty",
          "hierarchy": "Yi UI Vty",
          "module": "Yi.UI.Vty",
          "name": "Vty",
          "package": "yi",
          "partial": "Vty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Vty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialise the ui\n\u003c/p\u003e",
          "module": "Yi.UI.Vty",
          "name": "start",
          "package": "yi",
          "signature": "UIBoot",
          "source": "src/Yi-UI-Vty.html#start",
          "type": "function"
        },
        "index": {
          "description": "Initialise the ui",
          "hierarchy": "Yi UI Vty",
          "module": "Yi.UI.Vty",
          "name": "start",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-UI-Vty.html#v:start"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "source": "src/Yi-Verifier-JavaScript.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "JavaScript",
          "package": "yi",
          "partial": "Java Script",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "Error",
          "package": "yi",
          "source": "src/Yi-Verifier-JavaScript.html#Error",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "Error",
          "package": "yi",
          "partial": "Error",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#t:Error"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "Report",
          "package": "yi",
          "source": "src/Yi-Verifier-JavaScript.html#Report",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "Report",
          "package": "yi",
          "partial": "Report",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#t:Report"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "Warning",
          "package": "yi",
          "source": "src/Yi-Verifier-JavaScript.html#Warning",
          "type": "data"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "Warning",
          "package": "yi",
          "partial": "Warning",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#t:Warning"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "Err",
          "package": "yi",
          "signature": "Err Error",
          "source": "src/Yi-Verifier-JavaScript.html#Report",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "Err",
          "package": "yi",
          "partial": "Err",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:Err"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "MultipleFunctionDeclaration",
          "package": "yi",
          "signature": "MultipleFunctionDeclaration String [Posn]",
          "source": "src/Yi-Verifier-JavaScript.html#Error",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "MultipleFunctionDeclaration",
          "normalized": "MultipleFunctionDeclaration String[Posn]",
          "package": "yi",
          "partial": "Multiple Function Declaration",
          "signature": "MultipleFunctionDeclaration String[Posn]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:MultipleFunctionDeclaration"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "UnreachableCode",
          "package": "yi",
          "signature": "UnreachableCode Posn",
          "source": "src/Yi-Verifier-JavaScript.html#Warning",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "UnreachableCode",
          "package": "yi",
          "partial": "Unreachable Code",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:UnreachableCode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "Warn",
          "package": "yi",
          "signature": "Warn Warning",
          "source": "src/Yi-Verifier-JavaScript.html#Report",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "Warn",
          "package": "yi",
          "partial": "Warn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:Warn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a list of function declarations, checks for multiple function\n   declarations, including the functions' subfunctions.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "checkMultipleFuns",
          "package": "yi",
          "signature": "[Statement TT] -\u003e Writer (DList Report) ()",
          "source": "src/Yi-Verifier-JavaScript.html#checkMultipleFuns",
          "type": "function"
        },
        "index": {
          "description": "Given list of function declarations checks for multiple function declarations including the functions subfunctions",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "checkMultipleFuns",
          "normalized": "[Statement TT]-\u003eWriter(DList Report)()",
          "package": "yi",
          "partial": "Multiple Funs",
          "signature": "[Statement TT]-\u003eWriter(DList Report)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:checkMultipleFuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "checkUnreachable",
          "package": "yi",
          "signature": "[Statement TT] -\u003e Writer (DList Report) ()",
          "source": "src/Yi-Verifier-JavaScript.html#checkUnreachable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "checkUnreachable",
          "normalized": "[Statement TT]-\u003eWriter(DList Report)()",
          "package": "yi",
          "partial": "Unreachable",
          "signature": "[Statement TT]-\u003eWriter(DList Report)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:checkUnreachable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003edropWhile\u003c/a\u003e\u003c/code\u003e but drops the first element in the result.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "dropWhile'",
          "package": "yi",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Yi-Verifier-JavaScript.html#dropWhile%27",
          "type": "function"
        },
        "index": {
          "description": "Like dropWhile but drops the first element in the result",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "dropWhile'",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "yi",
          "partial": "While'",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:dropWhile-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "dupsBy",
          "package": "yi",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "source": "src/Yi-Verifier-JavaScript.html#dupsBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "dupsBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "yi",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:dupsBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a list of the functions in the given block.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "findFunctions",
          "package": "yi",
          "signature": "[Statement t] -\u003e [Statement t]",
          "source": "src/Yi-Verifier-JavaScript.html#findFunctions",
          "type": "function"
        },
        "index": {
          "description": "Returns list of the functions in the given block",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "findFunctions",
          "normalized": "[Statement a]-\u003e[Statement a]",
          "package": "yi",
          "partial": "Functions",
          "signature": "[Statement t]-\u003e[Statement t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:findFunctions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eFunDecl\u003c/a\u003e\u003c/code\u003e, returns its inner body as a list.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "funBody",
          "package": "yi",
          "signature": "Statement t -\u003e [Statement t]",
          "source": "src/Yi-Verifier-JavaScript.html#funBody",
          "type": "function"
        },
        "index": {
          "description": "Given FunDecl returns its inner body as list",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "funBody",
          "normalized": "Statement a-\u003e[Statement a]",
          "package": "yi",
          "partial": "Body",
          "signature": "Statement t-\u003e[Statement t]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:funBody"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003e\u003ca\u003eFunDecl\u003c/a\u003e\u003c/code\u003e, returns the token representing the name.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "funName",
          "package": "yi",
          "signature": "Statement t -\u003e t",
          "source": "src/Yi-Verifier-JavaScript.html#funName",
          "type": "function"
        },
        "index": {
          "description": "Given FunDecl returns the token representing the name",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "funName",
          "normalized": "Statement a-\u003ea",
          "package": "yi",
          "partial": "Name",
          "signature": "Statement t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:funName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "isReturn",
          "package": "yi",
          "signature": "Statement t -\u003e Bool",
          "source": "src/Yi-Verifier-JavaScript.html#isReturn",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "isReturn",
          "normalized": "Statement a-\u003eBool",
          "package": "yi",
          "partial": "Return",
          "signature": "Statement t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:isReturn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven a \u003ccode\u003eValidName\u003c/code\u003e returns the string representing the name.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "nameOf",
          "package": "yi",
          "signature": "Token -\u003e String",
          "source": "src/Yi-Verifier-JavaScript.html#nameOf",
          "type": "function"
        },
        "index": {
          "description": "Given ValidName returns the string representing the name",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "nameOf",
          "normalized": "Token-\u003eString",
          "package": "yi",
          "partial": "Of",
          "signature": "Token-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:nameOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Verifier.JavaScript",
          "name": "say",
          "package": "yi",
          "signature": "a -\u003e m ()",
          "source": "src/Yi-Verifier-JavaScript.html#say",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "say",
          "normalized": "a-\u003eb()",
          "package": "yi",
          "signature": "a-\u003em()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:say"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGiven two \u003ccode\u003eTok t\u003c/code\u003e, compares the \u003ccode\u003et\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "ttEq",
          "package": "yi",
          "signature": "Tok t -\u003e Tok t -\u003e Bool",
          "source": "src/Yi-Verifier-JavaScript.html#ttEq",
          "type": "function"
        },
        "index": {
          "description": "Given two Tok compares the",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "ttEq",
          "normalized": "Tok a-\u003eTok a-\u003eBool",
          "package": "yi",
          "partial": "Eq",
          "signature": "Tok t-\u003eTok t-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:ttEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe main verifier which calls the sub-verifiers.\n\u003c/p\u003e",
          "module": "Yi.Verifier.JavaScript",
          "name": "verify",
          "package": "yi",
          "signature": "Tree TT -\u003e Writer (DList Report) ()",
          "source": "src/Yi-Verifier-JavaScript.html#verify",
          "type": "function"
        },
        "index": {
          "description": "The main verifier which calls the sub-verifiers",
          "hierarchy": "Yi Verifier JavaScript",
          "module": "Yi.Verifier.JavaScript",
          "name": "verify",
          "normalized": "Tree TT-\u003eWriter(DList Report)()",
          "package": "yi",
          "signature": "Tree TT-\u003eWriter(DList Report)()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Verifier-JavaScript.html#v:verify"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Window",
          "name": "Window",
          "package": "yi",
          "source": "src/Yi-Window.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "Window",
          "package": "yi",
          "partial": "Window",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA window onto a buffer.\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "Window",
          "package": "yi",
          "source": "src/Yi-Window.html#Window",
          "type": "data"
        },
        "index": {
          "description": "window onto buffer",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "Window",
          "package": "yi",
          "partial": "Window",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#t:Window"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Window",
          "name": "Window",
          "package": "yi",
          "signature": "Window",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "Window",
          "package": "yi",
          "partial": "Window",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:Window"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe actual number of buffer lines displayed. Taking into account line wrapping\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "actualLines",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "The actual number of buffer lines displayed Taking into account line wrapping",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "actualLines",
          "package": "yi",
          "partial": "Lines",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:actualLines"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist of last accessed buffers (former bufKeys).\n Last accessed one is first element\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "bufAccessList",
          "package": "yi",
          "signature": "[BufferRef]",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "list of last accessed buffers former bufKeys Last accessed one is first element",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "bufAccessList",
          "normalized": "[BufferRef]",
          "package": "yi",
          "partial": "Access List",
          "signature": "[BufferRef]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:bufAccessList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe buffer this window opens to\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "bufkey",
          "package": "yi",
          "signature": "BufferRef",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "the buffer this window opens to",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "bufkey",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:bufkey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a \u003ca\u003efake\u003c/a\u003e window onto a buffer.\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "dummyWindow",
          "package": "yi",
          "signature": "BufferRef -\u003e Window",
          "source": "src/Yi-Window.html#dummyWindow",
          "type": "function"
        },
        "index": {
          "description": "Return fake window onto buffer",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "dummyWindow",
          "normalized": "BufferRef-\u003eWindow",
          "package": "yi",
          "partial": "Window",
          "signature": "BufferRef-\u003eWindow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:dummyWindow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eheight of the window (in number of screen lines displayed)\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "height",
          "package": "yi",
          "signature": "Int",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "height of the window in number of screen lines displayed",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "height",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:height"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eregular or mini window?\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "isMini",
          "package": "yi",
          "signature": "Bool",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "regular or mini window",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "isMini",
          "package": "yi",
          "partial": "Mini",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:isMini"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi.Window",
          "name": "jumpList",
          "package": "yi",
          "signature": "JumpList",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "jumpList",
          "package": "yi",
          "partial": "List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:jumpList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eview area.\n note that the top point is also available as a buffer mark.\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "winRegion",
          "package": "yi",
          "signature": "Region",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "view area note that the top point is also available as buffer mark",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "winRegion",
          "package": "yi",
          "partial": "Region",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:winRegion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the identification of a window.\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "winkey",
          "package": "yi",
          "signature": "Window -\u003e (Bool, BufferRef)",
          "source": "src/Yi-Window.html#winkey",
          "type": "function"
        },
        "index": {
          "description": "Get the identification of window",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "winkey",
          "normalized": "Window-\u003e(Bool,BufferRef)",
          "package": "yi",
          "signature": "Window-\u003e(Bool,BufferRef)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:winkey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eidentifier for the window (for UI sync)\n This is required for accurate scrolling.\n Scrolling depends on the actual number of buffer\n lines displayed. Line wrapping changes that number\n relative to the height so we can't use height for that\n purpose.\n\u003c/p\u003e",
          "module": "Yi.Window",
          "name": "wkey",
          "package": "yi",
          "signature": "WindowRef",
          "source": "src/Yi-Window.html#Window",
          "type": "function"
        },
        "index": {
          "description": "identifier for the window for UI sync This is required for accurate scrolling Scrolling depends on the actual number of buffer lines displayed Line wrapping changes that number relative to the height so we can use height for that purpose",
          "hierarchy": "Yi Window",
          "module": "Yi.Window",
          "name": "wkey",
          "package": "yi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi-Window.html#v:wkey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFacade of the Yi library, for use by confguration file. Just re-exports\n a bunch of modules.\n\u003c/p\u003e\u003cp\u003eYou should therefore:\n      import Yi\n in your ~\u003cem\u003e.config\u003c/em\u003eyi/ scripts\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Yi",
          "name": "Yi",
          "package": "yi",
          "source": "src/Yi.html",
          "type": "module"
        },
        "index": {
          "description": "Facade of the Yi library for use by confguration file Just re-exports bunch of modules You should therefore import Yi in your config yi scripts",
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "Yi",
          "package": "yi",
          "partial": "Yi",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA prototype. Typically the parameter will be a record type.\n Fields can be defined in terms of others fields, with the\n idea that some of these definitons can be overridden.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e data O = O {f1, f2, f3 :: Int}\n     deriving Show\n o1 = Proto $ \\self -\u003e O\n   {\n    f1 = 1,\n    f2 = f1 self + 1,  -- 'f1 self' refers to the overriden definition of f1.\n    f3 = f1 self + 2\n   }\n\u003c/pre\u003e",
          "module": "Yi",
          "name": "Proto",
          "package": "yi",
          "source": "src/Data-Prototype.html#Proto",
          "type": "newtype"
        },
        "index": {
          "description": "prototype Typically the parameter will be record type Fields can be defined in terms of others fields with the idea that some of these definitons can be overridden Example data f1 f2 f3 Int deriving Show o1 Proto self f1 f2 f1 self f1 self refers to the overriden definition of f1 f3 f1 self",
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "Proto",
          "package": "yi",
          "partial": "Proto",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#t:Proto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eField access\n\u003c/p\u003e",
          "module": "Yi",
          "name": "(.-\u003e)",
          "package": "yi",
          "signature": "forall t a.  Proto t -\u003e (t -\u003e a) -\u003e a",
          "source": "src/Data-Prototype.html#.-%3E",
          "type": "function"
        },
        "index": {
          "description": "Field access",
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "(.-\u003e) .-\u003e",
          "normalized": "a b c Proto b-\u003e(b-\u003ed)-\u003ed",
          "package": "yi",
          "signature": "forall t a. Proto t-\u003e(t-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#v:.-45--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi",
          "name": "Proto",
          "package": "yi",
          "signature": "Proto",
          "source": "src/Data-Prototype.html#Proto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "Proto",
          "package": "yi",
          "partial": "Proto",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#v:Proto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the value of a prototype.\n This can return bottom in case some fields are recursively defined in terms of each other.\n\u003c/p\u003e",
          "module": "Yi",
          "name": "extractValue",
          "package": "yi",
          "signature": "Proto t -\u003e t",
          "source": "src/Data-Prototype.html#extractValue",
          "type": "function"
        },
        "index": {
          "description": "Get the value of prototype This can return bottom in case some fields are recursively defined in terms of each other",
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "extractValue",
          "normalized": "Proto a-\u003ea",
          "package": "yi",
          "partial": "Value",
          "signature": "Proto t-\u003et",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#v:extractValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Yi",
          "name": "fromProto",
          "package": "yi",
          "signature": "a -\u003e a",
          "source": "src/Data-Prototype.html#Proto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "fromProto",
          "normalized": "a-\u003ea",
          "package": "yi",
          "partial": "Proto",
          "signature": "a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#v:fromProto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOverride a prototype. Fields can be defined in terms of their definition in the base prototype.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e o2 = o1 `override` \\super self -\u003e super \n    {\n    f1 = f1 super + 10,\n    f3 = f3 super + 1\n    }\n\u003c/pre\u003e",
          "module": "Yi",
          "name": "override",
          "package": "yi",
          "signature": "Proto a -\u003e (a -\u003e a -\u003e a) -\u003e Proto a",
          "source": "src/Data-Prototype.html#override",
          "type": "function"
        },
        "index": {
          "description": "Override prototype Fields can be defined in terms of their definition in the base prototype Example o2 o1 override super self super f1 f1 super f3 f3 super",
          "hierarchy": "Yi",
          "module": "Yi",
          "name": "override",
          "normalized": "Proto a-\u003e(a-\u003ea-\u003ea)-\u003eProto a",
          "package": "yi",
          "signature": "Proto a-\u003e(a-\u003ea-\u003ea)-\u003eProto a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/yi/docs/Yi.html#v:override"
      }
    }
  ]
]