[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "frisby"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eUnicode character parsers. The character classification is identical to the\n classification in the \u003ca\u003eData.Char\u003c/a\u003e module.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "Char",
          "package": "frisby",
          "source": "src/Text-Parsers-Frisby-Char.html",
          "type": "module"
        },
        "index": {
          "description": "Unicode character parsers The character classification is identical to the classification in the Data.Char module",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "Char",
          "package": "frisby",
          "partial": "Char",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an alphabetic Unicode character. Equivalent to \u003ccode\u003e\u003ca\u003eletter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "alpha",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#alpha",
          "type": "function"
        },
        "index": {
          "description": "Match an alphabetic Unicode character Equivalent to letter",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "alpha",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:alpha"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an alphabetic or numeric digit Unicode character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "alphaNum",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#alphaNum",
          "type": "function"
        },
        "index": {
          "description": "Match an alphabetic or numeric digit Unicode character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "alphaNum",
          "package": "frisby",
          "partial": "Num",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:alphaNum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a character of the ASCII character set.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "ascii",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#ascii",
          "type": "function"
        },
        "index": {
          "description": "Match character of the ASCII character set",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "ascii",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:ascii"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an ASCII lower-case letter.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "asciiLower",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#asciiLower",
          "type": "function"
        },
        "index": {
          "description": "Match an ASCII lower-case letter",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "asciiLower",
          "package": "frisby",
          "partial": "Lower",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:asciiLower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an ASCII upper-case letter.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "asciiUpper",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#asciiUpper",
          "type": "function"
        },
        "index": {
          "description": "Match an ASCII upper-case letter",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "asciiUpper",
          "package": "frisby",
          "partial": "Upper",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:asciiUpper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a control character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "control",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#control",
          "type": "function"
        },
        "index": {
          "description": "Match control character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "control",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:control"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an ASCII digit.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "digit",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#digit",
          "type": "function"
        },
        "index": {
          "description": "Match an ASCII digit",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "digit",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:digit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an ASCII hexadecimal digit.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "hexDigit",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#hexDigit",
          "type": "function"
        },
        "index": {
          "description": "Match an ASCII hexadecimal digit",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "hexDigit",
          "package": "frisby",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:hexDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a character of the ISO 8859-1 (Latin-1) character set.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "latin1",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#latin1",
          "type": "function"
        },
        "index": {
          "description": "Match character of the ISO Latin-1 character set",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "latin1",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:latin1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an alphabetic Unicode character. Equivalent to \u003ccode\u003e\u003ca\u003ealpha\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "letter",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#letter",
          "type": "function"
        },
        "index": {
          "description": "Match an alphabetic Unicode character Equivalent to alpha",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "letter",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:letter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a lower-case alphabetic Unicode character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "lower",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#lower",
          "type": "function"
        },
        "index": {
          "description": "Match lower-case alphabetic Unicode character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "lower",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:lower"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a Unicode mark character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "mark",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#mark",
          "type": "function"
        },
        "index": {
          "description": "Match Unicode mark character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "mark",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:mark"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a Unicode numeric character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "number",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#number",
          "type": "function"
        },
        "index": {
          "description": "Match Unicode numeric character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "number",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:number"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an ASCII octal digit.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "octDigit",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#octDigit",
          "type": "function"
        },
        "index": {
          "description": "Match an ASCII octal digit",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "octDigit",
          "package": "frisby",
          "partial": "Digit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:octDigit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a printable Unicode character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "printable",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#printable",
          "type": "function"
        },
        "index": {
          "description": "Match printable Unicode character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "printable",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:printable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a Unicode punctuation character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "punctuation",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#punctuation",
          "type": "function"
        },
        "index": {
          "description": "Match Unicode punctuation character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "punctuation",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:punctuation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a Unicode space or separator character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "separator",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#separator",
          "type": "function"
        },
        "index": {
          "description": "Match Unicode space or separator character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "separator",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:separator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a white-space character in the Latin-1 range.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "space",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#space",
          "type": "function"
        },
        "index": {
          "description": "Match white-space character in the Latin-1 range",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "space",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:space"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a Unicode symbol character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "symbol",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#symbol",
          "type": "function"
        },
        "index": {
          "description": "Match Unicode symbol character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "symbol",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch an upper-case or title-case alphabetic Unicode character.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby.Char",
          "name": "upper",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby-Char.html#upper",
          "type": "function"
        },
        "index": {
          "description": "Match an upper-case or title-case alphabetic Unicode character",
          "hierarchy": "Text Parsers Frisby Char",
          "module": "Text.Parsers.Frisby.Char",
          "name": "upper",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby-Char.html#v:upper"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLinear time composable parser for PEG grammars.\n\u003c/p\u003e\u003cp\u003efrisby is a parser library that can parse arbitrary PEG grammars in linear\n time. Unlike other parsers of PEG grammars, frisby need not be supplied with\n all possible rules up front, allowing composition of smaller parsers.\n\u003c/p\u003e\u003cp\u003ePEG parsers are never ambiguous and allow infinite lookahead with no\n backtracking penalty. Since PEG parsers can look ahead arbitrarily, they can\n easily express rules such as the maximal munch rule used in lexers, meaning\n no separate lexer is needed.\n\u003c/p\u003e\u003cp\u003eIn addition to many standard combinators, frisby provides routines to\n translate standard regex syntax into frisby parsers.\n\u003c/p\u003e\u003cp\u003ePEG based parsers have a number of advantages over other parsing strategies:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e PEG parsers are never ambiguous\n\u003c/li\u003e\u003cli\u003e PEG is a generalization of regexes, they can be though of as extended regexes with recursion, predicates, and ordered choice\n\u003c/li\u003e\u003cli\u003e you never need a separate lexing pass with PEG parsers, since you have arbitrary lookahead there is no need to break the stream into tokens to allow the limited LALR or LL lookahead to work.\n\u003c/li\u003e\u003cli\u003e things like the maximal munch and minimal munch rules are trivial to specify with PEGs, yet tricky with other parsers\n\u003c/li\u003e\u003cli\u003e since you have ordered choice, things like the if then else ambiguity are nonexistent.\n\u003c/li\u003e\u003cli\u003e parsers are very very fast, guaranteeing time linear in the size of the input, at the cost of greater memory consumption\n\u003c/li\u003e\u003cli\u003e the ability to make local choices about whether to accept something lets you write parsers that deal gracefully with errors very easy to write, no more uninformative \u003ca\u003eparse error\u003c/a\u003e messages\n\u003c/li\u003e\u003cli\u003e PEG parsers can be fully lazy, only as much of the input is read as is needed to satisfy the demand on the output, and once the output has been processed, the memory is immediately reclaimed since a PEG parser never \u003ccode\u003ebacktracks\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e PEG parsers can deal with infinite input, acting in a streaming manner\n\u003c/li\u003e\u003cli\u003e PEG parsers support predicates, letting you decide what rules to follow based on whether other rules apply, so you can have rules that match only if another rule does not match, or a rule that matches only if two other rules both match the same input.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTraditionally, PEG parsers have suffered from two major flaws:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e A global table of all productions must be generated or written by hand, disallowing composable parsers implemented as libraries and in general requiring the use of a parser generator tool like \u003ccode\u003epappy\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e Although memory consumption is linear in the size of the input, the constant factor is very large.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003efrisby attempts to address both these concerns.\n\u003c/p\u003e\u003cp\u003efrisby parsers achieve composability by having a \u003ccode\u003ecompilation\u003c/code\u003e pass,\n recursive parsers are specified using the recursive do notation \u003ccode\u003emdo\u003c/code\u003e which\n builds up a description of your parser where the recursive calls for which\n memoized entries must be made are explicit. then \u003ccode\u003e\u003ca\u003erunPeg\u003c/a\u003e\u003c/code\u003e takes this\n description and compiles it into a form that can be applied, during this\n compilation step it examines your composed parser, and collects the global\n table of rules needed for a packrat parser to work.\n\u003c/p\u003e\u003cp\u003eMemory consumption is much less of an issue on modern machines; tests show\n it is not a major concern, however frisby uses a couple of techniques\n for reducing the impact. First it attempts to create parsers that are as\n lazy as possible -- this means that no more of the file is read into memory\n than is needed, and more importantly, memory used by the parser can be\n reclaimed as you process its output.\n\u003c/p\u003e\u003cp\u003efrisby also attempts to \u003ccode\u003eoptimize\u003c/code\u003e your parser, using specialized strategies\n when allowed to reduce the number of entries in your memoization tables.\n\u003c/p\u003e\u003cp\u003efrisby attempts to be lazy in reading the results of parsers, parsers tend\n to work via sending out 'feeler' predicates to get an idea of what the\n rest of the file looks like before deciding what pass to take, frisby\n attempts to optimize these feeler predicates via extra lazyness such that\n they do not cause the actual computation of the results, but rather just\n compute enough to determine whether a predicate would have succeeded or not.\n\u003c/p\u003e\u003cp\u003e(It is interesting to note that the memory efficiency of frisby depends\n vitally on being as lazy as possible, in contrast to traditional thoughts\n when it comes to memory consumption)\n\u003c/p\u003e\u003cp\u003efrisby is a work in progress, it has a darcs repo at\n \u003ca\u003ehttp://repetae.net/repos/frisby\u003c/a\u003e which may be browsed at\n \u003ca\u003ehttp://repetae.net/dw/darcsweb.cgi?r=frisby;a=summary\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eAnd its homepage is at \u003ca\u003ehttp://repetae.net/computer/frisby\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eTo learn more about PEG parsers, see this paper\n \u003ca\u003ehttp://pdos.csail.mit.edu/~baford/packrat/popl04\u003c/a\u003e and Bryan Ford's packrat\n parsing page \u003ca\u003ehttp://pdos.csail.mit.edu/~baford/packrat/\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "Frisby",
          "package": "frisby",
          "source": "src/Text-Parsers-Frisby.html",
          "type": "module"
        },
        "index": {
          "description": "Linear time composable parser for PEG grammars frisby is parser library that can parse arbitrary PEG grammars in linear time Unlike other parsers of PEG grammars frisby need not be supplied with all possible rules up front allowing composition of smaller parsers PEG parsers are never ambiguous and allow infinite lookahead with no backtracking penalty Since PEG parsers can look ahead arbitrarily they can easily express rules such as the maximal munch rule used in lexers meaning no separate lexer is needed In addition to many standard combinators frisby provides routines to translate standard regex syntax into frisby parsers PEG based parsers have number of advantages over other parsing strategies PEG parsers are never ambiguous PEG is generalization of regexes they can be though of as extended regexes with recursion predicates and ordered choice you never need separate lexing pass with PEG parsers since you have arbitrary lookahead there is no need to break the stream into tokens to allow the limited LALR or LL lookahead to work things like the maximal munch and minimal munch rules are trivial to specify with PEGs yet tricky with other parsers since you have ordered choice things like the if then else ambiguity are nonexistent parsers are very very fast guaranteeing time linear in the size of the input at the cost of greater memory consumption the ability to make local choices about whether to accept something lets you write parsers that deal gracefully with errors very easy to write no more uninformative parse error messages PEG parsers can be fully lazy only as much of the input is read as is needed to satisfy the demand on the output and once the output has been processed the memory is immediately reclaimed since PEG parser never backtracks PEG parsers can deal with infinite input acting in streaming manner PEG parsers support predicates letting you decide what rules to follow based on whether other rules apply so you can have rules that match only if another rule does not match or rule that matches only if two other rules both match the same input Traditionally PEG parsers have suffered from two major flaws global table of all productions must be generated or written by hand disallowing composable parsers implemented as libraries and in general requiring the use of parser generator tool like pappy Although memory consumption is linear in the size of the input the constant factor is very large frisby attempts to address both these concerns frisby parsers achieve composability by having compilation pass recursive parsers are specified using the recursive do notation mdo which builds up description of your parser where the recursive calls for which memoized entries must be made are explicit then runPeg takes this description and compiles it into form that can be applied during this compilation step it examines your composed parser and collects the global table of rules needed for packrat parser to work Memory consumption is much less of an issue on modern machines tests show it is not major concern however frisby uses couple of techniques for reducing the impact First it attempts to create parsers that are as lazy as possible this means that no more of the file is read into memory than is needed and more importantly memory used by the parser can be reclaimed as you process its output frisby also attempts to optimize your parser using specialized strategies when allowed to reduce the number of entries in your memoization tables frisby attempts to be lazy in reading the results of parsers parsers tend to work via sending out feeler predicates to get an idea of what the rest of the file looks like before deciding what pass to take frisby attempts to optimize these feeler predicates via extra lazyness such that they do not cause the actual computation of the results but rather just compute enough to determine whether predicate would have succeeded or not It is interesting to note that the memory efficiency of frisby depends vitally on being as lazy as possible in contrast to traditional thoughts when it comes to memory consumption frisby is work in progress it has darcs repo at http repetae.net repos frisby which may be browsed at http repetae.net dw darcsweb.cgi frisby summary And its homepage is at http repetae.net computer frisby To learn more about PEG parsers see this paper http pdos.csail.mit.edu baford packrat popl04 and Bryan Ford packrat parsing page http pdos.csail.mit.edu baford packrat",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "Frisby",
          "package": "frisby",
          "partial": "Frisby",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Parsers.Frisby",
          "name": "P",
          "package": "frisby",
          "source": "src/Text-Parsers-Frisby.html#P",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "P",
          "package": "frisby",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#t:P"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Parsers.Frisby",
          "name": "PM",
          "package": "frisby",
          "source": "src/Text-Parsers-Frisby.html#PM",
          "type": "data"
        },
        "index": {
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "PM",
          "package": "frisby",
          "partial": "PM",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#t:PM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap a parser through a function. a fancy version of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(##)",
          "package": "frisby",
          "signature": "P s a -\u003e (a -\u003e b) -\u003e P s b",
          "source": "src/Text-Parsers-Frisby.html#%23%23",
          "type": "function"
        },
        "index": {
          "description": "Map parser through function fancy version of fmap",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(##) ##",
          "normalized": "P a b-\u003e(b-\u003ec)-\u003eP a c",
          "package": "frisby",
          "signature": "P s a-\u003e(a-\u003eb)-\u003eP s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-35--35-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse left argument and return the right argument.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(##\u003e)",
          "package": "frisby",
          "signature": "P s a -\u003e b -\u003e P s b",
          "source": "src/Text-Parsers-Frisby.html#%23%23%3E",
          "type": "function"
        },
        "index": {
          "description": "Parse left argument and return the right argument",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(##\u003e) ##\u003e",
          "normalized": "P a b-\u003ec-\u003eP a c",
          "package": "frisby",
          "signature": "P s a-\u003eb-\u003eP s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-35--35--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch first argument, then match the second, returning only the value on the right.\n\u003c/p\u003e\u003cpre\u003e x -\u003e\u003e y = x \u003c\u003e y ## snd\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(-\u003e\u003e)",
          "package": "frisby",
          "signature": "P s a -\u003e P s b -\u003e P s b",
          "source": "src/Text-Parsers-Frisby.html#-%3E%3E",
          "type": "function"
        },
        "index": {
          "description": "Match first argument then match the second returning only the value on the right snd",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(-\u003e\u003e) -\u003e\u003e",
          "normalized": "P a b-\u003eP a c-\u003eP a c",
          "package": "frisby",
          "signature": "P s a-\u003eP s b-\u003eP s b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-45--62--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered choice, try left argument, if it fails try the right one.\n This does not introduce any backtracking or penalty.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(//)",
          "package": "frisby",
          "signature": "P s a -\u003e P s a -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#%2F%2F",
          "type": "function"
        },
        "index": {
          "description": "Ordered choice try left argument if it fails try the right one This does not introduce any backtracking or penalty",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(//) //",
          "normalized": "P a b-\u003eP a b-\u003eP a b",
          "package": "frisby",
          "signature": "P s a-\u003eP s a-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-47--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOrdered choice, try left argument, if it fails then return right argument.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(//\u003e)",
          "package": "frisby",
          "signature": "P s a -\u003e a -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#%2F%2F%3E",
          "type": "function"
        },
        "index": {
          "description": "Ordered choice try left argument if it fails then return right argument",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(//\u003e) //\u003e",
          "normalized": "P a b-\u003eb-\u003eP a b",
          "package": "frisby",
          "signature": "P s a-\u003ea-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-47--47--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a pair of lists and concatenate them\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(\u003c++\u003e)",
          "package": "frisby",
          "signature": "P s [a] -\u003e P s [a] -\u003e P s [a]",
          "source": "src/Text-Parsers-Frisby.html#%3C%2B%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Match pair of lists and concatenate them",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(\u003c++\u003e) \u003c++\u003e",
          "normalized": "P a[b]-\u003eP a[b]-\u003eP a[b]",
          "package": "frisby",
          "signature": "P s[a]-\u003eP s[a]-\u003eP s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-60--43--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch first argument, then match the second, returning only the value on the left.\n\u003c/p\u003e\u003cpre\u003e x \u003c\u003c- y = x \u003c\u003e y ## fst\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(\u003c\u003c-)",
          "package": "frisby",
          "signature": "P s a -\u003e P s b -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#%3C%3C-",
          "type": "function"
        },
        "index": {
          "description": "Match first argument then match the second returning only the value on the left fst",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(\u003c\u003c-) \u003c\u003c-",
          "normalized": "P a b-\u003eP a c-\u003eP a b",
          "package": "frisby",
          "signature": "P s a-\u003eP s b-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-60--60--45-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch first argument, then match the second, returning both in a tuple\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "(\u003c\u003e)",
          "package": "frisby",
          "signature": "P s a -\u003e P s b -\u003e P s (a, b)",
          "source": "src/Text-Parsers-Frisby.html#%3C%3E",
          "type": "function"
        },
        "index": {
          "description": "Match first argument then match the second returning both in tuple",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "(\u003c\u003e) \u003c\u003e",
          "normalized": "P a b-\u003eP a c-\u003eP a(b,c)",
          "package": "frisby",
          "signature": "P s a-\u003eP s b-\u003eP s(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:-60--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch any character, fails on EOF\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "anyChar",
          "package": "frisby",
          "signature": "P s Char",
          "source": "src/Text-Parsers-Frisby.html#anyChar",
          "type": "function"
        },
        "index": {
          "description": "Match any character fails on EOF",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "anyChar",
          "package": "frisby",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:anyChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEquivalent to\n\u003c/p\u003e\u003cpre\u003e between open close thing = open -\u003e\u003e thing \u003c\u003c- close\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "between",
          "package": "frisby",
          "signature": "P s a -\u003e P s b -\u003e P s c -\u003e P s c",
          "source": "src/Text-Parsers-Frisby.html#between",
          "type": "function"
        },
        "index": {
          "description": "Equivalent to between open close thing open thing close",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "between",
          "normalized": "P a b-\u003eP a c-\u003eP a d-\u003eP a d",
          "package": "frisby",
          "signature": "P s a-\u003eP s b-\u003eP s c-\u003eP s c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:between"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eam at the beginning of the string.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "bof",
          "package": "frisby",
          "signature": "P s ()",
          "source": "src/Text-Parsers-Frisby.html#bof",
          "type": "function"
        },
        "index": {
          "description": "am at the beginning of the string",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "bof",
          "normalized": "P a()",
          "package": "frisby",
          "signature": "P s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:bof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch a specified character\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "char",
          "package": "frisby",
          "signature": "Char -\u003e P s Char",
          "source": "src/Text-Parsers-Frisby.html#char",
          "type": "function"
        },
        "index": {
          "description": "Match specified character",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "char",
          "normalized": "Char-\u003eP a Char",
          "package": "frisby",
          "signature": "Char-\u003eP s Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFirst matching parse wins, a simple iteration of (//).\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "choice",
          "package": "frisby",
          "signature": "[P s a] -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#choice",
          "type": "function"
        },
        "index": {
          "description": "First matching parse wins simple iteration of",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "choice",
          "normalized": "[P a b]-\u003eP a b",
          "package": "frisby",
          "signature": "[P s a]-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrow away the result of something.\n\u003c/p\u003e\u003cpre\u003e discard p = p -\u003e\u003e unit ()\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "discard",
          "package": "frisby",
          "signature": "P s a -\u003e P s ()",
          "source": "src/Text-Parsers-Frisby.html#discard",
          "type": "function"
        },
        "index": {
          "description": "Throw away the result of something discard unit",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "discard",
          "normalized": "P a b-\u003eP a()",
          "package": "frisby",
          "signature": "P s a-\u003eP s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:discard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceeds when the argument does not.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "doesNotMatch",
          "package": "frisby",
          "signature": "P s a -\u003e P s ()",
          "source": "src/Text-Parsers-Frisby.html#doesNotMatch",
          "type": "function"
        },
        "index": {
          "description": "Succeeds when the argument does not",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "doesNotMatch",
          "normalized": "P a b-\u003eP a()",
          "package": "frisby",
          "partial": "Not Match",
          "signature": "P s a-\u003eP s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:doesNotMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eam at the end of string.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "eof",
          "package": "frisby",
          "signature": "P s ()",
          "source": "src/Text-Parsers-Frisby.html#eof",
          "type": "function"
        },
        "index": {
          "description": "am at the end of string",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "eof",
          "normalized": "P a()",
          "package": "frisby",
          "signature": "P s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:eof"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet current position in file as number of characters since the beginning.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "getPos",
          "package": "frisby",
          "signature": "P s Int",
          "source": "src/Text-Parsers-Frisby.html#getPos",
          "type": "function"
        },
        "index": {
          "description": "Get current position in file as number of characters since the beginning",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "getPos",
          "package": "frisby",
          "partial": "Pos",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:getPos"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ealways succeeds, returning true if it consumed something.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "isMatch",
          "package": "frisby",
          "signature": "P s a -\u003e P s Bool",
          "source": "src/Text-Parsers-Frisby.html#isMatch",
          "type": "function"
        },
        "index": {
          "description": "always succeeds returning true if it consumed something",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "isMatch",
          "normalized": "P a b-\u003eP a Bool",
          "package": "frisby",
          "partial": "Match",
          "signature": "P s a-\u003eP s Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:isMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse many of something. Behaves like * in regexes.\n This eats as much as it possibly can, if you want a minimal much rule, then use \u003ccode\u003e\u003ca\u003emanyUntil\u003c/a\u003e\u003c/code\u003e which stops when a.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "many",
          "package": "frisby",
          "signature": "P s a -\u003e P s [a]",
          "source": "src/Text-Parsers-Frisby.html#many",
          "type": "function"
        },
        "index": {
          "description": "Parse many of something Behaves like in regexes This eats as much as it possibly can if you want minimal much rule then use manyUntil which stops when",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "many",
          "normalized": "P a b-\u003eP a[b]",
          "package": "frisby",
          "signature": "P s a-\u003eP s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:many"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch one or more of something via maximal munch rule.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "many1",
          "package": "frisby",
          "signature": "P s a -\u003e P s [a]",
          "source": "src/Text-Parsers-Frisby.html#many1",
          "type": "function"
        },
        "index": {
          "description": "Match one or more of something via maximal munch rule",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "many1",
          "normalized": "P a b-\u003eP a[b]",
          "package": "frisby",
          "signature": "P s a-\u003eP s[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:many1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse many of something via the minimal munch rule. behaves like *? in\n perl regexes. The final item is not consumed.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "manyUntil",
          "package": "frisby",
          "signature": "P s b -\u003e P s a -\u003e PM s (P s [a])",
          "source": "src/Text-Parsers-Frisby.html#manyUntil",
          "type": "function"
        },
        "index": {
          "description": "Parse many of something via the minimal munch rule behaves like in perl regexes The final item is not consumed",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "manyUntil",
          "normalized": "P a b-\u003eP a c-\u003ePM a(P a[c])",
          "package": "frisby",
          "partial": "Until",
          "signature": "P s b-\u003eP s a-\u003ePM s(P s[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:manyUntil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceeds when the argument does, but consumes no input.\n Equivalant to p -\u003e discard (peek p)\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "matches",
          "package": "frisby",
          "signature": "P s a -\u003e P s ()",
          "source": "src/Text-Parsers-Frisby.html#matches",
          "type": "function"
        },
        "index": {
          "description": "Succeeds when the argument does but consumes no input Equivalant to discard peek",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "matches",
          "normalized": "P a b-\u003eP a()",
          "package": "frisby",
          "signature": "P s a-\u003eP s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:matches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new regular expression matching parser. it returns something in a\n possibly failing monad to indicate an error in the regular expression itself.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "newRegex",
          "package": "frisby",
          "signature": "String -\u003e m (PM s (P s String))",
          "source": "src/Text-Parsers-Frisby.html#newRegex",
          "type": "function"
        },
        "index": {
          "description": "Create new regular expression matching parser it returns something in possibly failing monad to indicate an error in the regular expression itself",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "newRegex",
          "normalized": "String-\u003ea(PM b(P b String))",
          "package": "frisby",
          "partial": "Regex",
          "signature": "String-\u003em(PM s(P s String))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:newRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a new rule, which may be used recursively and caches its results.\n\u003c/p\u003e\u003cp\u003eThis is intended to be use in an \u003ccode\u003emdo\u003c/code\u003e block. such as the following.\n\u003c/p\u003e\u003cpre\u003e additive = mdo\n     additive \u003c- newRule $ multitive \u003c\u003e char '+' -\u003e\u003e additive ## uncurry (+) // multitive\n     multitive \u003c- newRule $ primary \u003c\u003e char '*' -\u003e\u003e multitive ## uncurry (*) // primary\n     primary \u003c- newRule $ char '(' -\u003e\u003e additive \u003c\u003c- char ')' // decimal\n     decimal \u003c- newRule $ many1 (oneOf ['0' .. '9']) ## read\n     return additive\n\u003c/pre\u003e\u003cp\u003eAll recursive calls must be bound via a rule. Left recursion should be avoided.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "newRule",
          "package": "frisby",
          "signature": "P s a -\u003e PM s (P s a)",
          "source": "src/Text-Parsers-Frisby.html#newRule",
          "type": "function"
        },
        "index": {
          "description": "Create new rule which may be used recursively and caches its results This is intended to be use in an mdo block such as the following additive mdo additive newRule multitive char additive uncurry multitive multitive newRule primary char multitive uncurry primary primary newRule char additive char decimal decimal newRule many1 oneOf read return additive All recursive calls must be bound via rule Left recursion should be avoided",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "newRule",
          "normalized": "P a b-\u003ePM a(P a b)",
          "package": "frisby",
          "partial": "Rule",
          "signature": "P s a-\u003ePM s(P s a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:newRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch any character other than the ones in the list.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "noneOf",
          "package": "frisby",
          "signature": "[Char] -\u003e P s Char",
          "source": "src/Text-Parsers-Frisby.html#noneOf",
          "type": "function"
        },
        "index": {
          "description": "Match any character other than the ones in the list",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "noneOf",
          "normalized": "[Char]-\u003eP a Char",
          "package": "frisby",
          "partial": "Of",
          "signature": "[Char]-\u003eP s Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:noneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch one of the set of characters.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "oneOf",
          "package": "frisby",
          "signature": "[Char] -\u003e P s Char",
          "source": "src/Text-Parsers-Frisby.html#oneOf",
          "type": "function"
        },
        "index": {
          "description": "Match one of the set of characters",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "oneOf",
          "normalized": "[Char]-\u003eP a Char",
          "package": "frisby",
          "partial": "Of",
          "signature": "[Char]-\u003eP s Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:oneOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSucceed only if thing parsed passes a predicate.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "onlyIf",
          "package": "frisby",
          "signature": "P s a -\u003e (a -\u003e Bool) -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#onlyIf",
          "type": "function"
        },
        "index": {
          "description": "Succeed only if thing parsed passes predicate",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "onlyIf",
          "normalized": "P a b-\u003e(b-\u003eBool)-\u003eP a b",
          "package": "frisby",
          "partial": "If",
          "signature": "P s a-\u003e(a-\u003eBool)-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:onlyIf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse something if you can, else return first value\n\u003c/p\u003e\u003cpre\u003e option a p = p // unit a\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "option",
          "package": "frisby",
          "signature": "a -\u003e P s a -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#option",
          "type": "function"
        },
        "index": {
          "description": "Parse something if you can else return first value option unit",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "option",
          "normalized": "a-\u003eP b a-\u003eP b a",
          "package": "frisby",
          "signature": "a-\u003eP s a-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse something if you can, discarding it.\n\u003c/p\u003e\u003cpre\u003e option a p = discard p // unit ()\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "optional",
          "package": "frisby",
          "signature": "P s a -\u003e P s ()",
          "source": "src/Text-Parsers-Frisby.html#optional",
          "type": "function"
        },
        "index": {
          "description": "Parse something if you can discarding it option discard unit",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "optional",
          "normalized": "P a b-\u003eP a()",
          "package": "frisby",
          "signature": "P s a-\u003eP s()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:optional"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFails, is identity of (//) and unit of (\u003c\u003e).\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "parseFailure",
          "package": "frisby",
          "signature": "P s a",
          "source": "src/Text-Parsers-Frisby.html#parseFailure",
          "type": "function"
        },
        "index": {
          "description": "Fails is identity of and unit of",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "parseFailure",
          "package": "frisby",
          "partial": "Failure",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:parseFailure"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse something and return it,  but do not advance the input stream.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "peek",
          "package": "frisby",
          "signature": "P s a -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#peek",
          "type": "function"
        },
        "index": {
          "description": "Parse something and return it but do not advance the input stream",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "peek",
          "normalized": "P a b-\u003eP a b",
          "package": "frisby",
          "signature": "P s a-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:peek"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake a new regex but abort on an error in the regex string itself.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "regex",
          "package": "frisby",
          "signature": "String -\u003e PM s (P s String)",
          "source": "src/Text-Parsers-Frisby.html#regex",
          "type": "function"
        },
        "index": {
          "description": "Make new regex but abort on an error in the regex string itself",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "regex",
          "normalized": "String-\u003ePM a(P a String)",
          "package": "frisby",
          "signature": "String-\u003ePM s(P s String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:regex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImmediately consume and return the rest of the input\n equivalent to (many anyChar), but more efficient.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "rest",
          "package": "frisby",
          "signature": "P s String",
          "source": "src/Text-Parsers-Frisby.html#rest",
          "type": "function"
        },
        "index": {
          "description": "Immediately consume and return the rest of the input equivalent to many anyChar but more efficient",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "rest",
          "package": "frisby",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:rest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRun a PEG grammar. Takes the rank-2 argument in order to ensure a rule\n created in one PM session isn't returned and used in another PEG parser.\n\u003c/p\u003e\u003cp\u003eThere is no need for special error handling, as it can be trivially implemented via\n\u003c/p\u003e\u003cpre\u003e  -- parse complete file, returning 'Nothing' if parse fails\n  fmap Just (myParser \u003c\u003c- eof) // unit Nothing\n\u003c/pre\u003e\u003cp\u003eThere is also no need for the parser to return its unused input, as that can be retrieved via \u003ccode\u003e\u003ca\u003erest\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e -- Now this returns (a,String) where String is the unconsumed input.\n myParser \u003c\u003e rest\n\u003c/pre\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "runPeg",
          "package": "frisby",
          "signature": "(forall s.  PM s (P s a)) -\u003e String -\u003e a",
          "source": "src/Text-Parsers-Frisby.html#runPeg",
          "type": "function"
        },
        "index": {
          "description": "Run PEG grammar Takes the rank-2 argument in order to ensure rule created in one PM session isn returned and used in another PEG parser There is no need for special error handling as it can be trivially implemented via parse complete file returning Nothing if parse fails fmap Just myParser eof unit Nothing There is also no need for the parser to return its unused input as that can be retrieved via rest Now this returns String where String is the unconsumed input myParser rest",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "runPeg",
          "normalized": "(a b PM c(P c d))-\u003eString-\u003ed",
          "package": "frisby",
          "partial": "Peg",
          "signature": "(forall s. PM s(P s a))-\u003eString-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:runPeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShow a representation of the parsed regex, mainly for debugging.\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "showRegex",
          "package": "frisby",
          "signature": "String -\u003e IO ()",
          "source": "src/Text-Parsers-Frisby.html#showRegex",
          "type": "function"
        },
        "index": {
          "description": "Show representation of the parsed regex mainly for debugging",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "showRegex",
          "normalized": "String-\u003eIO()",
          "package": "frisby",
          "partial": "Regex",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:showRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMatch some text\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "text",
          "package": "frisby",
          "signature": "String -\u003e P s String",
          "source": "src/Text-Parsers-Frisby.html#text",
          "type": "function"
        },
        "index": {
          "description": "Match some text",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "text",
          "normalized": "String-\u003eP a String",
          "package": "frisby",
          "signature": "String-\u003eP s String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:text"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn a value, always succeeds\n\u003c/p\u003e",
          "module": "Text.Parsers.Frisby",
          "name": "unit",
          "package": "frisby",
          "signature": "a -\u003e P s a",
          "source": "src/Text-Parsers-Frisby.html#unit",
          "type": "function"
        },
        "index": {
          "description": "Return value always succeeds",
          "hierarchy": "Text Parsers Frisby",
          "module": "Text.Parsers.Frisby",
          "name": "unit",
          "normalized": "a-\u003eP b a",
          "package": "frisby",
          "signature": "a-\u003eP s a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/frisby/docs/Text-Parsers-Frisby.html#v:unit"
      }
    }
  ]
]