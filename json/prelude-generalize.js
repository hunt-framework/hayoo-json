[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "prelude-generalize"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Generalize",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Generalize",
          "package": "prelude-generalize",
          "partial": "Generalize",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Copeanoid",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Copeanoid",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Copeanoid",
          "package": "prelude-generalize",
          "partial": "Copeanoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Copeanoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Function",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Function",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Function",
          "package": "prelude-generalize",
          "partial": "Function",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part1",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Part1",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part1",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part1M",
          "package": "prelude-generalize",
          "signature": "Part1M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part1M",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part1M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part2",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Part2",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part2",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part2M",
          "package": "prelude-generalize",
          "signature": "Part2M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part2M",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part2M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part3",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Part3",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part3",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part3M",
          "package": "prelude-generalize",
          "signature": "Part3M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part3M",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part3M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part4",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Part4",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part4",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part4M",
          "package": "prelude-generalize",
          "signature": "Part4M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part4M",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part4M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part5",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Part5",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part5",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part5M",
          "package": "prelude-generalize",
          "signature": "Part5M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part5M",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part5M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part6",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Part6",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part6",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Part6M",
          "package": "prelude-generalize",
          "signature": "Part6M",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Part6M",
          "package": "prelude-generalize",
          "partial": "Part",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Part6M"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Peano",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Peano",
          "type": "data"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Peano",
          "package": "prelude-generalize",
          "partial": "Peano",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Peano"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Peanoid",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Peanoid",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Peanoid",
          "package": "prelude-generalize",
          "partial": "Peanoid",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Peanoid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "QuestionMarkOp",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#QuestionMarkOp",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "QuestionMarkOp",
          "package": "prelude-generalize",
          "partial": "Question Mark Op",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:QuestionMarkOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "Swap",
          "package": "prelude-generalize",
          "source": "src/Prelude-Generalize.html#Swap",
          "type": "class"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "Swap",
          "package": "prelude-generalize",
          "partial": "Swap",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#t:Swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(!!)",
          "package": "prelude-generalize",
          "signature": "t x -\u003e i -\u003e x",
          "source": "src/Prelude-Generalize.html#%21%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(!!) !!",
          "normalized": "a b-\u003ec-\u003eb",
          "package": "prelude-generalize",
          "signature": "t x-\u003ei-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(!!!)",
          "package": "prelude-generalize",
          "signature": "t x -\u003e i -\u003e f x",
          "source": "src/Prelude-Generalize.html#%21%21%21",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(!!!) !!!",
          "normalized": "a b-\u003ec-\u003ed b",
          "package": "prelude-generalize",
          "signature": "t x-\u003ei-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-33--33--33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "($)",
          "package": "prelude-generalize",
          "signature": "f -\u003e i -\u003e o",
          "source": "src/Prelude-Generalize.html#%24",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "($) $",
          "normalized": "a-\u003eb-\u003ec",
          "package": "prelude-generalize",
          "signature": "f-\u003ei-\u003eo",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-36-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(++)",
          "package": "prelude-generalize",
          "signature": "m a -\u003e m a -\u003e m a",
          "source": "src/Prelude-Generalize.html#%2B%2B",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(++) ++",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "prelude-generalize",
          "signature": "m a-\u003em a-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-43--43-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\u003c\u003e\u003e=)",
          "package": "prelude-generalize",
          "signature": "m a -\u003e (a -\u003e m b) -\u003e m a",
          "source": "src/Prelude-Generalize.html#%3C%3E%3E%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\u003c\u003e\u003e=) \u003c\u003e\u003e=",
          "normalized": "a b-\u003e(b-\u003ea c)-\u003ea b",
          "package": "prelude-generalize",
          "signature": "m a-\u003e(a-\u003em b)-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-60--62--62--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=||)",
          "package": "prelude-generalize",
          "signature": "m (a, b) -\u003e (a -\u003e b -\u003e m z) -\u003e m z",
          "source": "src/Prelude-Generalize.html#%3E%3E%3D%7C%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=||) \u003e\u003e=||",
          "normalized": "a(b,c)-\u003e(b-\u003ec-\u003ea d)-\u003ea d",
          "package": "prelude-generalize",
          "signature": "m(a,b)-\u003e(a-\u003eb-\u003em z)-\u003em z",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-62--62--61--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=|||)",
          "package": "prelude-generalize",
          "signature": "m (a, b, c) -\u003e (a -\u003e b -\u003e c -\u003e m z) -\u003e m z",
          "source": "src/Prelude-Generalize.html#%3E%3E%3D%7C%7C%7C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=|||) \u003e\u003e=|||",
          "normalized": "a(b,c,d)-\u003e(b-\u003ec-\u003ed-\u003ea e)-\u003ea e",
          "package": "prelude-generalize",
          "signature": "m(a,b,c)-\u003e(a-\u003eb-\u003ec-\u003em z)-\u003em z",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-62--62--61--124--124--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=|\\/)",
          "package": "prelude-generalize",
          "signature": "m (a, b, c, d) -\u003e (a -\u003e b -\u003e c -\u003e d -\u003e m z) -\u003e m z",
          "source": "src/Prelude-Generalize.html#%3E%3E%3D%7C%5C%2F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=|\\/) \u003e\u003e=|\\/",
          "normalized": "a(b,c,d,e)-\u003e(b-\u003ec-\u003ed-\u003ee-\u003ea f)-\u003ea f",
          "package": "prelude-generalize",
          "signature": "m(a,b,c,d)-\u003e(a-\u003eb-\u003ec-\u003ed-\u003em z)-\u003em z",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-62--62--61--124--92--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e==)",
          "package": "prelude-generalize",
          "signature": "m x -\u003e (x -\u003e f y) -\u003e m y",
          "source": "src/Prelude-Generalize.html#%3E%3E%3D%3D",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e==) \u003e\u003e==",
          "normalized": "a b-\u003e(b-\u003ec d)-\u003ea d",
          "package": "prelude-generalize",
          "signature": "m x-\u003e(x-\u003ef y)-\u003em y",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-62--62--61--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=\\/)",
          "package": "prelude-generalize",
          "signature": "m (a, b, c, d, e) -\u003e (a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e m z) -\u003e m z",
          "source": "src/Prelude-Generalize.html#%3E%3E%3D%5C%2F",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\u003e\u003e=\\/) \u003e\u003e=\\/",
          "normalized": "a(b,c,d,e,f)-\u003e(b-\u003ec-\u003ed-\u003ee-\u003ef-\u003ea g)-\u003ea g",
          "package": "prelude-generalize",
          "signature": "m(a,b,c,d,e)-\u003e(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003em z)-\u003em z",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-62--62--61--92--47-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(?)",
          "package": "prelude-generalize",
          "signature": "x -\u003e y -\u003e z",
          "source": "src/Prelude-Generalize.html#%3F",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(?) ?",
          "normalized": "a-\u003eb-\u003ec",
          "package": "prelude-generalize",
          "signature": "x-\u003ey-\u003ez",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-63-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(\\\\)",
          "package": "prelude-generalize",
          "signature": "m b -\u003e t b -\u003e m b",
          "source": "src/Prelude-Generalize.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(\\\\) \\\\",
          "normalized": "a b-\u003ec b-\u003ea b",
          "package": "prelude-generalize",
          "signature": "m b-\u003et b-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(.:)",
          "package": "prelude-generalize",
          "signature": "cat b c -\u003e f (cat a b) -\u003e f (cat a c)",
          "source": "src/Prelude-Generalize.html#.%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(.:) .:",
          "normalized": "a b c-\u003ed(a e b)-\u003ed(a e c)",
          "package": "prelude-generalize",
          "signature": "cat b c-\u003ef(cat a b)-\u003ef(cat a c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:.:"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(.::)",
          "package": "prelude-generalize",
          "signature": "cat b c -\u003e f (g (cat a b)) -\u003e f (g (cat a c))",
          "source": "src/Prelude-Generalize.html#.%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(.::) .::",
          "normalized": "a b c-\u003ed(e(a f b))-\u003ed(e(a f c))",
          "package": "prelude-generalize",
          "signature": "cat b c-\u003ef(g(cat a b))-\u003ef(g(cat a c))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:.::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "(.:::)",
          "package": "prelude-generalize",
          "signature": "cat b c -\u003e f (g (h (cat a b))) -\u003e f (g (h (cat a c)))",
          "source": "src/Prelude-Generalize.html#.%3A%3A%3A",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "(.:::) .:::",
          "normalized": "a b c-\u003ed(e(f(a g b)))-\u003ed(e(f(a g c)))",
          "package": "prelude-generalize",
          "signature": "cat b c-\u003ef(g(h(cat a b)))-\u003ef(g(h(cat a c)))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:.:::"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "aplus",
          "package": "prelude-generalize",
          "signature": "f x -\u003e f x -\u003e f x",
          "source": "src/Prelude-Generalize.html#aplus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "aplus",
          "normalized": "a b-\u003ea b-\u003ea b",
          "package": "prelude-generalize",
          "signature": "f x-\u003ef x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:aplus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "atLeast",
          "package": "prelude-generalize",
          "signature": "i -\u003e Peano -\u003e Bool",
          "source": "src/Prelude-Generalize.html#atLeast",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "atLeast",
          "normalized": "a-\u003ePeano-\u003eBool",
          "package": "prelude-generalize",
          "partial": "Least",
          "signature": "i-\u003ePeano-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:atLeast"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "azero",
          "package": "prelude-generalize",
          "signature": "f x",
          "source": "src/Prelude-Generalize.html#azero",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "azero",
          "package": "prelude-generalize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:azero"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "bind2",
          "package": "prelude-generalize",
          "signature": "(x -\u003e y -\u003e m a) -\u003e m x -\u003e m y -\u003e m a",
          "source": "src/Prelude-Generalize.html#bind2",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "bind2",
          "normalized": "(a-\u003eb-\u003ec d)-\u003ec a-\u003ec b-\u003ec d",
          "package": "prelude-generalize",
          "signature": "(x-\u003ey-\u003em a)-\u003em x-\u003em y-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:bind2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "bind3",
          "package": "prelude-generalize",
          "signature": "(x -\u003e y -\u003e z -\u003e m a) -\u003e m x -\u003e m y -\u003e m z -\u003e m a",
          "source": "src/Prelude-Generalize.html#bind3",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "bind3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed e)-\u003ed a-\u003ed b-\u003ed c-\u003ed e",
          "package": "prelude-generalize",
          "signature": "(x-\u003ey-\u003ez-\u003em a)-\u003em x-\u003em y-\u003em z-\u003em a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:bind3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "bool",
          "package": "prelude-generalize",
          "signature": "x -\u003e x -\u003e Bool -\u003e x",
          "source": "src/Prelude-Generalize.html#bool",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "bool",
          "normalized": "a-\u003ea-\u003eBool-\u003ea",
          "package": "prelude-generalize",
          "signature": "x-\u003ex-\u003eBool-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:bool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "breakList",
          "package": "prelude-generalize",
          "signature": "([a] -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Prelude-Generalize.html#breakList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "breakList",
          "normalized": "([a]-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "prelude-generalize",
          "partial": "List",
          "signature": "([a]-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:breakList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "choice",
          "package": "prelude-generalize",
          "signature": "t (f x) -\u003e f x",
          "source": "src/Prelude-Generalize.html#choice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "choice",
          "normalized": "a(b c)-\u003eb c",
          "package": "prelude-generalize",
          "signature": "t(f x)-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:choice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "church",
          "package": "prelude-generalize",
          "signature": "i -\u003e (x -\u003e x) -\u003e x -\u003e x",
          "source": "src/Prelude-Generalize.html#church",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "church",
          "normalized": "a-\u003e(b-\u003eb)-\u003eb-\u003eb",
          "package": "prelude-generalize",
          "signature": "i-\u003e(x-\u003ex)-\u003ex-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:church"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "concat",
          "package": "prelude-generalize",
          "signature": "m (f x) -\u003e m x",
          "source": "src/Prelude-Generalize.html#concat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "concat",
          "normalized": "a(b c)-\u003ea c",
          "package": "prelude-generalize",
          "signature": "m(f x)-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:concat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "consA",
          "package": "prelude-generalize",
          "signature": "x -\u003e f x -\u003e f x",
          "source": "src/Prelude-Generalize.html#consA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "consA",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003ef x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:consA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "convList",
          "package": "prelude-generalize",
          "signature": "t x -\u003e f x",
          "source": "src/Prelude-Generalize.html#convList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "convList",
          "normalized": "a b-\u003ec b",
          "package": "prelude-generalize",
          "partial": "List",
          "signature": "t x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:convList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "count",
          "package": "prelude-generalize",
          "signature": "i -\u003e f x -\u003e f (g x)",
          "source": "src/Prelude-Generalize.html#count",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "count",
          "normalized": "a-\u003eb c-\u003eb(d c)",
          "package": "prelude-generalize",
          "signature": "i-\u003ef x-\u003ef(g x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:count"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "cycle",
          "package": "prelude-generalize",
          "signature": "f x -\u003e f x",
          "source": "src/Prelude-Generalize.html#cycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "cycle",
          "normalized": "a b-\u003ea b",
          "package": "prelude-generalize",
          "signature": "f x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:cycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "delete",
          "package": "prelude-generalize",
          "signature": "x -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#delete",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "delete",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "deleteF",
          "package": "prelude-generalize",
          "signature": "(x -\u003e Bool) -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#deleteF",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "deleteF",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "(x-\u003eBool)-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:deleteF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "drop",
          "package": "prelude-generalize",
          "signature": "i -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#drop",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "drop",
          "normalized": "a-\u003eb c-\u003eb c",
          "package": "prelude-generalize",
          "signature": "i-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "dropWhile",
          "package": "prelude-generalize",
          "signature": "(x -\u003e Bool) -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#dropWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "dropWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "partial": "While",
          "signature": "(x-\u003eBool)-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:dropWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "fair",
          "package": "prelude-generalize",
          "signature": "m (m x) -\u003e m x",
          "source": "src/Prelude-Generalize.html#fair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "fair",
          "normalized": "a(a b)-\u003ea b",
          "package": "prelude-generalize",
          "signature": "m(m x)-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:fair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "filter",
          "package": "prelude-generalize",
          "signature": "(x -\u003e Bool) -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#filter",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "(x-\u003eBool)-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "find",
          "package": "prelude-generalize",
          "signature": "(a -\u003e Bool) -\u003e t a -\u003e f a",
          "source": "src/Prelude-Generalize.html#find",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "find",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003ec a",
          "package": "prelude-generalize",
          "signature": "(a-\u003eBool)-\u003et a-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:find"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "findIndex",
          "package": "prelude-generalize",
          "signature": "(a -\u003e Bool) -\u003e t a -\u003e f i",
          "source": "src/Prelude-Generalize.html#findIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "findIndex",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003ec d",
          "package": "prelude-generalize",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003et a-\u003ef i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:findIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "get1",
          "package": "prelude-generalize",
          "signature": "x -\u003e Part1T x",
          "source": "src/Prelude-Generalize.html#get1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "get1",
          "normalized": "a-\u003ePart T a",
          "package": "prelude-generalize",
          "signature": "x-\u003ePart T x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:get1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "get2",
          "package": "prelude-generalize",
          "signature": "x -\u003e Part2T x",
          "source": "src/Prelude-Generalize.html#get2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "get2",
          "normalized": "a-\u003ePart T a",
          "package": "prelude-generalize",
          "signature": "x-\u003ePart T x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:get2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "get3",
          "package": "prelude-generalize",
          "signature": "x -\u003e Part3T x",
          "source": "src/Prelude-Generalize.html#get3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "get3",
          "normalized": "a-\u003ePart T a",
          "package": "prelude-generalize",
          "signature": "x-\u003ePart T x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:get3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "get4",
          "package": "prelude-generalize",
          "signature": "x -\u003e Part4T x",
          "source": "src/Prelude-Generalize.html#get4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "get4",
          "normalized": "a-\u003ePart T a",
          "package": "prelude-generalize",
          "signature": "x-\u003ePart T x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:get4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "get5",
          "package": "prelude-generalize",
          "signature": "x -\u003e Part5T x",
          "source": "src/Prelude-Generalize.html#get5",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "get5",
          "normalized": "a-\u003ePart T a",
          "package": "prelude-generalize",
          "signature": "x-\u003ePart T x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:get5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "get6",
          "package": "prelude-generalize",
          "signature": "x -\u003e Part6T x",
          "source": "src/Prelude-Generalize.html#get6",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "get6",
          "normalized": "a-\u003ePart T a",
          "package": "prelude-generalize",
          "signature": "x-\u003ePart T x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:get6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "getBits",
          "package": "prelude-generalize",
          "signature": "Int -\u003e Int -\u003e t -\u003e u",
          "source": "src/Prelude-Generalize.html#getBits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "getBits",
          "normalized": "Int-\u003eInt-\u003ea-\u003eb",
          "package": "prelude-generalize",
          "partial": "Bits",
          "signature": "Int-\u003eInt-\u003et-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:getBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "group",
          "package": "prelude-generalize",
          "signature": "t a -\u003e f (g a)",
          "source": "src/Prelude-Generalize.html#group",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "group",
          "normalized": "a b-\u003ec(d b)",
          "package": "prelude-generalize",
          "signature": "t a-\u003ef(g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "groupBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e t a -\u003e f (g a)",
          "source": "src/Prelude-Generalize.html#groupBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "groupBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003eb a-\u003ec(d a)",
          "package": "prelude-generalize",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003et a-\u003ef(g a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:groupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "hGetByte",
          "package": "prelude-generalize",
          "signature": "Handle -\u003e IO Word8",
          "source": "src/Prelude-Generalize.html#hGetByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "hGetByte",
          "normalized": "Handle-\u003eIO Word",
          "package": "prelude-generalize",
          "partial": "Get Byte",
          "signature": "Handle-\u003eIO Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:hGetByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "hPutByte",
          "package": "prelude-generalize",
          "signature": "Handle -\u003e Word8 -\u003e IO ()",
          "source": "src/Prelude-Generalize.html#hPutByte",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "hPutByte",
          "normalized": "Handle-\u003eWord-\u003eIO()",
          "package": "prelude-generalize",
          "partial": "Put Byte",
          "signature": "Handle-\u003eWord-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:hPutByte"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "head",
          "package": "prelude-generalize",
          "signature": "t x -\u003e x",
          "source": "src/Prelude-Generalize.html#head",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "head",
          "normalized": "a b-\u003eb",
          "package": "prelude-generalize",
          "signature": "t x-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:head"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "idQMO",
          "package": "prelude-generalize",
          "signature": "y",
          "source": "src/Prelude-Generalize.html#idQMO",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "idQMO",
          "package": "prelude-generalize",
          "partial": "QMO",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:idQMO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e function takes an element and a list and inserts the\n element into the list at the last position where it is still less\n than or equal to the next element.  In particular, if the list\n is sorted before the call, the result will also be sorted.\n It is a special case of \u003ccode\u003e\u003ca\u003einsertBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own comparison function.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "insert",
          "package": "prelude-generalize",
          "signature": "a -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The insert function takes an element and list and inserts the element into the list at the last position where it is still less than or equal to the next element In particular if the list is sorted before the call the result will also be sorted It is special case of insertBy which allows the programmer to supply their own comparison function",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "insert",
          "normalized": "a-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "a-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe non-overloaded version of \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "insertBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e a -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The non-overloaded version of insert",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "insertBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003ea-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:insertBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "intercalate",
          "package": "prelude-generalize",
          "signature": "m x -\u003e m (m x) -\u003e m x",
          "source": "src/Prelude-Generalize.html#intercalate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "intercalate",
          "normalized": "a b-\u003ea(a b)-\u003ea b",
          "package": "prelude-generalize",
          "signature": "m x-\u003em(m x)-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:intercalate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e function takes the list intersection of two lists.\n For example,\n\u003c/p\u003e\u003cpre\u003e [1,2,3,4] `intersect` [2,4,6,8] == [2,4]\n\u003c/pre\u003e\u003cp\u003eIf the first list contains duplicates, so will the result.\n\u003c/p\u003e\u003cpre\u003e [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]\n\u003c/pre\u003e\u003cp\u003eIt is a special case of \u003ccode\u003e\u003ca\u003eintersectBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to\n supply their own equality test.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "intersect",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The intersect function takes the list intersection of two lists For example intersect If the first list contains duplicates so will the result intersect It is special case of intersectBy which allows the programmer to supply their own equality test",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "intersect",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:intersect"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eintersectBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003eintersect\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "intersectBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The intersectBy function is the non-overloaded version of intersect",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "intersectBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:intersectBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "intersperse",
          "package": "prelude-generalize",
          "signature": "x -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#intersperse",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "intersperse",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:intersperse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "intersperse'",
          "package": "prelude-generalize",
          "signature": "x -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#intersperse%27",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "intersperse'",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:intersperse-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisInfixOf\u003c/a\u003e\u003c/code\u003e function takes two lists and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first list is contained, wholly and intact,\n anywhere within the second.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003eisInfixOf \"Haskell\" \"I really like Haskell.\" == True\nisInfixOf \"Ial\" \"I really like Haskell.\" == False\n\u003c/pre\u003e",
          "module": "Prelude.Generalize",
          "name": "isInfixOf",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "The isInfixOf function takes two lists and returns True iff the first list is contained wholly and intact anywhere within the second Example isInfixOf Haskell really like Haskell True isInfixOf Ial really like Haskell False",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "isInfixOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "prelude-generalize",
          "partial": "Infix Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:isInfixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisPrefixOf\u003c/a\u003e\u003c/code\u003e function takes two lists and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first list is a prefix of the second.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "isPrefixOf",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "The isPrefixOf function takes two lists and returns True iff the first list is prefix of the second",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "isPrefixOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "prelude-generalize",
          "partial": "Prefix Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:isPrefixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eisSuffixOf\u003c/a\u003e\u003c/code\u003e function takes two lists and returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n iff the first list is a suffix of the second.\n Both lists must be finite.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "isSuffixOf",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e Bool",
          "type": "function"
        },
        "index": {
          "description": "The isSuffixOf function takes two lists and returns True iff the first list is suffix of the second Both lists must be finite",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "isSuffixOf",
          "normalized": "[a]-\u003e[a]-\u003eBool",
          "package": "prelude-generalize",
          "partial": "Suffix Of",
          "signature": "[a]-\u003e[a]-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:isSuffixOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "iterate",
          "package": "prelude-generalize",
          "signature": "(x -\u003e x) -\u003e x -\u003e f x",
          "source": "src/Prelude-Generalize.html#iterate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "iterate",
          "normalized": "(a-\u003ea)-\u003ea-\u003eb a",
          "package": "prelude-generalize",
          "signature": "(x-\u003ex)-\u003ex-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:iterate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "lcomp",
          "package": "prelude-generalize",
          "signature": "t (c x x) -\u003e c x x",
          "source": "src/Prelude-Generalize.html#lcomp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "lcomp",
          "normalized": "a(b c c)-\u003eb c c",
          "package": "prelude-generalize",
          "signature": "t(c x x)-\u003ec x x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:lcomp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts from a list of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e all the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e elements\n All the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e elements are extracted in order.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "lefts",
          "package": "prelude-generalize",
          "signature": "[Either a b] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "Extracts from list of Either all the Left elements All the Left elements are extracted in order",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "lefts",
          "normalized": "[Either a b]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "[Either a b]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:lefts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "length",
          "package": "prelude-generalize",
          "signature": "t x -\u003e i",
          "source": "src/Prelude-Generalize.html#length",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "length",
          "normalized": "a b-\u003ec",
          "package": "prelude-generalize",
          "signature": "t x-\u003ei",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "liftPair",
          "package": "prelude-generalize",
          "signature": "(f x, f y) -\u003e f (x, y)",
          "source": "src/Prelude-Generalize.html#liftPair",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "liftPair",
          "normalized": "(a b,a c)-\u003ea(b,c)",
          "package": "prelude-generalize",
          "partial": "Pair",
          "signature": "(f x,f y)-\u003ef(x,y)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:liftPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "loeb",
          "package": "prelude-generalize",
          "signature": "f a -\u003e f b",
          "source": "src/Prelude-Generalize.html#loeb",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "loeb",
          "normalized": "a b-\u003ea c",
          "package": "prelude-generalize",
          "signature": "f a-\u003ef b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:loeb"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "low8bits",
          "package": "prelude-generalize",
          "signature": "t -\u003e Word8",
          "source": "src/Prelude-Generalize.html#low8bits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "low8bits",
          "normalized": "a-\u003eWord",
          "package": "prelude-generalize",
          "signature": "t-\u003eWord",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:low8bits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "map1",
          "package": "prelude-generalize",
          "signature": "(Part1T x -\u003e y) -\u003e x -\u003e Part1M x y",
          "source": "src/Prelude-Generalize.html#map1",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "map1",
          "normalized": "(Part T a-\u003eb)-\u003ea-\u003ePart M a b",
          "package": "prelude-generalize",
          "signature": "(Part T x-\u003ey)-\u003ex-\u003ePart M x y",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:map1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "map2",
          "package": "prelude-generalize",
          "signature": "(Part2T x -\u003e y) -\u003e x -\u003e Part2M x y",
          "source": "src/Prelude-Generalize.html#map2",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "map2",
          "normalized": "(Part T a-\u003eb)-\u003ea-\u003ePart M a b",
          "package": "prelude-generalize",
          "signature": "(Part T x-\u003ey)-\u003ex-\u003ePart M x y",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:map2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "map3",
          "package": "prelude-generalize",
          "signature": "(Part3T x -\u003e y) -\u003e x -\u003e Part3M x y",
          "source": "src/Prelude-Generalize.html#map3",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "map3",
          "normalized": "(Part T a-\u003eb)-\u003ea-\u003ePart M a b",
          "package": "prelude-generalize",
          "signature": "(Part T x-\u003ey)-\u003ex-\u003ePart M x y",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:map3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "map4",
          "package": "prelude-generalize",
          "signature": "(Part4T x -\u003e y) -\u003e x -\u003e Part4M x y",
          "source": "src/Prelude-Generalize.html#map4",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "map4",
          "normalized": "(Part T a-\u003eb)-\u003ea-\u003ePart M a b",
          "package": "prelude-generalize",
          "signature": "(Part T x-\u003ey)-\u003ex-\u003ePart M x y",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:map4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "map5",
          "package": "prelude-generalize",
          "signature": "(Part5T x -\u003e y) -\u003e x -\u003e Part5M x y",
          "source": "src/Prelude-Generalize.html#map5",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "map5",
          "normalized": "(Part T a-\u003eb)-\u003ea-\u003ePart M a b",
          "package": "prelude-generalize",
          "signature": "(Part T x-\u003ey)-\u003ex-\u003ePart M x y",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:map5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "map6",
          "package": "prelude-generalize",
          "signature": "(Part6T x -\u003e y) -\u003e x -\u003e Part6M x y",
          "source": "src/Prelude-Generalize.html#map6",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "map6",
          "normalized": "(Part T a-\u003eb)-\u003ea-\u003ePart M a b",
          "package": "prelude-generalize",
          "signature": "(Part T x-\u003ey)-\u003ex-\u003ePart M x y",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:map6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "mcycle",
          "package": "prelude-generalize",
          "signature": "x -\u003e x",
          "source": "src/Prelude-Generalize.html#mcycle",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "mcycle",
          "normalized": "a-\u003ea",
          "package": "prelude-generalize",
          "signature": "x-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:mcycle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "modifyBit",
          "package": "prelude-generalize",
          "signature": "Bool -\u003e a -\u003e Int -\u003e a",
          "source": "src/Prelude-Generalize.html#modifyBit",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "modifyBit",
          "normalized": "Bool-\u003ea-\u003eInt-\u003ea",
          "package": "prelude-generalize",
          "partial": "Bit",
          "signature": "Bool-\u003ea-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:modifyBit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "mreplicate",
          "package": "prelude-generalize",
          "signature": "i -\u003e x -\u003e x",
          "source": "src/Prelude-Generalize.html#mreplicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "mreplicate",
          "normalized": "a-\u003eb-\u003eb",
          "package": "prelude-generalize",
          "signature": "i-\u003ex-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:mreplicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n^2)\u003c/em\u003e. The \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e function removes duplicate elements from a list.\n In particular, it keeps only the first occurrence of each element.\n (The name \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e means `essence'.)\n It is a special case of \u003ccode\u003e\u003ca\u003enubBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own equality test.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "nub",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The nub function removes duplicate elements from list In particular it keeps only the first occurrence of each element The name nub means essence It is special case of nubBy which allows the programmer to supply their own equality test",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "nub",
          "normalized": "[a]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:nub"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003enubBy\u003c/a\u003e\u003c/code\u003e function behaves just like \u003ccode\u003e\u003ca\u003enub\u003c/a\u003e\u003c/code\u003e, except it uses a\n user-supplied equality predicate instead of the overloaded \u003ccode\u003e\u003ca\u003e==\u003c/a\u003e\u003c/code\u003e\n function.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "nubBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The nubBy function behaves just like nub except it uses user-supplied equality predicate instead of the overloaded function",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "nubBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:nubBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "null",
          "package": "prelude-generalize",
          "signature": "t x -\u003e Bool",
          "source": "src/Prelude-Generalize.html#null",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "null",
          "normalized": "a b-\u003eBool",
          "package": "prelude-generalize",
          "signature": "t x-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e(*) `on` f = \\x y -\u003e f x * f y\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eTypical usage: \u003ccode\u003e\u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003ecompare\u003c/a\u003e\u003c/code\u003e `on` \u003ccode\u003e\u003ca\u003efst\u003c/a\u003e\u003c/code\u003e)\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eAlgebraic properties:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(*) `on` \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e = (*)\u003c/code\u003e (if \u003ccode\u003e(*) &#8713; {&#8869;, \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e &#8869;}\u003c/code\u003e)\n\u003c/li\u003e\u003cli\u003e\u003cpre\u003e((*) `on` f) `on` g = (*) `on` (f . g)\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e on f . \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e on g = \u003ccode\u003e\u003ca\u003eflip\u003c/a\u003e\u003c/code\u003e on (g . f)\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e",
          "module": "Prelude.Generalize",
          "name": "on",
          "package": "prelude-generalize",
          "signature": "(b -\u003e b -\u003e c) -\u003e (a -\u003e b) -\u003e a -\u003e a -\u003e c",
          "type": "function"
        },
        "index": {
          "description": "on Typical usage sortBy compare on fst Algebraic properties on id if const on on on flip on flip on flip on",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "on",
          "normalized": "(a-\u003ea-\u003eb)-\u003e(c-\u003ea)-\u003ec-\u003ec-\u003eb",
          "package": "prelude-generalize",
          "signature": "(b-\u003eb-\u003ec)-\u003e(a-\u003eb)-\u003ea-\u003ea-\u003ec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:on"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "option",
          "package": "prelude-generalize",
          "signature": "x -\u003e f x -\u003e f x",
          "source": "src/Prelude-Generalize.html#option",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "option",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003ef x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:option"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e function takes a predicate a list and returns\n the pair of lists of elements which do and do not satisfy the\n predicate, respectively; i.e.,\n\u003c/p\u003e\u003cpre\u003e partition p xs == (filter p xs, filter (not . p) xs)\n\u003c/pre\u003e",
          "module": "Prelude.Generalize",
          "name": "partition",
          "package": "prelude-generalize",
          "signature": "(a -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "type": "function"
        },
        "index": {
          "description": "The partition function takes predicate list and returns the pair of lists of elements which do and do not satisfy the predicate respectively i.e partition xs filter xs filter not xs",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "prelude-generalize",
          "signature": "(a-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePartitions a list of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e into two lists\n All the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e elements are extracted, in order, to the first\n component of the output.  Similarly the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e elements are extracted\n to the second component of the output.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "partitionEithers",
          "package": "prelude-generalize",
          "signature": "[Either a b] -\u003e ([a], [b])",
          "type": "function"
        },
        "index": {
          "description": "Partitions list of Either into two lists All the Left elements are extracted in order to the first component of the output Similarly the Right elements are extracted to the second component of the output",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "partitionEithers",
          "normalized": "[Either a b]-\u003e([a],[b])",
          "package": "prelude-generalize",
          "partial": "Eithers",
          "signature": "[Either a b]-\u003e([a],[b])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:partitionEithers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003epermutations\u003c/a\u003e\u003c/code\u003e function returns the list of all permutations of the argument.\n\u003c/p\u003e\u003cpre\u003e permutations \"abc\" == [\"abc\",\"bac\",\"cba\",\"bca\",\"cab\",\"acb\"]\n\u003c/pre\u003e",
          "module": "Prelude.Generalize",
          "name": "permutations",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [[a]]",
          "type": "function"
        },
        "index": {
          "description": "The permutations function returns the list of all permutations of the argument permutations abc abc bac cba bca cab acb",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "permutations",
          "normalized": "[a]-\u003e[[a]]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:permutations"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "predP",
          "package": "prelude-generalize",
          "signature": "x -\u003e Maybe x",
          "source": "src/Prelude-Generalize.html#predP",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "predP",
          "normalized": "a-\u003eMaybe a",
          "package": "prelude-generalize",
          "signature": "x-\u003eMaybe x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:predP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "rcomp",
          "package": "prelude-generalize",
          "signature": "t (c x x) -\u003e c x x",
          "source": "src/Prelude-Generalize.html#rcomp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "rcomp",
          "normalized": "a(b c c)-\u003eb c c",
          "package": "prelude-generalize",
          "signature": "t(c x x)-\u003ec x x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:rcomp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "repeat",
          "package": "prelude-generalize",
          "signature": "x -\u003e f x",
          "source": "src/Prelude-Generalize.html#repeat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "repeat",
          "normalized": "a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:repeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "replace",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e [a] -\u003e [a]",
          "source": "src/Prelude-Generalize.html#replace",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "replace",
          "normalized": "[a]-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:replace"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "replicate",
          "package": "prelude-generalize",
          "signature": "i -\u003e x -\u003e f x",
          "source": "src/Prelude-Generalize.html#replicate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "replicate",
          "normalized": "a-\u003eb-\u003ec b",
          "package": "prelude-generalize",
          "signature": "i-\u003ex-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtracts from a list of \u003ccode\u003e\u003ca\u003eEither\u003c/a\u003e\u003c/code\u003e all the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e elements\n All the \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e elements are extracted in order.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "rights",
          "package": "prelude-generalize",
          "signature": "[Either a b] -\u003e [b]",
          "type": "function"
        },
        "index": {
          "description": "Extracts from list of Either all the Right elements All the Right elements are extracted in order",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "rights",
          "normalized": "[Either a b]-\u003e[b]",
          "package": "prelude-generalize",
          "signature": "[Either a b]-\u003e[b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:rights"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "selectBits",
          "package": "prelude-generalize",
          "signature": "x -\u003e x -\u003e x",
          "source": "src/Prelude-Generalize.html#selectBits",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "selectBits",
          "normalized": "a-\u003ea-\u003ea",
          "package": "prelude-generalize",
          "partial": "Bits",
          "signature": "x-\u003ex-\u003ex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:selectBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "selectItems",
          "package": "prelude-generalize",
          "signature": "[x] -\u003e [Bool] -\u003e [x]",
          "source": "src/Prelude-Generalize.html#selectItems",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "selectItems",
          "normalized": "[a]-\u003e[Bool]-\u003e[a]",
          "package": "prelude-generalize",
          "partial": "Items",
          "signature": "[x]-\u003e[Bool]-\u003e[x]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:selectItems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "snocA",
          "package": "prelude-generalize",
          "signature": "x -\u003e f x -\u003e f x",
          "source": "src/Prelude-Generalize.html#snocA",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "snocA",
          "normalized": "a-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "signature": "x-\u003ef x-\u003ef x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:snocA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e function implements a stable sorting algorithm.\n It is a special case of \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own comparison function.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "sort",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The sort function implements stable sorting algorithm It is special case of sortBy which allows the programmer to supply their own comparison function",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "sort",
          "normalized": "[a]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "sortBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The sortBy function is the non-overloaded version of sort",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "sortBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:sortBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "spanList",
          "package": "prelude-generalize",
          "signature": "([a] -\u003e Bool) -\u003e [a] -\u003e ([a], [a])",
          "source": "src/Prelude-Generalize.html#spanList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "spanList",
          "normalized": "([a]-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "package": "prelude-generalize",
          "partial": "List",
          "signature": "([a]-\u003eBool)-\u003e[a]-\u003e([a],[a])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:spanList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "split",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e f [a]",
          "source": "src/Prelude-Generalize.html#split",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "split",
          "normalized": "[a]-\u003e[a]-\u003eb[a]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[a]-\u003ef[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003estripPrefix\u003c/a\u003e\u003c/code\u003e function drops the given prefix from a list.\n It returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the list did not start with the prefix\n given, or \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e the list after the prefix, if it does.\n\u003c/p\u003e\u003cpre\u003e stripPrefix \"foo\" \"foobar\" == Just \"bar\"\n stripPrefix \"foo\" \"foo\" == Just \"\"\n stripPrefix \"foo\" \"barfoo\" == Nothing\n stripPrefix \"foo\" \"barfoobaz\" == Nothing\n\u003c/pre\u003e",
          "module": "Prelude.Generalize",
          "name": "stripPrefix",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e Maybe [a]",
          "type": "function"
        },
        "index": {
          "description": "The stripPrefix function drops the given prefix from list It returns Nothing if the list did not start with the prefix given or Just the list after the prefix if it does stripPrefix foo foobar Just bar stripPrefix foo foo Just stripPrefix foo barfoo Nothing stripPrefix foo barfoobaz Nothing",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "stripPrefix",
          "normalized": "[a]-\u003e[a]-\u003eMaybe[a]",
          "package": "prelude-generalize",
          "partial": "Prefix",
          "signature": "[a]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:stripPrefix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "stripPrefixBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e Maybe [a]",
          "source": "src/Prelude-Generalize.html#stripPrefixBy",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "stripPrefixBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003eMaybe[a]",
          "package": "prelude-generalize",
          "partial": "Prefix By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003eMaybe[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:stripPrefixBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "subIndex",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e f i",
          "source": "src/Prelude-Generalize.html#subIndex",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "subIndex",
          "normalized": "[a]-\u003e[a]-\u003eb c",
          "package": "prelude-generalize",
          "partial": "Index",
          "signature": "[a]-\u003e[a]-\u003ef i",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:subIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003esubsequences\u003c/a\u003e\u003c/code\u003e function returns the list of all subsequences of the argument.\n\u003c/p\u003e\u003cpre\u003e subsequences \"abc\" == [\"\",\"a\",\"b\",\"ab\",\"c\",\"ac\",\"bc\",\"abc\"]\n\u003c/pre\u003e",
          "module": "Prelude.Generalize",
          "name": "subsequences",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [[a]]",
          "type": "function"
        },
        "index": {
          "description": "The subsequences function returns the list of all subsequences of the argument subsequences abc ab ac bc abc",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "subsequences",
          "normalized": "[a]-\u003e[[a]]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:subsequences"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "succP",
          "package": "prelude-generalize",
          "signature": "x -\u003e x",
          "source": "src/Prelude-Generalize.html#succP",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "succP",
          "normalized": "a-\u003ea",
          "package": "prelude-generalize",
          "signature": "x-\u003ex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:succP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "swap",
          "package": "prelude-generalize",
          "signature": "f x y -\u003e f y x",
          "source": "src/Prelude-Generalize.html#swap",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "swap",
          "normalized": "a b c-\u003ea c b",
          "package": "prelude-generalize",
          "signature": "f x y-\u003ef y x",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:swap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "tail",
          "package": "prelude-generalize",
          "signature": "m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#tail",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "tail",
          "normalized": "a b-\u003ea b",
          "package": "prelude-generalize",
          "signature": "m x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:tail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "tails",
          "package": "prelude-generalize",
          "signature": "m x -\u003e m (m x)",
          "source": "src/Prelude-Generalize.html#tails",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "tails",
          "normalized": "a b-\u003ea(a b)",
          "package": "prelude-generalize",
          "signature": "m x-\u003em(m x)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "take",
          "package": "prelude-generalize",
          "signature": "i -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#take",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "take",
          "normalized": "a-\u003eb c-\u003eb c",
          "package": "prelude-generalize",
          "signature": "i-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "takeWhile",
          "package": "prelude-generalize",
          "signature": "(x -\u003e Bool) -\u003e m x -\u003e m x",
          "source": "src/Prelude-Generalize.html#takeWhile",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "takeWhile",
          "normalized": "(a-\u003eBool)-\u003eb a-\u003eb a",
          "package": "prelude-generalize",
          "partial": "While",
          "signature": "(x-\u003eBool)-\u003em x-\u003em x",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:takeWhile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "transEnum",
          "package": "prelude-generalize",
          "signature": "t -\u003e u",
          "source": "src/Prelude-Generalize.html#transEnum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "transEnum",
          "normalized": "a-\u003eb",
          "package": "prelude-generalize",
          "partial": "Enum",
          "signature": "t-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:transEnum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "transInt",
          "package": "prelude-generalize",
          "signature": "t -\u003e u",
          "source": "src/Prelude-Generalize.html#transInt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "transInt",
          "normalized": "a-\u003eb",
          "package": "prelude-generalize",
          "partial": "Int",
          "signature": "t-\u003eu",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:transInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "transPeano",
          "package": "prelude-generalize",
          "signature": "i -\u003e o",
          "source": "src/Prelude-Generalize.html#transPeano",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "transPeano",
          "normalized": "a-\u003eb",
          "package": "prelude-generalize",
          "partial": "Peano",
          "signature": "i-\u003eo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:transPeano"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003etranspose\u003c/a\u003e\u003c/code\u003e function transposes the rows and columns of its argument.\n For example,\n\u003c/p\u003e\u003cpre\u003e transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]\n\u003c/pre\u003e",
          "module": "Prelude.Generalize",
          "name": "transpose",
          "package": "prelude-generalize",
          "signature": "[[a]] -\u003e [[a]]",
          "type": "function"
        },
        "index": {
          "description": "The transpose function transposes the rows and columns of its argument For example transpose",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "transpose",
          "normalized": "[[a]]-\u003e[[a]]",
          "package": "prelude-generalize",
          "signature": "[[a]]-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:transpose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "unfoldr",
          "package": "prelude-generalize",
          "signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e f a",
          "source": "src/Prelude-Generalize.html#unfoldr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unfoldr",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003ec b",
          "package": "prelude-generalize",
          "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003ef a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e function returns the list union of the two lists.\n For example,\n\u003c/p\u003e\u003cpre\u003e \"dog\" `union` \"cow\" == \"dogcw\"\n\u003c/pre\u003e\u003cp\u003eDuplicates, and elements of the first list, are removed from the\n the second list, but if the first list contains duplicates, so will\n the result.\n It is a special case of \u003ccode\u003e\u003ca\u003eunionBy\u003c/a\u003e\u003c/code\u003e, which allows the programmer to supply\n their own equality test.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "union",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The union function returns the list union of the two lists For example dog union cow dogcw Duplicates and elements of the first list are removed from the the second list but if the first list contains duplicates so will the result It is special case of unionBy which allows the programmer to supply their own equality test",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "union",
          "normalized": "[a]-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunionBy\u003c/a\u003e\u003c/code\u003e function is the non-overloaded version of \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "unionBy",
          "package": "prelude-generalize",
          "signature": "(a -\u003e a -\u003e Bool) -\u003e [a] -\u003e [a] -\u003e [a]",
          "type": "function"
        },
        "index": {
          "description": "The unionBy function is the non-overloaded version of union",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unionBy",
          "normalized": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "package": "prelude-generalize",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eBool)-\u003e[a]-\u003e[a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unionBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "unnull",
          "package": "prelude-generalize",
          "signature": "t x -\u003e Bool",
          "source": "src/Prelude-Generalize.html#unnull",
          "type": "function"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unnull",
          "normalized": "a b-\u003eBool",
          "package": "prelude-generalize",
          "signature": "t x-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unnull"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip4\u003c/a\u003e\u003c/code\u003e function takes a list of quadruples and returns four\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "unzip4",
          "package": "prelude-generalize",
          "signature": "[(a, b, c, d)] -\u003e ([a], [b], [c], [d])",
          "type": "function"
        },
        "index": {
          "description": "The unzip4 function takes list of quadruples and returns four lists analogous to unzip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unzip4",
          "normalized": "[(a,b,c,d)]-\u003e([a],[b],[c],[d])",
          "package": "prelude-generalize",
          "signature": "[(a,b,c,d)]-\u003e([a],[b],[c],[d])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unzip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip5\u003c/a\u003e\u003c/code\u003e function takes a list of five-tuples and returns five\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "unzip5",
          "package": "prelude-generalize",
          "signature": "[(a, b, c, d, e)] -\u003e ([a], [b], [c], [d], [e])",
          "type": "function"
        },
        "index": {
          "description": "The unzip5 function takes list of five-tuples and returns five lists analogous to unzip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unzip5",
          "normalized": "[(a,b,c,d,e)]-\u003e([a],[b],[c],[d],[e])",
          "package": "prelude-generalize",
          "signature": "[(a,b,c,d,e)]-\u003e([a],[b],[c],[d],[e])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unzip5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip6\u003c/a\u003e\u003c/code\u003e function takes a list of six-tuples and returns six\n lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "unzip6",
          "package": "prelude-generalize",
          "signature": "[(a, b, c, d, e, f)] -\u003e ([a], [b], [c], [d], [e], [f])",
          "type": "function"
        },
        "index": {
          "description": "The unzip6 function takes list of six-tuples and returns six lists analogous to unzip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unzip6",
          "normalized": "[(a,b,c,d,e,f)]-\u003e([a],[b],[c],[d],[e],[f])",
          "package": "prelude-generalize",
          "signature": "[(a,b,c,d,e,f)]-\u003e([a],[b],[c],[d],[e],[f])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unzip6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eunzip7\u003c/a\u003e\u003c/code\u003e function takes a list of seven-tuples and returns\n seven lists, analogous to \u003ccode\u003e\u003ca\u003eunzip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "unzip7",
          "package": "prelude-generalize",
          "signature": "[(a, b, c, d, e, f, g)] -\u003e ([a], [b], [c], [d], [e], [f], [g])",
          "type": "function"
        },
        "index": {
          "description": "The unzip7 function takes list of seven-tuples and returns seven lists analogous to unzip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "unzip7",
          "normalized": "[(a,b,c,d,e,f,g)]-\u003e([a],[b],[c],[d],[e],[f],[g])",
          "package": "prelude-generalize",
          "signature": "[(a,b,c,d,e,f,g)]-\u003e([a],[b],[c],[d],[e],[f],[g])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:unzip7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Prelude.Generalize",
          "name": "zeroP",
          "package": "prelude-generalize",
          "signature": "x",
          "source": "src/Prelude-Generalize.html#zeroP",
          "type": "method"
        },
        "index": {
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zeroP",
          "package": "prelude-generalize",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zeroP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip4\u003c/a\u003e\u003c/code\u003e function takes four lists and returns a list of\n quadruples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zip4",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [(a, b, c, d)]",
          "type": "function"
        },
        "index": {
          "description": "The zip4 function takes four lists and returns list of quadruples analogous to zip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zip4",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[(a,b,c,d)]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[(a,b,c,d)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip5\u003c/a\u003e\u003c/code\u003e function takes five lists and returns a list of\n five-tuples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zip5",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [(a, b, c, d, e)]",
          "type": "function"
        },
        "index": {
          "description": "The zip5 function takes five lists and returns list of five-tuples analogous to zip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zip5",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[(a,b,c,d,e)]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[(a,b,c,d,e)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zip5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip6\u003c/a\u003e\u003c/code\u003e function takes six lists and returns a list of six-tuples,\n analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zip6",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [(a, b, c, d, e, f)]",
          "type": "function"
        },
        "index": {
          "description": "The zip6 function takes six lists and returns list of six-tuples analogous to zip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zip6",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[(a,b,c,d,e,f)]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[(a,b,c,d,e,f)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zip6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezip7\u003c/a\u003e\u003c/code\u003e function takes seven lists and returns a list of\n seven-tuples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zip7",
          "package": "prelude-generalize",
          "signature": "[a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [g] -\u003e [(a, b, c, d, e, f, g)]",
          "type": "function"
        },
        "index": {
          "description": "The zip7 function takes seven lists and returns list of seven-tuples analogous to zip",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zip7",
          "normalized": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[(a,b,c,d,e,f,g)]",
          "package": "prelude-generalize",
          "signature": "[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[(a,b,c,d,e,f,g)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zip7"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith4\u003c/a\u003e\u003c/code\u003e function takes a function which combines four\n elements, as well as four lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zipWith4",
          "package": "prelude-generalize",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e]",
          "type": "function"
        },
        "index": {
          "description": "The zipWith4 function takes function which combines four elements as well as four lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]",
          "package": "prelude-generalize",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith5\u003c/a\u003e\u003c/code\u003e function takes a function which combines five\n elements, as well as five lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zipWith5",
          "package": "prelude-generalize",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f]",
          "type": "function"
        },
        "index": {
          "description": "The zipWith5 function takes function which combines five elements as well as five lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zipWith5",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]",
          "package": "prelude-generalize",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zipWith5"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith6\u003c/a\u003e\u003c/code\u003e function takes a function which combines six\n elements, as well as six lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zipWith6",
          "package": "prelude-generalize",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [g]",
          "type": "function"
        },
        "index": {
          "description": "The zipWith6 function takes function which combines six elements as well as six lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zipWith6",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]",
          "package": "prelude-generalize",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zipWith6"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003ezipWith7\u003c/a\u003e\u003c/code\u003e function takes a function which combines seven\n elements, as well as seven lists and returns a list of their point-wise\n combination, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Prelude.Generalize",
          "name": "zipWith7",
          "package": "prelude-generalize",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e -\u003e f -\u003e g -\u003e h) -\u003e [a] -\u003e [b] -\u003e [c] -\u003e [d] -\u003e [e] -\u003e [f] -\u003e [g] -\u003e [h]",
          "type": "function"
        },
        "index": {
          "description": "The zipWith7 function takes function which combines seven elements as well as seven lists and returns list of their point-wise combination analogous to zipWith",
          "hierarchy": "Prelude Generalize",
          "module": "Prelude.Generalize",
          "name": "zipWith7",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg-\u003eh)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[h]",
          "package": "prelude-generalize",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee-\u003ef-\u003eg-\u003eh)-\u003e[a]-\u003e[b]-\u003e[c]-\u003e[d]-\u003e[e]-\u003e[f]-\u003e[g]-\u003e[h]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/prelude-generalize/docs/Prelude-Generalize.html#v:zipWith7"
      }
    }
  ]
]