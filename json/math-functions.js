[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "math-functions"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eConstant values common to much numeric code.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "Constants",
          "package": "math-functions",
          "source": "src/Numeric-MathFunctions-Constants.html",
          "type": "module"
        },
        "index": {
          "description": "Constant values common to much numeric code",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "Constants",
          "package": "math-functions",
          "partial": "Constants",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e1 / sqrt 2\u003c/pre\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_1_sqrt_2",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_1_sqrt_2",
          "type": "function"
        },
        "index": {
          "description": "sqrt",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_1_sqrt_2",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_1_sqrt_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003e2 / sqrt pi\u003c/pre\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_2_sqrt_pi",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_2_sqrt_pi",
          "type": "function"
        },
        "index": {
          "description": "sqrt pi",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_2_sqrt_pi",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_2_sqrt_pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNot a number.\n\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_NaN",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_NaN",
          "type": "function"
        },
        "index": {
          "description": "Not number",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_NaN",
          "package": "math-functions",
          "partial": "Na",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_NaN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe smallest \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e &#949; such that 1 + &#949; &#8800; 1.\n\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_epsilon",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_epsilon",
          "type": "function"
        },
        "index": {
          "description": "The smallest Double such that",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_epsilon",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_epsilon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEuler&#8211;Mascheroni constant (&#947; = 0.57721...)\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_eulerMascheroni",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_eulerMascheroni",
          "type": "function"
        },
        "index": {
          "description": "Euler Mascheroni constant",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_eulerMascheroni",
          "package": "math-functions",
          "partial": "Mascheroni",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_eulerMascheroni"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA very large number.\n\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_huge",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_huge",
          "type": "function"
        },
        "index": {
          "description": "very large number",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_huge",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_huge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003elog(sqrt((2*pi))\u003c/pre\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_ln_sqrt_2_pi",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_ln_sqrt_2_pi",
          "type": "function"
        },
        "index": {
          "description": "log sqrt pi",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_ln_sqrt_2_pi",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_ln_sqrt_2_pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe largest \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e \u003cem\u003ex\u003c/em\u003e such that 2**(\u003cem\u003ex\u003c/em\u003e-1) is approximately\n representable as a \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_max_exp",
          "package": "math-functions",
          "signature": "Int",
          "source": "src/Numeric-MathFunctions-Constants.html#m_max_exp",
          "type": "function"
        },
        "index": {
          "description": "The largest Int such that is approximately representable as Double",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_max_exp",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_max_exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegative infinity.\n\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_neg_inf",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_neg_inf",
          "type": "function"
        },
        "index": {
          "description": "Negative infinity",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_neg_inf",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_neg_inf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePositive infinity.\n\u003c/p\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_pos_inf",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_pos_inf",
          "type": "function"
        },
        "index": {
          "description": "Positive infinity",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_pos_inf",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_pos_inf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003esqrt 2\u003c/pre\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_sqrt_2",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_sqrt_2",
          "type": "function"
        },
        "index": {
          "description": "sqrt",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_sqrt_2",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_sqrt_2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cpre\u003esqrt (2 * pi)\u003c/pre\u003e",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_sqrt_2_pi",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_sqrt_2_pi",
          "type": "function"
        },
        "index": {
          "description": "sqrt pi",
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_sqrt_2_pi",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_sqrt_2_pi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_tiny",
          "package": "math-functions",
          "signature": "Double",
          "source": "src/Numeric-MathFunctions-Constants.html#m_tiny",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric MathFunctions Constants",
          "module": "Numeric.MathFunctions.Constants",
          "name": "m_tiny",
          "package": "math-functions",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-MathFunctions-Constants.html#v:m_tiny"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eChebyshev polynomials.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.Polynomial.Chebyshev",
          "name": "Chebyshev",
          "package": "math-functions",
          "source": "src/Numeric-Polynomial-Chebyshev.html",
          "type": "module"
        },
        "index": {
          "description": "Chebyshev polynomials",
          "hierarchy": "Numeric Polynomial Chebyshev",
          "module": "Numeric.Polynomial.Chebyshev",
          "name": "Chebyshev",
          "package": "math-functions",
          "partial": "Chebyshev",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial-Chebyshev.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a Chebyshev polynomial of the first kind. Uses\n Clenshaw's algorithm.\n\u003c/p\u003e",
          "module": "Numeric.Polynomial.Chebyshev",
          "name": "chebyshev",
          "package": "math-functions",
          "signature": "Double-\u003e v Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Evaluate Chebyshev polynomial of the first kind Uses Clenshaw algorithm",
          "hierarchy": "Numeric Polynomial Chebyshev",
          "module": "Numeric.Polynomial.Chebyshev",
          "name": "chebyshev",
          "normalized": "Double-\u003ea Double-\u003eDouble",
          "package": "math-functions",
          "signature": "Double-\u003ev Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial-Chebyshev.html#v:chebyshev"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate a Chebyshev polynomial of the first kind. Uses Broucke's\n ECHEB algorithm, and his convention for coefficient handling. It\n treat 0th coefficient different so\n\u003c/p\u003e\u003cpre\u003e chebyshev x [a0,a1,a2...] == chebyshevBroucke [2*a0,a1,a2...]\n\u003c/pre\u003e",
          "module": "Numeric.Polynomial.Chebyshev",
          "name": "chebyshevBroucke",
          "package": "math-functions",
          "signature": "Double-\u003e v Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Evaluate Chebyshev polynomial of the first kind Uses Broucke ECHEB algorithm and his convention for coefficient handling It treat th coefficient different so chebyshev a0 a1 a2 chebyshevBroucke a0 a1 a2",
          "hierarchy": "Numeric Polynomial Chebyshev",
          "module": "Numeric.Polynomial.Chebyshev",
          "name": "chebyshevBroucke",
          "normalized": "Double-\u003ea Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Broucke",
          "signature": "Double-\u003ev Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial-Chebyshev.html#v:chebyshevBroucke"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunction for evaluating polynomials using Horher's method.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.Polynomial",
          "name": "Polynomial",
          "package": "math-functions",
          "source": "src/Numeric-Polynomial.html",
          "type": "module"
        },
        "index": {
          "description": "Function for evaluating polynomials using Horher method",
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "Polynomial",
          "package": "math-functions",
          "partial": "Polynomial",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate polynomial with only even powers using Horner's method.\n Coefficients starts from lowest. In pseudocode:\n\u003c/p\u003e\u003cpre\u003e evaluateOddPolynomial x [1,2,3] = 1 + 2*x^2 + 3*x^4\n\u003c/pre\u003e",
          "module": "Numeric.Polynomial",
          "name": "evaluateEvenPolynomial",
          "package": "math-functions",
          "signature": "a-\u003e v a-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Evaluate polynomial with only even powers using Horner method Coefficients starts from lowest In pseudocode evaluateOddPolynomial",
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "evaluateEvenPolynomial",
          "normalized": "a-\u003eb a-\u003ea",
          "package": "math-functions",
          "partial": "Even Polynomial",
          "signature": "a-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateEvenPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Polynomial",
          "name": "evaluateEvenPolynomialL",
          "package": "math-functions",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/Numeric-Polynomial.html#evaluateEvenPolynomialL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "evaluateEvenPolynomialL",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "math-functions",
          "partial": "Even Polynomial",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateEvenPolynomialL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate polynomial with only odd powers using Horner's method.\n Coefficients starts from lowest. In pseudocode:\n\u003c/p\u003e\u003cpre\u003e evaluateOddPolynomial x [1,2,3] = 1*x + 2*x^3 + 3*x^5\n\u003c/pre\u003e",
          "module": "Numeric.Polynomial",
          "name": "evaluateOddPolynomial",
          "package": "math-functions",
          "signature": "a-\u003e v a-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Evaluate polynomial with only odd powers using Horner method Coefficients starts from lowest In pseudocode evaluateOddPolynomial",
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "evaluateOddPolynomial",
          "normalized": "a-\u003eb a-\u003ea",
          "package": "math-functions",
          "partial": "Odd Polynomial",
          "signature": "a-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateOddPolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Polynomial",
          "name": "evaluateOddPolynomialL",
          "package": "math-functions",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/Numeric-Polynomial.html#evaluateOddPolynomialL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "evaluateOddPolynomialL",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "math-functions",
          "partial": "Odd Polynomial",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluateOddPolynomialL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate polynomial using Horner's method. Coefficients starts\n from lowest. In pseudocode:\n\u003c/p\u003e\u003cpre\u003e evaluateOddPolynomial x [1,2,3] = 1 + 2*x + 3*x^2\n\u003c/pre\u003e",
          "module": "Numeric.Polynomial",
          "name": "evaluatePolynomial",
          "package": "math-functions",
          "signature": "a-\u003e v a-\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Evaluate polynomial using Horner method Coefficients starts from lowest In pseudocode evaluateOddPolynomial",
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "evaluatePolynomial",
          "normalized": "a-\u003eb a-\u003ea",
          "package": "math-functions",
          "partial": "Polynomial",
          "signature": "a-\u003ev a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluatePolynomial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Polynomial",
          "name": "evaluatePolynomialL",
          "package": "math-functions",
          "signature": "a -\u003e [a] -\u003e a",
          "source": "src/Numeric-Polynomial.html#evaluatePolynomialL",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Polynomial",
          "module": "Numeric.Polynomial",
          "name": "evaluatePolynomialL",
          "normalized": "a-\u003e[a]-\u003ea",
          "package": "math-functions",
          "partial": "Polynomial",
          "signature": "a-\u003e[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Polynomial.html#v:evaluatePolynomialL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLess common mathematical functions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.SpecFunctions.Extra",
          "name": "Extra",
          "package": "math-functions",
          "source": "src/Numeric-SpecFunctions-Extra.html",
          "type": "module"
        },
        "index": {
          "description": "Less common mathematical functions",
          "hierarchy": "Numeric SpecFunctions Extra",
          "module": "Numeric.SpecFunctions.Extra",
          "name": "Extra",
          "package": "math-functions",
          "partial": "Extra",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions-Extra.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEvaluate the deviance term \u003ccode\u003ex log(x/np) + np - x\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions.Extra",
          "name": "bd0",
          "package": "math-functions",
          "signature": "Double-\u003e Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Evaluate the deviance term log np np",
          "hierarchy": "Numeric SpecFunctions Extra",
          "module": "Numeric.SpecFunctions.Extra",
          "name": "bd0",
          "normalized": "Double-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "signature": "Double-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions-Extra.html#v:bd0"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eSpecial functions and factorials.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "SpecFunctions",
          "package": "math-functions",
          "source": "src/Numeric-SpecFunctions.html",
          "type": "module"
        },
        "index": {
          "description": "Special functions and factorials",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "SpecFunctions",
          "package": "math-functions",
          "partial": "Spec Functions",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the binomial coefficient \u003cem\u003en\u003c/em\u003e \u003ccode\u003e`\u003ccode\u003e\u003ca\u003echoose\u003c/a\u003e\u003c/code\u003e`\u003c/code\u003e \u003cem\u003ek\u003c/em\u003e. For\n values of \u003cem\u003ek\u003c/em\u003e \u003e 30, this uses an approximation for performance\n reasons.  The approximation is accurate to 12 decimal places in the\n worst case\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e 7 `choose` 3 == 35\n\u003c/pre\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "choose",
          "package": "math-functions",
          "signature": "Int -\u003e Int -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#choose",
          "type": "function"
        },
        "index": {
          "description": "Compute the binomial coefficient choose For values of this uses an approximation for performance reasons The approximation is accurate to decimal places in the worst case Example choose",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "choose",
          "normalized": "Int-\u003eInt-\u003eDouble",
          "package": "math-functions",
          "signature": "Int-\u003eInt-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:choose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute &#968;0(\u003cem\u003ex\u003c/em\u003e), the first logarithmic derivative of the gamma\n function. Uses Algorithm AS 103 by Bernardo, based on Minka's C\n implementation.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "digamma",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#digamma",
          "type": "function"
        },
        "index": {
          "description": "Compute the first logarithmic derivative of the gamma function Uses Algorithm AS by Bernardo based on Minka implementation",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "digamma",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:digamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eError function.\n\u003c/p\u003e\u003cpre\u003e erf -&#8734; = -1\n erf  0 =  0\n erf +&#8734; =  1\n\u003c/pre\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "erf",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#erf",
          "type": "function"
        },
        "index": {
          "description": "Error function erf erf erf",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "erf",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:erf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eComplementary error function.\n\u003c/p\u003e\u003cpre\u003e erfc -&#8734; = 2\n erfc  0 = 1\n errc +&#8734; = 0\n\u003c/pre\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "erfc",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#erfc",
          "type": "function"
        },
        "index": {
          "description": "Complementary error function erfc erfc errc",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "erfc",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:erfc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the factorial function \u003cem\u003en\u003c/em\u003e!.  Returns +&#8734; if the\n input is above 170 (above which the result cannot be represented by\n a 64-bit \u003ccode\u003e\u003ca\u003eDouble\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "factorial",
          "package": "math-functions",
          "signature": "Int -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#factorial",
          "type": "function"
        },
        "index": {
          "description": "Compute the factorial function Returns if the input is above above which the result cannot be represented by bit Double",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "factorial",
          "normalized": "Int-\u003eDouble",
          "package": "math-functions",
          "signature": "Int-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:factorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegularized incomplete beta function. Uses algorithm AS63 by\n Majumder and Bhattachrjee and quadrature approximation for large\n \u003cem\u003ep\u003c/em\u003e and \u003cem\u003eq\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "incompleteBeta",
          "package": "math-functions",
          "signature": "Double-\u003e Double-\u003e Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Regularized incomplete beta function Uses algorithm AS63 by Majumder and Bhattachrjee and quadrature approximation for large and",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "incompleteBeta",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "partial": "Beta",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:incompleteBeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegularized incomplete beta function. Same as \u003ccode\u003e\u003ca\u003eincompleteBeta\u003c/a\u003e\u003c/code\u003e\n but also takes logarithm of beta function as parameter.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "incompleteBeta_",
          "package": "math-functions",
          "signature": "Double-\u003e Double-\u003e Double-\u003e Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Regularized incomplete beta function Same as incompleteBeta but also takes logarithm of beta function as parameter",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "incompleteBeta_",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "partial": "Beta",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:incompleteBeta_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the normalized lower incomplete gamma function\n &#947;\u003cem\u003es\u003c/em\u003e,\u003cem\u003ex\u003c/em\u003e). Normalization means that\n &#947;\u003cem\u003es\u003c/em\u003e,&#8734;)=1. Uses Algorithm AS 239 by Shea.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "incompleteGamma",
          "package": "math-functions",
          "signature": "Double-\u003e Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Compute the normalized lower incomplete gamma function Normalization means that Uses Algorithm AS by Shea",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "incompleteGamma",
          "normalized": "Double-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "partial": "Gamma",
          "signature": "Double-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:incompleteGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eerf\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "invErf",
          "package": "math-functions",
          "signature": "Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Inverse of erf",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "invErf",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Erf",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invErf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse of \u003ccode\u003e\u003ca\u003eerfc\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "invErfc",
          "package": "math-functions",
          "signature": "Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Inverse of erfc",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "invErfc",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Erfc",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invErfc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute inverse of regularized incomplete beta function. Uses\n initial approximation from AS109, AS64 and Halley method to solve\n equation.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "invIncompleteBeta",
          "package": "math-functions",
          "signature": "Double-\u003e Double-\u003e Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Compute inverse of regularized incomplete beta function Uses initial approximation from AS109 AS64 and Halley method to solve equation",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "invIncompleteBeta",
          "normalized": "Double-\u003eDouble-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "partial": "Incomplete Beta",
          "signature": "Double-\u003eDouble-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invIncompleteBeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInverse incomplete gamma function. It's approximately inverse of\n   \u003ccode\u003e\u003ca\u003eincompleteGamma\u003c/a\u003e\u003c/code\u003e for the same \u003cem\u003es\u003c/em\u003e. So following equality\n   approximately holds:\n\u003c/p\u003e\u003cpre\u003e invIncompleteGamma s . incompleteGamma s = id\n\u003c/pre\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "invIncompleteGamma",
          "package": "math-functions",
          "signature": "Double-\u003e Double-\u003e Double",
          "type": "function"
        },
        "index": {
          "description": "Inverse incomplete gamma function It approximately inverse of incompleteGamma for the same So following equality approximately holds invIncompleteGamma incompleteGamma id",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "invIncompleteGamma",
          "normalized": "Double-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "partial": "Incomplete Gamma",
          "signature": "Double-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:invIncompleteGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the natural logarithm of 1 + \u003ccode\u003ex\u003c/code\u003e.  This is accurate even\n for values of \u003ccode\u003ex\u003c/code\u003e near zero, where use of \u003ccode\u003elog(1+x)\u003c/code\u003e would lose\n precision.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "log1p",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#log1p",
          "type": "function"
        },
        "index": {
          "description": "Compute the natural logarithm of This is accurate even for values of near zero where use of log would lose precision",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "log1p",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:log1p"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e Compute the logarithm in base 2 of the given value.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "log2",
          "package": "math-functions",
          "signature": "Int -\u003e Int",
          "source": "src/Numeric-SpecFunctions.html#log2",
          "type": "function"
        },
        "index": {
          "description": "log Compute the logarithm in base of the given value",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "log2",
          "normalized": "Int-\u003eInt",
          "package": "math-functions",
          "signature": "Int-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:log2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the natural logarithm of the beta function.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "logBeta",
          "package": "math-functions",
          "signature": "Double -\u003e Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#logBeta",
          "type": "function"
        },
        "index": {
          "description": "Compute the natural logarithm of the beta function",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "logBeta",
          "normalized": "Double-\u003eDouble-\u003eDouble",
          "package": "math-functions",
          "partial": "Beta",
          "signature": "Double-\u003eDouble-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logBeta"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the natural logarithm of the factorial function.  Gives\n 16 decimal digits of precision.\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "logFactorial",
          "package": "math-functions",
          "signature": "a -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#logFactorial",
          "type": "function"
        },
        "index": {
          "description": "Compute the natural logarithm of the factorial function Gives decimal digits of precision",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "logFactorial",
          "normalized": "a-\u003eDouble",
          "package": "math-functions",
          "partial": "Factorial",
          "signature": "a-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logFactorial"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the logarithm of the gamma function &#915;\u003cem\u003ex\u003c/em\u003e).  Uses\n Algorithm AS 245 by Macleod.\n\u003c/p\u003e\u003cp\u003eGives an accuracy of 10-12 significant decimal digits, except\n for small regions around \u003cem\u003ex\u003c/em\u003e = 1 and \u003cem\u003ex\u003c/em\u003e = 2, where the function\n goes to zero.  For greater accuracy, use \u003ccode\u003e\u003ca\u003elogGammaL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eReturns &#8734; if the input is outside of the range (0 \u003c \u003cem\u003ex\u003c/em\u003e &#8804; 1e305).\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "logGamma",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#logGamma",
          "type": "function"
        },
        "index": {
          "description": "Compute the logarithm of the gamma function Uses Algorithm AS by Macleod Gives an accuracy of significant decimal digits except for small regions around and where the function goes to zero For greater accuracy use logGammaL Returns if the input is outside of the range e305",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "logGamma",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Gamma",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logGamma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the logarithm of the gamma function, &#915;(\u003cem\u003ex\u003c/em\u003e).  Uses a\n Lanczos approximation.\n\u003c/p\u003e\u003cp\u003eThis function is slower than \u003ccode\u003e\u003ca\u003elogGamma\u003c/a\u003e\u003c/code\u003e, but gives 14 or more\n significant decimal digits of accuracy, except around \u003cem\u003ex\u003c/em\u003e = 1 and\n \u003cem\u003ex\u003c/em\u003e = 2, where the function goes to zero.\n\u003c/p\u003e\u003cp\u003eReturns &#8734; if the input is outside of the range (0 \u003c \u003cem\u003ex\u003c/em\u003e\n &#8804; 1e305).\n\u003c/p\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "logGammaL",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#logGammaL",
          "type": "function"
        },
        "index": {
          "description": "Compute the logarithm of the gamma function Uses Lanczos approximation This function is slower than logGamma but gives or more significant decimal digits of accuracy except around and where the function goes to zero Returns if the input is outside of the range e305",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "logGammaL",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Gamma",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:logGammaL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCalculate the error term of the Stirling approximation.  This is\n only defined for non-negative values.\n\u003c/p\u003e\u003cpre\u003e stirlingError @n@ = @log(n!) - log(sqrt(2*pi*n)*(n/e)^n)\n\u003c/pre\u003e",
          "module": "Numeric.SpecFunctions",
          "name": "stirlingError",
          "package": "math-functions",
          "signature": "Double -\u003e Double",
          "source": "src/Numeric-SpecFunctions.html#stirlingError",
          "type": "function"
        },
        "index": {
          "description": "Calculate the error term of the Stirling approximation This is only defined for non-negative values stirlingError log log sqrt pi",
          "hierarchy": "Numeric SpecFunctions",
          "module": "Numeric.SpecFunctions",
          "name": "stirlingError",
          "normalized": "Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Error",
          "signature": "Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-SpecFunctions.html#v:stirlingError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFunctions for summing floating point numbers more accurately than\n the naive \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e function and its counterparts in the\n \u003ccode\u003evector\u003c/code\u003e package and elsewhere.\n\u003c/p\u003e\u003cp\u003eWhen used with floating point numbers, in the worst case, the\n \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e function accumulates numeric error at a rate\n proportional to the number of values being summed. The algorithms\n in this module implement different methods of /compensated\n summation/, which reduce the accumulation of numeric error so that\n it either grows much more slowly than the number of inputs\n (e.g. logarithmically), or remains constant.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Numeric.Sum",
          "name": "Sum",
          "package": "math-functions",
          "source": "src/Numeric-Sum.html",
          "type": "module"
        },
        "index": {
          "description": "Functions for summing floating point numbers more accurately than the naive sum function and its counterparts in the vector package and elsewhere When used with floating point numbers in the worst case the sum function accumulates numeric error at rate proportional to the number of values being summed The algorithms in this module implement different methods of compensated summation which reduce the accumulation of numeric error so that it either grows much more slowly than the number of inputs e.g logarithmically or remains constant",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "Sum",
          "package": "math-functions",
          "partial": "Sum",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSecond-order Kahan-Babu&#353;ka summation.  This is more\n computationally costly than Kahan-Babu&#353;ka-Neumaier summation,\n running at about a third the speed.  Its advantage is that it can\n lose less precision (in admittedly obscure cases).\n\u003c/p\u003e\u003cp\u003eThis method compensates for error in both the sum and the\n first-order compensation term, hence the use of \"second order\" in\n the name.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "KB2Sum",
          "package": "math-functions",
          "source": "src/Numeric-Sum.html#KB2Sum",
          "type": "data"
        },
        "index": {
          "description": "Second-order Kahan-Babu ka summation This is more computationally costly than Kahan-Babu ka-Neumaier summation running at about third the speed Its advantage is that it can lose less precision in admittedly obscure cases This method compensates for error in both the sum and the first-order compensation term hence the use of second order in the name",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "KB2Sum",
          "package": "math-functions",
          "partial": "KB Sum",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#t:KB2Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKahan-Babu&#353;ka-Neumaier summation. This is a little more\n computationally costly than plain Kahan summation, but is \u003cem\u003ealways\u003c/em\u003e\n at least as accurate.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "KBNSum",
          "package": "math-functions",
          "source": "src/Numeric-Sum.html#KBNSum",
          "type": "data"
        },
        "index": {
          "description": "Kahan-Babu ka-Neumaier summation This is little more computationally costly than plain Kahan summation but is always at least as accurate",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "KBNSum",
          "package": "math-functions",
          "partial": "KBNSum",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#t:KBNSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eKahan summation. This is the least accurate of the compensated\n summation methods.  In practice, it only beats naive summation for\n inputs with large magnitude.  Kahan summation can be \u003cem\u003eless\u003c/em\u003e\n accurate than naive summation for small-magnitude inputs.\n\u003c/p\u003e\u003cp\u003eThis summation method is included for completeness. Its use is not\n recommended.  In practice, \u003ccode\u003e\u003ca\u003eKBNSum\u003c/a\u003e\u003c/code\u003e is both 30% faster and more\n accurate.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "KahanSum",
          "package": "math-functions",
          "source": "src/Numeric-Sum.html#KahanSum",
          "type": "data"
        },
        "index": {
          "description": "Kahan summation This is the least accurate of the compensated summation methods In practice it only beats naive summation for inputs with large magnitude Kahan summation can be less accurate than naive summation for small-magnitude inputs This summation method is included for completeness Its use is not recommended In practice KBNSum is both faster and more accurate",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "KahanSum",
          "package": "math-functions",
          "partial": "Kahan Sum",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#t:KahanSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class for summation of floating point numbers.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "Summation",
          "package": "math-functions",
          "source": "src/Numeric-Sum.html#Summation",
          "type": "class"
        },
        "index": {
          "description": "class for summation of floating point numbers",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "Summation",
          "package": "math-functions",
          "partial": "Summation",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#t:Summation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Sum",
          "name": "KB2Sum",
          "package": "math-functions",
          "signature": "KB2Sum !Double !Double !Double",
          "source": "src/Numeric-Sum.html#KB2Sum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "KB2Sum",
          "package": "math-functions",
          "partial": "KB Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:KB2Sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Sum",
          "name": "KBNSum",
          "package": "math-functions",
          "signature": "KBNSum !Double !Double",
          "source": "src/Numeric-Sum.html#KBNSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "KBNSum",
          "package": "math-functions",
          "partial": "KBNSum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:KBNSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Numeric.Sum",
          "name": "KahanSum",
          "package": "math-functions",
          "signature": "KahanSum !Double !Double",
          "source": "src/Numeric-Sum.html#KahanSum",
          "type": "function"
        },
        "index": {
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "KahanSum",
          "package": "math-functions",
          "partial": "Kahan Sum",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:KahanSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd a value to a sum.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "add",
          "package": "math-functions",
          "signature": "s -\u003e Double -\u003e s",
          "source": "src/Numeric-Sum.html#add",
          "type": "method"
        },
        "index": {
          "description": "Add value to sum",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "add",
          "normalized": "a-\u003eDouble-\u003ea",
          "package": "math-functions",
          "signature": "s-\u003eDouble-\u003es",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:add"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the result of a Kahan sum.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "kahan",
          "package": "math-functions",
          "signature": "KahanSum -\u003e Double",
          "source": "src/Numeric-Sum.html#kahan",
          "type": "function"
        },
        "index": {
          "description": "Return the result of Kahan sum",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "kahan",
          "normalized": "KahanSum-\u003eDouble",
          "package": "math-functions",
          "signature": "KahanSum-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:kahan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the result of an order-2 Kahan-Babu&#353;ka sum.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "kb2",
          "package": "math-functions",
          "signature": "KB2Sum -\u003e Double",
          "source": "src/Numeric-Sum.html#kb2",
          "type": "function"
        },
        "index": {
          "description": "Return the result of an order-2 Kahan-Babu ka sum",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "kb2",
          "normalized": "KB Sum-\u003eDouble",
          "package": "math-functions",
          "signature": "KB Sum-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:kb2"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the result of a Kahan-Babu&#353;ka-Neumaier sum.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "kbn",
          "package": "math-functions",
          "signature": "KBNSum -\u003e Double",
          "source": "src/Numeric-Sum.html#kbn",
          "type": "function"
        },
        "index": {
          "description": "Return the result of Kahan-Babu ka-Neumaier sum",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "kbn",
          "normalized": "KBNSum-\u003eDouble",
          "package": "math-functions",
          "signature": "KBNSum-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:kbn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Sum a vector of values using pairwise summation.\n\u003c/p\u003e\u003cp\u003eThis approach is perhaps 10% faster than \u003ccode\u003e\u003ca\u003eKBNSum\u003c/a\u003e\u003c/code\u003e, but has poorer\n bounds on its error growth.  Instead of having roughly constant\n error regardless of the size of the input vector, in the worst case\n its accumulated error grows with \u003cem\u003eO(log n)\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "pairwiseSum",
          "package": "math-functions",
          "signature": "v Double -\u003e Double",
          "source": "src/Numeric-Sum.html#pairwiseSum",
          "type": "function"
        },
        "index": {
          "description": "Sum vector of values using pairwise summation This approach is perhaps faster than KBNSum but has poorer bounds on its error growth Instead of having roughly constant error regardless of the size of the input vector in the worst case its accumulated error grows with log",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "pairwiseSum",
          "normalized": "a Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Sum",
          "signature": "v Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:pairwiseSum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSum a collection of values.\n\u003c/p\u003e\u003cp\u003eExample:\n \u003ccode\u003efoo = \u003ccode\u003e\u003ca\u003esum\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003ekbn\u003c/a\u003e\u003c/code\u003e [1,2,3]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "sum",
          "package": "math-functions",
          "signature": "(s -\u003e Double) -\u003e f Double -\u003e Double",
          "source": "src/Numeric-Sum.html#sum",
          "type": "method"
        },
        "index": {
          "description": "Sum collection of values Example foo sum kbn",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "sum",
          "normalized": "(a-\u003eDouble)-\u003eb Double-\u003eDouble",
          "package": "math-functions",
          "signature": "(s-\u003eDouble)-\u003ef Double-\u003eDouble",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:sum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e Sum a vector of values.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "sumVector",
          "package": "math-functions",
          "signature": "(s -\u003e Double) -\u003e v Double -\u003e Double",
          "source": "src/Numeric-Sum.html#sumVector",
          "type": "function"
        },
        "index": {
          "description": "Sum vector of values",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "sumVector",
          "normalized": "(a-\u003eDouble)-\u003eb Double-\u003eDouble",
          "package": "math-functions",
          "partial": "Vector",
          "signature": "(s-\u003eDouble)-\u003ev Double-\u003eDouble",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:sumVector"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe identity for summation.\n\u003c/p\u003e",
          "module": "Numeric.Sum",
          "name": "zero",
          "package": "math-functions",
          "signature": "s",
          "source": "src/Numeric-Sum.html#zero",
          "type": "method"
        },
        "index": {
          "description": "The identity for summation",
          "hierarchy": "Numeric Sum",
          "module": "Numeric.Sum",
          "name": "zero",
          "package": "math-functions",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/math-functions/docs/Numeric-Sum.html#v:zero"
      }
    }
  ]
]