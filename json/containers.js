[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "containers"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA version of the graph algorithms described in:\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eStructuring Depth-First Search Algorithms in Haskell\u003c/em\u003e,\n   by David King and John Launchbury.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Graph",
          "name": "Graph",
          "package": "containers",
          "source": "src/Data-Graph.html",
          "type": "module"
        },
        "index": {
          "description": "version of the graph algorithms described in Structuring Depth-First Search Algorithms in Haskell by David King and John Launchbury",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "Graph",
          "package": "containers",
          "partial": "Graph",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe bounds of a \u003ccode\u003e\u003ca\u003eTable\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "Bounds",
          "package": "containers",
          "source": "src/Data-Graph.html#Bounds",
          "type": "type"
        },
        "index": {
          "description": "The bounds of Table",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "Bounds",
          "package": "containers",
          "partial": "Bounds",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#t:Bounds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn edge from the first vertex to the second.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "Edge",
          "package": "containers",
          "source": "src/Data-Graph.html#Edge",
          "type": "type"
        },
        "index": {
          "description": "An edge from the first vertex to the second",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "Edge",
          "package": "containers",
          "partial": "Edge",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#t:Edge"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdjacency list representation of a graph, mapping each vertex to its\n list of successors.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "Graph",
          "package": "containers",
          "source": "src/Data-Graph.html#Graph",
          "type": "type"
        },
        "index": {
          "description": "Adjacency list representation of graph mapping each vertex to its list of successors",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "Graph",
          "package": "containers",
          "partial": "Graph",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#t:Graph"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStrongly connected component.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "SCC",
          "package": "containers",
          "source": "src/Data-Graph.html#SCC",
          "type": "data"
        },
        "index": {
          "description": "Strongly connected component",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "SCC",
          "package": "containers",
          "partial": "SCC",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#t:SCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTable indexed by a contiguous set of vertices.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "Table",
          "package": "containers",
          "source": "src/Data-Graph.html#Table",
          "type": "type"
        },
        "index": {
          "description": "Table indexed by contiguous set of vertices",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "Table",
          "package": "containers",
          "partial": "Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#t:Table"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAbstract representation of vertices.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "Vertex",
          "package": "containers",
          "source": "src/Data-Graph.html#Vertex",
          "type": "type"
        },
        "index": {
          "description": "Abstract representation of vertices",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "Vertex",
          "package": "containers",
          "partial": "Vertex",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#t:Vertex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single vertex that is not\n in any cycle.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "AcyclicSCC",
          "package": "containers",
          "signature": "AcyclicSCC vertex",
          "source": "src/Data-Graph.html#SCC",
          "type": "function"
        },
        "index": {
          "description": "single vertex that is not in any cycle",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "AcyclicSCC",
          "package": "containers",
          "partial": "Acyclic SCC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:AcyclicSCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA maximal set of mutually\n reachable vertices.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "CyclicSCC",
          "package": "containers",
          "signature": "CyclicSCC [vertex]",
          "source": "src/Data-Graph.html#SCC",
          "type": "function"
        },
        "index": {
          "description": "maximal set of mutually reachable vertices",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "CyclicSCC",
          "normalized": "CyclicSCC[a]",
          "package": "containers",
          "partial": "Cyclic SCC",
          "signature": "CyclicSCC[vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:CyclicSCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe biconnected components of a graph.\n An undirected graph is biconnected if the deletion of any vertex\n leaves it connected.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "bcc",
          "package": "containers",
          "signature": "Graph -\u003e Forest [Vertex]",
          "source": "src/Data-Graph.html#bcc",
          "type": "function"
        },
        "index": {
          "description": "The biconnected components of graph An undirected graph is biconnected if the deletion of any vertex leaves it connected",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "bcc",
          "normalized": "Graph-\u003eForest[Vertex]",
          "package": "containers",
          "signature": "Graph-\u003eForest[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:bcc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a graph from a list of edges.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "buildG",
          "package": "containers",
          "signature": "Bounds -\u003e [Edge] -\u003e Graph",
          "source": "src/Data-Graph.html#buildG",
          "type": "function"
        },
        "index": {
          "description": "Build graph from list of edges",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "buildG",
          "normalized": "Bounds-\u003e[Edge]-\u003eGraph",
          "package": "containers",
          "signature": "Bounds-\u003e[Edge]-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:buildG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe connected components of a graph.\n Two vertices are connected if there is a path between them, traversing\n edges in either direction.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "components",
          "package": "containers",
          "signature": "Graph -\u003e Forest Vertex",
          "source": "src/Data-Graph.html#components",
          "type": "function"
        },
        "index": {
          "description": "The connected components of graph Two vertices are connected if there is path between them traversing edges in either direction",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "components",
          "normalized": "Graph-\u003eForest Vertex",
          "package": "containers",
          "signature": "Graph-\u003eForest Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:components"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA spanning forest of the graph, obtained from a depth-first search of\n the graph starting from each vertex in an unspecified order.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "dff",
          "package": "containers",
          "signature": "Graph -\u003e Forest Vertex",
          "source": "src/Data-Graph.html#dff",
          "type": "function"
        },
        "index": {
          "description": "spanning forest of the graph obtained from depth-first search of the graph starting from each vertex in an unspecified order",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "dff",
          "normalized": "Graph-\u003eForest Vertex",
          "package": "containers",
          "signature": "Graph-\u003eForest Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:dff"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA spanning forest of the part of the graph reachable from the listed\n vertices, obtained from a depth-first search of the graph starting at\n each of the listed vertices in order.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "dfs",
          "package": "containers",
          "signature": "Graph -\u003e [Vertex] -\u003e Forest Vertex",
          "source": "src/Data-Graph.html#dfs",
          "type": "function"
        },
        "index": {
          "description": "spanning forest of the part of the graph reachable from the listed vertices obtained from depth-first search of the graph starting at each of the listed vertices in order",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "dfs",
          "normalized": "Graph-\u003e[Vertex]-\u003eForest Vertex",
          "package": "containers",
          "signature": "Graph-\u003e[Vertex]-\u003eForest Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:dfs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll edges of a graph.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "edges",
          "package": "containers",
          "signature": "Graph -\u003e [Edge]",
          "source": "src/Data-Graph.html#edges",
          "type": "function"
        },
        "index": {
          "description": "All edges of graph",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "edges",
          "normalized": "Graph-\u003e[Edge]",
          "package": "containers",
          "signature": "Graph-\u003e[Edge]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:edges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe vertices of a strongly connected component.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "flattenSCC",
          "package": "containers",
          "signature": "SCC vertex -\u003e [vertex]",
          "source": "src/Data-Graph.html#flattenSCC",
          "type": "function"
        },
        "index": {
          "description": "The vertices of strongly connected component",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "flattenSCC",
          "normalized": "SCC a-\u003e[a]",
          "package": "containers",
          "partial": "SCC",
          "signature": "SCC vertex-\u003e[vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:flattenSCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe vertices of a list of strongly connected components.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "flattenSCCs",
          "package": "containers",
          "signature": "[SCC a] -\u003e [a]",
          "source": "src/Data-Graph.html#flattenSCCs",
          "type": "function"
        },
        "index": {
          "description": "The vertices of list of strongly connected components",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "flattenSCCs",
          "normalized": "[SCC a]-\u003e[a]",
          "package": "containers",
          "partial": "SCCs",
          "signature": "[SCC a]-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:flattenSCCs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a graph from a list of nodes uniquely identified by keys,\n with a list of keys of nodes this node should have edges to.\n The out-list may contain keys that don't correspond to\n nodes of the graph; they are ignored.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "graphFromEdges",
          "package": "containers",
          "signature": "[(node, key, [key])] -\u003e (Graph, Vertex -\u003e (node, key, [key]), key -\u003e Maybe Vertex)",
          "source": "src/Data-Graph.html#graphFromEdges",
          "type": "function"
        },
        "index": {
          "description": "Build graph from list of nodes uniquely identified by keys with list of keys of nodes this node should have edges to The out-list may contain keys that don correspond to nodes of the graph they are ignored",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "graphFromEdges",
          "normalized": "[(a,b,[b])]-\u003e(Graph,Vertex-\u003e(a,b,[b]),b-\u003eMaybe Vertex)",
          "package": "containers",
          "partial": "From Edges",
          "signature": "[(node,key,[key])]-\u003e(Graph,Vertex-\u003e(node,key,[key]),key-\u003eMaybe Vertex)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:graphFromEdges"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentical to \u003ccode\u003e\u003ca\u003egraphFromEdges\u003c/a\u003e\u003c/code\u003e, except that the return value\n does not include the function which maps keys to vertices.  This\n version of \u003ccode\u003e\u003ca\u003egraphFromEdges\u003c/a\u003e\u003c/code\u003e is for backwards compatibility.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "graphFromEdges'",
          "package": "containers",
          "signature": "[(node, key, [key])] -\u003e (Graph, Vertex -\u003e (node, key, [key]))",
          "source": "src/Data-Graph.html#graphFromEdges%27",
          "type": "function"
        },
        "index": {
          "description": "Identical to graphFromEdges except that the return value does not include the function which maps keys to vertices This version of graphFromEdges is for backwards compatibility",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "graphFromEdges'",
          "normalized": "[(a,b,[b])]-\u003e(Graph,Vertex-\u003e(a,b,[b]))",
          "package": "containers",
          "partial": "From Edges'",
          "signature": "[(node,key,[key])]-\u003e(Graph,Vertex-\u003e(node,key,[key]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:graphFromEdges-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA table of the count of edges into each node.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "indegree",
          "package": "containers",
          "signature": "Graph -\u003e Table Int",
          "source": "src/Data-Graph.html#indegree",
          "type": "function"
        },
        "index": {
          "description": "table of the count of edges into each node",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "indegree",
          "normalized": "Graph-\u003eTable Int",
          "package": "containers",
          "signature": "Graph-\u003eTable Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:indegree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA table of the count of edges from each node.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "outdegree",
          "package": "containers",
          "signature": "Graph -\u003e Table Int",
          "source": "src/Data-Graph.html#outdegree",
          "type": "function"
        },
        "index": {
          "description": "table of the count of edges from each node",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "outdegree",
          "normalized": "Graph-\u003eTable Int",
          "package": "containers",
          "signature": "Graph-\u003eTable Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:outdegree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs the second vertex reachable from the first?\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "path",
          "package": "containers",
          "signature": "Graph -\u003e Vertex -\u003e Vertex -\u003e Bool",
          "source": "src/Data-Graph.html#path",
          "type": "function"
        },
        "index": {
          "description": "Is the second vertex reachable from the first",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "path",
          "normalized": "Graph-\u003eVertex-\u003eVertex-\u003eBool",
          "package": "containers",
          "signature": "Graph-\u003eVertex-\u003eVertex-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:path"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list of vertices reachable from a given vertex.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "reachable",
          "package": "containers",
          "signature": "Graph -\u003e Vertex -\u003e [Vertex]",
          "source": "src/Data-Graph.html#reachable",
          "type": "function"
        },
        "index": {
          "description": "list of vertices reachable from given vertex",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "reachable",
          "normalized": "Graph-\u003eVertex-\u003e[Vertex]",
          "package": "containers",
          "signature": "Graph-\u003eVertex-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:reachable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strongly connected components of a graph.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "scc",
          "package": "containers",
          "signature": "Graph -\u003e Forest Vertex",
          "source": "src/Data-Graph.html#scc",
          "type": "function"
        },
        "index": {
          "description": "The strongly connected components of graph",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "scc",
          "normalized": "Graph-\u003eForest Vertex",
          "package": "containers",
          "signature": "Graph-\u003eForest Vertex",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:scc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strongly connected components of a directed graph, topologically\n sorted.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "stronglyConnComp",
          "package": "containers",
          "signature": "[(node, key, [key])]-\u003e [SCC node]",
          "type": "function"
        },
        "index": {
          "description": "The strongly connected components of directed graph topologically sorted",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "stronglyConnComp",
          "normalized": "[(a,b,[b])]-\u003e[SCC a]",
          "package": "containers",
          "partial": "Conn Comp",
          "signature": "[(node,key,[key])]-\u003e[SCC node]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:stronglyConnComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe strongly connected components of a directed graph, topologically\n sorted.  The function is the same as \u003ccode\u003e\u003ca\u003estronglyConnComp\u003c/a\u003e\u003c/code\u003e, except that\n all the information about each node retained.\n This interface is used when you expect to apply \u003ccode\u003e\u003ca\u003eSCC\u003c/a\u003e\u003c/code\u003e to\n (some of) the result of \u003ccode\u003e\u003ca\u003eSCC\u003c/a\u003e\u003c/code\u003e, so you don't want to lose the\n dependency information.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "stronglyConnCompR",
          "package": "containers",
          "signature": "[(node, key, [key])]-\u003e [SCC (node, key, [key])]",
          "type": "function"
        },
        "index": {
          "description": "The strongly connected components of directed graph topologically sorted The function is the same as stronglyConnComp except that all the information about each node retained This interface is used when you expect to apply SCC to some of the result of SCC so you don want to lose the dependency information",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "stronglyConnCompR",
          "normalized": "[(a,b,[b])]-\u003e[SCC(a,b,[b])]",
          "package": "containers",
          "partial": "Conn Comp",
          "signature": "[(node,key,[key])]-\u003e[SCC(node,key,[key])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:stronglyConnCompR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA topological sort of the graph.\n The order is partially specified by the condition that a vertex \u003cem\u003ei\u003c/em\u003e\n precedes \u003cem\u003ej\u003c/em\u003e whenever \u003cem\u003ej\u003c/em\u003e is reachable from \u003cem\u003ei\u003c/em\u003e but not vice versa.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "topSort",
          "package": "containers",
          "signature": "Graph -\u003e [Vertex]",
          "source": "src/Data-Graph.html#topSort",
          "type": "function"
        },
        "index": {
          "description": "topological sort of the graph The order is partially specified by the condition that vertex precedes whenever is reachable from but not vice versa",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "topSort",
          "normalized": "Graph-\u003e[Vertex]",
          "package": "containers",
          "partial": "Sort",
          "signature": "Graph-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:topSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe graph obtained by reversing all edges.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "transposeG",
          "package": "containers",
          "signature": "Graph -\u003e Graph",
          "source": "src/Data-Graph.html#transposeG",
          "type": "function"
        },
        "index": {
          "description": "The graph obtained by reversing all edges",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "transposeG",
          "normalized": "Graph-\u003eGraph",
          "package": "containers",
          "signature": "Graph-\u003eGraph",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:transposeG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll vertices of a graph.\n\u003c/p\u003e",
          "module": "Data.Graph",
          "name": "vertices",
          "package": "containers",
          "signature": "Graph -\u003e [Vertex]",
          "source": "src/Data-Graph.html#vertices",
          "type": "function"
        },
        "index": {
          "description": "All vertices of graph",
          "hierarchy": "Data Graph",
          "module": "Data.Graph",
          "name": "vertices",
          "normalized": "Graph-\u003e[Vertex]",
          "package": "containers",
          "signature": "Graph-\u003e[Vertex]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Graph.html#v:vertices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of maps from integer keys to values\n (dictionaries).\n\u003c/p\u003e\u003cp\u003eAPI of this module is strict in the keys, but lazy in the values.\n If you need value-strict maps, use \u003ca\u003eData.IntMap.Strict\u003c/a\u003e instead.\n The \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e type itself is shared between the lazy and strict modules,\n meaning that the same \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e value can be passed to functions in\n both modules (although that is rarely needed).\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import Data.IntMap.Lazy (IntMap)\n  import qualified Data.IntMap.Lazy as IntMap\n\u003c/pre\u003e\u003cp\u003eThe implementation is based on \u003cem\u003ebig-endian patricia trees\u003c/em\u003e.  This data\n structure performs especially well on binary operations like \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e.  However, my benchmarks show that it is also\n (much) faster on insertions and deletions when compared to a generic\n size-balanced map implementation (see \u003ca\u003eData.Map\u003c/a\u003e).\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Chris Okasaki and Andy Gill,  \"\u003cem\u003eFast Mergeable Integer Maps\u003c/em\u003e\",\n      Workshop on ML, September 1998, pages 77-86,\n      \u003ca\u003ehttp://citeseer.ist.psu.edu/okasaki98fast.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve\n      Information Coded In Alphanumeric/\", Journal of the ACM, 15(4),\n      October 1968, pages 514-534.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOperation comments contain the operation time complexity in\n the Big-O notation \u003ca\u003ehttp://en.wikipedia.org/wiki/Big_O_notation\u003c/a\u003e.\n Many operations have a worst-case complexity of \u003cem\u003eO(min(n,W))\u003c/em\u003e.\n This means that the operation can become linear in the number of\n elements with a maximum of \u003cem\u003eW\u003c/em\u003e -- the number of bits in an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n (32 or 64).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "Lazy",
          "package": "containers",
          "source": "src/Data-IntMap-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of maps from integer keys to values dictionaries API of this module is strict in the keys but lazy in the values If you need value-strict maps use Data.IntMap.Strict instead The IntMap type itself is shared between the lazy and strict modules meaning that the same IntMap value can be passed to functions in both modules although that is rarely needed These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import Data.IntMap.Lazy IntMap import qualified Data.IntMap.Lazy as IntMap The implementation is based on big-endian patricia trees This data structure performs especially well on binary operations like union and intersection However my benchmarks show that it is also much faster on insertions and deletions when compared to generic size-balanced map implementation see Data.Map Chris Okasaki and Andy Gill Fast Mergeable Integer Maps Workshop on ML September pages http citeseer.ist.psu.edu okasaki98fast.html D.R Morrison PATRICIA Practical Algorithm To Retrieve Information Coded In Alphanumeric Journal of the ACM October pages Operation comments contain the operation time complexity in the Big-O notation http en.wikipedia.org wiki Big notation Many operations have worst-case complexity of min This means that the operation can become linear in the number of elements with maximum of the number of bits in an Int or",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "Lazy",
          "package": "containers",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map of integers to values \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "IntMap",
          "package": "containers",
          "source": "src/Data-IntMap-Base.html#IntMap",
          "type": "data"
        },
        "index": {
          "description": "map of integers to values",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "IntMap",
          "package": "containers",
          "partial": "Int Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#t:IntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.Lazy",
          "name": "Key",
          "package": "containers",
          "source": "src/Data-IntSet-Base.html#Key",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "Key",
          "package": "containers",
          "partial": "Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Find the value at a key.\n Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e when the element can not be found.\n\u003c/p\u003e\u003cpre\u003e fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map\n fromList [(5,'a'), (3,'b')] ! 5 == 'a'\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "(!)",
          "package": "containers",
          "signature": "IntMap a -\u003e Key -\u003e a",
          "source": "src/Data-IntMap-Base.html#%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:-33-\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:-33-\"]"
        },
        "index": {
          "description": "min Find the value at key Calls error when the element can not be found fromList Error element not in the map fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "(!) !",
          "normalized": "IntMap a-\u003eKey-\u003ea",
          "package": "containers",
          "signature": "IntMap a-\u003eKey-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "(\\\\)",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#%5C%5C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:-92--92-\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:-92--92-\"]"
        },
        "index": {
          "description": "Same as difference",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "(\\\\) \\\\",
          "normalized": "IntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "signature": "IntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Adjust a value at a specific key. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e adjust (\"new \" ++) 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n adjust (\"new \" ++) 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjust (\"new \" ++) 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "adjust",
          "package": "containers",
          "signature": "(a -\u003e a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#adjust",
          "type": "function"
        },
        "index": {
          "description": "min Adjust value at specific key When the key is not member of the map the original map is returned adjust new fromList fromList new adjust new fromList fromList adjust new empty empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(a-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Adjust a value at a specific key. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":new \" ++ x\n adjustWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n adjustWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjustWithKey f 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "adjustWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#adjustWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Adjust value at specific key When the key is not member of the map the original map is returned let key show key new adjustWithKey fromList fromList new adjustWithKey fromList fromList adjustWithKey empty empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "adjustWithKey",
          "normalized": "(Key-\u003ea-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:adjustWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) alters the value \u003ccode\u003ex\u003c/code\u003e at \u003ccode\u003ek\u003c/code\u003e, or absence thereof.\n \u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e can be used to insert, delete, or update a value in an \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e.\n In short : \u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k (\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k m) = f (\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k m)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "alter",
          "package": "containers",
          "signature": "(Maybe a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#alter",
          "type": "function"
        },
        "index": {
          "description": "min The expression alter map alters the value at or absence thereof alter can be used to insert delete or update value in an IntMap In short lookup alter lookup",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "alter",
          "normalized": "(Maybe a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(Maybe a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:alter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. An alias for \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e. Returns all key/value pairs in the\n map in ascending key order. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e assocs (fromList [(5,\"a\"), (3,\"b\")]) == [(3,\"b\"), (5,\"a\")]\n assocs empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "assocs",
          "package": "containers",
          "signature": "IntMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-Base.html#assocs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:assocs\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:assocs\"]"
        },
        "index": {
          "description": "An alias for toAscList Returns all key value pairs in the map in ascending key order Subject to list fusion assocs fromList assocs empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "assocs",
          "normalized": "IntMap a-\u003e[(Key,a)]",
          "package": "containers",
          "signature": "IntMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:assocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete a key and its value from the map. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e delete 5 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n delete 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n delete 5 empty                         == empty\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "delete",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#delete",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:delete\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:delete\"]"
        },
        "index": {
          "description": "min Delete key and its value from the map When the key is not member of the map the original map is returned delete fromList singleton delete fromList fromList delete empty empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "delete",
          "normalized": "Key-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "Key-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete and find the maximal element.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "deleteFindMax",
          "package": "containers",
          "signature": "IntMap a -\u003e ((Key, a), IntMap a)",
          "source": "src/Data-IntMap-Base.html#deleteFindMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteFindMax\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:deleteFindMax\"]"
        },
        "index": {
          "description": "min Delete and find the maximal element",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "deleteFindMax",
          "normalized": "IntMap a-\u003e((Key,a),IntMap a)",
          "package": "containers",
          "partial": "Find Max",
          "signature": "IntMap a-\u003e((Key,a),IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteFindMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete and find the minimal element.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "deleteFindMin",
          "package": "containers",
          "signature": "IntMap a -\u003e ((Key, a), IntMap a)",
          "source": "src/Data-IntMap-Base.html#deleteFindMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteFindMin\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:deleteFindMin\"]"
        },
        "index": {
          "description": "min Delete and find the minimal element",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "deleteFindMin",
          "normalized": "IntMap a-\u003e((Key,a),IntMap a)",
          "package": "containers",
          "partial": "Find Min",
          "signature": "IntMap a-\u003e((Key,a),IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteFindMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete the maximal key. Returns an empty map if the map is empty.\n\u003c/p\u003e\u003cp\u003eNote that this is a change of behaviour for consistency with \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e &#8211;\n versions prior to 0.5 threw an error if the \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e was already empty.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "deleteMax",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#deleteMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteMax\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:deleteMax\"]"
        },
        "index": {
          "description": "min Delete the maximal key Returns an empty map if the map is empty Note that this is change of behaviour for consistency with Map versions prior to threw an error if the IntMap was already empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "deleteMax",
          "normalized": "IntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Max",
          "signature": "IntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete the minimal key. Returns an empty map if the map is empty.\n\u003c/p\u003e\u003cp\u003eNote that this is a change of behaviour for consistency with \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e &#8211;\n versions prior to 0.5 threw an error if the \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e was already empty.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "deleteMin",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#deleteMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteMin\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:deleteMin\"]"
        },
        "index": {
          "description": "min Delete the minimal key Returns an empty map if the map is empty Note that this is change of behaviour for consistency with Map versions prior to threw an error if the IntMap was already empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "deleteMin",
          "normalized": "IntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Min",
          "signature": "IntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:deleteMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference between two maps (based on keys).\n\u003c/p\u003e\u003cpre\u003e difference (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "difference",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#difference",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:difference\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:difference\"]"
        },
        "index": {
          "description": "Difference between two maps based on keys difference fromList fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "difference",
          "normalized": "IntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "signature": "IntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function.\n\u003c/p\u003e\u003cpre\u003e let f al ar = if al == \"b\" then Just (al ++ \":\" ++ ar) else Nothing\n differenceWith f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (7, \"C\")])\n     == singleton 3 \"b:B\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "differenceWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#differenceWith",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function let al ar if al then Just al ar else Nothing differenceWith fromList fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "differenceWith",
          "normalized": "(a-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function. When two equal keys are\n encountered, the combining function is applied to the key and both values.\n If it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is discarded (proper set difference).\n If it returns (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the element is updated with a new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = if al == \"b\" then Just ((show k) ++ \":\" ++ al ++ \"|\" ++ ar) else Nothing\n differenceWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (10, \"C\")])\n     == singleton 3 \"3:b|B\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "differenceWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#differenceWithKey",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function When two equal keys are encountered the combining function is applied to the key and both values If it returns Nothing the element is discarded proper set difference If it returns Just the element is updated with new value let al ar if al then Just show al ar else Nothing differenceWithKey fromList fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "differenceWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:differenceWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.\n Return all elements of the map in the ascending order of their keys.\n Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e elems (fromList [(5,\"a\"), (3,\"b\")]) == [\"b\",\"a\"]\n elems empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "elems",
          "package": "containers",
          "signature": "IntMap a -\u003e [a]",
          "source": "src/Data-IntMap-Base.html#elems",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:elems\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:elems\"]"
        },
        "index": {
          "description": "Return all elements of the map in the ascending order of their keys Subject to list fusion elems fromList elems empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "elems",
          "normalized": "IntMap a-\u003e[a]",
          "package": "containers",
          "signature": "IntMap a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The empty map.\n\u003c/p\u003e\u003cpre\u003e empty      == fromList []\n size empty == 0\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "empty",
          "package": "containers",
          "signature": "IntMap a",
          "source": "src/Data-IntMap-Base.html#empty",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:empty\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:empty\"]"
        },
        "index": {
          "description": "The empty map empty fromList size empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "empty",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Filter all values that satisfy some predicate.\n\u003c/p\u003e\u003cpre\u003e filter (\u003e \"a\") (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n filter (\u003e \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == empty\n filter (\u003c \"a\") (fromList [(5,\"a\"), (3,\"b\")]) == empty\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "filter",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#filter",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:filter\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:filter\"]"
        },
        "index": {
          "description": "Filter all values that satisfy some predicate filter fromList singleton filter fromList empty filter fromList empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Filter all keys/values that satisfy some predicate.\n\u003c/p\u003e\u003cpre\u003e filterWithKey (\\k _ -\u003e k \u003e 4) (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "filterWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Bool) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#filterWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:filterWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:filterWithKey\"]"
        },
        "index": {
          "description": "Filter all keys values that satisfy some predicate filterWithKey fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "filterWithKey",
          "normalized": "(Key-\u003ea-\u003eBool)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eBool)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:filterWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The maximal key of the map.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "findMax",
          "package": "containers",
          "signature": "IntMap a -\u003e (Key, a)",
          "source": "src/Data-IntMap-Base.html#findMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:findMax\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:findMax\"]"
        },
        "index": {
          "description": "min The maximal key of the map",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "findMax",
          "normalized": "IntMap a-\u003e(Key,a)",
          "package": "containers",
          "partial": "Max",
          "signature": "IntMap a-\u003e(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:findMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The minimal key of the map.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "findMin",
          "package": "containers",
          "signature": "IntMap a -\u003e (Key, a)",
          "source": "src/Data-IntMap-Base.html#findMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:findMin\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:findMin\"]"
        },
        "index": {
          "description": "min The minimal key of the map",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "findMin",
          "normalized": "IntMap a-\u003e(Key,a)",
          "package": "containers",
          "partial": "Min",
          "signature": "IntMap a-\u003e(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:findMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression \u003ccode\u003e(\u003ccode\u003e\u003ca\u003efindWithDefault\u003c/a\u003e\u003c/code\u003e def k map)\u003c/code\u003e\n returns the value at key \u003ccode\u003ek\u003c/code\u003e or returns \u003ccode\u003edef\u003c/code\u003e when the key is not an\n element of the map.\n\u003c/p\u003e\u003cpre\u003e findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'\n findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "findWithDefault",
          "package": "containers",
          "signature": "a -\u003e Key -\u003e IntMap a -\u003e a",
          "source": "src/Data-IntMap-Base.html#findWithDefault",
          "type": "function"
        },
        "index": {
          "description": "min The expression findWithDefault def map returns the value at key or returns def when the key is not an element of the map findWithDefault fromList findWithDefault fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "findWithDefault",
          "normalized": "a-\u003eKey-\u003eIntMap a-\u003ea",
          "package": "containers",
          "partial": "With Default",
          "signature": "a-\u003eKey-\u003eIntMap a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:findWithDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given monoid, such that\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldMapWithKey\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003efold\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003emapWithKey\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003cp\u003eThis can be an asymptotically faster than \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efoldlWithKey\u003c/a\u003e\u003c/code\u003e for some monoids.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldMapWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e m) -\u003e IntMap a -\u003e m",
          "source": "src/Data-IntMap-Base.html#foldMapWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldMapWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldMapWithKey\"]"
        },
        "index": {
          "description": "Fold the keys and values in the map using the given monoid such that foldMapWithKey fold mapWithKey This can be an asymptotically faster than foldrWithKey or foldlWithKey for some monoids",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldMapWithKey",
          "normalized": "(Key-\u003ea-\u003eb)-\u003eIntMap a-\u003eb",
          "package": "containers",
          "partial": "Map With Key",
          "signature": "(Key-\u003ea-\u003em)-\u003eIntMap a-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldMapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the values in the map using the given left-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003eelems\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e elems = reverse . foldl (flip (:)) []\n\u003c/pre\u003e\u003cpre\u003e let f len a = len + (length a)\n foldl f 0 (fromList [(5,\"a\"), (3,\"bbb\")]) == 4\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldl",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e IntMap b -\u003e a",
          "source": "src/Data-IntMap-Base.html#foldl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldl\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldl\"]"
        },
        "index": {
          "description": "Fold the values in the map using the given left-associative binary operator such that foldl foldl elems For example elems reverse foldl flip let len len length foldl fromList bbb",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldl'",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e IntMap b -\u003e a",
          "source": "src/Data-IntMap-Base.html#foldl%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldl-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldl-39-\"]"
        },
        "index": {
          "description": "strict version of foldl Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given left-associative\n binary operator, such that\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldlWithKey\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e (\\z' (kx, x) -\u003e f z' kx x) z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e keys = reverse . foldlWithKey (\\ks k x -\u003e k:ks) []\n\u003c/pre\u003e\u003cpre\u003e let f result k a = result ++ \"(\" ++ (show k) ++ \":\" ++ a ++ \")\"\n foldlWithKey f \"Map: \" (fromList [(5,\"a\"), (3,\"b\")]) == \"Map: (3:b)(5:a)\"\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldlWithKey",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e b -\u003e a) -\u003e a -\u003e IntMap b -\u003e a",
          "source": "src/Data-IntMap-Base.html#foldlWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldlWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldlWithKey\"]"
        },
        "index": {
          "description": "Fold the keys and values in the map using the given left-associative binary operator such that foldlWithKey foldl kx kx toAscList For example keys reverse foldlWithKey ks ks let result result show foldlWithKey Map fromList Map",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldlWithKey",
          "normalized": "(a-\u003eKey-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "package": "containers",
          "partial": "With Key",
          "signature": "(a-\u003eKey-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldlWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldlWithKey\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldlWithKey'",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e b -\u003e a) -\u003e a -\u003e IntMap b -\u003e a",
          "source": "src/Data-IntMap-Base.html#foldlWithKey%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldlWithKey-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldlWithKey-39-\"]"
        },
        "index": {
          "description": "strict version of foldlWithKey Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldlWithKey'",
          "normalized": "(a-\u003eKey-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "package": "containers",
          "partial": "With Key'",
          "signature": "(a-\u003eKey-\u003eb-\u003ea)-\u003ea-\u003eIntMap b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldlWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the values in the map using the given right-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003eelems\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e elems map = foldr (:) [] map\n\u003c/pre\u003e\u003cpre\u003e let f a len = len + (length a)\n foldr f 0 (fromList [(5,\"a\"), (3,\"bbb\")]) == 4\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldr",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e IntMap a -\u003e b",
          "source": "src/Data-IntMap-Base.html#foldr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldr\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldr\"]"
        },
        "index": {
          "description": "Fold the values in the map using the given right-associative binary operator such that foldr foldr elems For example elems map foldr map let len len length foldr fromList bbb",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldr'",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e IntMap a -\u003e b",
          "source": "src/Data-IntMap-Base.html#foldr%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldr-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldr-39-\"]"
        },
        "index": {
          "description": "strict version of foldr Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given right-associative\n binary operator, such that\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003euncurry\u003c/a\u003e\u003c/code\u003e f) z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e keys map = foldrWithKey (\\k x ks -\u003e k:ks) [] map\n\u003c/pre\u003e\u003cpre\u003e let f k a result = result ++ \"(\" ++ (show k) ++ \":\" ++ a ++ \")\"\n foldrWithKey f \"Map: \" (fromList [(5,\"a\"), (3,\"b\")]) == \"Map: (5:a)(3:b)\"\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldrWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e IntMap a -\u003e b",
          "source": "src/Data-IntMap-Base.html#foldrWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldrWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldrWithKey\"]"
        },
        "index": {
          "description": "Fold the keys and values in the map using the given right-associative binary operator such that foldrWithKey foldr uncurry toAscList For example keys map foldrWithKey ks ks map let result result show foldrWithKey Map fromList Map",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldrWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldrWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "foldrWithKey'",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e IntMap a -\u003e b",
          "source": "src/Data-IntMap-Base.html#foldrWithKey%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldrWithKey-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:foldrWithKey-39-\"]"
        },
        "index": {
          "description": "strict version of foldrWithKey Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "foldrWithKey'",
          "normalized": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "package": "containers",
          "partial": "With Key'",
          "signature": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:foldrWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order.\n\u003c/p\u003e\u003cpre\u003e fromAscList [(3,\"b\"), (5,\"a\")]          == fromList [(3, \"b\"), (5, \"a\")]\n fromAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"b\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromAscList",
          "package": "containers",
          "signature": "[(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order fromAscList fromList fromAscList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromAscList",
          "normalized": "[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Asc List",
          "signature": "[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order, with a combining function on equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"ba\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromAscListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromAscListWith",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order with combining function on equal keys The precondition input list is ascending is not checked fromAscListWith fromList ba",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromAscListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Asc List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromAscListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order, with a combining function on equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n fromAscListWithKey f [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"5:b|a\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromAscListWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromAscListWithKey",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order with combining function on equal keys The precondition input list is ascending is not checked let key new value old value show key new value old value fromAscListWithKey fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromAscListWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Asc List With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromAscListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order and all distinct.\n \u003cem\u003eThe precondition (input list is strictly ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromDistinctAscList [(3,\"b\"), (5,\"a\")] == fromList [(3, \"b\"), (5, \"a\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromDistinctAscList",
          "package": "containers",
          "signature": "[(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order and all distinct The precondition input list is strictly ascending is not checked fromDistinctAscList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromDistinctAscList",
          "normalized": "[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Distinct Asc List",
          "signature": "[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Create a map from a list of key/value pairs.\n\u003c/p\u003e\u003cpre\u003e fromList [] == empty\n fromList [(5,\"a\"), (3,\"b\"), (5, \"c\")] == fromList [(5,\"c\"), (3,\"b\")]\n fromList [(5,\"c\"), (3,\"b\"), (5, \"a\")] == fromList [(5,\"a\"), (3,\"b\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromList",
          "package": "containers",
          "signature": "[(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "min Create map from list of key value pairs fromList empty fromList fromList fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromList",
          "normalized": "[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "List",
          "signature": "[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Create a map from a list of key/value pairs with a combining function. See also \u003ccode\u003e\u003ca\u003efromAscListWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e fromListWith (++) [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"c\")] == fromList [(3, \"ab\"), (5, \"cba\")]\n fromListWith (++) [] == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromListWith",
          "type": "function"
        },
        "index": {
          "description": "min Create map from list of key value pairs with combining function See also fromAscListWith fromListWith fromList ab cba fromListWith empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey'.\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n fromListWithKey f [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"c\")] == fromList [(3, \"3:a|b\"), (5, \"5:c|5:b|a\")]\n fromListWithKey f [] == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromListWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromListWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Build map from list of key value pairs with combining function See also fromAscListWithKey let key new value old value show key new value old value fromListWithKey fromList fromListWithKey empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromListWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "List With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a set of keys and a function which for each key\n computes its value.\n\u003c/p\u003e\u003cpre\u003e fromSet (\\k -\u003e replicate k 'a') (Data.IntSet.fromList [3, 5]) == fromList [(5,\"aaaaa\"), (3,\"aaa\")]\n fromSet undefined Data.IntSet.empty == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "fromSet",
          "package": "containers",
          "signature": "(Key -\u003e a) -\u003e IntSet -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#fromSet",
          "type": "function"
        },
        "index": {
          "description": "Build map from set of keys and function which for each key computes its value fromSet replicate Data.IntSet.fromList fromList aaaaa aaa fromSet undefined Data.IntSet.empty empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "fromSet",
          "normalized": "(Key-\u003ea)-\u003eIntSet-\u003eIntMap a",
          "package": "containers",
          "partial": "Set",
          "signature": "(Key-\u003ea)-\u003eIntSet-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:fromSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Insert a new key/value pair in the map.\n If the key is already present in the map, the associated value is\n replaced with the supplied value, i.e. \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]\n insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]\n insert 5 'x' empty                         == singleton 5 'x'\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "insert",
          "package": "containers",
          "signature": "Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#insert",
          "type": "function"
        },
        "index": {
          "description": "min Insert new key value pair in the map If the key is already present in the map the associated value is replaced with the supplied value i.e insert is equivalent to insertWith const insert fromList fromList insert fromList fromList insert empty singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "insert",
          "normalized": "Key-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "Key-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertLookupWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e)\n is a pair where the first element is equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e)\n and the second element equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertLookupWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"5:xxx|a\")])\n insertLookupWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")])\n insertLookupWithKey f 5 \"xxx\" empty                         == (Nothing,  singleton 5 \"xxx\")\n\u003c/pre\u003e\u003cp\u003eThis is how to define \u003ccode\u003einsertLookup\u003c/code\u003e using \u003ccode\u003einsertLookupWithKey\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e let insertLookup kx x t = insertLookupWithKey (\\_ a _ -\u003e a) kx x t\n insertLookup 5 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"x\")])\n insertLookup 7 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"x\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "insertLookupWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e (Maybe a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#insertLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "min The expression insertLookupWithKey map is pair where the first element is equal to lookup map and the second element equal to insertWithKey map let key new value old value show key new value old value insertLookupWithKey xxx fromList Just fromList xxx insertLookupWithKey xxx fromList Nothing fromList xxx insertLookupWithKey xxx empty Nothing singleton xxx This is how to define insertLookup using insertLookupWithKey let insertLookup kx insertLookupWithKey kx insertLookup fromList Just fromList insertLookup fromList Nothing fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "insertLookupWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:insertLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Insert with a combining function.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert \u003ccode\u003ef new_value old_value\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insertWith (++) 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"xxxa\")]\n insertWith (++) 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWith (++) 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "insertWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#insertWith",
          "type": "function"
        },
        "index": {
          "description": "min Insert with combining function insertWith key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert new value old value insertWith xxx fromList fromList xxxa insertWith xxx fromList fromList xxx insertWith xxx empty singleton xxx",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "insertWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:insertWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Insert with a combining function.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert \u003ccode\u003ef key new_value old_value\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:xxx|a\")]\n insertWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWithKey f 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "insertWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#insertWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Insert with combining function insertWithKey key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert key new value old value let key new value old value show key new value old value insertWithKey xxx fromList fromList xxx insertWithKey xxx fromList fromList xxx insertWithKey xxx empty singleton xxx",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "insertWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:insertWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The (left-biased) intersection of two maps (based on keys).\n\u003c/p\u003e\u003cpre\u003e intersection (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "intersection",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#intersection",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:intersection\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:intersection\"]"
        },
        "index": {
          "description": "The left-biased intersection of two maps based on keys intersection fromList fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "intersection",
          "normalized": "IntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "signature": "IntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The intersection with a combining function.\n\u003c/p\u003e\u003cpre\u003e intersectionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"aA\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "intersectionWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap c",
          "source": "src/Data-IntMap-Base.html#intersectionWith",
          "type": "function"
        },
        "index": {
          "description": "The intersection with combining function intersectionWith fromList fromList singleton aA",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "intersectionWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:intersectionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The intersection with a combining function.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = (show k) ++ \":\" ++ al ++ \"|\" ++ ar\n intersectionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"5:a|A\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "intersectionWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e c) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap c",
          "source": "src/Data-IntMap-Base.html#intersectionWithKey",
          "type": "function"
        },
        "index": {
          "description": "The intersection with combining function let al ar show al ar intersectionWithKey fromList fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "intersectionWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:intersectionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a proper submap? (ie. a submap but not equal).\n Defined as (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisProperSubmapOf\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eisProperSubmapOfBy\u003c/a\u003e\u003c/code\u003e (==)\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "isProperSubmapOf",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap a -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#isProperSubmapOf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isProperSubmapOf\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:isProperSubmapOf\"]"
        },
        "index": {
          "description": "Is this proper submap ie submap but not equal Defined as isProperSubmapOf isProperSubmapOfBy",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "isProperSubmapOf",
          "normalized": "IntMap a-\u003eIntMap a-\u003eBool",
          "package": "containers",
          "partial": "Proper Submap Of",
          "signature": "IntMap a-\u003eIntMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isProperSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a proper submap? (ie. a submap but not equal).\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisProperSubmapOfBy\u003c/a\u003e\u003c/code\u003e f m1 m2\u003c/code\u003e) returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n \u003ccode\u003em1\u003c/code\u003e and \u003ccode\u003em2\u003c/code\u003e are not equal,\n all keys in \u003ccode\u003em1\u003c/code\u003e are in \u003ccode\u003em2\u003c/code\u003e, and when \u003ccode\u003ef\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n applied to their respective values. For example, the following\n expressions are all \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n isProperSubmapOfBy (\u003c=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n\u003c/pre\u003e\u003cp\u003eBut the following are all \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])\n isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])\n isProperSubmapOfBy (\u003c)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "isProperSubmapOfBy",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e IntMap a -\u003e IntMap b -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#isProperSubmapOfBy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isProperSubmapOfBy\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:isProperSubmapOfBy\"]"
        },
        "index": {
          "description": "Is this proper submap ie submap but not equal The expression isProperSubmapOfBy m1 m2 returns True when m1 and m2 are not equal all keys in m1 are in m2 and when returns True when applied to their respective values For example the following expressions are all True isProperSubmapOfBy fromList fromList isProperSubmapOfBy fromList fromList But the following are all False isProperSubmapOfBy fromList fromList isProperSubmapOfBy fromList fromList isProperSubmapOfBy fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "isProperSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eIntMap a-\u003eIntMap b-\u003eBool",
          "package": "containers",
          "partial": "Proper Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eIntMap a-\u003eIntMap b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isProperSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a submap?\n Defined as (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisSubmapOf\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eisSubmapOfBy\u003c/a\u003e\u003c/code\u003e (==)\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "isSubmapOf",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap a -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#isSubmapOf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isSubmapOf\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:isSubmapOf\"]"
        },
        "index": {
          "description": "Is this submap Defined as isSubmapOf isSubmapOfBy",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "isSubmapOf",
          "normalized": "IntMap a-\u003eIntMap a-\u003eBool",
          "package": "containers",
          "partial": "Submap Of",
          "signature": "IntMap a-\u003eIntMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e.\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisSubmapOfBy\u003c/a\u003e\u003c/code\u003e f m1 m2\u003c/code\u003e) returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if\n all keys in \u003ccode\u003em1\u003c/code\u003e are in \u003ccode\u003em2\u003c/code\u003e, and when \u003ccode\u003ef\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n applied to their respective values. For example, the following\n expressions are all \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n isSubmapOfBy (\u003c=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])\n\u003c/pre\u003e\u003cp\u003eBut the following are all \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isSubmapOfBy (==) (fromList [(1,2)]) (fromList [(1,1),(2,2)])\n isSubmapOfBy (\u003c) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n isSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "isSubmapOfBy",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e IntMap a -\u003e IntMap b -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#isSubmapOfBy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isSubmapOfBy\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:isSubmapOfBy\"]"
        },
        "index": {
          "description": "The expression isSubmapOfBy m1 m2 returns True if all keys in m1 are in m2 and when returns True when applied to their respective values For example the following expressions are all True isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList But the following are all False isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "isSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eIntMap a-\u003eIntMap b-\u003eBool",
          "package": "containers",
          "partial": "Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eIntMap a-\u003eIntMap b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:isSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Return all keys of the map in ascending order. Subject to list\n fusion.\n\u003c/p\u003e\u003cpre\u003e keys (fromList [(5,\"a\"), (3,\"b\")]) == [3,5]\n keys empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "keys",
          "package": "containers",
          "signature": "IntMap a -\u003e [Key]",
          "source": "src/Data-IntMap-Base.html#keys",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:keys\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:keys\"]"
        },
        "index": {
          "description": "Return all keys of the map in ascending order Subject to list fusion keys fromList keys empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "keys",
          "normalized": "IntMap a-\u003e[Key]",
          "package": "containers",
          "signature": "IntMap a-\u003e[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. The set of all keys of the map.\n\u003c/p\u003e\u003cpre\u003e keysSet (fromList [(5,\"a\"), (3,\"b\")]) == Data.IntSet.fromList [3,5]\n keysSet empty == Data.IntSet.empty\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "keysSet",
          "package": "containers",
          "signature": "IntMap a -\u003e IntSet",
          "source": "src/Data-IntMap-Base.html#keysSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:keysSet\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:keysSet\"]"
        },
        "index": {
          "description": "min The set of all keys of the map keysSet fromList Data.IntSet.fromList keysSet empty Data.IntSet.empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "keysSet",
          "normalized": "IntMap a-\u003eIntSet",
          "package": "containers",
          "partial": "Set",
          "signature": "IntMap a-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:keysSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Lookup the value at a key in the map. See also \u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "lookup",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Maybe a",
          "source": "src/Data-IntMap-Base.html#lookup",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookup\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:lookup\"]"
        },
        "index": {
          "description": "min Lookup the value at key in the map See also lookup",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "lookup",
          "normalized": "Key-\u003eIntMap a-\u003eMaybe a",
          "package": "containers",
          "signature": "Key-\u003eIntMap a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest key greater or equal to the given one and return\n the corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')\n lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')\n lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "lookupGE",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Maybe (Key, a)",
          "source": "src/Data-IntMap-Base.html#lookupGE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupGE\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:lookupGE\"]"
        },
        "index": {
          "description": "log Find smallest key greater or equal to the given one and return the corresponding key value pair lookupGE fromList Just lookupGE fromList Just lookupGE fromList Nothing",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "lookupGE",
          "normalized": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "package": "containers",
          "partial": "GE",
          "signature": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest key greater than the given one and return the\n corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')\n lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "lookupGT",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Maybe (Key, a)",
          "source": "src/Data-IntMap-Base.html#lookupGT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupGT\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:lookupGT\"]"
        },
        "index": {
          "description": "log Find smallest key greater than the given one and return the corresponding key value pair lookupGT fromList Just lookupGT fromList Nothing",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "lookupGT",
          "normalized": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "package": "containers",
          "partial": "GT",
          "signature": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest key smaller or equal to the given one and return\n the corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing\n lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')\n lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "lookupLE",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Maybe (Key, a)",
          "source": "src/Data-IntMap-Base.html#lookupLE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupLE\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:lookupLE\"]"
        },
        "index": {
          "description": "log Find largest key smaller or equal to the given one and return the corresponding key value pair lookupLE fromList Nothing lookupLE fromList Just lookupLE fromList Just",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "lookupLE",
          "normalized": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "package": "containers",
          "partial": "LE",
          "signature": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest key smaller than the given one and return the\n corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing\n lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "lookupLT",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Maybe (Key, a)",
          "source": "src/Data-IntMap-Base.html#lookupLT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupLT\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:lookupLT\"]"
        },
        "index": {
          "description": "log Find largest key smaller than the given one and return the corresponding key value pair lookupLT fromList Nothing lookupLT fromList Just",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "lookupLT",
          "normalized": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "package": "containers",
          "partial": "LT",
          "signature": "Key-\u003eIntMap a-\u003eMaybe(Key,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:lookupLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e map (++ \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"bx\"), (5, \"ax\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "map",
          "package": "containers",
          "signature": "(a -\u003e b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Base.html#map",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map map fromList fromList bx ax",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "signature": "(a-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapAccum\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a b = (a ++ b, b ++ \"X\")\n mapAccum f \"Everything: \" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: ba\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapAccum",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e IntMap b -\u003e (a, IntMap c)",
          "source": "src/Data-IntMap-Base.html#mapAccum",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccum threads an accumulating argument through the map in ascending order of keys let mapAccum Everything fromList Everything ba fromList bX aX",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapAccum",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "package": "containers",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ccode\u003emapAccumR\u003c/code\u003e\u003c/code\u003e threads an accumulating\n argument through the map in descending order of keys.\n\u003c/p\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapAccumRWithKey",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e b -\u003e (a, c)) -\u003e a -\u003e IntMap b -\u003e (a, IntMap c)",
          "source": "src/Data-IntMap-Base.html#mapAccumRWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumR threads an accumulating argument through the map in descending order of keys",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapAccumRWithKey",
          "normalized": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "package": "containers",
          "partial": "Accum RWith Key",
          "signature": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapAccumRWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapAccumWithKey\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a k b = (a ++ \" \" ++ (show k) ++ \"-\" ++ b, b ++ \"X\")\n mapAccumWithKey f \"Everything:\" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: 3-b 5-a\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapAccumWithKey",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e b -\u003e (a, c)) -\u003e a -\u003e IntMap b -\u003e (a, IntMap c)",
          "source": "src/Data-IntMap-Base.html#mapAccumWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys let show mapAccumWithKey Everything fromList Everything fromList bX aX",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapAccumWithKey",
          "normalized": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "package": "containers",
          "partial": "Accum With Key",
          "signature": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapAccumWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f a = if a \u003c \"c\" then Left a else Right a\n mapEither f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(3,\"b\"), (5,\"a\")], fromList [(1,\"x\"), (7,\"z\")])\n\n mapEither (\\ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapEither",
          "package": "containers",
          "signature": "(a -\u003e Either b c) -\u003e IntMap a -\u003e (IntMap b, IntMap c)",
          "source": "src/Data-IntMap-Base.html#mapEither",
          "type": "function"
        },
        "index": {
          "description": "Map values and separate the Left and Right results let if then Left else Right mapEither fromList fromList fromList mapEither Right fromList empty fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapEither",
          "normalized": "(a-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "package": "containers",
          "partial": "Either",
          "signature": "(a-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k a = if k \u003c 5 then Left (k * 2) else Right (a ++ a)\n mapEitherWithKey f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(1,2), (3,6)], fromList [(5,\"aa\"), (7,\"zz\")])\n\n mapEitherWithKey (\\_ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(1,\"x\"), (3,\"b\"), (5,\"a\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapEitherWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Either b c) -\u003e IntMap a -\u003e (IntMap b, IntMap c)",
          "source": "src/Data-IntMap-Base.html#mapEitherWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and separate the Left and Right results let if then Left else Right mapEitherWithKey fromList fromList fromList aa zz mapEitherWithKey Right fromList empty fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapEitherWithKey",
          "normalized": "(Key-\u003ea-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "package": "containers",
          "partial": "Either With Key",
          "signature": "(Key-\u003ea-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapEitherWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeys\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e is the map obtained by applying \u003ccode\u003ef\u003c/code\u003e to each key of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe size of the result may be smaller if \u003ccode\u003ef\u003c/code\u003e maps two or more distinct\n keys to the same new key.  In this case the value at the greatest of the\n original keys is retained.\n\u003c/p\u003e\u003cpre\u003e mapKeys (+ 1) (fromList [(5,\"a\"), (3,\"b\")])                        == fromList [(4, \"b\"), (6, \"a\")]\n mapKeys (\\ _ -\u003e 1) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 1 \"c\"\n mapKeys (\\ _ -\u003e 3) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 3 \"c\"\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "mapKeys",
          "package": "containers",
          "signature": "(Key -\u003e Key) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#mapKeys",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapKeys\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapKeys\"]"
        },
        "index": {
          "description": "min mapKeys is the map obtained by applying to each key of The size of the result may be smaller if maps two or more distinct keys to the same new key In this case the value at the greatest of the original keys is retained mapKeys fromList fromList mapKeys fromList singleton mapKeys fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapKeys",
          "normalized": "(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Keys",
          "signature": "(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapKeys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeysMonotonic\u003c/a\u003e\u003c/code\u003e f s == \u003ccode\u003e\u003ca\u003emapKeys\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e, but works only when \u003ccode\u003ef\u003c/code\u003e\n is strictly monotonic.\n That is, for any values \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e, if \u003ccode\u003ex\u003c/code\u003e \u003c \u003ccode\u003ey\u003c/code\u003e then \u003ccode\u003ef x\u003c/code\u003e \u003c \u003ccode\u003ef y\u003c/code\u003e.\n \u003cem\u003eThe precondition is not checked.\u003c/em\u003e\n Semi-formally, we have:\n\u003c/p\u003e\u003cpre\u003e and [x \u003c y ==\u003e f x \u003c f y | x \u003c- ls, y \u003c- ls]\n                     ==\u003e mapKeysMonotonic f s == mapKeys f s\n     where ls = keys s\n\u003c/pre\u003e\u003cp\u003eThis means that \u003ccode\u003ef\u003c/code\u003e maps distinct original keys to distinct resulting keys.\n This function has slightly better performance than \u003ccode\u003e\u003ca\u003emapKeys\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e mapKeysMonotonic (\\ k -\u003e k * 2) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(6, \"b\"), (10, \"a\")]\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "mapKeysMonotonic",
          "package": "containers",
          "signature": "(Key -\u003e Key) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#mapKeysMonotonic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapKeysMonotonic\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapKeysMonotonic\"]"
        },
        "index": {
          "description": "min mapKeysMonotonic mapKeys but works only when is strictly monotonic That is for any values and if then The precondition is not checked Semi-formally we have and ls ls mapKeysMonotonic mapKeys where ls keys This means that maps distinct original keys to distinct resulting keys This function has slightly better performance than mapKeys mapKeysMonotonic fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapKeysMonotonic",
          "normalized": "(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Keys Monotonic",
          "signature": "(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapKeysMonotonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeysWith\u003c/a\u003e\u003c/code\u003e c f s\u003c/code\u003e is the map obtained by applying \u003ccode\u003ef\u003c/code\u003e to each key of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe size of the result may be smaller if \u003ccode\u003ef\u003c/code\u003e maps two or more distinct\n keys to the same new key.  In this case the associated values will be\n combined using \u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e mapKeysWith (++) (\\ _ -\u003e 1) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 1 \"cdab\"\n mapKeysWith (++) (\\ _ -\u003e 3) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 3 \"cdab\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapKeysWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e (Key -\u003e Key) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#mapKeysWith",
          "type": "function"
        },
        "index": {
          "description": "min mapKeysWith is the map obtained by applying to each key of The size of the result may be smaller if maps two or more distinct keys to the same new key In this case the associated values will be combined using mapKeysWith fromList singleton cdab mapKeysWith fromList singleton cdab",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapKeysWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Keys With",
          "signature": "(a-\u003ea-\u003ea)-\u003e(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapKeysWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n mapMaybe f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"new a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapMaybe",
          "package": "containers",
          "signature": "(a -\u003e Maybe b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Base.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "description": "Map values and collect the Just results let if then Just new else Nothing mapMaybe fromList singleton new",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k _ = if k \u003c 5 then Just (\"key : \" ++ (show k)) else Nothing\n mapMaybeWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"key : 3\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapMaybeWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Base.html#mapMaybeWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and collect the Just results let if then Just key show else Nothing mapMaybeWithKey fromList singleton key",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapMaybeWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "partial": "Maybe With Key",
          "signature": "(Key-\u003ea-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapMaybeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":\" ++ x\n mapWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"3:b\"), (5, \"5:a\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mapWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Base.html#mapWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map let key show key mapWithKey fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mapWithKey",
          "normalized": "(Key-\u003ea-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Retrieves the maximal key of the map, and the map\n stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty map.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "maxView",
          "package": "containers",
          "signature": "IntMap a -\u003e Maybe (a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#maxView",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:maxView\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:maxView\"]"
        },
        "index": {
          "description": "min Retrieves the maximal key of the map and the map stripped of that element or Nothing if passed an empty map",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "maxView",
          "normalized": "IntMap a-\u003eMaybe(a,IntMap a)",
          "package": "containers",
          "partial": "View",
          "signature": "IntMap a-\u003eMaybe(a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:maxView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Retrieves the maximal (key,value) pair of the map, and\n the map stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty map.\n\u003c/p\u003e\u003cpre\u003e maxViewWithKey (fromList [(5,\"a\"), (3,\"b\")]) == Just ((5,\"a\"), singleton 3 \"b\")\n maxViewWithKey empty == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "maxViewWithKey",
          "package": "containers",
          "signature": "IntMap a -\u003e Maybe ((Key, a), IntMap a)",
          "source": "src/Data-IntMap-Base.html#maxViewWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:maxViewWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:maxViewWithKey\"]"
        },
        "index": {
          "description": "min Retrieves the maximal key value pair of the map and the map stripped of that element or Nothing if passed an empty map maxViewWithKey fromList Just singleton maxViewWithKey empty Nothing",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "maxViewWithKey",
          "normalized": "IntMap a-\u003eMaybe((Key,a),IntMap a)",
          "package": "containers",
          "partial": "View With Key",
          "signature": "IntMap a-\u003eMaybe((Key,a),IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:maxViewWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Is the key a member of the map?\n\u003c/p\u003e\u003cpre\u003e member 5 (fromList [(5,'a'), (3,'b')]) == True\n member 1 (fromList [(5,'a'), (3,'b')]) == False\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "member",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#member",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:member\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:member\"]"
        },
        "index": {
          "description": "min Is the key member of the map member fromList True member fromList False",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "member",
          "normalized": "Key-\u003eIntMap a-\u003eBool",
          "package": "containers",
          "signature": "Key-\u003eIntMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. A high-performance universal combining function. Using\n \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e, all combining functions can be defined without any loss of\n efficiency (with exception of \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e,\n where sharing of some nodes is lost with \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003ePlease make sure you know what is going on when using \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e,\n otherwise you can be surprised by unexpected code growth or even\n corruption of the data structure.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e is given three arguments, it is inlined to the call\n site. You should therefore use \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e only to define your custom\n combining functions. For example, you could define \u003ccode\u003e\u003ca\u003eunionWithKey\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003edifferenceWithKey\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eintersectionWithKey\u003c/a\u003e\u003c/code\u003e as\n\u003c/p\u003e\u003cpre\u003e myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) id id m1 m2\n myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) (const empty) (const empty) m1 m2\n\u003c/pre\u003e\u003cp\u003eWhen calling \u003ccode\u003e\u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e combine only1 only2\u003c/code\u003e, a function combining two\n \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003es is created, such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if a key is present in both maps, it is passed with both corresponding\n   values to the \u003ccode\u003ecombine\u003c/code\u003e function. Depending on the result, the key is either\n   present in the result with specified value, or is left out;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the first map is passed to \u003ccode\u003eonly1\u003c/code\u003e and\n   the output is added to the result;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the second map is passed to \u003ccode\u003eonly2\u003c/code\u003e and\n   the output is added to the result.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003eonly1\u003c/code\u003e and \u003ccode\u003eonly2\u003c/code\u003e methods \u003cem\u003emust return a map with a subset (possibly empty) of the keys of the given map\u003c/em\u003e.\n The values can be modified arbitrarily. Most common variants of \u003ccode\u003eonly1\u003c/code\u003e and\n \u003ccode\u003eonly2\u003c/code\u003e are \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but for example \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e or\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efilterWithKey\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e could be used for any \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "mergeWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e Maybe c) -\u003e (IntMap a -\u003e IntMap c) -\u003e (IntMap b -\u003e IntMap c) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap c",
          "source": "src/Data-IntMap-Base.html#mergeWithKey",
          "type": "function"
        },
        "index": {
          "description": "high-performance universal combining function Using mergeWithKey all combining functions can be defined without any loss of efficiency with exception of union difference and intersection where sharing of some nodes is lost with mergeWithKey Please make sure you know what is going on when using mergeWithKey otherwise you can be surprised by unexpected code growth or even corruption of the data structure When mergeWithKey is given three arguments it is inlined to the call site You should therefore use mergeWithKey only to define your custom combining functions For example you could define unionWithKey differenceWithKey and intersectionWithKey as myUnionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 id id m1 m2 myDifferenceWithKey m1 m2 mergeWithKey id const empty m1 m2 myIntersectionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 const empty const empty m1 m2 When calling mergeWithKey combine only1 only2 function combining two IntMap is created such that if key is present in both maps it is passed with both corresponding values to the combine function Depending on the result the key is either present in the result with specified value or is left out nonempty subtree present only in the first map is passed to only1 and the output is added to the result nonempty subtree present only in the second map is passed to only2 and the output is added to the result The only1 and only2 methods must return map with subset possibly empty of the keys of the given map The values can be modified arbitrarily Most common variants of only1 and only2 are id and const empty but for example map or filterWithKey could be used for any",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "mergeWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eMaybe c)-\u003e(IntMap a-\u003eIntMap c)-\u003e(IntMap b-\u003eIntMap c)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eMaybe c)-\u003e(IntMap a-\u003eIntMap c)-\u003e(IntMap b-\u003eIntMap c)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:mergeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Retrieves the minimal key of the map, and the map\n stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty map.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "minView",
          "package": "containers",
          "signature": "IntMap a -\u003e Maybe (a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#minView",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:minView\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:minView\"]"
        },
        "index": {
          "description": "min Retrieves the minimal key of the map and the map stripped of that element or Nothing if passed an empty map",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "minView",
          "normalized": "IntMap a-\u003eMaybe(a,IntMap a)",
          "package": "containers",
          "partial": "View",
          "signature": "IntMap a-\u003eMaybe(a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:minView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Retrieves the minimal (key,value) pair of the map, and\n the map stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty map.\n\u003c/p\u003e\u003cpre\u003e minViewWithKey (fromList [(5,\"a\"), (3,\"b\")]) == Just ((3,\"b\"), singleton 5 \"a\")\n minViewWithKey empty == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "minViewWithKey",
          "package": "containers",
          "signature": "IntMap a -\u003e Maybe ((Key, a), IntMap a)",
          "source": "src/Data-IntMap-Base.html#minViewWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:minViewWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:minViewWithKey\"]"
        },
        "index": {
          "description": "min Retrieves the minimal key value pair of the map and the map stripped of that element or Nothing if passed an empty map minViewWithKey fromList Just singleton minViewWithKey empty Nothing",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "minViewWithKey",
          "normalized": "IntMap a-\u003eMaybe((Key,a),IntMap a)",
          "package": "containers",
          "partial": "View With Key",
          "signature": "IntMap a-\u003eMaybe((Key,a),IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:minViewWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Is the key not a member of the map?\n\u003c/p\u003e\u003cpre\u003e notMember 5 (fromList [(5,'a'), (3,'b')]) == False\n notMember 1 (fromList [(5,'a'), (3,'b')]) == True\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "notMember",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#notMember",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:notMember\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:notMember\"]"
        },
        "index": {
          "description": "min Is the key not member of the map notMember fromList False notMember fromList True",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "notMember",
          "normalized": "Key-\u003eIntMap a-\u003eBool",
          "package": "containers",
          "partial": "Member",
          "signature": "Key-\u003eIntMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Is the map empty?\n\u003c/p\u003e\u003cpre\u003e Data.IntMap.null (empty)           == True\n Data.IntMap.null (singleton 1 'a') == False\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "null",
          "package": "containers",
          "signature": "IntMap a -\u003e Bool",
          "source": "src/Data-IntMap-Base.html#null",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:null\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:null\"]"
        },
        "index": {
          "description": "Is the map empty Data.IntMap.null empty True Data.IntMap.null singleton False",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "null",
          "normalized": "IntMap a-\u003eBool",
          "package": "containers",
          "signature": "IntMap a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Partition the map according to some predicate. The first\n map contains all elements that satisfy the predicate, the second all\n elements that fail the predicate. See also \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e partition (\u003e \"a\") (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", singleton 5 \"a\")\n partition (\u003c \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3, \"b\"), (5, \"a\")], empty)\n partition (\u003e \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == (empty, fromList [(3, \"b\"), (5, \"a\")])\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "partition",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e IntMap a -\u003e (IntMap a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#partition",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:partition\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:partition\"]"
        },
        "index": {
          "description": "Partition the map according to some predicate The first map contains all elements that satisfy the predicate the second all elements that fail the predicate See also split partition fromList singleton singleton partition fromList fromList empty partition fromList empty fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eIntMap a-\u003e(IntMap a,IntMap a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eIntMap a-\u003e(IntMap a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Partition the map according to some predicate. The first\n map contains all elements that satisfy the predicate, the second all\n elements that fail the predicate. See also \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e partitionWithKey (\\ k _ -\u003e k \u003e 3) (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 5 \"a\", singleton 3 \"b\")\n partitionWithKey (\\ k _ -\u003e k \u003c 7) (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3, \"b\"), (5, \"a\")], empty)\n partitionWithKey (\\ k _ -\u003e k \u003e 7) (fromList [(5,\"a\"), (3,\"b\")]) == (empty, fromList [(3, \"b\"), (5, \"a\")])\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "partitionWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Bool) -\u003e IntMap a -\u003e (IntMap a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#partitionWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:partitionWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:partitionWithKey\"]"
        },
        "index": {
          "description": "Partition the map according to some predicate The first map contains all elements that satisfy the predicate the second all elements that fail the predicate See also split partitionWithKey fromList singleton singleton partitionWithKey fromList fromList empty partitionWithKey fromList empty fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "partitionWithKey",
          "normalized": "(Key-\u003ea-\u003eBool)-\u003eIntMap a-\u003e(IntMap a,IntMap a)",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eBool)-\u003eIntMap a-\u003e(IntMap a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:partitionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Show the tree that implements the map. The tree is shown\n in a compressed, hanging format.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "showTree",
          "package": "containers",
          "signature": "IntMap a -\u003e String",
          "source": "src/Data-IntMap-Base.html#showTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:showTree\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:showTree\"]"
        },
        "index": {
          "description": "Show the tree that implements the map The tree is shown in compressed hanging format",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "showTree",
          "normalized": "IntMap a-\u003eString",
          "package": "containers",
          "partial": "Tree",
          "signature": "IntMap a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eshowTreeWith\u003c/a\u003e\u003c/code\u003e hang wide map\u003c/code\u003e) shows\n the tree that implements the map. If \u003ccode\u003ehang\u003c/code\u003e is\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, a \u003cem\u003ehanging\u003c/em\u003e tree is shown otherwise a rotated tree is shown. If\n \u003ccode\u003ewide\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, an extra wide version is shown.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "showTreeWith",
          "package": "containers",
          "signature": "Bool -\u003e Bool -\u003e IntMap a -\u003e String",
          "source": "src/Data-IntMap-Base.html#showTreeWith",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:showTreeWith\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:showTreeWith\"]"
        },
        "index": {
          "description": "The expression showTreeWith hang wide map shows the tree that implements the map If hang is True hanging tree is shown otherwise rotated tree is shown If wide is True an extra wide version is shown",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "showTreeWith",
          "normalized": "Bool-\u003eBool-\u003eIntMap a-\u003eString",
          "package": "containers",
          "partial": "Tree With",
          "signature": "Bool-\u003eBool-\u003eIntMap a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. A map of one element.\n\u003c/p\u003e\u003cpre\u003e singleton 1 'a'        == fromList [(1, 'a')]\n size (singleton 1 'a') == 1\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "singleton",
          "package": "containers",
          "signature": "Key -\u003e a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "map of one element singleton fromList size singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "singleton",
          "normalized": "Key-\u003ea-\u003eIntMap a",
          "package": "containers",
          "signature": "Key-\u003ea-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Number of elements in the map.\n\u003c/p\u003e\u003cpre\u003e size empty                                   == 0\n size (singleton 1 'a')                       == 1\n size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "size",
          "package": "containers",
          "signature": "IntMap a -\u003e Int",
          "source": "src/Data-IntMap-Base.html#size",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:size\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:size\"]"
        },
        "index": {
          "description": "Number of elements in the map size empty size singleton size fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "size",
          "normalized": "IntMap a-\u003eInt",
          "package": "containers",
          "signature": "IntMap a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e) is a pair \u003ccode\u003e(map1,map2)\u003c/code\u003e\n where all keys in \u003ccode\u003emap1\u003c/code\u003e are lower than \u003ccode\u003ek\u003c/code\u003e and all keys in\n \u003ccode\u003emap2\u003c/code\u003e larger than \u003ccode\u003ek\u003c/code\u003e. Any key equal to \u003ccode\u003ek\u003c/code\u003e is found in neither \u003ccode\u003emap1\u003c/code\u003e nor \u003ccode\u003emap2\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e split 2 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, fromList [(3,\"b\"), (5,\"a\")])\n split 3 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, singleton 5 \"a\")\n split 4 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", singleton 5 \"a\")\n split 5 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", empty)\n split 6 (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3,\"b\"), (5,\"a\")], empty)\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "split",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e (IntMap a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#split",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:split\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:split\"]"
        },
        "index": {
          "description": "min The expression split map is pair map1 map2 where all keys in map1 are lower than and all keys in map2 larger than Any key equal to is found in neither map1 nor map2 split fromList empty fromList split fromList empty singleton split fromList singleton singleton split fromList singleton empty split fromList fromList empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "split",
          "normalized": "Key-\u003eIntMap a-\u003e(IntMap a,IntMap a)",
          "package": "containers",
          "signature": "Key-\u003eIntMap a-\u003e(IntMap a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Performs a \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e but also returns whether the pivot\n key was found in the original map.\n\u003c/p\u003e\u003cpre\u003e splitLookup 2 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, Nothing, fromList [(3,\"b\"), (5,\"a\")])\n splitLookup 3 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, Just \"b\", singleton 5 \"a\")\n splitLookup 4 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", Nothing, singleton 5 \"a\")\n splitLookup 5 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", Just \"a\", empty)\n splitLookup 6 (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3,\"b\"), (5,\"a\")], Nothing, empty)\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "splitLookup",
          "package": "containers",
          "signature": "Key -\u003e IntMap a -\u003e (IntMap a, Maybe a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#splitLookup",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:splitLookup\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:splitLookup\"]"
        },
        "index": {
          "description": "min Performs split but also returns whether the pivot key was found in the original map splitLookup fromList empty Nothing fromList splitLookup fromList empty Just singleton splitLookup fromList singleton Nothing singleton splitLookup fromList singleton Just empty splitLookup fromList fromList Nothing empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "splitLookup",
          "normalized": "Key-\u003eIntMap a-\u003e(IntMap a,Maybe a,IntMap a)",
          "package": "containers",
          "partial": "Lookup",
          "signature": "Key-\u003eIntMap a-\u003e(IntMap a,Maybe a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:splitLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e.  Decompose a map into pieces based on the structure of the underlying\n tree.  This function is useful for consuming a map in parallel.\n\u003c/p\u003e\u003cp\u003eNo guarantee is made as to the sizes of the pieces; an internal, but\n deterministic process determines this.  However, it is guaranteed that the\n pieces returned will be in ascending order (all elements in the first submap\n less than all elements in the second, and so on).\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e splitRoot (fromList (zip [1..6::Int] ['a'..])) ==\n   [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d'),(5,'e'),(6,'f')]]\n\u003c/pre\u003e\u003cpre\u003e splitRoot empty == []\n\u003c/pre\u003e\u003cp\u003eNote that the current implementation does not return more than two submaps,\n  but you should not depend on this behaviour because it can change in the\n  future without notice.\n\u003c/p\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "splitRoot",
          "package": "containers",
          "signature": "IntMap a -\u003e [IntMap a]",
          "source": "src/Data-IntMap-Base.html#splitRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:splitRoot\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:splitRoot\"]"
        },
        "index": {
          "description": "Decompose map into pieces based on the structure of the underlying tree This function is useful for consuming map in parallel No guarantee is made as to the sizes of the pieces an internal but deterministic process determines this However it is guaranteed that the pieces returned will be in ascending order all elements in the first submap less than all elements in the second and so on Examples splitRoot fromList zip Int fromList fromList splitRoot empty Note that the current implementation does not return more than two submaps but you should not depend on this behaviour because it can change in the future without notice",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "splitRoot",
          "normalized": "IntMap a-\u003e[IntMap a]",
          "package": "containers",
          "partial": "Root",
          "signature": "IntMap a-\u003e[IntMap a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:splitRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the map to a list of key/value pairs where the\n keys are in ascending order. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e toAscList (fromList [(5,\"a\"), (3,\"b\")]) == [(3,\"b\"), (5,\"a\")]\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "toAscList",
          "package": "containers",
          "signature": "IntMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-Base.html#toAscList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:toAscList\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:toAscList\"]"
        },
        "index": {
          "description": "Convert the map to list of key value pairs where the keys are in ascending order Subject to list fusion toAscList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "toAscList",
          "normalized": "IntMap a-\u003e[(Key,a)]",
          "package": "containers",
          "partial": "Asc List",
          "signature": "IntMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the map to a list of key/value pairs where the keys\n are in descending order. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e toDescList (fromList [(5,\"a\"), (3,\"b\")]) == [(5,\"a\"), (3,\"b\")]\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "toDescList",
          "package": "containers",
          "signature": "IntMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-Base.html#toDescList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:toDescList\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:toDescList\"]"
        },
        "index": {
          "description": "Convert the map to list of key value pairs where the keys are in descending order Subject to list fusion toDescList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "toDescList",
          "normalized": "IntMap a-\u003e[(Key,a)]",
          "package": "containers",
          "partial": "Desc List",
          "signature": "IntMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:toDescList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the map to a list of key/value pairs. Subject to list\n fusion.\n\u003c/p\u003e\u003cpre\u003e toList (fromList [(5,\"a\"), (3,\"b\")]) == [(3,\"b\"), (5,\"a\")]\n toList empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "toList",
          "package": "containers",
          "signature": "IntMap a -\u003e [(Key, a)]",
          "source": "src/Data-IntMap-Base.html#toList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:toList\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:toList\"]"
        },
        "index": {
          "description": "Convert the map to list of key value pairs Subject to list fusion toList fromList toList empty",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "toList",
          "normalized": "IntMap a-\u003e[(Key,a)]",
          "package": "containers",
          "partial": "List",
          "signature": "IntMap a-\u003e[(Key,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003etraverseWithKey\u003c/a\u003e\u003c/code\u003e f s == \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e \u003ca\u003e$\u003c/a\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e ((k, v) -\u003e (,) k \u003ca\u003e$\u003c/a\u003e f k v) (\u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e m)\u003c/code\u003e\n That is, behaves exactly like a regular \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e except that the traversing\n function also has access to the key associated with a value.\n\u003c/p\u003e\u003cpre\u003e traverseWithKey (\\k v -\u003e if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])\n traverseWithKey (\\k v -\u003e if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "traverseWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e t b) -\u003e IntMap a -\u003e t (IntMap b)",
          "source": "src/Data-IntMap-Base.html#traverseWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:traverseWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:traverseWithKey\"]"
        },
        "index": {
          "description": "traverseWithKey fromList traverse toList That is behaves exactly like regular traverse except that the traversing function also has access to the key associated with value traverseWithKey if odd then Just succ else Nothing fromList Just fromList traverseWithKey if odd then Just succ else Nothing fromList Nothing",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "traverseWithKey",
          "normalized": "(Key-\u003ea-\u003eb c)-\u003eIntMap a-\u003eb(IntMap c)",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003et b)-\u003eIntMap a-\u003et(IntMap b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:traverseWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The (left-biased) union of two maps.\n It prefers the first map when duplicate keys are encountered,\n i.e. (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e == \u003ccode\u003e\u003ca\u003eunionWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e union (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "union",
          "package": "containers",
          "signature": "IntMap a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#union",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:union\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:union\"]"
        },
        "index": {
          "description": "The left-biased union of two maps It prefers the first map when duplicate keys are encountered i.e union unionWith const union fromList fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "union",
          "normalized": "IntMap a-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "IntMap a-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The union with a combining function.\n\u003c/p\u003e\u003cpre\u003e unionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"aA\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "unionWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e IntMap a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#unionWith",
          "type": "function"
        },
        "index": {
          "description": "The union with combining function unionWith fromList fromList fromList aA",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "unionWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:unionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The union with a combining function.\n\u003c/p\u003e\u003cpre\u003e let f key left_value right_value = (show key) ++ \":\" ++ left_value ++ \"|\" ++ right_value\n unionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"5:a|A\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "unionWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e IntMap a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#unionWithKey",
          "type": "function"
        },
        "index": {
          "description": "The union with combining function let key left value right value show key left value right value unionWithKey fromList fromList fromList",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "unionWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:unionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of maps.\n\u003c/p\u003e\u003cpre\u003e unions [(fromList [(5, \"a\"), (3, \"b\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"A3\"), (3, \"B3\")])]\n     == fromList [(3, \"b\"), (5, \"a\"), (7, \"C\")]\n unions [(fromList [(5, \"A3\"), (3, \"B3\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"a\"), (3, \"b\")])]\n     == fromList [(3, \"B3\"), (5, \"A3\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "[\"Data.IntMap.Lazy\",\"Data.IntMap.Strict\"]",
          "name": "unions",
          "package": "containers",
          "signature": "[IntMap a] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#unions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:unions\",\"http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:unions\"]"
        },
        "index": {
          "description": "The union of list of maps unions fromList fromList fromList A3 B3 fromList unions fromList A3 B3 fromList fromList fromList B3 A3",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "unions",
          "normalized": "[IntMap a]-\u003eIntMap a",
          "package": "containers",
          "signature": "[IntMap a]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of maps, with a combining operation.\n\u003c/p\u003e\u003cpre\u003e unionsWith (++) [(fromList [(5, \"a\"), (3, \"b\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"A3\"), (3, \"B3\")])]\n     == fromList [(3, \"bB3\"), (5, \"aAA3\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "unionsWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [IntMap a] -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#unionsWith",
          "type": "function"
        },
        "index": {
          "description": "The union of list of maps with combining operation unionsWith fromList fromList fromList A3 B3 fromList bB3 aAA3",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "unionsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[IntMap a]-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[IntMap a]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:unionsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the value \u003ccode\u003ex\u003c/code\u003e\n at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is\n deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n update f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n update f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n update f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "update",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#update",
          "type": "function"
        },
        "index": {
          "description": "min The expression update map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just new else Nothing update fromList fromList new update fromList fromList update fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "update",
          "normalized": "(a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Lookup and update.\n The function returns original value, if it is updated.\n This is different behavior than \u003ccode\u003e\u003ca\u003eupdateLookupWithKey\u003c/a\u003e\u003c/code\u003e.\n Returns the original key value if the map entry is deleted.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateLookupWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"5:new a\")])\n updateLookupWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\")])\n updateLookupWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"b\", singleton 5 \"a\")\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "updateLookupWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e (Maybe a, IntMap a)",
          "source": "src/Data-IntMap-Base.html#updateLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Lookup and update The function returns original value if it is updated This is different behavior than updateLookupWithKey Returns the original key value if the map entry is deleted let if then Just show new else Nothing updateLookupWithKey fromList Just fromList new updateLookupWithKey fromList Nothing fromList updateLookupWithKey fromList Just singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "updateLookupWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:updateLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMax (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"Xa\")]\n updateMax (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "updateMax",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#updateMax",
          "type": "function"
        },
        "index": {
          "description": "min Update the value at the maximal key updateMax Just fromList fromList Xa updateMax Nothing fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "updateMax",
          "normalized": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Max",
          "signature": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:updateMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMaxWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"b\"), (5,\"5:a\")]\n updateMaxWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "updateMaxWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#updateMaxWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Update the value at the maximal key updateMaxWithKey Just show fromList fromList updateMaxWithKey Nothing fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "updateMaxWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Max With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:updateMaxWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMin (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"Xb\"), (5, \"a\")]\n updateMin (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "updateMin",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#updateMin",
          "type": "function"
        },
        "index": {
          "description": "min Update the value at the minimal key updateMin Just fromList fromList Xb updateMin Nothing fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "updateMin",
          "normalized": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Min",
          "signature": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:updateMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMinWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"3:b\"), (5,\"a\")]\n updateMinWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "updateMinWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#updateMinWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Update the value at the minimal key updateMinWithKey Just show fromList fromList updateMinWithKey Nothing fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "updateMinWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Min With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:updateMinWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the value \u003ccode\u003ex\u003c/code\u003e\n at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef k x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is\n deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n updateWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n updateWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Lazy",
          "name": "updateWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Base.html#updateWithKey",
          "type": "function"
        },
        "index": {
          "description": "min The expression update map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just show new else Nothing updateWithKey fromList fromList new updateWithKey fromList fromList updateWithKey fromList singleton",
          "hierarchy": "Data IntMap Lazy",
          "module": "Data.IntMap.Lazy",
          "name": "updateWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Lazy.html#v:updateWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of maps from integer keys to values\n (dictionaries).\n\u003c/p\u003e\u003cp\u003eAPI of this module is strict in both the keys and the values.\n If you need value-lazy maps, use \u003ca\u003eData.IntMap.Lazy\u003c/a\u003e instead.\n The \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e type itself is shared between the lazy and strict modules,\n meaning that the same \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e value can be passed to functions in\n both modules (although that is rarely needed).\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import Data.IntMap.Strict (IntMap)\n  import qualified Data.IntMap.Strict as IntMap\n\u003c/pre\u003e\u003cp\u003eThe implementation is based on \u003cem\u003ebig-endian patricia trees\u003c/em\u003e.  This data\n structure performs especially well on binary operations like \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e.  However, my benchmarks show that it is also\n (much) faster on insertions and deletions when compared to a generic\n size-balanced map implementation (see \u003ca\u003eData.Map\u003c/a\u003e).\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Chris Okasaki and Andy Gill,  \"\u003cem\u003eFast Mergeable Integer Maps\u003c/em\u003e\",\n      Workshop on ML, September 1998, pages 77-86,\n      \u003ca\u003ehttp://citeseer.ist.psu.edu/okasaki98fast.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve\n      Information Coded In Alphanumeric/\", Journal of the ACM, 15(4),\n      October 1968, pages 514-534.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOperation comments contain the operation time complexity in\n the Big-O notation \u003ca\u003ehttp://en.wikipedia.org/wiki/Big_O_notation\u003c/a\u003e.\n Many operations have a worst-case complexity of \u003cem\u003eO(min(n,W))\u003c/em\u003e.\n This means that the operation can become linear in the number of\n elements with a maximum of \u003cem\u003eW\u003c/em\u003e -- the number of bits in an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n (32 or 64).\n\u003c/p\u003e\u003cp\u003eBe aware that the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003eTraversable\u003c/code\u003e and \u003ccode\u003eData\u003c/code\u003e instances\n are the same as for the \u003ca\u003eData.IntMap.Lazy\u003c/a\u003e module, so if they are used\n on strict maps, the resulting maps will be lazy.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IntMap.Strict",
          "name": "Strict",
          "package": "containers",
          "source": "src/Data-IntMap-Strict.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of maps from integer keys to values dictionaries API of this module is strict in both the keys and the values If you need value-lazy maps use Data.IntMap.Lazy instead The IntMap type itself is shared between the lazy and strict modules meaning that the same IntMap value can be passed to functions in both modules although that is rarely needed These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import Data.IntMap.Strict IntMap import qualified Data.IntMap.Strict as IntMap The implementation is based on big-endian patricia trees This data structure performs especially well on binary operations like union and intersection However my benchmarks show that it is also much faster on insertions and deletions when compared to generic size-balanced map implementation see Data.Map Chris Okasaki and Andy Gill Fast Mergeable Integer Maps Workshop on ML September pages http citeseer.ist.psu.edu okasaki98fast.html D.R Morrison PATRICIA Practical Algorithm To Retrieve Information Coded In Alphanumeric Journal of the ACM October pages Operation comments contain the operation time complexity in the Big-O notation http en.wikipedia.org wiki Big notation Many operations have worst-case complexity of min This means that the operation can become linear in the number of elements with maximum of the number of bits in an Int or Be aware that the Functor Traversable and Data instances are the same as for the Data.IntMap.Lazy module so if they are used on strict maps the resulting maps will be lazy",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "Strict",
          "package": "containers",
          "partial": "Strict",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA map of integers to values \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Strict",
          "name": "IntMap",
          "package": "containers",
          "source": "src/Data-IntMap-Base.html#IntMap",
          "type": "data"
        },
        "index": {
          "description": "map of integers to values",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "IntMap",
          "package": "containers",
          "partial": "Int Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#t:IntMap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntMap.Strict",
          "name": "Key",
          "package": "containers",
          "source": "src/Data-IntSet-Base.html#Key",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "Key",
          "package": "containers",
          "partial": "Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Adjust a value at a specific key. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e adjust (\"new \" ++) 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n adjust (\"new \" ++) 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjust (\"new \" ++) 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "adjust",
          "package": "containers",
          "signature": "(a -\u003e a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#adjust",
          "type": "function"
        },
        "index": {
          "description": "min Adjust value at specific key When the key is not member of the map the original map is returned adjust new fromList fromList new adjust new fromList fromList adjust new empty empty",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(a-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Adjust a value at a specific key. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":new \" ++ x\n adjustWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n adjustWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjustWithKey f 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "adjustWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#adjustWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Adjust value at specific key When the key is not member of the map the original map is returned let key show key new adjustWithKey fromList fromList new adjustWithKey fromList fromList adjustWithKey empty empty",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "adjustWithKey",
          "normalized": "(Key-\u003ea-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:adjustWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) alters the value \u003ccode\u003ex\u003c/code\u003e at \u003ccode\u003ek\u003c/code\u003e, or absence thereof.\n \u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e can be used to insert, delete, or update a value in an \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003e.\n In short : \u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k (\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k m) = f (\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k m)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Strict",
          "name": "alter",
          "package": "containers",
          "signature": "(Maybe a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#alter",
          "type": "function"
        },
        "index": {
          "description": "log The expression alter map alters the value at or absence thereof alter can be used to insert delete or update value in an IntMap In short lookup alter lookup",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "alter",
          "normalized": "(Maybe a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(Maybe a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:alter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function.\n\u003c/p\u003e\u003cpre\u003e let f al ar = if al == \"b\" then Just (al ++ \":\" ++ ar) else Nothing\n differenceWith f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (7, \"C\")])\n     == singleton 3 \"b:B\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "differenceWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#differenceWith",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function let al ar if al then Just al ar else Nothing differenceWith fromList fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "differenceWith",
          "normalized": "(a-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function. When two equal keys are\n encountered, the combining function is applied to the key and both values.\n If it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is discarded (proper set difference).\n If it returns (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the element is updated with a new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = if al == \"b\" then Just ((show k) ++ \":\" ++ al ++ \"|\" ++ ar) else Nothing\n differenceWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (10, \"C\")])\n     == singleton 3 \"3:b|B\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "differenceWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#differenceWithKey",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function When two equal keys are encountered the combining function is applied to the key and both values If it returns Nothing the element is discarded proper set difference If it returns Just the element is updated with new value let al ar if al then Just show al ar else Nothing differenceWithKey fromList fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "differenceWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:differenceWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression \u003ccode\u003e(\u003ccode\u003e\u003ca\u003efindWithDefault\u003c/a\u003e\u003c/code\u003e def k map)\u003c/code\u003e\n returns the value at key \u003ccode\u003ek\u003c/code\u003e or returns \u003ccode\u003edef\u003c/code\u003e when the key is not an\n element of the map.\n\u003c/p\u003e\u003cpre\u003e findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'\n findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "findWithDefault",
          "package": "containers",
          "signature": "a -\u003e Key -\u003e IntMap a -\u003e a",
          "source": "src/Data-IntMap-Strict.html#findWithDefault",
          "type": "function"
        },
        "index": {
          "description": "min The expression findWithDefault def map returns the value at key or returns def when the key is not an element of the map findWithDefault fromList findWithDefault fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "findWithDefault",
          "normalized": "a-\u003eKey-\u003eIntMap a-\u003ea",
          "package": "containers",
          "partial": "With Default",
          "signature": "a-\u003eKey-\u003eIntMap a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:findWithDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order.\n\u003c/p\u003e\u003cpre\u003e fromAscList [(3,\"b\"), (5,\"a\")]          == fromList [(3, \"b\"), (5, \"a\")]\n fromAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"b\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromAscList",
          "package": "containers",
          "signature": "[(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order fromAscList fromList fromAscList fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromAscList",
          "normalized": "[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Asc List",
          "signature": "[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order, with a combining function on equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"ba\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromAscListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromAscListWith",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order with combining function on equal keys The precondition input list is ascending is not checked fromAscListWith fromList ba",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromAscListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Asc List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromAscListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order, with a combining function on equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"ba\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromAscListWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromAscListWithKey",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order with combining function on equal keys The precondition input list is ascending is not checked fromAscListWith fromList ba",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromAscListWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Asc List With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromAscListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a list of key/value pairs where\n the keys are in ascending order and all distinct.\n \u003cem\u003eThe precondition (input list is strictly ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromDistinctAscList [(3,\"b\"), (5,\"a\")] == fromList [(3, \"b\"), (5, \"a\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromDistinctAscList",
          "package": "containers",
          "signature": "[(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from list of key value pairs where the keys are in ascending order and all distinct The precondition input list is strictly ascending is not checked fromDistinctAscList fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromDistinctAscList",
          "normalized": "[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "Distinct Asc List",
          "signature": "[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Create a map from a list of key/value pairs.\n\u003c/p\u003e\u003cpre\u003e fromList [] == empty\n fromList [(5,\"a\"), (3,\"b\"), (5, \"c\")] == fromList [(5,\"c\"), (3,\"b\")]\n fromList [(5,\"c\"), (3,\"b\"), (5, \"a\")] == fromList [(5,\"a\"), (3,\"b\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromList",
          "package": "containers",
          "signature": "[(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "min Create map from list of key value pairs fromList empty fromList fromList fromList fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromList",
          "normalized": "[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "List",
          "signature": "[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Create a map from a list of key/value pairs with a combining function. See also \u003ccode\u003e\u003ca\u003efromAscListWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e fromListWith (++) [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"a\")] == fromList [(3, \"ab\"), (5, \"aba\")]\n fromListWith (++) [] == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromListWith",
          "type": "function"
        },
        "index": {
          "description": "min Create map from list of key value pairs with combining function See also fromAscListWith fromListWith fromList ab aba fromListWith empty",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Build a map from a list of key/value pairs with a combining function. See also fromAscListWithKey'.\n\u003c/p\u003e\u003cpre\u003e fromListWith (++) [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"a\")] == fromList [(3, \"ab\"), (5, \"aba\")]\n fromListWith (++) [] == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromListWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e [(Key, a)] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromListWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Build map from list of key value pairs with combining function See also fromAscListWithKey fromListWith fromList ab aba fromListWith empty",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromListWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "package": "containers",
          "partial": "List With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003e[(Key,a)]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a set of keys and a function which for each key\n computes its value.\n\u003c/p\u003e\u003cpre\u003e fromSet (\\k -\u003e replicate k 'a') (Data.IntSet.fromList [3, 5]) == fromList [(5,\"aaaaa\"), (3,\"aaa\")]\n fromSet undefined Data.IntSet.empty == empty\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "fromSet",
          "package": "containers",
          "signature": "(Key -\u003e a) -\u003e IntSet -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#fromSet",
          "type": "function"
        },
        "index": {
          "description": "Build map from set of keys and function which for each key computes its value fromSet replicate Data.IntSet.fromList fromList aaaaa aaa fromSet undefined Data.IntSet.empty empty",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "fromSet",
          "normalized": "(Key-\u003ea)-\u003eIntSet-\u003eIntMap a",
          "package": "containers",
          "partial": "Set",
          "signature": "(Key-\u003ea)-\u003eIntSet-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:fromSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Insert a new key/value pair in the map.\n If the key is already present in the map, the associated value is\n replaced with the supplied value, i.e. \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]\n insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]\n insert 5 'x' empty                         == singleton 5 'x'\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "insert",
          "package": "containers",
          "signature": "Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#insert",
          "type": "function"
        },
        "index": {
          "description": "min Insert new key value pair in the map If the key is already present in the map the associated value is replaced with the supplied value i.e insert is equivalent to insertWith const insert fromList fromList insert fromList fromList insert empty singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "insert",
          "normalized": "Key-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "Key-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertLookupWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e)\n is a pair where the first element is equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e)\n and the second element equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertLookupWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"5:xxx|a\")])\n insertLookupWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")])\n insertLookupWithKey f 5 \"xxx\" empty                         == (Nothing,  singleton 5 \"xxx\")\n\u003c/pre\u003e\u003cp\u003eThis is how to define \u003ccode\u003einsertLookup\u003c/code\u003e using \u003ccode\u003einsertLookupWithKey\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e let insertLookup kx x t = insertLookupWithKey (\\_ a _ -\u003e a) kx x t\n insertLookup 5 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"x\")])\n insertLookup 7 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"x\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "insertLookupWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e (Maybe a, IntMap a)",
          "source": "src/Data-IntMap-Strict.html#insertLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "min The expression insertLookupWithKey map is pair where the first element is equal to lookup map and the second element equal to insertWithKey map let key new value old value show key new value old value insertLookupWithKey xxx fromList Just fromList xxx insertLookupWithKey xxx fromList Nothing fromList xxx insertLookupWithKey xxx empty Nothing singleton xxx This is how to define insertLookup using insertLookupWithKey let insertLookup kx insertLookupWithKey kx insertLookup fromList Just fromList insertLookup fromList Nothing fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "insertLookupWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:insertLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Insert with a combining function.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert \u003ccode\u003ef new_value old_value\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insertWith (++) 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"xxxa\")]\n insertWith (++) 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWith (++) 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "insertWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#insertWith",
          "type": "function"
        },
        "index": {
          "description": "min Insert with combining function insertWith key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert new value old value insertWith xxx fromList fromList xxxa insertWith xxx fromList fromList xxx insertWith xxx empty singleton xxx",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "insertWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:insertWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Insert with a combining function.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert \u003ccode\u003ef key new_value old_value\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:xxx|a\")]\n insertWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWithKey f 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e\u003cp\u003eIf the key exists in the map, this function is lazy in \u003ccode\u003ex\u003c/code\u003e but strict\n in the result of \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Strict",
          "name": "insertWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#insertWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Insert with combining function insertWithKey key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert key new value old value let key new value old value show key new value old value insertWithKey xxx fromList fromList xxx insertWithKey xxx fromList fromList xxx insertWithKey xxx empty singleton xxx If the key exists in the map this function is lazy in but strict in the result of",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "insertWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:insertWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The intersection with a combining function.\n\u003c/p\u003e\u003cpre\u003e intersectionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"aA\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "intersectionWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap c",
          "source": "src/Data-IntMap-Strict.html#intersectionWith",
          "type": "function"
        },
        "index": {
          "description": "The intersection with combining function intersectionWith fromList fromList singleton aA",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "intersectionWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:intersectionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The intersection with a combining function.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = (show k) ++ \":\" ++ al ++ \"|\" ++ ar\n intersectionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"5:a|A\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "intersectionWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e c) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap c",
          "source": "src/Data-IntMap-Strict.html#intersectionWithKey",
          "type": "function"
        },
        "index": {
          "description": "The intersection with combining function let al ar show al ar intersectionWithKey fromList fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "intersectionWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003ec)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:intersectionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e map (++ \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"bx\"), (5, \"ax\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "map",
          "package": "containers",
          "signature": "(a -\u003e b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Strict.html#map",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map map fromList fromList bx ax",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "signature": "(a-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapAccum\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a b = (a ++ b, b ++ \"X\")\n mapAccum f \"Everything: \" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: ba\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapAccum",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e IntMap b -\u003e (a, IntMap c)",
          "source": "src/Data-IntMap-Strict.html#mapAccum",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccum threads an accumulating argument through the map in ascending order of keys let mapAccum Everything fromList Everything ba fromList bX aX",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapAccum",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "package": "containers",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ccode\u003emapAccumR\u003c/code\u003e\u003c/code\u003e threads an accumulating\n argument through the map in descending order of keys.\n\u003c/p\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapAccumRWithKey",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e b -\u003e (a, c)) -\u003e a -\u003e IntMap b -\u003e (a, IntMap c)",
          "source": "src/Data-IntMap-Strict.html#mapAccumRWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumR threads an accumulating argument through the map in descending order of keys",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapAccumRWithKey",
          "normalized": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "package": "containers",
          "partial": "Accum RWith Key",
          "signature": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapAccumRWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapAccumWithKey\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a k b = (a ++ \" \" ++ (show k) ++ \"-\" ++ b, b ++ \"X\")\n mapAccumWithKey f \"Everything:\" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: 3-b 5-a\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapAccumWithKey",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e b -\u003e (a, c)) -\u003e a -\u003e IntMap b -\u003e (a, IntMap c)",
          "source": "src/Data-IntMap-Strict.html#mapAccumWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys let show mapAccumWithKey Everything fromList Everything fromList bX aX",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapAccumWithKey",
          "normalized": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "package": "containers",
          "partial": "Accum With Key",
          "signature": "(a-\u003eKey-\u003eb-\u003e(a,c))-\u003ea-\u003eIntMap b-\u003e(a,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapAccumWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f a = if a \u003c \"c\" then Left a else Right a\n mapEither f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(3,\"b\"), (5,\"a\")], fromList [(1,\"x\"), (7,\"z\")])\n\n mapEither (\\ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapEither",
          "package": "containers",
          "signature": "(a -\u003e Either b c) -\u003e IntMap a -\u003e (IntMap b, IntMap c)",
          "source": "src/Data-IntMap-Strict.html#mapEither",
          "type": "function"
        },
        "index": {
          "description": "Map values and separate the Left and Right results let if then Left else Right mapEither fromList fromList fromList mapEither Right fromList empty fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapEither",
          "normalized": "(a-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "package": "containers",
          "partial": "Either",
          "signature": "(a-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k a = if k \u003c 5 then Left (k * 2) else Right (a ++ a)\n mapEitherWithKey f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(1,2), (3,6)], fromList [(5,\"aa\"), (7,\"zz\")])\n\n mapEitherWithKey (\\_ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(1,\"x\"), (3,\"b\"), (5,\"a\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapEitherWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Either b c) -\u003e IntMap a -\u003e (IntMap b, IntMap c)",
          "source": "src/Data-IntMap-Strict.html#mapEitherWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and separate the Left and Right results let if then Left else Right mapEitherWithKey fromList fromList fromList aa zz mapEitherWithKey Right fromList empty fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapEitherWithKey",
          "normalized": "(Key-\u003ea-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "package": "containers",
          "partial": "Either With Key",
          "signature": "(Key-\u003ea-\u003eEither b c)-\u003eIntMap a-\u003e(IntMap b,IntMap c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapEitherWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeysWith\u003c/a\u003e\u003c/code\u003e c f s\u003c/code\u003e is the map obtained by applying \u003ccode\u003ef\u003c/code\u003e to each key of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe size of the result may be smaller if \u003ccode\u003ef\u003c/code\u003e maps two or more distinct\n keys to the same new key.  In this case the associated values will be\n combined using \u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e mapKeysWith (++) (\\ _ -\u003e 1) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 1 \"cdab\"\n mapKeysWith (++) (\\ _ -\u003e 3) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 3 \"cdab\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapKeysWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e (Key -\u003e Key) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#mapKeysWith",
          "type": "function"
        },
        "index": {
          "description": "log mapKeysWith is the map obtained by applying to each key of The size of the result may be smaller if maps two or more distinct keys to the same new key In this case the associated values will be combined using mapKeysWith fromList singleton cdab mapKeysWith fromList singleton cdab",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapKeysWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Keys With",
          "signature": "(a-\u003ea-\u003ea)-\u003e(Key-\u003eKey)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapKeysWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n mapMaybe f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"new a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapMaybe",
          "package": "containers",
          "signature": "(a -\u003e Maybe b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Strict.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "description": "Map values and collect the Just results let if then Just new else Nothing mapMaybe fromList singleton new",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k _ = if k \u003c 5 then Just (\"key : \" ++ (show k)) else Nothing\n mapMaybeWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"key : 3\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapMaybeWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Strict.html#mapMaybeWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and collect the Just results let if then Just key show else Nothing mapMaybeWithKey fromList singleton key",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapMaybeWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "partial": "Maybe With Key",
          "signature": "(Key-\u003ea-\u003eMaybe b)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapMaybeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":\" ++ x\n mapWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"3:b\"), (5, \"5:a\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mapWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b) -\u003e IntMap a -\u003e IntMap b",
          "source": "src/Data-IntMap-Strict.html#mapWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map let key show key mapWithKey fromList fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mapWithKey",
          "normalized": "(Key-\u003ea-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb)-\u003eIntMap a-\u003eIntMap b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. A high-performance universal combining function. Using\n \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e, all combining functions can be defined without any loss of\n efficiency (with exception of \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e,\n where sharing of some nodes is lost with \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cp\u003ePlease make sure you know what is going on when using \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e,\n otherwise you can be surprised by unexpected code growth or even\n corruption of the data structure.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e is given three arguments, it is inlined to the call\n site. You should therefore use \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e only to define your custom\n combining functions. For example, you could define \u003ccode\u003e\u003ca\u003eunionWithKey\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003edifferenceWithKey\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eintersectionWithKey\u003c/a\u003e\u003c/code\u003e as\n\u003c/p\u003e\u003cpre\u003e myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) id id m1 m2\n myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) (const empty) (const empty) m1 m2\n\u003c/pre\u003e\u003cp\u003eWhen calling \u003ccode\u003e\u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e combine only1 only2\u003c/code\u003e, a function combining two\n \u003ccode\u003e\u003ca\u003eIntMap\u003c/a\u003e\u003c/code\u003es is created, such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if a key is present in both maps, it is passed with both corresponding\n   values to the \u003ccode\u003ecombine\u003c/code\u003e function. Depending on the result, the key is either\n   present in the result with specified value, or is left out;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the first map is passed to \u003ccode\u003eonly1\u003c/code\u003e and\n   the output is added to the result;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the second map is passed to \u003ccode\u003eonly2\u003c/code\u003e and\n   the output is added to the result.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003eonly1\u003c/code\u003e and \u003ccode\u003eonly2\u003c/code\u003e methods \u003cem\u003emust return a map with a subset (possibly empty) of the keys of the given map\u003c/em\u003e.\n The values can be modified arbitrarily.  Most common variants of \u003ccode\u003eonly1\u003c/code\u003e and\n \u003ccode\u003eonly2\u003c/code\u003e are \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but for example \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e or\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efilterWithKey\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e could be used for any \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntMap.Strict",
          "name": "mergeWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e Maybe c) -\u003e (IntMap a -\u003e IntMap c) -\u003e (IntMap b -\u003e IntMap c) -\u003e IntMap a -\u003e IntMap b -\u003e IntMap c",
          "source": "src/Data-IntMap-Strict.html#mergeWithKey",
          "type": "function"
        },
        "index": {
          "description": "high-performance universal combining function Using mergeWithKey all combining functions can be defined without any loss of efficiency with exception of union difference and intersection where sharing of some nodes is lost with mergeWithKey Please make sure you know what is going on when using mergeWithKey otherwise you can be surprised by unexpected code growth or even corruption of the data structure When mergeWithKey is given three arguments it is inlined to the call site You should therefore use mergeWithKey only to define your custom combining functions For example you could define unionWithKey differenceWithKey and intersectionWithKey as myUnionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 id id m1 m2 myDifferenceWithKey m1 m2 mergeWithKey id const empty m1 m2 myIntersectionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 const empty const empty m1 m2 When calling mergeWithKey combine only1 only2 function combining two IntMap is created such that if key is present in both maps it is passed with both corresponding values to the combine function Depending on the result the key is either present in the result with specified value or is left out nonempty subtree present only in the first map is passed to only1 and the output is added to the result nonempty subtree present only in the second map is passed to only2 and the output is added to the result The only1 and only2 methods must return map with subset possibly empty of the keys of the given map The values can be modified arbitrarily Most common variants of only1 and only2 are id and const empty but for example map or filterWithKey could be used for any",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "mergeWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eMaybe c)-\u003e(IntMap a-\u003eIntMap c)-\u003e(IntMap b-\u003eIntMap c)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eMaybe c)-\u003e(IntMap a-\u003eIntMap c)-\u003e(IntMap b-\u003eIntMap c)-\u003eIntMap a-\u003eIntMap b-\u003eIntMap c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:mergeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. A map of one element.\n\u003c/p\u003e\u003cpre\u003e singleton 1 'a'        == fromList [(1, 'a')]\n size (singleton 1 'a') == 1\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "singleton",
          "package": "containers",
          "signature": "Key -\u003e a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "map of one element singleton fromList size singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "singleton",
          "normalized": "Key-\u003ea-\u003eIntMap a",
          "package": "containers",
          "signature": "Key-\u003ea-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The union with a combining function.\n\u003c/p\u003e\u003cpre\u003e unionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"aA\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "unionWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e IntMap a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#unionWith",
          "type": "function"
        },
        "index": {
          "description": "The union with combining function unionWith fromList fromList fromList aA",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "unionWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:unionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The union with a combining function.\n\u003c/p\u003e\u003cpre\u003e let f key left_value right_value = (show key) ++ \":\" ++ left_value ++ \"|\" ++ right_value\n unionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"5:a|A\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "unionWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e IntMap a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#unionWithKey",
          "type": "function"
        },
        "index": {
          "description": "The union with combining function let key left value right value show key left value right value unionWithKey fromList fromList fromList",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "unionWithKey",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eIntMap a-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:unionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of maps, with a combining operation.\n\u003c/p\u003e\u003cpre\u003e unionsWith (++) [(fromList [(5, \"a\"), (3, \"b\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"A3\"), (3, \"B3\")])]\n     == fromList [(3, \"bB3\"), (5, \"aAA3\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "unionsWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [IntMap a] -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#unionsWith",
          "type": "function"
        },
        "index": {
          "description": "The union of list of maps with combining operation unionsWith fromList fromList fromList A3 B3 fromList bB3 aAA3",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "unionsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[IntMap a]-\u003eIntMap a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[IntMap a]-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:unionsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the value \u003ccode\u003ex\u003c/code\u003e\n at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is\n deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n update f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n update f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n update f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "update",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#update",
          "type": "function"
        },
        "index": {
          "description": "min The expression update map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just new else Nothing update fromList fromList new update fromList fromList update fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "update",
          "normalized": "(a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "signature": "(a-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Lookup and update.\n The function returns original value, if it is updated.\n This is different behavior than \u003ccode\u003e\u003ca\u003eupdateLookupWithKey\u003c/a\u003e\u003c/code\u003e.\n Returns the original key value if the map entry is deleted.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateLookupWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"5:new a\")])\n updateLookupWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\")])\n updateLookupWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"b\", singleton 5 \"a\")\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "updateLookupWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e (Maybe a, IntMap a)",
          "source": "src/Data-IntMap-Strict.html#updateLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "min Lookup and update The function returns original value if it is updated This is different behavior than updateLookupWithKey Returns the original key value if the map entry is deleted let if then Just show new else Nothing updateLookupWithKey fromList Just fromList new updateLookupWithKey fromList Nothing fromList updateLookupWithKey fromList Just singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "updateLookupWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003e(Maybe a,IntMap a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:updateLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMax (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"Xa\")]\n updateMax (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "updateMax",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#updateMax",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the maximal key updateMax Just fromList fromList Xa updateMax Nothing fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "updateMax",
          "normalized": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Max",
          "signature": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:updateMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMaxWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"b\"), (5,\"5:a\")]\n updateMaxWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "updateMaxWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#updateMaxWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the maximal key updateMaxWithKey Just show fromList fromList updateMaxWithKey Nothing fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "updateMaxWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Max With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:updateMaxWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMin (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"Xb\"), (5, \"a\")]\n updateMin (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "updateMin",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#updateMin",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the minimal key updateMin Just fromList fromList Xb updateMin Nothing fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "updateMin",
          "normalized": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Min",
          "signature": "(a-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:updateMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMinWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"3:b\"), (5,\"a\")]\n updateMinWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "updateMinWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#updateMinWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the minimal key updateMinWithKey Just show fromList fromList updateMinWithKey Nothing fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "updateMinWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "Min With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:updateMinWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the value \u003ccode\u003ex\u003c/code\u003e\n at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef k x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is\n deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n updateWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n updateWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.IntMap.Strict",
          "name": "updateWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e Maybe a) -\u003e Key -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap-Strict.html#updateWithKey",
          "type": "function"
        },
        "index": {
          "description": "min The expression update map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just show new else Nothing updateWithKey fromList fromList new updateWithKey fromList fromList updateWithKey fromList singleton",
          "hierarchy": "Data IntMap Strict",
          "module": "Data.IntMap.Strict",
          "name": "updateWithKey",
          "normalized": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eMaybe a)-\u003eKey-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap-Strict.html#v:updateWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of maps from integer keys to values\n (dictionaries).\n\u003c/p\u003e\u003cp\u003eThis module re-exports the value lazy \u003ca\u003eData.IntMap.Lazy\u003c/a\u003e API, plus\n several deprecated value strict functions. Please note that these functions\n have different strictness properties than those in \u003ca\u003eData.IntMap.Strict\u003c/a\u003e:\n they only evaluate the result of the combining function. For example, the\n default value to \u003ccode\u003e\u003ca\u003einsertWith'\u003c/a\u003e\u003c/code\u003e is only evaluated if the combining function\n is called and uses it.\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import Data.IntMap (IntMap)\n  import qualified Data.IntMap as IntMap\n\u003c/pre\u003e\u003cp\u003eThe implementation is based on \u003cem\u003ebig-endian patricia trees\u003c/em\u003e.  This data\n structure performs especially well on binary operations like \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e.  However, my benchmarks show that it is also\n (much) faster on insertions and deletions when compared to a generic\n size-balanced map implementation (see \u003ca\u003eData.Map\u003c/a\u003e).\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Chris Okasaki and Andy Gill,  \"\u003cem\u003eFast Mergeable Integer Maps\u003c/em\u003e\",\n      Workshop on ML, September 1998, pages 77-86,\n      \u003ca\u003ehttp://citeseer.ist.psu.edu/okasaki98fast.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve\n      Information Coded In Alphanumeric/\", Journal of the ACM, 15(4),\n      October 1968, pages 514-534.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eOperation comments contain the operation time complexity in\n the Big-O notation \u003ca\u003ehttp://en.wikipedia.org/wiki/Big_O_notation\u003c/a\u003e.\n Many operations have a worst-case complexity of \u003cem\u003eO(min(n,W))\u003c/em\u003e.\n This means that the operation can become linear in the number of\n elements with a maximum of \u003cem\u003eW\u003c/em\u003e -- the number of bits in an \u003ccode\u003eInt\u003c/code\u003e\n (32 or 64).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IntMap",
          "name": "IntMap",
          "package": "containers",
          "source": "src/Data-IntMap.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of maps from integer keys to values dictionaries This module re-exports the value lazy Data.IntMap.Lazy API plus several deprecated value strict functions Please note that these functions have different strictness properties than those in Data.IntMap.Strict they only evaluate the result of the combining function For example the default value to insertWith is only evaluated if the combining function is called and uses it These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import Data.IntMap IntMap import qualified Data.IntMap as IntMap The implementation is based on big-endian patricia trees This data structure performs especially well on binary operations like union and intersection However my benchmarks show that it is also much faster on insertions and deletions when compared to generic size-balanced map implementation see Data.Map Chris Okasaki and Andy Gill Fast Mergeable Integer Maps Workshop on ML September pages http citeseer.ist.psu.edu okasaki98fast.html D.R Morrison PATRICIA Practical Algorithm To Retrieve Information Coded In Alphanumeric Journal of the ACM October pages Operation comments contain the operation time complexity in the Big-O notation http en.wikipedia.org wiki Big notation Many operations have worst-case complexity of min This means that the operation can become linear in the number of elements with maximum of the number of bits in an Int or",
          "hierarchy": "Data IntMap",
          "module": "Data.IntMap",
          "name": "IntMap",
          "package": "containers",
          "partial": "Int Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the values in the map using the given\n right-associative binary operator. This function is an equivalent\n of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e and is present for compatibility only.\n\u003c/p\u003e",
          "module": "Data.IntMap",
          "name": "fold",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e IntMap a -\u003e b",
          "source": "src/Data-IntMap.html#fold",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by foldr Fold the values in the map using the given right-associative binary operator This function is an equivalent of foldr and is present for compatibility only",
          "hierarchy": "Data IntMap",
          "module": "Data.IntMap",
          "name": "fold",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given\n right-associative binary operator. This function is an equivalent\n of \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e and is present for compatibility only.\n\u003c/p\u003e",
          "module": "Data.IntMap",
          "name": "foldWithKey",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e IntMap a -\u003e b",
          "source": "src/Data-IntMap.html#foldWithKey",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by foldrWithKey Fold the keys and values in the map using the given right-associative binary operator This function is an equivalent of foldrWithKey and is present for compatibility only",
          "hierarchy": "Data IntMap",
          "module": "Data.IntMap",
          "name": "foldWithKey",
          "normalized": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "package": "containers",
          "partial": "With Key",
          "signature": "(Key-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eIntMap a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap.html#v:foldWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by\n \u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Same as \u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e, but the result of the combining function\n is evaluated to WHNF before inserted to the map.\n\u003c/p\u003e",
          "module": "Data.IntMap",
          "name": "insertWith'",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap.html#insertWith%27",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by insertWith log Same as insertWith but the result of the combining function is evaluated to WHNF before inserted to the map",
          "hierarchy": "Data IntMap",
          "module": "Data.IntMap",
          "name": "insertWith'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With'",
          "signature": "(a-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap.html#v:insertWith-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by\n \u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Same as \u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e, but the result of the combining\n function is evaluated to WHNF before inserted to the map.\n\u003c/p\u003e",
          "module": "Data.IntMap",
          "name": "insertWithKey'",
          "package": "containers",
          "signature": "(Key -\u003e a -\u003e a -\u003e a) -\u003e Key -\u003e a -\u003e IntMap a -\u003e IntMap a",
          "source": "src/Data-IntMap.html#insertWithKey%27",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by insertWithKey log Same as insertWithKey but the result of the combining function is evaluated to WHNF before inserted to the map",
          "hierarchy": "Data IntMap",
          "module": "Data.IntMap",
          "name": "insertWithKey'",
          "normalized": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "package": "containers",
          "partial": "With Key'",
          "signature": "(Key-\u003ea-\u003ea-\u003ea)-\u003eKey-\u003ea-\u003eIntMap a-\u003eIntMap a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntMap.html#v:insertWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of integer sets.\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import Data.IntSet (IntSet)\n  import qualified Data.IntSet as IntSet\n\u003c/pre\u003e\u003cp\u003eThe implementation is based on \u003cem\u003ebig-endian patricia trees\u003c/em\u003e.  This data\n structure performs especially well on binary operations like \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e\n and \u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e.  However, my benchmarks show that it is also\n (much) faster on insertions and deletions when compared to a generic\n size-balanced set implementation (see \u003ca\u003eData.Set\u003c/a\u003e).\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Chris Okasaki and Andy Gill,  \"\u003cem\u003eFast Mergeable Integer Maps\u003c/em\u003e\",\n      Workshop on ML, September 1998, pages 77-86,\n      \u003ca\u003ehttp://citeseer.ist.psu.edu/okasaki98fast.html\u003c/a\u003e\n\u003c/li\u003e\u003cli\u003e D.R. Morrison, \"/PATRICIA -- Practical Algorithm To Retrieve\n      Information Coded In Alphanumeric/\", Journal of the ACM, 15(4),\n      October 1968, pages 514-534.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAdditionally, this implementation places bitmaps in the leaves of the tree.\n Their size is the natural size of a machine word (32 or 64 bits) and greatly\n reduce memory footprint and execution times for dense sets, e.g. sets where\n it is likely that many values lie close to each other. The asymptotics are\n not affected by this optimization.\n\u003c/p\u003e\u003cp\u003eMany operations have a worst-case complexity of \u003cem\u003eO(min(n,W))\u003c/em\u003e.\n This means that the operation can become linear in the number of\n elements with a maximum of \u003cem\u003eW\u003c/em\u003e -- the number of bits in an \u003ccode\u003e\u003ca\u003eInt\u003c/a\u003e\u003c/code\u003e\n (32 or 64).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.IntSet",
          "name": "IntSet",
          "package": "containers",
          "source": "src/Data-IntSet.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of integer sets These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import Data.IntSet IntSet import qualified Data.IntSet as IntSet The implementation is based on big-endian patricia trees This data structure performs especially well on binary operations like union and intersection However my benchmarks show that it is also much faster on insertions and deletions when compared to generic size-balanced set implementation see Data.Set Chris Okasaki and Andy Gill Fast Mergeable Integer Maps Workshop on ML September pages http citeseer.ist.psu.edu okasaki98fast.html D.R Morrison PATRICIA Practical Algorithm To Retrieve Information Coded In Alphanumeric Journal of the ACM October pages Additionally this implementation places bitmaps in the leaves of the tree Their size is the natural size of machine word or bits and greatly reduce memory footprint and execution times for dense sets e.g sets where it is likely that many values lie close to each other The asymptotics are not affected by this optimization Many operations have worst-case complexity of min This means that the operation can become linear in the number of elements with maximum of the number of bits in an Int or",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "IntSet",
          "package": "containers",
          "partial": "Int Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of integers.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "IntSet",
          "package": "containers",
          "source": "src/Data-IntSet-Base.html#IntSet",
          "type": "data"
        },
        "index": {
          "description": "set of integers",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "IntSet",
          "package": "containers",
          "partial": "Int Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#t:IntSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.IntSet",
          "name": "Key",
          "package": "containers",
          "source": "src/Data-IntSet-Base.html#Key",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "Key",
          "package": "containers",
          "partial": "Key",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#t:Key"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. See \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "(\\\\)",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "description": "See difference",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "(\\\\) \\\\",
          "normalized": "IntSet-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "IntSet-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete a value in the set. Returns the\n original set when the value was not present.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "delete",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#delete",
          "type": "function"
        },
        "index": {
          "description": "min Delete value in the set Returns the original set when the value was not present",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "delete",
          "normalized": "Key-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "Key-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete and find the maximal element.\n\u003c/p\u003e\u003cpre\u003e deleteFindMax set = (findMax set, deleteMax set)\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "deleteFindMax",
          "package": "containers",
          "signature": "IntSet -\u003e (Key, IntSet)",
          "source": "src/Data-IntSet-Base.html#deleteFindMax",
          "type": "function"
        },
        "index": {
          "description": "min Delete and find the maximal element deleteFindMax set findMax set deleteMax set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "deleteFindMax",
          "normalized": "IntSet-\u003e(Key,IntSet)",
          "package": "containers",
          "partial": "Find Max",
          "signature": "IntSet-\u003e(Key,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:deleteFindMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete and find the minimal element.\n\u003c/p\u003e\u003cpre\u003e deleteFindMin set = (findMin set, deleteMin set)\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "deleteFindMin",
          "package": "containers",
          "signature": "IntSet -\u003e (Key, IntSet)",
          "source": "src/Data-IntSet-Base.html#deleteFindMin",
          "type": "function"
        },
        "index": {
          "description": "min Delete and find the minimal element deleteFindMin set findMin set deleteMin set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "deleteFindMin",
          "normalized": "IntSet-\u003e(Key,IntSet)",
          "package": "containers",
          "partial": "Find Min",
          "signature": "IntSet-\u003e(Key,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:deleteFindMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete the maximal element. Returns an empty set if the set is empty.\n\u003c/p\u003e\u003cp\u003eNote that this is a change of behaviour for consistency with \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e &#8211;\n versions prior to 0.5 threw an error if the \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e was already empty.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "deleteMax",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#deleteMax",
          "type": "function"
        },
        "index": {
          "description": "min Delete the maximal element Returns an empty set if the set is empty Note that this is change of behaviour for consistency with Set versions prior to threw an error if the IntSet was already empty",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "deleteMax",
          "normalized": "IntSet-\u003eIntSet",
          "package": "containers",
          "partial": "Max",
          "signature": "IntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:deleteMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Delete the minimal element. Returns an empty set if the set is empty.\n\u003c/p\u003e\u003cp\u003eNote that this is a change of behaviour for consistency with \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e &#8211;\n versions prior to 0.5 threw an error if the \u003ccode\u003e\u003ca\u003eIntSet\u003c/a\u003e\u003c/code\u003e was already empty.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "deleteMin",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#deleteMin",
          "type": "function"
        },
        "index": {
          "description": "min Delete the minimal element Returns an empty set if the set is empty Note that this is change of behaviour for consistency with Set versions prior to threw an error if the IntSet was already empty",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "deleteMin",
          "normalized": "IntSet-\u003eIntSet",
          "package": "containers",
          "partial": "Min",
          "signature": "IntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:deleteMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference between two sets.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "difference",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#difference",
          "type": "function"
        },
        "index": {
          "description": "Difference between two sets",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "difference",
          "normalized": "IntSet-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "IntSet-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. An alias of \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e. The elements of a set in ascending order.\n Subject to list fusion.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "elems",
          "package": "containers",
          "signature": "IntSet -\u003e [Key]",
          "source": "src/Data-IntSet-Base.html#elems",
          "type": "function"
        },
        "index": {
          "description": "An alias of toAscList The elements of set in ascending order Subject to list fusion",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "elems",
          "normalized": "IntSet-\u003e[Key]",
          "package": "containers",
          "signature": "IntSet-\u003e[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The empty set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "empty",
          "package": "containers",
          "signature": "IntSet",
          "source": "src/Data-IntSet-Base.html#empty",
          "type": "function"
        },
        "index": {
          "description": "The empty set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "empty",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Filter all elements that satisfy some predicate.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "filter",
          "package": "containers",
          "signature": "(Key -\u003e Bool) -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#filter",
          "type": "function"
        },
        "index": {
          "description": "Filter all elements that satisfy some predicate",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "filter",
          "normalized": "(Key-\u003eBool)-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "(Key-\u003eBool)-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The maximal element of a set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "findMax",
          "package": "containers",
          "signature": "IntSet -\u003e Key",
          "source": "src/Data-IntSet-Base.html#findMax",
          "type": "function"
        },
        "index": {
          "description": "min The maximal element of set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "findMax",
          "normalized": "IntSet-\u003eKey",
          "package": "containers",
          "partial": "Max",
          "signature": "IntSet-\u003eKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:findMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The minimal element of the set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "findMin",
          "package": "containers",
          "signature": "IntSet -\u003e Key",
          "source": "src/Data-IntSet-Base.html#findMin",
          "type": "function"
        },
        "index": {
          "description": "min The minimal element of the set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "findMin",
          "normalized": "IntSet-\u003eKey",
          "package": "containers",
          "partial": "Min",
          "signature": "IntSet-\u003eKey",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:findMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the elements in the set using the given right-associative\n binary operator. This function is an equivalent of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e and is present\n for compatibility only.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ePlease note that fold will be deprecated in the future and removed.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "fold",
          "package": "containers",
          "signature": "(Key -\u003e b -\u003e b) -\u003e b -\u003e IntSet -\u003e b",
          "source": "src/Data-IntSet-Base.html#fold",
          "type": "function"
        },
        "index": {
          "description": "Fold the elements in the set using the given right-associative binary operator This function is an equivalent of foldr and is present for compatibility only Please note that fold will be deprecated in the future and removed",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "fold",
          "normalized": "(Key-\u003ea-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "package": "containers",
          "signature": "(Key-\u003eb-\u003eb)-\u003eb-\u003eIntSet-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the elements in the set using the given left-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e toDescList set = foldl (flip (:)) [] set\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "foldl",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e a) -\u003e a -\u003e IntSet -\u003e a",
          "source": "src/Data-IntSet-Base.html#foldl",
          "type": "function"
        },
        "index": {
          "description": "Fold the elements in the set using the given left-associative binary operator such that foldl foldl toAscList For example toDescList set foldl flip set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "foldl",
          "normalized": "(a-\u003eKey-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eKey-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "foldl'",
          "package": "containers",
          "signature": "(a -\u003e Key -\u003e a) -\u003e a -\u003e IntSet -\u003e a",
          "source": "src/Data-IntSet-Base.html#foldl%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of foldl Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "foldl'",
          "normalized": "(a-\u003eKey-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eKey-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the elements in the set using the given right-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e toAscList set = foldr (:) [] set\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "foldr",
          "package": "containers",
          "signature": "(Key -\u003e b -\u003e b) -\u003e b -\u003e IntSet -\u003e b",
          "source": "src/Data-IntSet-Base.html#foldr",
          "type": "function"
        },
        "index": {
          "description": "Fold the elements in the set using the given right-associative binary operator such that foldr foldr toAscList For example toAscList set foldr set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "foldr",
          "normalized": "(Key-\u003ea-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "package": "containers",
          "signature": "(Key-\u003eb-\u003eb)-\u003eb-\u003eIntSet-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "foldr'",
          "package": "containers",
          "signature": "(Key -\u003e b -\u003e b) -\u003e b -\u003e IntSet -\u003e b",
          "source": "src/Data-IntSet-Base.html#foldr%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of foldr Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "foldr'",
          "normalized": "(Key-\u003ea-\u003ea)-\u003ea-\u003eIntSet-\u003ea",
          "package": "containers",
          "signature": "(Key-\u003eb-\u003eb)-\u003eb-\u003eIntSet-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a set from an ascending list of elements.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "fromAscList",
          "package": "containers",
          "signature": "[Key] -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build set from an ascending list of elements The precondition input list is ascending is not checked",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "fromAscList",
          "normalized": "[Key]-\u003eIntSet",
          "package": "containers",
          "partial": "Asc List",
          "signature": "[Key]-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a set from an ascending list of distinct elements.\n \u003cem\u003eThe precondition (input list is strictly ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "fromDistinctAscList",
          "package": "containers",
          "signature": "[Key] -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "description": "Build set from an ascending list of distinct elements The precondition input list is strictly ascending is not checked",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "fromDistinctAscList",
          "normalized": "[Key]-\u003eIntSet",
          "package": "containers",
          "partial": "Distinct Asc List",
          "signature": "[Key]-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e. Create a set from a list of integers.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "fromList",
          "package": "containers",
          "signature": "[Key] -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "min Create set from list of integers",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "fromList",
          "normalized": "[Key]-\u003eIntSet",
          "package": "containers",
          "partial": "List",
          "signature": "[Key]-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Add a value to the set. There is no left- or right bias for\n IntSets.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "insert",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#insert",
          "type": "function"
        },
        "index": {
          "description": "min Add value to the set There is no left or right bias for IntSets",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "insert",
          "normalized": "Key-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "Key-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The intersection of two sets.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "intersection",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#intersection",
          "type": "function"
        },
        "index": {
          "description": "The intersection of two sets",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "intersection",
          "normalized": "IntSet-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "IntSet-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a proper subset? (ie. a subset but not equal).\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "isProperSubsetOf",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet -\u003e Bool",
          "source": "src/Data-IntSet-Base.html#isProperSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "Is this proper subset ie subset but not equal",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "isProperSubsetOf",
          "normalized": "IntSet-\u003eIntSet-\u003eBool",
          "package": "containers",
          "partial": "Proper Subset Of",
          "signature": "IntSet-\u003eIntSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:isProperSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a subset?\n \u003ccode\u003e(s1 \u003ccode\u003e\u003ca\u003eisSubsetOf\u003c/a\u003e\u003c/code\u003e s2)\u003c/code\u003e tells whether \u003ccode\u003es1\u003c/code\u003e is a subset of \u003ccode\u003es2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "isSubsetOf",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet -\u003e Bool",
          "source": "src/Data-IntSet-Base.html#isSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "Is this subset s1 isSubsetOf s2 tells whether s1 is subset of s2",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "isSubsetOf",
          "normalized": "IntSet-\u003eIntSet-\u003eBool",
          "package": "containers",
          "partial": "Subset Of",
          "signature": "IntSet-\u003eIntSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:isSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest element greater or equal to the given one.\n\u003c/p\u003e\u003cpre\u003e lookupGE 3 (fromList [3, 5]) == Just 3\n lookupGE 4 (fromList [3, 5]) == Just 5\n lookupGE 6 (fromList [3, 5]) == Nothing\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "lookupGE",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e Maybe Key",
          "source": "src/Data-IntSet-Base.html#lookupGE",
          "type": "function"
        },
        "index": {
          "description": "log Find smallest element greater or equal to the given one lookupGE fromList Just lookupGE fromList Just lookupGE fromList Nothing",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "lookupGE",
          "normalized": "Key-\u003eIntSet-\u003eMaybe Key",
          "package": "containers",
          "partial": "GE",
          "signature": "Key-\u003eIntSet-\u003eMaybe Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:lookupGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest element greater than the given one.\n\u003c/p\u003e\u003cpre\u003e lookupGT 4 (fromList [3, 5]) == Just 5\n lookupGT 5 (fromList [3, 5]) == Nothing\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "lookupGT",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e Maybe Key",
          "source": "src/Data-IntSet-Base.html#lookupGT",
          "type": "function"
        },
        "index": {
          "description": "log Find smallest element greater than the given one lookupGT fromList Just lookupGT fromList Nothing",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "lookupGT",
          "normalized": "Key-\u003eIntSet-\u003eMaybe Key",
          "package": "containers",
          "partial": "GT",
          "signature": "Key-\u003eIntSet-\u003eMaybe Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:lookupGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest element smaller or equal to the given one.\n\u003c/p\u003e\u003cpre\u003e lookupLE 2 (fromList [3, 5]) == Nothing\n lookupLE 4 (fromList [3, 5]) == Just 3\n lookupLE 5 (fromList [3, 5]) == Just 5\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "lookupLE",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e Maybe Key",
          "source": "src/Data-IntSet-Base.html#lookupLE",
          "type": "function"
        },
        "index": {
          "description": "log Find largest element smaller or equal to the given one lookupLE fromList Nothing lookupLE fromList Just lookupLE fromList Just",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "lookupLE",
          "normalized": "Key-\u003eIntSet-\u003eMaybe Key",
          "package": "containers",
          "partial": "LE",
          "signature": "Key-\u003eIntSet-\u003eMaybe Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:lookupLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest element smaller than the given one.\n\u003c/p\u003e\u003cpre\u003e lookupLT 3 (fromList [3, 5]) == Nothing\n lookupLT 5 (fromList [3, 5]) == Just 3\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "lookupLT",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e Maybe Key",
          "source": "src/Data-IntSet-Base.html#lookupLT",
          "type": "function"
        },
        "index": {
          "description": "log Find largest element smaller than the given one lookupLT fromList Nothing lookupLT fromList Just",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "lookupLT",
          "normalized": "Key-\u003eIntSet-\u003eMaybe Key",
          "package": "containers",
          "partial": "LT",
          "signature": "Key-\u003eIntSet-\u003eMaybe Key",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:lookupLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*min(n,W))\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e is the set obtained by applying \u003ccode\u003ef\u003c/code\u003e to each element of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIt's worth noting that the size of the result may be smaller if,\n for some \u003ccode\u003e(x,y)\u003c/code\u003e, \u003ccode\u003ex /= y && f x == f y\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "map",
          "package": "containers",
          "signature": "(Key -\u003e Key) -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#map",
          "type": "function"
        },
        "index": {
          "description": "min map is the set obtained by applying to each element of It worth noting that the size of the result may be smaller if for some",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "map",
          "normalized": "(Key-\u003eKey)-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "(Key-\u003eKey)-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Retrieves the maximal key of the set, and the set\n stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "maxView",
          "package": "containers",
          "signature": "IntSet -\u003e Maybe (Key, IntSet)",
          "source": "src/Data-IntSet-Base.html#maxView",
          "type": "function"
        },
        "index": {
          "description": "min Retrieves the maximal key of the set and the set stripped of that element or Nothing if passed an empty set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "maxView",
          "normalized": "IntSet-\u003eMaybe(Key,IntSet)",
          "package": "containers",
          "partial": "View",
          "signature": "IntSet-\u003eMaybe(Key,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:maxView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Is the value a member of the set?\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "member",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e Bool",
          "source": "src/Data-IntSet-Base.html#member",
          "type": "function"
        },
        "index": {
          "description": "min Is the value member of the set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "member",
          "normalized": "Key-\u003eIntSet-\u003eBool",
          "package": "containers",
          "signature": "Key-\u003eIntSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Retrieves the minimal key of the set, and the set\n stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "minView",
          "package": "containers",
          "signature": "IntSet -\u003e Maybe (Key, IntSet)",
          "source": "src/Data-IntSet-Base.html#minView",
          "type": "function"
        },
        "index": {
          "description": "min Retrieves the minimal key of the set and the set stripped of that element or Nothing if passed an empty set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "minView",
          "normalized": "IntSet-\u003eMaybe(Key,IntSet)",
          "package": "containers",
          "partial": "View",
          "signature": "IntSet-\u003eMaybe(Key,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:minView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Is the element not in the set?\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "notMember",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e Bool",
          "source": "src/Data-IntSet-Base.html#notMember",
          "type": "function"
        },
        "index": {
          "description": "min Is the element not in the set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "notMember",
          "normalized": "Key-\u003eIntSet-\u003eBool",
          "package": "containers",
          "partial": "Member",
          "signature": "Key-\u003eIntSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Is the set empty?\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "null",
          "package": "containers",
          "signature": "IntSet -\u003e Bool",
          "source": "src/Data-IntSet-Base.html#null",
          "type": "function"
        },
        "index": {
          "description": "Is the set empty",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "null",
          "normalized": "IntSet-\u003eBool",
          "package": "containers",
          "signature": "IntSet-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. partition the set according to some predicate.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "partition",
          "package": "containers",
          "signature": "(Key -\u003e Bool) -\u003e IntSet -\u003e (IntSet, IntSet)",
          "source": "src/Data-IntSet-Base.html#partition",
          "type": "function"
        },
        "index": {
          "description": "partition the set according to some predicate",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "partition",
          "normalized": "(Key-\u003eBool)-\u003eIntSet-\u003e(IntSet,IntSet)",
          "package": "containers",
          "signature": "(Key-\u003eBool)-\u003eIntSet-\u003e(IntSet,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Show the tree that implements the set. The tree is shown\n in a compressed, hanging format.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "showTree",
          "package": "containers",
          "signature": "IntSet -\u003e String",
          "source": "src/Data-IntSet-Base.html#showTree",
          "type": "function"
        },
        "index": {
          "description": "Show the tree that implements the set The tree is shown in compressed hanging format",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "showTree",
          "normalized": "IntSet-\u003eString",
          "package": "containers",
          "partial": "Tree",
          "signature": "IntSet-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eshowTreeWith\u003c/a\u003e\u003c/code\u003e hang wide map\u003c/code\u003e) shows\n the tree that implements the set. If \u003ccode\u003ehang\u003c/code\u003e is\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, a \u003cem\u003ehanging\u003c/em\u003e tree is shown otherwise a rotated tree is shown. If\n \u003ccode\u003ewide\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, an extra wide version is shown.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "showTreeWith",
          "package": "containers",
          "signature": "Bool -\u003e Bool -\u003e IntSet -\u003e String",
          "source": "src/Data-IntSet-Base.html#showTreeWith",
          "type": "function"
        },
        "index": {
          "description": "The expression showTreeWith hang wide map shows the tree that implements the set If hang is True hanging tree is shown otherwise rotated tree is shown If wide is True an extra wide version is shown",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "showTreeWith",
          "normalized": "Bool-\u003eBool-\u003eIntSet-\u003eString",
          "package": "containers",
          "partial": "Tree With",
          "signature": "Bool-\u003eBool-\u003eIntSet-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. A set of one element.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "singleton",
          "package": "containers",
          "signature": "Key -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "set of one element",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "singleton",
          "normalized": "Key-\u003eIntSet",
          "package": "containers",
          "signature": "Key-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Cardinality of the set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "size",
          "package": "containers",
          "signature": "IntSet -\u003e Int",
          "source": "src/Data-IntSet-Base.html#size",
          "type": "function"
        },
        "index": {
          "description": "Cardinality of the set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "size",
          "normalized": "IntSet-\u003eInt",
          "package": "containers",
          "signature": "IntSet-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e x set\u003c/code\u003e) is a pair \u003ccode\u003e(set1,set2)\u003c/code\u003e\n where \u003ccode\u003eset1\u003c/code\u003e comprises the elements of \u003ccode\u003eset\u003c/code\u003e less than \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003eset2\u003c/code\u003e\n comprises the elements of \u003ccode\u003eset\u003c/code\u003e greater than \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])\n\u003c/pre\u003e",
          "module": "Data.IntSet",
          "name": "split",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e (IntSet, IntSet)",
          "source": "src/Data-IntSet-Base.html#split",
          "type": "function"
        },
        "index": {
          "description": "min The expression split set is pair set1 set2 where set1 comprises the elements of set less than and set2 comprises the elements of set greater than split fromList fromList fromList",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "split",
          "normalized": "Key-\u003eIntSet-\u003e(IntSet,IntSet)",
          "package": "containers",
          "signature": "Key-\u003eIntSet-\u003e(IntSet,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n,W))\u003c/em\u003e. Performs a \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e but also returns whether the pivot\n element was found in the original set.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "splitMember",
          "package": "containers",
          "signature": "Key -\u003e IntSet -\u003e (IntSet, Bool, IntSet)",
          "source": "src/Data-IntSet-Base.html#splitMember",
          "type": "function"
        },
        "index": {
          "description": "min Performs split but also returns whether the pivot element was found in the original set",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "splitMember",
          "normalized": "Key-\u003eIntSet-\u003e(IntSet,Bool,IntSet)",
          "package": "containers",
          "partial": "Member",
          "signature": "Key-\u003eIntSet-\u003e(IntSet,Bool,IntSet)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:splitMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e.  Decompose a set into pieces based on the structure of the underlying\n tree.  This function is useful for consuming a set in parallel.\n\u003c/p\u003e\u003cp\u003eNo guarantee is made as to the sizes of the pieces; an internal, but\n deterministic process determines this.  However, it is guaranteed that the\n pieces returned will be in ascending order (all elements in the first submap\n less than all elements in the second, and so on).\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e splitRoot (fromList [1..120]) == [fromList [1..63],fromList [64..120]]\n splitRoot empty == []\n\u003c/pre\u003e\u003cp\u003eNote that the current implementation does not return more than two subsets,\n  but you should not depend on this behaviour because it can change in the\n  future without notice. Also, the current version does not continue\n  splitting all the way to individual singleton sets -- it stops at some\n  point.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "splitRoot",
          "package": "containers",
          "signature": "IntSet -\u003e [IntSet]",
          "source": "src/Data-IntSet-Base.html#splitRoot",
          "type": "function"
        },
        "index": {
          "description": "Decompose set into pieces based on the structure of the underlying tree This function is useful for consuming set in parallel No guarantee is made as to the sizes of the pieces an internal but deterministic process determines this However it is guaranteed that the pieces returned will be in ascending order all elements in the first submap less than all elements in the second and so on Examples splitRoot fromList fromList fromList splitRoot empty Note that the current implementation does not return more than two subsets but you should not depend on this behaviour because it can change in the future without notice Also the current version does not continue splitting all the way to individual singleton sets it stops at some point",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "splitRoot",
          "normalized": "IntSet-\u003e[IntSet]",
          "package": "containers",
          "partial": "Root",
          "signature": "IntSet-\u003e[IntSet]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:splitRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the set to an ascending list of elements. Subject to list\n fusion.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "toAscList",
          "package": "containers",
          "signature": "IntSet -\u003e [Key]",
          "source": "src/Data-IntSet-Base.html#toAscList",
          "type": "function"
        },
        "index": {
          "description": "Convert the set to an ascending list of elements Subject to list fusion",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "toAscList",
          "normalized": "IntSet-\u003e[Key]",
          "package": "containers",
          "partial": "Asc List",
          "signature": "IntSet-\u003e[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the set to a descending list of elements. Subject to list\n fusion.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "toDescList",
          "package": "containers",
          "signature": "IntSet -\u003e [Key]",
          "source": "src/Data-IntSet-Base.html#toDescList",
          "type": "function"
        },
        "index": {
          "description": "Convert the set to descending list of elements Subject to list fusion",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "toDescList",
          "normalized": "IntSet-\u003e[Key]",
          "package": "containers",
          "partial": "Desc List",
          "signature": "IntSet-\u003e[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:toDescList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the set to a list of elements. Subject to list fusion.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "toList",
          "package": "containers",
          "signature": "IntSet -\u003e [Key]",
          "source": "src/Data-IntSet-Base.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Convert the set to list of elements Subject to list fusion",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "toList",
          "normalized": "IntSet-\u003e[Key]",
          "package": "containers",
          "partial": "List",
          "signature": "IntSet-\u003e[Key]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The union of two sets.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "union",
          "package": "containers",
          "signature": "IntSet -\u003e IntSet -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#union",
          "type": "function"
        },
        "index": {
          "description": "The union of two sets",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "union",
          "normalized": "IntSet-\u003eIntSet-\u003eIntSet",
          "package": "containers",
          "signature": "IntSet-\u003eIntSet-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of sets.\n\u003c/p\u003e",
          "module": "Data.IntSet",
          "name": "unions",
          "package": "containers",
          "signature": "[IntSet] -\u003e IntSet",
          "source": "src/Data-IntSet-Base.html#unions",
          "type": "function"
        },
        "index": {
          "description": "The union of list of sets",
          "hierarchy": "Data IntSet",
          "module": "Data.IntSet",
          "name": "unions",
          "normalized": "[IntSet]-\u003eIntSet",
          "package": "containers",
          "signature": "[IntSet]-\u003eIntSet",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-IntSet.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of ordered maps from keys to values\n (dictionaries).\n\u003c/p\u003e\u003cp\u003eAPI of this module is strict in the keys, but lazy in the values.\n If you need value-strict maps, use \u003ca\u003eData.Map.Strict\u003c/a\u003e instead.\n The \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e type itself is shared between the lazy and strict modules,\n meaning that the same \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e value can be passed to functions in\n both modules (although that is rarely needed).\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import qualified Data.Map.Lazy as Map\n\u003c/pre\u003e\u003cp\u003eThe implementation of \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e is based on \u003cem\u003esize balanced\u003c/em\u003e binary trees (or\n trees of \u003cem\u003ebounded balance\u003c/em\u003e) as described by:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Stephen Adams, \"\u003cem\u003eEfficient sets: a balancing act\u003c/em\u003e\",\n     Journal of Functional Programming 3(4):553-562, October 1993,\n     \u003ca\u003ehttp://www.swiss.ai.mit.edu/~adams/BB/\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e J. Nievergelt and E.M. Reingold,\n      \"\u003cem\u003eBinary search trees of bounded balance\u003c/em\u003e\",\n      SIAM journal of computing 2(1), March 1973.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote that the implementation is \u003cem\u003eleft-biased\u003c/em\u003e -- the elements of a\n first argument are always preferred to the second, for example in\n \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOperation comments contain the operation time complexity in\n the Big-O notation (\u003ca\u003ehttp://en.wikipedia.org/wiki/Big_O_notation\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Map.Lazy",
          "name": "Lazy",
          "package": "containers",
          "source": "src/Data-Map-Lazy.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of ordered maps from keys to values dictionaries API of this module is strict in the keys but lazy in the values If you need value-strict maps use Data.Map.Strict instead The Map type itself is shared between the lazy and strict modules meaning that the same Map value can be passed to functions in both modules although that is rarely needed These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import qualified Data.Map.Lazy as Map The implementation of Map is based on size balanced binary trees or trees of bounded balance as described by Stephen Adams Efficient sets balancing act Journal of Functional Programming October http www.swiss.ai.mit.edu adams BB Nievergelt and E.M Reingold Binary search trees of bounded balance SIAM journal of computing March Note that the implementation is left-biased the elements of first argument are always preferred to the second for example in union or insert Operation comments contain the operation time complexity in the Big-O notation http en.wikipedia.org wiki Big notation",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "Lazy",
          "package": "containers",
          "partial": "Lazy",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Map from keys \u003ccode\u003ek\u003c/code\u003e to values \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Map.Lazy",
          "name": "Map",
          "package": "containers",
          "source": "src/Data-Map-Base.html#Map",
          "type": "data"
        },
        "index": {
          "description": "Map from keys to values",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "Map",
          "package": "containers",
          "partial": "Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#t:Map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find the value at a key.\n Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e when the element can not be found.\n\u003c/p\u003e\u003cpre\u003e fromList [(5,'a'), (3,'b')] ! 1    Error: element not in the map\n fromList [(5,'a'), (3,'b')] ! 5 == 'a'\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "(!)",
          "package": "containers",
          "signature": "Map k a -\u003e k -\u003e a",
          "source": "src/Data-Map-Base.html#%21",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:-33-\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:-33-\"]"
        },
        "index": {
          "description": "log Find the value at key Calls error when the element can not be found fromList Error element not in the map fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "(!) !",
          "normalized": "Map a b-\u003ea-\u003eb",
          "package": "containers",
          "signature": "Map k a-\u003ek-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:-33-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSame as \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "(\\\\)",
          "package": "containers",
          "signature": "Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Base.html#%5C%5C",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:-92--92-\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:-92--92-\"]"
        },
        "index": {
          "description": "Same as difference",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "(\\\\) \\\\",
          "normalized": "Map a b-\u003eMap a c-\u003eMap a b",
          "package": "containers",
          "signature": "Map k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update a value at a specific key with the result of the provided function.\n When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e adjust (\"new \" ++) 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n adjust (\"new \" ++) 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjust (\"new \" ++) 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "adjust",
          "package": "containers",
          "signature": "(a -\u003e a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#adjust",
          "type": "function"
        },
        "index": {
          "description": "log Update value at specific key with the result of the provided function When the key is not member of the map the original map is returned adjust new fromList fromList new adjust new fromList fromList adjust new empty empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(a-\u003ea)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Adjust a value at a specific key. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":new \" ++ x\n adjustWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n adjustWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjustWithKey f 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "adjustWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#adjustWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Adjust value at specific key When the key is not member of the map the original map is returned let key show key new adjustWithKey fromList fromList new adjustWithKey fromList fromList adjustWithKey empty empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "adjustWithKey",
          "normalized": "(a-\u003eb-\u003eb)-\u003ea-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003ea)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:adjustWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) alters the value \u003ccode\u003ex\u003c/code\u003e at \u003ccode\u003ek\u003c/code\u003e, or absence thereof.\n \u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e can be used to insert, delete, or update a value in a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e.\n In short : \u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k (\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k m) = f (\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k m)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f _ = Nothing\n alter f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n alter f 5 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\n let f _ = Just \"c\"\n alter f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"c\")]\n alter f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"c\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "alter",
          "package": "containers",
          "signature": "(Maybe a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#alter",
          "type": "function"
        },
        "index": {
          "description": "log The expression alter map alters the value at or absence thereof alter can be used to insert delete or update value in Map In short lookup alter lookup let Nothing alter fromList fromList alter fromList singleton let Just alter fromList fromList alter fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "alter",
          "normalized": "(Maybe a-\u003eMaybe a)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(Maybe a-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:alter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. An alias for \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e. Return all key/value pairs in the map\n in ascending key order. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e assocs (fromList [(5,\"a\"), (3,\"b\")]) == [(3,\"b\"), (5,\"a\")]\n assocs empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "assocs",
          "package": "containers",
          "signature": "Map k a -\u003e [(k, a)]",
          "source": "src/Data-Map-Base.html#assocs",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:assocs\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:assocs\"]"
        },
        "index": {
          "description": "An alias for toAscList Return all key value pairs in the map in ascending key order Subject to list fusion assocs fromList assocs empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "assocs",
          "normalized": "Map a b-\u003e[(a,b)]",
          "package": "containers",
          "signature": "Map k a-\u003e[(k,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:assocs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete a key and its value from the map. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e delete 5 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n delete 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n delete 5 empty                         == empty\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "delete",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#delete",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:delete\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:delete\"]"
        },
        "index": {
          "description": "log Delete key and its value from the map When the key is not member of the map the original map is returned delete fromList singleton delete fromList fromList delete empty empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "delete",
          "normalized": "a-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "signature": "k-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete the element at \u003cem\u003eindex\u003c/em\u003e, i.e. by its zero-based index in\n the sequence sorted by keys. If the \u003cem\u003eindex\u003c/em\u003e is out of range (less than zero,\n greater or equal to \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the map), \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e\u003cpre\u003e deleteAt 0  (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n deleteAt 1  (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n deleteAt 2 (fromList [(5,\"a\"), (3,\"b\")])     Error: index out of range\n deleteAt (-1) (fromList [(5,\"a\"), (3,\"b\")])  Error: index out of range\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "deleteAt",
          "package": "containers",
          "signature": "Int -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#deleteAt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteAt\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:deleteAt\"]"
        },
        "index": {
          "description": "log Delete the element at index i.e by its zero-based index in the sequence sorted by keys If the index is out of range less than zero greater or equal to size of the map error is called deleteAt fromList singleton deleteAt fromList singleton deleteAt fromList Error index out of range deleteAt fromList Error index out of range",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "deleteAt",
          "normalized": "Int-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "At",
          "signature": "Int-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete and find the maximal element.\n\u003c/p\u003e\u003cpre\u003e deleteFindMax (fromList [(5,\"a\"), (3,\"b\"), (10,\"c\")]) == ((10,\"c\"), fromList [(3,\"b\"), (5,\"a\")])\n deleteFindMax empty                                      Error: can not return the maximal element of an empty map\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "deleteFindMax",
          "package": "containers",
          "signature": "Map k a -\u003e ((k, a), Map k a)",
          "source": "src/Data-Map-Base.html#deleteFindMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteFindMax\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:deleteFindMax\"]"
        },
        "index": {
          "description": "log Delete and find the maximal element deleteFindMax fromList fromList deleteFindMax empty Error can not return the maximal element of an empty map",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "deleteFindMax",
          "normalized": "Map a b-\u003e((a,b),Map a b)",
          "package": "containers",
          "partial": "Find Max",
          "signature": "Map k a-\u003e((k,a),Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteFindMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete and find the minimal element.\n\u003c/p\u003e\u003cpre\u003e deleteFindMin (fromList [(5,\"a\"), (3,\"b\"), (10,\"c\")]) == ((3,\"b\"), fromList[(5,\"a\"), (10,\"c\")])\n deleteFindMin                                            Error: can not return the minimal element of an empty map\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "deleteFindMin",
          "package": "containers",
          "signature": "Map k a -\u003e ((k, a), Map k a)",
          "source": "src/Data-Map-Base.html#deleteFindMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteFindMin\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:deleteFindMin\"]"
        },
        "index": {
          "description": "log Delete and find the minimal element deleteFindMin fromList fromList deleteFindMin Error can not return the minimal element of an empty map",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "deleteFindMin",
          "normalized": "Map a b-\u003e((a,b),Map a b)",
          "package": "containers",
          "partial": "Find Min",
          "signature": "Map k a-\u003e((k,a),Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteFindMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete the maximal key. Returns an empty map if the map is empty.\n\u003c/p\u003e\u003cpre\u003e deleteMax (fromList [(5,\"a\"), (3,\"b\"), (7,\"c\")]) == fromList [(3,\"b\"), (5,\"a\")]\n deleteMax empty == empty\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "deleteMax",
          "package": "containers",
          "signature": "Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#deleteMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteMax\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:deleteMax\"]"
        },
        "index": {
          "description": "log Delete the maximal key Returns an empty map if the map is empty deleteMax fromList fromList deleteMax empty empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "deleteMax",
          "normalized": "Map a b-\u003eMap a b",
          "package": "containers",
          "partial": "Max",
          "signature": "Map k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete the minimal key. Returns an empty map if the map is empty.\n\u003c/p\u003e\u003cpre\u003e deleteMin (fromList [(5,\"a\"), (3,\"b\"), (7,\"c\")]) == fromList [(5,\"a\"), (7,\"c\")]\n deleteMin empty == empty\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "deleteMin",
          "package": "containers",
          "signature": "Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#deleteMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteMin\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:deleteMin\"]"
        },
        "index": {
          "description": "log Delete the minimal key Returns an empty map if the map is empty deleteMin fromList fromList deleteMin empty empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "deleteMin",
          "normalized": "Map a b-\u003eMap a b",
          "package": "containers",
          "partial": "Min",
          "signature": "Map k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:deleteMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference of two maps.\n Return elements of the first map not existing in the second map.\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e difference (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "difference",
          "package": "containers",
          "signature": "Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Base.html#difference",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:difference\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:difference\"]"
        },
        "index": {
          "description": "Difference of two maps Return elements of the first map not existing in the second map The implementation uses an efficient hedge algorithm comparable with hedge-union difference fromList fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "difference",
          "normalized": "Map a b-\u003eMap a c-\u003eMap a b",
          "package": "containers",
          "signature": "Map k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function.\n When two equal keys are\n encountered, the combining function is applied to the values of these keys.\n If it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is discarded (proper set difference). If\n it returns (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the element is updated with a new value \u003ccode\u003ey\u003c/code\u003e.\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let f al ar = if al == \"b\" then Just (al ++ \":\" ++ ar) else Nothing\n differenceWith f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (7, \"C\")])\n     == singleton 3 \"b:B\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "differenceWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Maybe a) -\u003e Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Base.html#differenceWith",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function When two equal keys are encountered the combining function is applied to the values of these keys If it returns Nothing the element is discarded proper set difference If it returns Just the element is updated with new value The implementation uses an efficient hedge algorithm comparable with hedge-union let al ar if al then Just al ar else Nothing differenceWith fromList fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "differenceWith",
          "normalized": "(a-\u003eb-\u003eMaybe a)-\u003eMap c a-\u003eMap c b-\u003eMap c a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eMaybe a)-\u003eMap k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function. When two equal keys are\n encountered, the combining function is applied to the key and both values.\n If it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is discarded (proper set difference). If\n it returns (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the element is updated with a new value \u003ccode\u003ey\u003c/code\u003e.\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = if al == \"b\" then Just ((show k) ++ \":\" ++ al ++ \"|\" ++ ar) else Nothing\n differenceWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (10, \"C\")])\n     == singleton 3 \"3:b|B\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "differenceWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e Maybe a) -\u003e Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Base.html#differenceWithKey",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function When two equal keys are encountered the combining function is applied to the key and both values If it returns Nothing the element is discarded proper set difference If it returns Just the element is updated with new value The implementation uses an efficient hedge algorithm comparable with hedge-union let al ar if al then Just show al ar else Nothing differenceWithKey fromList fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "differenceWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003eMaybe b)-\u003eMap a b-\u003eMap a c-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003eMaybe a)-\u003eMap k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:differenceWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieve an element by its \u003cem\u003eindex\u003c/em\u003e, i.e. by its zero-based\n index in the sequence sorted by keys. If the \u003cem\u003eindex\u003c/em\u003e is out of range (less\n than zero, greater or equal to \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the map), \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e\u003cpre\u003e elemAt 0 (fromList [(5,\"a\"), (3,\"b\")]) == (3,\"b\")\n elemAt 1 (fromList [(5,\"a\"), (3,\"b\")]) == (5, \"a\")\n elemAt 2 (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "elemAt",
          "package": "containers",
          "signature": "Int -\u003e Map k a -\u003e (k, a)",
          "source": "src/Data-Map-Base.html#elemAt",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:elemAt\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:elemAt\"]"
        },
        "index": {
          "description": "log Retrieve an element by its index i.e by its zero-based index in the sequence sorted by keys If the index is out of range less than zero greater or equal to size of the map error is called elemAt fromList elemAt fromList elemAt fromList Error index out of range",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "elemAt",
          "normalized": "Int-\u003eMap a b-\u003e(a,b)",
          "package": "containers",
          "partial": "At",
          "signature": "Int-\u003eMap k a-\u003e(k,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:elemAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.\n Return all elements of the map in the ascending order of their keys.\n Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e elems (fromList [(5,\"a\"), (3,\"b\")]) == [\"b\",\"a\"]\n elems empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "elems",
          "package": "containers",
          "signature": "Map k a -\u003e [a]",
          "source": "src/Data-Map-Base.html#elems",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:elems\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:elems\"]"
        },
        "index": {
          "description": "Return all elements of the map in the ascending order of their keys Subject to list fusion elems fromList elems empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "elems",
          "normalized": "Map a b-\u003e[b]",
          "package": "containers",
          "signature": "Map k a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The empty map.\n\u003c/p\u003e\u003cpre\u003e empty      == fromList []\n size empty == 0\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "empty",
          "package": "containers",
          "signature": "Map k a",
          "source": "src/Data-Map-Base.html#empty",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:empty\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:empty\"]"
        },
        "index": {
          "description": "The empty map empty fromList size empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "empty",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Filter all values that satisfy the predicate.\n\u003c/p\u003e\u003cpre\u003e filter (\u003e \"a\") (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n filter (\u003e \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == empty\n filter (\u003c \"a\") (fromList [(5,\"a\"), (3,\"b\")]) == empty\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "filter",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#filter",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:filter\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:filter\"]"
        },
        "index": {
          "description": "Filter all values that satisfy the predicate filter fromList singleton filter fromList empty filter fromList empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Filter all keys/values that satisfy the predicate.\n\u003c/p\u003e\u003cpre\u003e filterWithKey (\\k _ -\u003e k \u003e 4) (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "filterWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Bool) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#filterWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:filterWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:filterWithKey\"]"
        },
        "index": {
          "description": "Filter all keys values that satisfy the predicate filterWithKey fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "filterWithKey",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eBool)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:filterWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Return the \u003cem\u003eindex\u003c/em\u003e of a key, which is its zero-based index in\n the sequence sorted by keys. The index is a number from \u003cem\u003e0\u003c/em\u003e up to, but not\n including, the \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the map. Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e when the key is not\n a \u003ccode\u003e\u003ca\u003emember\u003c/a\u003e\u003c/code\u003e of the map.\n\u003c/p\u003e\u003cpre\u003e findIndex 2 (fromList [(5,\"a\"), (3,\"b\")])    Error: element is not in the map\n findIndex 3 (fromList [(5,\"a\"), (3,\"b\")]) == 0\n findIndex 5 (fromList [(5,\"a\"), (3,\"b\")]) == 1\n findIndex 6 (fromList [(5,\"a\"), (3,\"b\")])    Error: element is not in the map\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "findIndex",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e Int",
          "source": "src/Data-Map-Base.html#findIndex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findIndex\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:findIndex\"]"
        },
        "index": {
          "description": "log Return the index of key which is its zero-based index in the sequence sorted by keys The index is number from up to but not including the size of the map Calls error when the key is not member of the map findIndex fromList Error element is not in the map findIndex fromList findIndex fromList findIndex fromList Error element is not in the map",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "findIndex",
          "normalized": "a-\u003eMap a b-\u003eInt",
          "package": "containers",
          "partial": "Index",
          "signature": "k-\u003eMap k a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The maximal key of the map. Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e if the map is empty.\n\u003c/p\u003e\u003cpre\u003e findMax (fromList [(5,\"a\"), (3,\"b\")]) == (5,\"a\")\n findMax empty                            Error: empty map has no maximal element\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "findMax",
          "package": "containers",
          "signature": "Map k a -\u003e (k, a)",
          "source": "src/Data-Map-Base.html#findMax",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findMax\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:findMax\"]"
        },
        "index": {
          "description": "log The maximal key of the map Calls error if the map is empty findMax fromList findMax empty Error empty map has no maximal element",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "findMax",
          "normalized": "Map a b-\u003e(a,b)",
          "package": "containers",
          "partial": "Max",
          "signature": "Map k a-\u003e(k,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The minimal key of the map. Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e if the map is empty.\n\u003c/p\u003e\u003cpre\u003e findMin (fromList [(5,\"a\"), (3,\"b\")]) == (3,\"b\")\n findMin empty                            Error: empty map has no minimal element\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "findMin",
          "package": "containers",
          "signature": "Map k a -\u003e (k, a)",
          "source": "src/Data-Map-Base.html#findMin",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findMin\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:findMin\"]"
        },
        "index": {
          "description": "log The minimal key of the map Calls error if the map is empty findMin fromList findMin empty Error empty map has no minimal element",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "findMin",
          "normalized": "Map a b-\u003e(a,b)",
          "package": "containers",
          "partial": "Min",
          "signature": "Map k a-\u003e(k,a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression \u003ccode\u003e(\u003ccode\u003e\u003ca\u003efindWithDefault\u003c/a\u003e\u003c/code\u003e def k map)\u003c/code\u003e returns\n the value at key \u003ccode\u003ek\u003c/code\u003e or returns default value \u003ccode\u003edef\u003c/code\u003e\n when the key is not in the map.\n\u003c/p\u003e\u003cpre\u003e findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'\n findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "findWithDefault",
          "package": "containers",
          "signature": "a -\u003e k -\u003e Map k a -\u003e a",
          "source": "src/Data-Map-Base.html#findWithDefault",
          "type": "function"
        },
        "index": {
          "description": "log The expression findWithDefault def map returns the value at key or returns default value def when the key is not in the map findWithDefault fromList findWithDefault fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "findWithDefault",
          "normalized": "a-\u003eb-\u003eMap b a-\u003ea",
          "package": "containers",
          "partial": "With Default",
          "signature": "a-\u003ek-\u003eMap k a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:findWithDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given monoid, such that\n\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u003ca\u003efoldMapWithKey\u003c/a\u003e\u003c/code\u003e f = \u003ccode\u003e\u003ca\u003efold\u003c/a\u003e\u003c/code\u003e . \u003ccode\u003e\u003ca\u003emapWithKey\u003c/a\u003e\u003c/code\u003e f\u003c/pre\u003e\u003cp\u003eThis can be an asymptotically faster than \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003efoldlWithKey\u003c/a\u003e\u003c/code\u003e for some monoids.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldMapWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e m) -\u003e Map k a -\u003e m",
          "source": "src/Data-Map-Base.html#foldMapWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldMapWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldMapWithKey\"]"
        },
        "index": {
          "description": "Fold the keys and values in the map using the given monoid such that foldMapWithKey fold mapWithKey This can be an asymptotically faster than foldrWithKey or foldlWithKey for some monoids",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldMapWithKey",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap a b-\u003ec",
          "package": "containers",
          "partial": "Map With Key",
          "signature": "(k-\u003ea-\u003em)-\u003eMap k a-\u003em",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldMapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the values in the map using the given left-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003eelems\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e elems = reverse . foldl (flip (:)) []\n\u003c/pre\u003e\u003cpre\u003e let f len a = len + (length a)\n foldl f 0 (fromList [(5,\"a\"), (3,\"bbb\")]) == 4\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldl",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Map k b -\u003e a",
          "source": "src/Data-Map-Base.html#foldl",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldl\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldl\"]"
        },
        "index": {
          "description": "Fold the values in the map using the given left-associative binary operator such that foldl foldl elems For example elems reverse foldl flip let len len length foldl fromList bbb",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eMap c b-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eMap k b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldl'",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Map k b -\u003e a",
          "source": "src/Data-Map-Base.html#foldl%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldl-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldl-39-\"]"
        },
        "index": {
          "description": "strict version of foldl Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eMap c b-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eMap k b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given left-associative\n binary operator, such that\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldlWithKey\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e (\\z' (kx, x) -\u003e f z' kx x) z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e keys = reverse . foldlWithKey (\\ks k x -\u003e k:ks) []\n\u003c/pre\u003e\u003cpre\u003e let f result k a = result ++ \"(\" ++ (show k) ++ \":\" ++ a ++ \")\"\n foldlWithKey f \"Map: \" (fromList [(5,\"a\"), (3,\"b\")]) == \"Map: (3:b)(5:a)\"\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldlWithKey",
          "package": "containers",
          "signature": "(a -\u003e k -\u003e b -\u003e a) -\u003e a -\u003e Map k b -\u003e a",
          "source": "src/Data-Map-Base.html#foldlWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldlWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldlWithKey\"]"
        },
        "index": {
          "description": "Fold the keys and values in the map using the given left-associative binary operator such that foldlWithKey foldl kx kx toAscList For example keys reverse foldlWithKey ks ks let result result show foldlWithKey Map fromList Map",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldlWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003ea)-\u003ea-\u003eMap b c-\u003ea",
          "package": "containers",
          "partial": "With Key",
          "signature": "(a-\u003ek-\u003eb-\u003ea)-\u003ea-\u003eMap k b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldlWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldlWithKey\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldlWithKey'",
          "package": "containers",
          "signature": "(a -\u003e k -\u003e b -\u003e a) -\u003e a -\u003e Map k b -\u003e a",
          "source": "src/Data-Map-Base.html#foldlWithKey%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldlWithKey-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldlWithKey-39-\"]"
        },
        "index": {
          "description": "strict version of foldlWithKey Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldlWithKey'",
          "normalized": "(a-\u003eb-\u003ec-\u003ea)-\u003ea-\u003eMap b c-\u003ea",
          "package": "containers",
          "partial": "With Key'",
          "signature": "(a-\u003ek-\u003eb-\u003ea)-\u003ea-\u003eMap k b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldlWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the values in the map using the given right-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003eelems\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e elems map = foldr (:) [] map\n\u003c/pre\u003e\u003cpre\u003e let f a len = len + (length a)\n foldr f 0 (fromList [(5,\"a\"), (3,\"bbb\")]) == 4\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldr",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Map k a -\u003e b",
          "source": "src/Data-Map-Base.html#foldr",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldr\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldr\"]"
        },
        "index": {
          "description": "Fold the values in the map using the given right-associative binary operator such that foldr foldr elems For example elems map foldr map let len len length foldr fromList bbb",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eMap c a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eMap k a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldr'",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Map k a -\u003e b",
          "source": "src/Data-Map-Base.html#foldr%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldr-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldr-39-\"]"
        },
        "index": {
          "description": "strict version of foldr Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eMap c a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eMap k a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given right-associative\n binary operator, such that\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003euncurry\u003c/a\u003e\u003c/code\u003e f) z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e keys map = foldrWithKey (\\k x ks -\u003e k:ks) [] map\n\u003c/pre\u003e\u003cpre\u003e let f k a result = result ++ \"(\" ++ (show k) ++ \":\" ++ a ++ \")\"\n foldrWithKey f \"Map: \" (fromList [(5,\"a\"), (3,\"b\")]) == \"Map: (5:a)(3:b)\"\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldrWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Map k a -\u003e b",
          "source": "src/Data-Map-Base.html#foldrWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldrWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldrWithKey\"]"
        },
        "index": {
          "description": "Fold the keys and values in the map using the given right-associative binary operator such that foldrWithKey foldr uncurry toAscList For example keys map foldrWithKey ks ks map let result result show foldrWithKey Map fromList Map",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldrWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003ec)-\u003ec-\u003eMap a b-\u003ec",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eMap k a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldrWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "foldrWithKey'",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Map k a -\u003e b",
          "source": "src/Data-Map-Base.html#foldrWithKey%27",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldrWithKey-39-\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:foldrWithKey-39-\"]"
        },
        "index": {
          "description": "strict version of foldrWithKey Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "foldrWithKey'",
          "normalized": "(a-\u003eb-\u003ec-\u003ec)-\u003ec-\u003eMap a b-\u003ec",
          "package": "containers",
          "partial": "With Key'",
          "signature": "(k-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eMap k a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:foldrWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list in linear time.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscList [(3,\"b\"), (5,\"a\")]          == fromList [(3, \"b\"), (5, \"a\")]\n fromAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"b\")]\n valid (fromAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")]) == True\n valid (fromAscList [(5,\"a\"), (3,\"b\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromAscList",
          "package": "containers",
          "signature": "[(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list in linear time The precondition input list is ascending is not checked fromAscList fromList fromAscList fromList valid fromAscList True valid fromAscList False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromAscList",
          "normalized": "[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "Asc List",
          "signature": "[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list in linear time with a combining function for equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"ba\")]\n valid (fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")]) == True\n valid (fromAscListWith (++) [(5,\"a\"), (3,\"b\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromAscListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromAscListWith",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list in linear time with combining function for equal keys The precondition input list is ascending is not checked fromAscListWith fromList ba valid fromAscListWith True valid fromAscListWith False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromAscListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003eMap b a",
          "package": "containers",
          "partial": "Asc List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromAscListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list in linear time with a\n combining function for equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e let f k a1 a2 = (show k) ++ \":\" ++ a1 ++ a2\n fromAscListWithKey f [(3,\"b\"), (5,\"a\"), (5,\"b\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"5:b5:ba\")]\n valid (fromAscListWithKey f [(3,\"b\"), (5,\"a\"), (5,\"b\"), (5,\"b\")]) == True\n valid (fromAscListWithKey f [(5,\"a\"), (3,\"b\"), (5,\"b\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromAscListWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromAscListWithKey",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list in linear time with combining function for equal keys The precondition input list is ascending is not checked let a1 a2 show a1 a2 fromAscListWithKey fromList b5 ba valid fromAscListWithKey True valid fromAscListWithKey False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromAscListWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003e[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "Asc List With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromAscListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list of distinct elements in linear time.\n \u003cem\u003eThe precondition is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromDistinctAscList [(3,\"b\"), (5,\"a\")] == fromList [(3, \"b\"), (5, \"a\")]\n valid (fromDistinctAscList [(3,\"b\"), (5,\"a\")])          == True\n valid (fromDistinctAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromDistinctAscList",
          "package": "containers",
          "signature": "[(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list of distinct elements in linear time The precondition is not checked fromDistinctAscList fromList valid fromDistinctAscList True valid fromDistinctAscList False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromDistinctAscList",
          "normalized": "[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "Distinct Asc List",
          "signature": "[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Build a map from a list of key/value pairs. See also \u003ccode\u003e\u003ca\u003efromAscList\u003c/a\u003e\u003c/code\u003e.\n If the list contains more than one value for the same key, the last value\n for the key is retained.\n\u003c/p\u003e\u003cp\u003eIf the keys of the list are ordered, linear-time implementation is used,\n with the performance equal to \u003ccode\u003e\u003ca\u003efromDistinctAscList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e fromList [] == empty\n fromList [(5,\"a\"), (3,\"b\"), (5, \"c\")] == fromList [(5,\"c\"), (3,\"b\")]\n fromList [(5,\"c\"), (3,\"b\"), (5, \"a\")] == fromList [(5,\"a\"), (3,\"b\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromList",
          "package": "containers",
          "signature": "[(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "log Build map from list of key value pairs See also fromAscList If the list contains more than one value for the same key the last value for the key is retained If the keys of the list are ordered linear-time implementation is used with the performance equal to fromDistinctAscList fromList empty fromList fromList fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromList",
          "normalized": "[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "List",
          "signature": "[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Build a map from a list of key/value pairs with a combining function. See also \u003ccode\u003e\u003ca\u003efromAscListWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e fromListWith (++) [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"a\")] == fromList [(3, \"ab\"), (5, \"aba\")]\n fromListWith (++) [] == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromListWith",
          "type": "function"
        },
        "index": {
          "description": "log Build map from list of key value pairs with combining function See also fromAscListWith fromListWith fromList ab aba fromListWith empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003eMap b a",
          "package": "containers",
          "partial": "List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Build a map from a list of key/value pairs with a combining function. See also \u003ccode\u003e\u003ca\u003efromAscListWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k a1 a2 = (show k) ++ a1 ++ a2\n fromListWithKey f [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"a\")] == fromList [(3, \"3ab\"), (5, \"5a5ba\")]\n fromListWithKey f [] == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromListWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromListWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Build map from list of key value pairs with combining function See also fromAscListWithKey let a1 a2 show a1 a2 fromListWithKey fromList ab a5ba fromListWithKey empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromListWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003e[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "List With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a set of keys and a function which for each key\n computes its value.\n\u003c/p\u003e\u003cpre\u003e fromSet (\\k -\u003e replicate k 'a') (Data.Set.fromList [3, 5]) == fromList [(5,\"aaaaa\"), (3,\"aaa\")]\n fromSet undefined Data.Set.empty == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "fromSet",
          "package": "containers",
          "signature": "(k -\u003e a) -\u003e Set k -\u003e Map k a",
          "source": "src/Data-Map-Base.html#fromSet",
          "type": "function"
        },
        "index": {
          "description": "Build map from set of keys and function which for each key computes its value fromSet replicate Data.Set.fromList fromList aaaaa aaa fromSet undefined Data.Set.empty empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "fromSet",
          "normalized": "(a-\u003eb)-\u003eSet a-\u003eMap a b",
          "package": "containers",
          "partial": "Set",
          "signature": "(k-\u003ea)-\u003eSet k-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:fromSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert a new key and value in the map.\n If the key is already present in the map, the associated value is\n replaced with the supplied value. \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]\n insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]\n insert 5 'x' empty                         == singleton 5 'x'\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "insert",
          "package": "containers",
          "signature": "k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#insert",
          "type": "function"
        },
        "index": {
          "description": "log Insert new key and value in the map If the key is already present in the map the associated value is replaced with the supplied value insert is equivalent to insertWith const insert fromList fromList insert fromList fromList insert empty singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "insert",
          "normalized": "a-\u003eb-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "signature": "k-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Combines insert operation with old value retrieval.\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertLookupWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e)\n is a pair where the first element is equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e)\n and the second element equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertLookupWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"5:xxx|a\")])\n insertLookupWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")])\n insertLookupWithKey f 5 \"xxx\" empty                         == (Nothing,  singleton 5 \"xxx\")\n\u003c/pre\u003e\u003cp\u003eThis is how to define \u003ccode\u003einsertLookup\u003c/code\u003e using \u003ccode\u003einsertLookupWithKey\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e let insertLookup kx x t = insertLookupWithKey (\\_ a _ -\u003e a) kx x t\n insertLookup 5 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"x\")])\n insertLookup 7 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"x\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "insertLookupWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e (Maybe a, Map k a)",
          "source": "src/Data-Map-Base.html#insertLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Combines insert operation with old value retrieval The expression insertLookupWithKey map is pair where the first element is equal to lookup map and the second element equal to insertWithKey map let key new value old value show key new value old value insertLookupWithKey xxx fromList Just fromList xxx insertLookupWithKey xxx fromList Nothing fromList xxx insertLookupWithKey xxx empty Nothing singleton xxx This is how to define insertLookup using insertLookupWithKey let insertLookup kx insertLookupWithKey kx insertLookup fromList Just fromList insertLookup fromList Nothing fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "insertLookupWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eMap a b-\u003e(Maybe b,Map a b)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003e(Maybe a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:insertLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert with a function, combining new value and old value.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert the pair \u003ccode\u003e(key, f new_value old_value)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insertWith (++) 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"xxxa\")]\n insertWith (++) 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWith (++) 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "insertWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#insertWith",
          "type": "function"
        },
        "index": {
          "description": "log Insert with function combining new value and old value insertWith key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert the pair key new value old value insertWith xxx fromList fromList xxxa insertWith xxx fromList fromList xxx insertWith xxx empty singleton xxx",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "insertWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:insertWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert with a function, combining key, new value and old value.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert the pair \u003ccode\u003e(key,f key new_value old_value)\u003c/code\u003e.\n Note that the key passed to f is the same key passed to \u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:xxx|a\")]\n insertWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWithKey f 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "insertWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#insertWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Insert with function combining key new value and old value insertWithKey key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert the pair key key new value old value Note that the key passed to is the same key passed to insertWithKey let key new value old value show key new value old value insertWithKey xxx fromList fromList xxx insertWithKey xxx fromList fromList xxx insertWithKey xxx empty singleton xxx",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "insertWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:insertWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Intersection of two maps.\n Return data in the first map for the keys existing in both maps.\n (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eintersection\u003c/a\u003e\u003c/code\u003e m1 m2 == \u003ccode\u003e\u003ca\u003eintersectionWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e m1 m2\u003c/code\u003e).\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with\n \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e intersection (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "intersection",
          "package": "containers",
          "signature": "Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Base.html#intersection",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:intersection\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:intersection\"]"
        },
        "index": {
          "description": "Intersection of two maps Return data in the first map for the keys existing in both maps intersection m1 m2 intersectionWith const m1 m2 The implementation uses an efficient hedge algorithm comparable with hedge-union intersection fromList fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "intersection",
          "normalized": "Map a b-\u003eMap a c-\u003eMap a b",
          "package": "containers",
          "signature": "Map k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Intersection with a combining function.  The implementation uses\n an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e intersectionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"aA\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "intersectionWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c) -\u003e Map k a -\u003e Map k b -\u003e Map k c",
          "source": "src/Data-Map-Base.html#intersectionWith",
          "type": "function"
        },
        "index": {
          "description": "Intersection with combining function The implementation uses an efficient hedge algorithm comparable with hedge-union intersectionWith fromList fromList singleton aA",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "intersectionWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap d a-\u003eMap d b-\u003eMap d c",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eMap k a-\u003eMap k b-\u003eMap k c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:intersectionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Intersection with a combining function.  The implementation uses\n an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = (show k) ++ \":\" ++ al ++ \"|\" ++ ar\n intersectionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"5:a|A\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "intersectionWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e c) -\u003e Map k a -\u003e Map k b -\u003e Map k c",
          "source": "src/Data-Map-Base.html#intersectionWithKey",
          "type": "function"
        },
        "index": {
          "description": "Intersection with combining function The implementation uses an efficient hedge algorithm comparable with hedge-union let al ar show al ar intersectionWithKey fromList fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "intersectionWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eMap a b-\u003eMap a c-\u003eMap a d",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003ec)-\u003eMap k a-\u003eMap k b-\u003eMap k c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:intersectionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a proper submap? (ie. a submap but not equal).\n Defined as (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisProperSubmapOf\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eisProperSubmapOfBy\u003c/a\u003e\u003c/code\u003e (==)\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "isProperSubmapOf",
          "package": "containers",
          "signature": "Map k a -\u003e Map k a -\u003e Bool",
          "source": "src/Data-Map-Base.html#isProperSubmapOf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isProperSubmapOf\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:isProperSubmapOf\"]"
        },
        "index": {
          "description": "Is this proper submap ie submap but not equal Defined as isProperSubmapOf isProperSubmapOfBy",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "isProperSubmapOf",
          "normalized": "Map a b-\u003eMap a b-\u003eBool",
          "package": "containers",
          "partial": "Proper Submap Of",
          "signature": "Map k a-\u003eMap k a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isProperSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a proper submap? (ie. a submap but not equal).\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisProperSubmapOfBy\u003c/a\u003e\u003c/code\u003e f m1 m2\u003c/code\u003e) returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n \u003ccode\u003em1\u003c/code\u003e and \u003ccode\u003em2\u003c/code\u003e are not equal,\n all keys in \u003ccode\u003em1\u003c/code\u003e are in \u003ccode\u003em2\u003c/code\u003e, and when \u003ccode\u003ef\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n applied to their respective values. For example, the following\n expressions are all \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isProperSubmapOfBy (==) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n isProperSubmapOfBy (\u003c=) (fromList [(1,1)]) (fromList [(1,1),(2,2)])\n\u003c/pre\u003e\u003cp\u003eBut the following are all \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1),(2,2)])\n isProperSubmapOfBy (==) (fromList [(1,1),(2,2)]) (fromList [(1,1)])\n isProperSubmapOfBy (\u003c)  (fromList [(1,1)])       (fromList [(1,1),(2,2)])\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "isProperSubmapOfBy",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e Map k a -\u003e Map k b -\u003e Bool",
          "source": "src/Data-Map-Base.html#isProperSubmapOfBy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isProperSubmapOfBy\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:isProperSubmapOfBy\"]"
        },
        "index": {
          "description": "Is this proper submap ie submap but not equal The expression isProperSubmapOfBy m1 m2 returns True when m1 and m2 are not equal all keys in m1 are in m2 and when returns True when applied to their respective values For example the following expressions are all True isProperSubmapOfBy fromList fromList isProperSubmapOfBy fromList fromList But the following are all False isProperSubmapOfBy fromList fromList isProperSubmapOfBy fromList fromList isProperSubmapOfBy fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "isProperSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eMap c a-\u003eMap c b-\u003eBool",
          "package": "containers",
          "partial": "Proper Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eMap k a-\u003eMap k b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isProperSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e.\n This function is defined as (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisSubmapOf\u003c/a\u003e\u003c/code\u003e = \u003ccode\u003e\u003ca\u003eisSubmapOfBy\u003c/a\u003e\u003c/code\u003e (==)\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "isSubmapOf",
          "package": "containers",
          "signature": "Map k a -\u003e Map k a -\u003e Bool",
          "source": "src/Data-Map-Base.html#isSubmapOf",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isSubmapOf\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:isSubmapOf\"]"
        },
        "index": {
          "description": "This function is defined as isSubmapOf isSubmapOfBy",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "isSubmapOf",
          "normalized": "Map a b-\u003eMap a b-\u003eBool",
          "package": "containers",
          "partial": "Submap Of",
          "signature": "Map k a-\u003eMap k a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isSubmapOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e.\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eisSubmapOfBy\u003c/a\u003e\u003c/code\u003e f t1 t2\u003c/code\u003e) returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if\n all keys in \u003ccode\u003et1\u003c/code\u003e are in tree \u003ccode\u003et2\u003c/code\u003e, and when \u003ccode\u003ef\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e when\n applied to their respective values. For example, the following\n expressions are all \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])\n isSubmapOfBy (\u003c=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])\n isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])\n\u003c/pre\u003e\u003cp\u003eBut the following are all \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])\n isSubmapOfBy (\u003c)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])\n isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "isSubmapOfBy",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Bool) -\u003e Map k a -\u003e Map k b -\u003e Bool",
          "source": "src/Data-Map-Base.html#isSubmapOfBy",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isSubmapOfBy\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:isSubmapOfBy\"]"
        },
        "index": {
          "description": "The expression isSubmapOfBy t1 t2 returns True if all keys in t1 are in tree t2 and when returns True when applied to their respective values For example the following expressions are all True isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList But the following are all False isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList isSubmapOfBy fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "isSubmapOfBy",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eMap c a-\u003eMap c b-\u003eBool",
          "package": "containers",
          "partial": "Submap Of By",
          "signature": "(a-\u003eb-\u003eBool)-\u003eMap k a-\u003eMap k b-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:isSubmapOfBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Return all keys of the map in ascending order. Subject to list\n fusion.\n\u003c/p\u003e\u003cpre\u003e keys (fromList [(5,\"a\"), (3,\"b\")]) == [3,5]\n keys empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "keys",
          "package": "containers",
          "signature": "Map k a -\u003e [k]",
          "source": "src/Data-Map-Base.html#keys",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:keys\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:keys\"]"
        },
        "index": {
          "description": "Return all keys of the map in ascending order Subject to list fusion keys fromList keys empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "keys",
          "normalized": "Map a b-\u003e[a]",
          "package": "containers",
          "signature": "Map k a-\u003e[k]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:keys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The set of all keys of the map.\n\u003c/p\u003e\u003cpre\u003e keysSet (fromList [(5,\"a\"), (3,\"b\")]) == Data.Set.fromList [3,5]\n keysSet empty == Data.Set.empty\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "keysSet",
          "package": "containers",
          "signature": "Map k a -\u003e Set k",
          "source": "src/Data-Map-Base.html#keysSet",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:keysSet\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:keysSet\"]"
        },
        "index": {
          "description": "The set of all keys of the map keysSet fromList Data.Set.fromList keysSet empty Data.Set.empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "keysSet",
          "normalized": "Map a b-\u003eSet a",
          "package": "containers",
          "partial": "Set",
          "signature": "Map k a-\u003eSet k",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:keysSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Lookup the value at a key in the map.\n\u003c/p\u003e\u003cp\u003eThe function will return the corresponding value as \u003ccode\u003e(\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e value)\u003c/code\u003e,\n or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the key isn't in the map.\n\u003c/p\u003e\u003cp\u003eAn example of using \u003ccode\u003elookup\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e import Prelude hiding (lookup)\n import Data.Map\n\n employeeDept = fromList([(\"John\",\"Sales\"), (\"Bob\",\"IT\")])\n deptCountry = fromList([(\"IT\",\"USA\"), (\"Sales\",\"France\")])\n countryCurrency = fromList([(\"USA\", \"Dollar\"), (\"France\", \"Euro\")])\n\n employeeCurrency :: String -\u003e Maybe String\n employeeCurrency name = do\n     dept \u003c- lookup name employeeDept\n     country \u003c- lookup dept deptCountry\n     lookup country countryCurrency\n\n main = do\n     putStrLn $ \"John's currency: \" ++ (show (employeeCurrency \"John\"))\n     putStrLn $ \"Pete's currency: \" ++ (show (employeeCurrency \"Pete\"))\n\u003c/pre\u003e\u003cp\u003eThe output of this program:\n\u003c/p\u003e\u003cpre\u003e   John's currency: Just \"Euro\"\n   Pete's currency: Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "lookup",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e Maybe a",
          "source": "src/Data-Map-Base.html#lookup",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookup\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:lookup\"]"
        },
        "index": {
          "description": "log Lookup the value at key in the map The function will return the corresponding value as Just value or Nothing if the key isn in the map An example of using lookup import Prelude hiding lookup import Data.Map employeeDept fromList John Sales Bob IT deptCountry fromList IT USA Sales France countryCurrency fromList USA Dollar France Euro employeeCurrency String Maybe String employeeCurrency name do dept lookup name employeeDept country lookup dept deptCountry lookup country countryCurrency main do putStrLn John currency show employeeCurrency John putStrLn Pete currency show employeeCurrency Pete The output of this program John currency Just Euro Pete currency Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "lookup",
          "normalized": "a-\u003eMap a b-\u003eMaybe b",
          "package": "containers",
          "signature": "k-\u003eMap k a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest key greater or equal to the given one and return\n the corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupGE 3 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')\n lookupGE 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')\n lookupGE 6 (fromList [(3,'a'), (5,'b')]) == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "lookupGE",
          "package": "containers",
          "signature": "k -\u003e Map k v -\u003e Maybe (k, v)",
          "source": "src/Data-Map-Base.html#lookupGE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupGE\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:lookupGE\"]"
        },
        "index": {
          "description": "log Find smallest key greater or equal to the given one and return the corresponding key value pair lookupGE fromList Just lookupGE fromList Just lookupGE fromList Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "lookupGE",
          "normalized": "a-\u003eMap a b-\u003eMaybe(a,b)",
          "package": "containers",
          "partial": "GE",
          "signature": "k-\u003eMap k v-\u003eMaybe(k,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest key greater than the given one and return the\n corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupGT 4 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')\n lookupGT 5 (fromList [(3,'a'), (5,'b')]) == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "lookupGT",
          "package": "containers",
          "signature": "k -\u003e Map k v -\u003e Maybe (k, v)",
          "source": "src/Data-Map-Base.html#lookupGT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupGT\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:lookupGT\"]"
        },
        "index": {
          "description": "log Find smallest key greater than the given one and return the corresponding key value pair lookupGT fromList Just lookupGT fromList Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "lookupGT",
          "normalized": "a-\u003eMap a b-\u003eMaybe(a,b)",
          "package": "containers",
          "partial": "GT",
          "signature": "k-\u003eMap k v-\u003eMaybe(k,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Lookup the \u003cem\u003eindex\u003c/em\u003e of a key, which is its zero-based index in\n the sequence sorted by keys. The index is a number from \u003cem\u003e0\u003c/em\u003e up to, but not\n including, the \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the map.\n\u003c/p\u003e\u003cpre\u003e isJust (lookupIndex 2 (fromList [(5,\"a\"), (3,\"b\")]))   == False\n fromJust (lookupIndex 3 (fromList [(5,\"a\"), (3,\"b\")])) == 0\n fromJust (lookupIndex 5 (fromList [(5,\"a\"), (3,\"b\")])) == 1\n isJust (lookupIndex 6 (fromList [(5,\"a\"), (3,\"b\")]))   == False\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "lookupIndex",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e Maybe Int",
          "source": "src/Data-Map-Base.html#lookupIndex",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupIndex\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:lookupIndex\"]"
        },
        "index": {
          "description": "log Lookup the index of key which is its zero-based index in the sequence sorted by keys The index is number from up to but not including the size of the map isJust lookupIndex fromList False fromJust lookupIndex fromList fromJust lookupIndex fromList isJust lookupIndex fromList False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "lookupIndex",
          "normalized": "a-\u003eMap a b-\u003eMaybe Int",
          "package": "containers",
          "partial": "Index",
          "signature": "k-\u003eMap k a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest key smaller or equal to the given one and return\n the corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupLE 2 (fromList [(3,'a'), (5,'b')]) == Nothing\n lookupLE 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')\n lookupLE 5 (fromList [(3,'a'), (5,'b')]) == Just (5, 'b')\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "lookupLE",
          "package": "containers",
          "signature": "k -\u003e Map k v -\u003e Maybe (k, v)",
          "source": "src/Data-Map-Base.html#lookupLE",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupLE\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:lookupLE\"]"
        },
        "index": {
          "description": "log Find largest key smaller or equal to the given one and return the corresponding key value pair lookupLE fromList Nothing lookupLE fromList Just lookupLE fromList Just",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "lookupLE",
          "normalized": "a-\u003eMap a b-\u003eMaybe(a,b)",
          "package": "containers",
          "partial": "LE",
          "signature": "k-\u003eMap k v-\u003eMaybe(k,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest key smaller than the given one and return the\n corresponding (key, value) pair.\n\u003c/p\u003e\u003cpre\u003e lookupLT 3 (fromList [(3,'a'), (5,'b')]) == Nothing\n lookupLT 4 (fromList [(3,'a'), (5,'b')]) == Just (3, 'a')\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "lookupLT",
          "package": "containers",
          "signature": "k -\u003e Map k v -\u003e Maybe (k, v)",
          "source": "src/Data-Map-Base.html#lookupLT",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupLT\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:lookupLT\"]"
        },
        "index": {
          "description": "log Find largest key smaller than the given one and return the corresponding key value pair lookupLT fromList Nothing lookupLT fromList Just",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "lookupLT",
          "normalized": "a-\u003eMap a b-\u003eMaybe(a,b)",
          "package": "containers",
          "partial": "LT",
          "signature": "k-\u003eMap k v-\u003eMaybe(k,v)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:lookupLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e map (++ \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"bx\"), (5, \"ax\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "map",
          "package": "containers",
          "signature": "(a -\u003e b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Base.html#map",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map map fromList fromList bx ax",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eMap c a-\u003eMap c b",
          "package": "containers",
          "signature": "(a-\u003eb)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ca\u003emapAccum\u003c/a\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a b = (a ++ b, b ++ \"X\")\n mapAccum f \"Everything: \" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: ba\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapAccum",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e Map k b -\u003e (a, Map k c)",
          "source": "src/Data-Map-Base.html#mapAccum",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccum threads an accumulating argument through the map in ascending order of keys let mapAccum Everything fromList Everything ba fromList bX aX",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapAccum",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eMap d b-\u003e(a,Map d c)",
          "package": "containers",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eMap k b-\u003e(a,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003emapAccumR\u003c/code\u003e threads an accumulating\n argument through the map in descending order of keys.\n\u003c/p\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapAccumRWithKey",
          "package": "containers",
          "signature": "(a -\u003e k -\u003e b -\u003e (a, c)) -\u003e a -\u003e Map k b -\u003e (a, Map k c)",
          "source": "src/Data-Map-Base.html#mapAccumRWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumR threads an accumulating argument through the map in descending order of keys",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapAccumRWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003e(a,d))-\u003ea-\u003eMap b c-\u003e(a,Map b d)",
          "package": "containers",
          "partial": "Accum RWith Key",
          "signature": "(a-\u003ek-\u003eb-\u003e(a,c))-\u003ea-\u003eMap k b-\u003e(a,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapAccumRWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ca\u003emapAccumWithKey\u003c/a\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a k b = (a ++ \" \" ++ (show k) ++ \"-\" ++ b, b ++ \"X\")\n mapAccumWithKey f \"Everything:\" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: 3-b 5-a\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapAccumWithKey",
          "package": "containers",
          "signature": "(a -\u003e k -\u003e b -\u003e (a, c)) -\u003e a -\u003e Map k b -\u003e (a, Map k c)",
          "source": "src/Data-Map-Base.html#mapAccumWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys let show mapAccumWithKey Everything fromList Everything fromList bX aX",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapAccumWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003e(a,d))-\u003ea-\u003eMap b c-\u003e(a,Map b d)",
          "package": "containers",
          "partial": "Accum With Key",
          "signature": "(a-\u003ek-\u003eb-\u003e(a,c))-\u003ea-\u003eMap k b-\u003e(a,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapAccumWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f a = if a \u003c \"c\" then Left a else Right a\n mapEither f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(3,\"b\"), (5,\"a\")], fromList [(1,\"x\"), (7,\"z\")])\n\n mapEither (\\ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapEither",
          "package": "containers",
          "signature": "(a -\u003e Either b c) -\u003e Map k a -\u003e (Map k b, Map k c)",
          "source": "src/Data-Map-Base.html#mapEither",
          "type": "function"
        },
        "index": {
          "description": "Map values and separate the Left and Right results let if then Left else Right mapEither fromList fromList fromList mapEither Right fromList empty fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapEither",
          "normalized": "(a-\u003eEither b c)-\u003eMap d a-\u003e(Map d b,Map d c)",
          "package": "containers",
          "partial": "Either",
          "signature": "(a-\u003eEither b c)-\u003eMap k a-\u003e(Map k b,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k a = if k \u003c 5 then Left (k * 2) else Right (a ++ a)\n mapEitherWithKey f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(1,2), (3,6)], fromList [(5,\"aa\"), (7,\"zz\")])\n\n mapEitherWithKey (\\_ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(1,\"x\"), (3,\"b\"), (5,\"a\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapEitherWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Either b c) -\u003e Map k a -\u003e (Map k b, Map k c)",
          "source": "src/Data-Map-Base.html#mapEitherWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and separate the Left and Right results let if then Left else Right mapEitherWithKey fromList fromList fromList aa zz mapEitherWithKey Right fromList empty fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapEitherWithKey",
          "normalized": "(a-\u003eb-\u003eEither c d)-\u003eMap a b-\u003e(Map a c,Map a d)",
          "package": "containers",
          "partial": "Either With Key",
          "signature": "(k-\u003ea-\u003eEither b c)-\u003eMap k a-\u003e(Map k b,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapEitherWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeys\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e is the map obtained by applying \u003ccode\u003ef\u003c/code\u003e to each key of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe size of the result may be smaller if \u003ccode\u003ef\u003c/code\u003e maps two or more distinct\n keys to the same new key.  In this case the value at the greatest of the\n original keys is retained.\n\u003c/p\u003e\u003cpre\u003e mapKeys (+ 1) (fromList [(5,\"a\"), (3,\"b\")])                        == fromList [(4, \"b\"), (6, \"a\")]\n mapKeys (\\ _ -\u003e 1) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 1 \"c\"\n mapKeys (\\ _ -\u003e 3) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 3 \"c\"\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "mapKeys",
          "package": "containers",
          "signature": "(k1 -\u003e k2) -\u003e Map k1 a -\u003e Map k2 a",
          "source": "src/Data-Map-Base.html#mapKeys",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapKeys\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapKeys\"]"
        },
        "index": {
          "description": "log mapKeys is the map obtained by applying to each key of The size of the result may be smaller if maps two or more distinct keys to the same new key In this case the value at the greatest of the original keys is retained mapKeys fromList fromList mapKeys fromList singleton mapKeys fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapKeys",
          "normalized": "(a-\u003ea)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "Keys",
          "signature": "(k-\u003ek)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapKeys"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeysMonotonic\u003c/a\u003e\u003c/code\u003e f s == \u003ccode\u003e\u003ca\u003emapKeys\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e, but works only when \u003ccode\u003ef\u003c/code\u003e\n is strictly monotonic.\n That is, for any values \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003ey\u003c/code\u003e, if \u003ccode\u003ex\u003c/code\u003e \u003c \u003ccode\u003ey\u003c/code\u003e then \u003ccode\u003ef x\u003c/code\u003e \u003c \u003ccode\u003ef y\u003c/code\u003e.\n \u003cem\u003eThe precondition is not checked.\u003c/em\u003e\n Semi-formally, we have:\n\u003c/p\u003e\u003cpre\u003e and [x \u003c y ==\u003e f x \u003c f y | x \u003c- ls, y \u003c- ls]\n                     ==\u003e mapKeysMonotonic f s == mapKeys f s\n     where ls = keys s\n\u003c/pre\u003e\u003cp\u003eThis means that \u003ccode\u003ef\u003c/code\u003e maps distinct original keys to distinct resulting keys.\n This function has better performance than \u003ccode\u003e\u003ca\u003emapKeys\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e mapKeysMonotonic (\\ k -\u003e k * 2) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(6, \"b\"), (10, \"a\")]\n valid (mapKeysMonotonic (\\ k -\u003e k * 2) (fromList [(5,\"a\"), (3,\"b\")])) == True\n valid (mapKeysMonotonic (\\ _ -\u003e 1)     (fromList [(5,\"a\"), (3,\"b\")])) == False\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "mapKeysMonotonic",
          "package": "containers",
          "signature": "(k1 -\u003e k2) -\u003e Map k1 a -\u003e Map k2 a",
          "source": "src/Data-Map-Base.html#mapKeysMonotonic",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapKeysMonotonic\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapKeysMonotonic\"]"
        },
        "index": {
          "description": "mapKeysMonotonic mapKeys but works only when is strictly monotonic That is for any values and if then The precondition is not checked Semi-formally we have and ls ls mapKeysMonotonic mapKeys where ls keys This means that maps distinct original keys to distinct resulting keys This function has better performance than mapKeys mapKeysMonotonic fromList fromList valid mapKeysMonotonic fromList True valid mapKeysMonotonic fromList False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapKeysMonotonic",
          "normalized": "(a-\u003ea)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "Keys Monotonic",
          "signature": "(k-\u003ek)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapKeysMonotonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeysWith\u003c/a\u003e\u003c/code\u003e c f s\u003c/code\u003e is the map obtained by applying \u003ccode\u003ef\u003c/code\u003e to each key of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe size of the result may be smaller if \u003ccode\u003ef\u003c/code\u003e maps two or more distinct\n keys to the same new key.  In this case the associated values will be\n combined using \u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e mapKeysWith (++) (\\ _ -\u003e 1) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 1 \"cdab\"\n mapKeysWith (++) (\\ _ -\u003e 3) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 3 \"cdab\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapKeysWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e (k1 -\u003e k2) -\u003e Map k1 a -\u003e Map k2 a",
          "source": "src/Data-Map-Base.html#mapKeysWith",
          "type": "function"
        },
        "index": {
          "description": "log mapKeysWith is the map obtained by applying to each key of The size of the result may be smaller if maps two or more distinct keys to the same new key In this case the associated values will be combined using mapKeysWith fromList singleton cdab mapKeysWith fromList singleton cdab",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapKeysWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(b-\u003eb)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "Keys With",
          "signature": "(a-\u003ea-\u003ea)-\u003e(k-\u003ek)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapKeysWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n mapMaybe f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"new a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapMaybe",
          "package": "containers",
          "signature": "(a -\u003e Maybe b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Base.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "description": "Map values and collect the Just results let if then Just new else Nothing mapMaybe fromList singleton new",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eMap c a-\u003eMap c b",
          "package": "containers",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k _ = if k \u003c 5 then Just (\"key : \" ++ (show k)) else Nothing\n mapMaybeWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"key : 3\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapMaybeWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Base.html#mapMaybeWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and collect the Just results let if then Just key show else Nothing mapMaybeWithKey fromList singleton key",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapMaybeWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe c)-\u003eMap a b-\u003eMap a c",
          "package": "containers",
          "partial": "Maybe With Key",
          "signature": "(k-\u003ea-\u003eMaybe b)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapMaybeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":\" ++ x\n mapWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"3:b\"), (5, \"5:a\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "mapWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Base.html#mapWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map let key show key mapWithKey fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mapWithKey",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap a b-\u003eMap a c",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieves the value associated with maximal key of the\n map, and the map stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an\n\u003c/p\u003e\u003cpre\u003e maxView (fromList [(5,\"a\"), (3,\"b\")]) == Just (\"a\", singleton 3 \"b\")\n maxView empty == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "maxView",
          "package": "containers",
          "signature": "Map k a -\u003e Maybe (a, Map k a)",
          "source": "src/Data-Map-Base.html#maxView",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:maxView\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:maxView\"]"
        },
        "index": {
          "description": "log Retrieves the value associated with maximal key of the map and the map stripped of that element or Nothing if passed an maxView fromList Just singleton maxView empty Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "maxView",
          "normalized": "Map a b-\u003eMaybe(b,Map a b)",
          "package": "containers",
          "partial": "View",
          "signature": "Map k a-\u003eMaybe(a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:maxView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieves the maximal (key,value) pair of the map, and\n the map stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty map.\n\u003c/p\u003e\u003cpre\u003e maxViewWithKey (fromList [(5,\"a\"), (3,\"b\")]) == Just ((5,\"a\"), singleton 3 \"b\")\n maxViewWithKey empty == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "maxViewWithKey",
          "package": "containers",
          "signature": "Map k a -\u003e Maybe ((k, a), Map k a)",
          "source": "src/Data-Map-Base.html#maxViewWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:maxViewWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:maxViewWithKey\"]"
        },
        "index": {
          "description": "log Retrieves the maximal key value pair of the map and the map stripped of that element or Nothing if passed an empty map maxViewWithKey fromList Just singleton maxViewWithKey empty Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "maxViewWithKey",
          "normalized": "Map a b-\u003eMaybe((a,b),Map a b)",
          "package": "containers",
          "partial": "View With Key",
          "signature": "Map k a-\u003eMaybe((k,a),Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:maxViewWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Is the key a member of the map? See also \u003ccode\u003e\u003ca\u003enotMember\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e member 5 (fromList [(5,'a'), (3,'b')]) == True\n member 1 (fromList [(5,'a'), (3,'b')]) == False\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "member",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e Bool",
          "source": "src/Data-Map-Base.html#member",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:member\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:member\"]"
        },
        "index": {
          "description": "log Is the key member of the map See also notMember member fromList True member fromList False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "member",
          "normalized": "a-\u003eMap a b-\u003eBool",
          "package": "containers",
          "signature": "k-\u003eMap k a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. A high-performance universal combining function. This function\n is used to define \u003ccode\u003e\u003ca\u003eunionWith\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunionWithKey\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edifferenceWith\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003edifferenceWithKey\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eintersectionWith\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eintersectionWithKey\u003c/a\u003e\u003c/code\u003e and can be\n used to define other custom combine functions.\n\u003c/p\u003e\u003cp\u003ePlease make sure you know what is going on when using \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e,\n otherwise you can be surprised by unexpected code growth or even\n corruption of the data structure.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e is given three arguments, it is inlined to the call\n site. You should therefore use \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e only to define your custom\n combining functions. For example, you could define \u003ccode\u003e\u003ca\u003eunionWithKey\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003edifferenceWithKey\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eintersectionWithKey\u003c/a\u003e\u003c/code\u003e as\n\u003c/p\u003e\u003cpre\u003e myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) id id m1 m2\n myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) (const empty) (const empty) m1 m2\n\u003c/pre\u003e\u003cp\u003eWhen calling \u003ccode\u003e\u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e combine only1 only2\u003c/code\u003e, a function combining two\n \u003ccode\u003eIntMap\u003c/code\u003es is created, such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if a key is present in both maps, it is passed with both corresponding\n   values to the \u003ccode\u003ecombine\u003c/code\u003e function. Depending on the result, the key is either\n   present in the result with specified value, or is left out;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the first map is passed to \u003ccode\u003eonly1\u003c/code\u003e and\n   the output is added to the result;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the second map is passed to \u003ccode\u003eonly2\u003c/code\u003e and\n   the output is added to the result.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003eonly1\u003c/code\u003e and \u003ccode\u003eonly2\u003c/code\u003e methods \u003cem\u003emust return a map with a subset (possibly empty) of the keys of the given map\u003c/em\u003e.\n The values can be modified arbitrarily. Most common variants of \u003ccode\u003eonly1\u003c/code\u003e and\n \u003ccode\u003eonly2\u003c/code\u003e are \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but for example \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e or\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efilterWithKey\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e could be used for any \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Map.Lazy",
          "name": "mergeWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e Maybe c) -\u003e (Map k a -\u003e Map k c) -\u003e (Map k b -\u003e Map k c) -\u003e Map k a -\u003e Map k b -\u003e Map k c",
          "source": "src/Data-Map-Base.html#mergeWithKey",
          "type": "function"
        },
        "index": {
          "description": "high-performance universal combining function This function is used to define unionWith unionWithKey differenceWith differenceWithKey intersectionWith intersectionWithKey and can be used to define other custom combine functions Please make sure you know what is going on when using mergeWithKey otherwise you can be surprised by unexpected code growth or even corruption of the data structure When mergeWithKey is given three arguments it is inlined to the call site You should therefore use mergeWithKey only to define your custom combining functions For example you could define unionWithKey differenceWithKey and intersectionWithKey as myUnionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 id id m1 m2 myDifferenceWithKey m1 m2 mergeWithKey id const empty m1 m2 myIntersectionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 const empty const empty m1 m2 When calling mergeWithKey combine only1 only2 function combining two IntMap is created such that if key is present in both maps it is passed with both corresponding values to the combine function Depending on the result the key is either present in the result with specified value or is left out nonempty subtree present only in the first map is passed to only1 and the output is added to the result nonempty subtree present only in the second map is passed to only2 and the output is added to the result The only1 and only2 methods must return map with subset possibly empty of the keys of the given map The values can be modified arbitrarily Most common variants of only1 and only2 are id and const empty but for example map or filterWithKey could be used for any",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "mergeWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003eMaybe d)-\u003e(Map a b-\u003eMap a d)-\u003e(Map a c-\u003eMap a d)-\u003eMap a b-\u003eMap a c-\u003eMap a d",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003eMaybe c)-\u003e(Map k a-\u003eMap k c)-\u003e(Map k b-\u003eMap k c)-\u003eMap k a-\u003eMap k b-\u003eMap k c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:mergeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieves the value associated with minimal key of the\n map, and the map stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an\n empty map.\n\u003c/p\u003e\u003cpre\u003e minView (fromList [(5,\"a\"), (3,\"b\")]) == Just (\"b\", singleton 5 \"a\")\n minView empty == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "minView",
          "package": "containers",
          "signature": "Map k a -\u003e Maybe (a, Map k a)",
          "source": "src/Data-Map-Base.html#minView",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:minView\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:minView\"]"
        },
        "index": {
          "description": "log Retrieves the value associated with minimal key of the map and the map stripped of that element or Nothing if passed an empty map minView fromList Just singleton minView empty Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "minView",
          "normalized": "Map a b-\u003eMaybe(b,Map a b)",
          "package": "containers",
          "partial": "View",
          "signature": "Map k a-\u003eMaybe(a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:minView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieves the minimal (key,value) pair of the map, and\n the map stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty map.\n\u003c/p\u003e\u003cpre\u003e minViewWithKey (fromList [(5,\"a\"), (3,\"b\")]) == Just ((3,\"b\"), singleton 5 \"a\")\n minViewWithKey empty == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "minViewWithKey",
          "package": "containers",
          "signature": "Map k a -\u003e Maybe ((k, a), Map k a)",
          "source": "src/Data-Map-Base.html#minViewWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:minViewWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:minViewWithKey\"]"
        },
        "index": {
          "description": "log Retrieves the minimal key value pair of the map and the map stripped of that element or Nothing if passed an empty map minViewWithKey fromList Just singleton minViewWithKey empty Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "minViewWithKey",
          "normalized": "Map a b-\u003eMaybe((a,b),Map a b)",
          "package": "containers",
          "partial": "View With Key",
          "signature": "Map k a-\u003eMaybe((k,a),Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:minViewWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Is the key not a member of the map? See also \u003ccode\u003e\u003ca\u003emember\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e notMember 5 (fromList [(5,'a'), (3,'b')]) == False\n notMember 1 (fromList [(5,'a'), (3,'b')]) == True\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "notMember",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e Bool",
          "source": "src/Data-Map-Base.html#notMember",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:notMember\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:notMember\"]"
        },
        "index": {
          "description": "log Is the key not member of the map See also member notMember fromList False notMember fromList True",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "notMember",
          "normalized": "a-\u003eMap a b-\u003eBool",
          "package": "containers",
          "partial": "Member",
          "signature": "k-\u003eMap k a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Is the map empty?\n\u003c/p\u003e\u003cpre\u003e Data.Map.null (empty)           == True\n Data.Map.null (singleton 1 'a') == False\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "null",
          "package": "containers",
          "signature": "Map k a -\u003e Bool",
          "source": "src/Data-Map-Base.html#null",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:null\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:null\"]"
        },
        "index": {
          "description": "Is the map empty Data.Map.null empty True Data.Map.null singleton False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "null",
          "normalized": "Map a b-\u003eBool",
          "package": "containers",
          "signature": "Map k a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Partition the map according to a predicate. The first\n map contains all elements that satisfy the predicate, the second all\n elements that fail the predicate. See also \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e partition (\u003e \"a\") (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", singleton 5 \"a\")\n partition (\u003c \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3, \"b\"), (5, \"a\")], empty)\n partition (\u003e \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == (empty, fromList [(3, \"b\"), (5, \"a\")])\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "partition",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Map k a -\u003e (Map k a, Map k a)",
          "source": "src/Data-Map-Base.html#partition",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:partition\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:partition\"]"
        },
        "index": {
          "description": "Partition the map according to predicate The first map contains all elements that satisfy the predicate the second all elements that fail the predicate See also split partition fromList singleton singleton partition fromList fromList empty partition fromList empty fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eMap b a-\u003e(Map b a,Map b a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eMap k a-\u003e(Map k a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Partition the map according to a predicate. The first\n map contains all elements that satisfy the predicate, the second all\n elements that fail the predicate. See also \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e partitionWithKey (\\ k _ -\u003e k \u003e 3) (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 5 \"a\", singleton 3 \"b\")\n partitionWithKey (\\ k _ -\u003e k \u003c 7) (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3, \"b\"), (5, \"a\")], empty)\n partitionWithKey (\\ k _ -\u003e k \u003e 7) (fromList [(5,\"a\"), (3,\"b\")]) == (empty, fromList [(3, \"b\"), (5, \"a\")])\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "partitionWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Bool) -\u003e Map k a -\u003e (Map k a, Map k a)",
          "source": "src/Data-Map-Base.html#partitionWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:partitionWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:partitionWithKey\"]"
        },
        "index": {
          "description": "Partition the map according to predicate The first map contains all elements that satisfy the predicate the second all elements that fail the predicate See also split partitionWithKey fromList singleton singleton partitionWithKey fromList fromList empty partitionWithKey fromList empty fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "partitionWithKey",
          "normalized": "(a-\u003eb-\u003eBool)-\u003eMap a b-\u003e(Map a b,Map a b)",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eBool)-\u003eMap k a-\u003e(Map k a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:partitionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Show the tree that implements the map. The tree is shown\n in a compressed, hanging format. See \u003ccode\u003e\u003ca\u003eshowTreeWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "showTree",
          "package": "containers",
          "signature": "Map k a -\u003e String",
          "source": "src/Data-Map-Base.html#showTree",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:showTree\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:showTree\"]"
        },
        "index": {
          "description": "Show the tree that implements the map The tree is shown in compressed hanging format See showTreeWith",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "showTree",
          "normalized": "Map a b-\u003eString",
          "package": "containers",
          "partial": "Tree",
          "signature": "Map k a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eshowTreeWith\u003c/a\u003e\u003c/code\u003e showelem hang wide map\u003c/code\u003e) shows\n the tree that implements the map. Elements are shown using the \u003ccode\u003eshowElem\u003c/code\u003e function. If \u003ccode\u003ehang\u003c/code\u003e is\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, a \u003cem\u003ehanging\u003c/em\u003e tree is shown otherwise a rotated tree is shown. If\n \u003ccode\u003ewide\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, an extra wide version is shown.\n\u003c/p\u003e\u003cpre\u003e  Map\u003e let t = fromDistinctAscList [(x,()) | x \u003c- [1..5]]\n  Map\u003e putStrLn $ showTreeWith (\\k x -\u003e show (k,x)) True False t\n  (4,())\n  +--(2,())\n  |  +--(1,())\n  |  +--(3,())\n  +--(5,())\n\n  Map\u003e putStrLn $ showTreeWith (\\k x -\u003e show (k,x)) True True t\n  (4,())\n  |\n  +--(2,())\n  |  |\n  |  +--(1,())\n  |  |\n  |  +--(3,())\n  |\n  +--(5,())\n\n  Map\u003e putStrLn $ showTreeWith (\\k x -\u003e show (k,x)) False True t\n  +--(5,())\n  |\n  (4,())\n  |\n  |  +--(3,())\n  |  |\n  +--(2,())\n     |\n     +--(1,())\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "showTreeWith",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e String) -\u003e Bool -\u003e Bool -\u003e Map k a -\u003e String",
          "source": "src/Data-Map-Base.html#showTreeWith",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:showTreeWith\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:showTreeWith\"]"
        },
        "index": {
          "description": "The expression showTreeWith showelem hang wide map shows the tree that implements the map Elements are shown using the showElem function If hang is True hanging tree is shown otherwise rotated tree is shown If wide is True an extra wide version is shown Map let fromDistinctAscList Map putStrLn showTreeWith show True False Map putStrLn showTreeWith show True True Map putStrLn showTreeWith show False True",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "showTreeWith",
          "normalized": "(a-\u003eb-\u003eString)-\u003eBool-\u003eBool-\u003eMap a b-\u003eString",
          "package": "containers",
          "partial": "Tree With",
          "signature": "(k-\u003ea-\u003eString)-\u003eBool-\u003eBool-\u003eMap k a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. A map with a single element.\n\u003c/p\u003e\u003cpre\u003e singleton 1 'a'        == fromList [(1, 'a')]\n size (singleton 1 'a') == 1\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "singleton",
          "package": "containers",
          "signature": "k -\u003e a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "map with single element singleton fromList size singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "singleton",
          "normalized": "a-\u003eb-\u003eMap a b",
          "package": "containers",
          "signature": "k-\u003ea-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The number of elements in the map.\n\u003c/p\u003e\u003cpre\u003e size empty                                   == 0\n size (singleton 1 'a')                       == 1\n size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "size",
          "package": "containers",
          "signature": "Map k a -\u003e Int",
          "source": "src/Data-Map-Base.html#size",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:size\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:size\"]"
        },
        "index": {
          "description": "The number of elements in the map size empty size singleton size fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "size",
          "normalized": "Map a b-\u003eInt",
          "package": "containers",
          "signature": "Map k a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e) is a pair \u003ccode\u003e(map1,map2)\u003c/code\u003e where\n the keys in \u003ccode\u003emap1\u003c/code\u003e are smaller than \u003ccode\u003ek\u003c/code\u003e and the keys in \u003ccode\u003emap2\u003c/code\u003e larger than \u003ccode\u003ek\u003c/code\u003e.\n Any key equal to \u003ccode\u003ek\u003c/code\u003e is found in neither \u003ccode\u003emap1\u003c/code\u003e nor \u003ccode\u003emap2\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e split 2 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, fromList [(3,\"b\"), (5,\"a\")])\n split 3 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, singleton 5 \"a\")\n split 4 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", singleton 5 \"a\")\n split 5 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", empty)\n split 6 (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3,\"b\"), (5,\"a\")], empty)\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "split",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e (Map k a, Map k a)",
          "source": "src/Data-Map-Base.html#split",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:split\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:split\"]"
        },
        "index": {
          "description": "log The expression split map is pair map1 map2 where the keys in map1 are smaller than and the keys in map2 larger than Any key equal to is found in neither map1 nor map2 split fromList empty fromList split fromList empty singleton split fromList singleton singleton split fromList singleton empty split fromList fromList empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "split",
          "normalized": "a-\u003eMap a b-\u003e(Map a b,Map a b)",
          "package": "containers",
          "signature": "k-\u003eMap k a-\u003e(Map k a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitLookup\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e) splits a map just\n like \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e but also returns \u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e splitLookup 2 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, Nothing, fromList [(3,\"b\"), (5,\"a\")])\n splitLookup 3 (fromList [(5,\"a\"), (3,\"b\")]) == (empty, Just \"b\", singleton 5 \"a\")\n splitLookup 4 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", Nothing, singleton 5 \"a\")\n splitLookup 5 (fromList [(5,\"a\"), (3,\"b\")]) == (singleton 3 \"b\", Just \"a\", empty)\n splitLookup 6 (fromList [(5,\"a\"), (3,\"b\")]) == (fromList [(3,\"b\"), (5,\"a\")], Nothing, empty)\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "splitLookup",
          "package": "containers",
          "signature": "k -\u003e Map k a -\u003e (Map k a, Maybe a, Map k a)",
          "source": "src/Data-Map-Base.html#splitLookup",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:splitLookup\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:splitLookup\"]"
        },
        "index": {
          "description": "log The expression splitLookup map splits map just like split but also returns lookup map splitLookup fromList empty Nothing fromList splitLookup fromList empty Just singleton splitLookup fromList singleton Nothing singleton splitLookup fromList singleton Just empty splitLookup fromList fromList Nothing empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "splitLookup",
          "normalized": "a-\u003eMap a b-\u003e(Map a b,Maybe b,Map a b)",
          "package": "containers",
          "partial": "Lookup",
          "signature": "k-\u003eMap k a-\u003e(Map k a,Maybe a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:splitLookup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e.  Decompose a map into pieces based on the structure of the underlying\n tree.  This function is useful for consuming a map in parallel.\n\u003c/p\u003e\u003cp\u003eNo guarantee is made as to the sizes of the pieces; an internal, but\n deterministic process determines this.  However, it is guaranteed that the pieces\n returned will be in ascending order (all elements in the first submap less than all\n elements in the second, and so on).\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e splitRoot (fromList (zip [1..6] ['a'..])) ==\n   [fromList [(1,'a'),(2,'b'),(3,'c')],fromList [(4,'d')],fromList [(5,'e'),(6,'f')]]\n\u003c/pre\u003e\u003cpre\u003e splitRoot empty == []\n\u003c/pre\u003e\u003cp\u003eNote that the current implementation does not return more than three submaps,\n  but you should not depend on this behaviour because it can change in the\n  future without notice.\n\u003c/p\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "splitRoot",
          "package": "containers",
          "signature": "Map k b -\u003e [Map k b]",
          "source": "src/Data-Map-Base.html#splitRoot",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:splitRoot\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:splitRoot\"]"
        },
        "index": {
          "description": "Decompose map into pieces based on the structure of the underlying tree This function is useful for consuming map in parallel No guarantee is made as to the sizes of the pieces an internal but deterministic process determines this However it is guaranteed that the pieces returned will be in ascending order all elements in the first submap less than all elements in the second and so on Examples splitRoot fromList zip fromList fromList fromList splitRoot empty Note that the current implementation does not return more than three submaps but you should not depend on this behaviour because it can change in the future without notice",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "splitRoot",
          "normalized": "Map a b-\u003e[Map a b]",
          "package": "containers",
          "partial": "Root",
          "signature": "Map k b-\u003e[Map k b]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:splitRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the map to a list of key/value pairs where the keys are\n in ascending order. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e toAscList (fromList [(5,\"a\"), (3,\"b\")]) == [(3,\"b\"), (5,\"a\")]\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "toAscList",
          "package": "containers",
          "signature": "Map k a -\u003e [(k, a)]",
          "source": "src/Data-Map-Base.html#toAscList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:toAscList\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:toAscList\"]"
        },
        "index": {
          "description": "Convert the map to list of key value pairs where the keys are in ascending order Subject to list fusion toAscList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "toAscList",
          "normalized": "Map a b-\u003e[(a,b)]",
          "package": "containers",
          "partial": "Asc List",
          "signature": "Map k a-\u003e[(k,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the map to a list of key/value pairs where the keys\n are in descending order. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e toDescList (fromList [(5,\"a\"), (3,\"b\")]) == [(5,\"a\"), (3,\"b\")]\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "toDescList",
          "package": "containers",
          "signature": "Map k a -\u003e [(k, a)]",
          "source": "src/Data-Map-Base.html#toDescList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:toDescList\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:toDescList\"]"
        },
        "index": {
          "description": "Convert the map to list of key value pairs where the keys are in descending order Subject to list fusion toDescList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "toDescList",
          "normalized": "Map a b-\u003e[(a,b)]",
          "package": "containers",
          "partial": "Desc List",
          "signature": "Map k a-\u003e[(k,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:toDescList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the map to a list of key/value pairs. Subject to list fusion.\n\u003c/p\u003e\u003cpre\u003e toList (fromList [(5,\"a\"), (3,\"b\")]) == [(3,\"b\"), (5,\"a\")]\n toList empty == []\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "toList",
          "package": "containers",
          "signature": "Map k a -\u003e [(k, a)]",
          "source": "src/Data-Map-Base.html#toList",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:toList\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:toList\"]"
        },
        "index": {
          "description": "Convert the map to list of key value pairs Subject to list fusion toList fromList toList empty",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "toList",
          "normalized": "Map a b-\u003e[(a,b)]",
          "package": "containers",
          "partial": "List",
          "signature": "Map k a-\u003e[(k,a)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003etraverseWithKey\u003c/a\u003e\u003c/code\u003e f s == \u003ccode\u003e\u003ca\u003efromList\u003c/a\u003e\u003c/code\u003e \u003ca\u003e$\u003c/a\u003e \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e ((k, v) -\u003e (,) k \u003ca\u003e$\u003c/a\u003e f k v) (\u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e m)\u003c/code\u003e\n That is, behaves exactly like a regular \u003ccode\u003e\u003ca\u003etraverse\u003c/a\u003e\u003c/code\u003e except that the traversing\n function also has access to the key associated with a value.\n\u003c/p\u003e\u003cpre\u003e traverseWithKey (\\k v -\u003e if odd k then Just (succ v) else Nothing) (fromList [(1, 'a'), (5, 'e')]) == Just (fromList [(1, 'b'), (5, 'f')])\n traverseWithKey (\\k v -\u003e if odd k then Just (succ v) else Nothing) (fromList [(2, 'c')])           == Nothing\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "traverseWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e t b) -\u003e Map k a -\u003e t (Map k b)",
          "source": "src/Data-Map-Base.html#traverseWithKey",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:traverseWithKey\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:traverseWithKey\"]"
        },
        "index": {
          "description": "traverseWithKey fromList traverse toList That is behaves exactly like regular traverse except that the traversing function also has access to the key associated with value traverseWithKey if odd then Just succ else Nothing fromList Just fromList traverseWithKey if odd then Just succ else Nothing fromList Nothing",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "traverseWithKey",
          "normalized": "(a-\u003eb-\u003ec d)-\u003eMap a b-\u003ec(Map a d)",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003et b)-\u003eMap k a-\u003et(Map k b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:traverseWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e.\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e t1 t2\u003c/code\u003e) takes the left-biased union of \u003ccode\u003et1\u003c/code\u003e and \u003ccode\u003et2\u003c/code\u003e.\n It prefers \u003ccode\u003et1\u003c/code\u003e when duplicate keys are encountered,\n i.e. (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e == \u003ccode\u003e\u003ca\u003eunionWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n The implementation uses the efficient \u003cem\u003ehedge-union\u003c/em\u003e algorithm.\n\u003c/p\u003e\u003cpre\u003e union (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "union",
          "package": "containers",
          "signature": "Map k a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#union",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:union\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:union\"]"
        },
        "index": {
          "description": "The expression union t1 t2 takes the left-biased union of t1 and t2 It prefers t1 when duplicate keys are encountered i.e union unionWith const The implementation uses the efficient hedge-union algorithm union fromList fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "union",
          "normalized": "Map a b-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "signature": "Map k a-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Union with a combining function. The implementation uses the efficient \u003cem\u003ehedge-union\u003c/em\u003e algorithm.\n\u003c/p\u003e\u003cpre\u003e unionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"aA\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "unionWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Map k a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#unionWith",
          "type": "function"
        },
        "index": {
          "description": "Union with combining function The implementation uses the efficient hedge-union algorithm unionWith fromList fromList fromList aA",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "unionWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eMap b a-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eMap k a-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:unionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e.\n Union with a combining function. The implementation uses the efficient \u003cem\u003ehedge-union\u003c/em\u003e algorithm.\n\u003c/p\u003e\u003cpre\u003e let f key left_value right_value = (show key) ++ \":\" ++ left_value ++ \"|\" ++ right_value\n unionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"5:a|A\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "unionWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e Map k a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#unionWithKey",
          "type": "function"
        },
        "index": {
          "description": "Union with combining function The implementation uses the efficient hedge-union algorithm let key left value right value show key left value right value unionWithKey fromList fromList fromList",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "unionWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003eMap a b-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003eMap k a-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:unionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of maps:\n   (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunions\u003c/a\u003e\u003c/code\u003e == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e unions [(fromList [(5, \"a\"), (3, \"b\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"A3\"), (3, \"B3\")])]\n     == fromList [(3, \"b\"), (5, \"a\"), (7, \"C\")]\n unions [(fromList [(5, \"A3\"), (3, \"B3\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"a\"), (3, \"b\")])]\n     == fromList [(3, \"B3\"), (5, \"A3\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "unions",
          "package": "containers",
          "signature": "[Map k a] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#unions",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:unions\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:unions\"]"
        },
        "index": {
          "description": "The union of list of maps unions foldl union empty unions fromList fromList fromList A3 B3 fromList unions fromList A3 B3 fromList fromList fromList B3 A3",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "unions",
          "normalized": "[Map a b]-\u003eMap a b",
          "package": "containers",
          "signature": "[Map k a]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of maps, with a combining operation:\n   (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunionsWith\u003c/a\u003e\u003c/code\u003e f == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eunionWith\u003c/a\u003e\u003c/code\u003e f) \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e unionsWith (++) [(fromList [(5, \"a\"), (3, \"b\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"A3\"), (3, \"B3\")])]\n     == fromList [(3, \"bB3\"), (5, \"aAA3\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "unionsWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [Map k a] -\u003e Map k a",
          "source": "src/Data-Map-Base.html#unionsWith",
          "type": "function"
        },
        "index": {
          "description": "The union of list of maps with combining operation unionsWith foldl unionWith empty unionsWith fromList fromList fromList A3 B3 fromList bB3 aAA3",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "unionsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[Map b a]-\u003eMap b a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[Map k a]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:unionsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the value \u003ccode\u003ex\u003c/code\u003e\n at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is\n deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n update f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n update f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n update f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "update",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#update",
          "type": "function"
        },
        "index": {
          "description": "log The expression update map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just new else Nothing update fromList fromList new update fromList fromList update fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "update",
          "normalized": "(a-\u003eMaybe a)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(a-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the element at \u003cem\u003eindex\u003c/em\u003e, i.e. by its zero-based index in\n the sequence sorted by keys. If the \u003cem\u003eindex\u003c/em\u003e is out of range (less than zero,\n greater or equal to \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the map), \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e\u003cpre\u003e updateAt (\\ _ _ -\u003e Just \"x\") 0    (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"x\"), (5, \"a\")]\n updateAt (\\ _ _ -\u003e Just \"x\") 1    (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"x\")]\n updateAt (\\ _ _ -\u003e Just \"x\") 2    (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n updateAt (\\ _ _ -\u003e Just \"x\") (-1) (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n updateAt (\\_ _  -\u003e Nothing)  0    (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n updateAt (\\_ _  -\u003e Nothing)  1    (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n updateAt (\\_ _  -\u003e Nothing)  2    (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n updateAt (\\_ _  -\u003e Nothing)  (-1) (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateAt",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e Int -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#updateAt",
          "type": "function"
        },
        "index": {
          "description": "log Update the element at index i.e by its zero-based index in the sequence sorted by keys If the index is out of range less than zero greater or equal to size of the map error is called updateAt Just fromList fromList updateAt Just fromList fromList updateAt Just fromList Error index out of range updateAt Just fromList Error index out of range updateAt Nothing fromList singleton updateAt Nothing fromList singleton updateAt Nothing fromList Error index out of range updateAt Nothing fromList Error index out of range",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateAt",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eInt-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "At",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003eInt-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Lookup and update. See also \u003ccode\u003e\u003ca\u003eupdateWithKey\u003c/a\u003e\u003c/code\u003e.\n The function returns changed value, if it is updated.\n Returns the original key value if the map entry is deleted.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateLookupWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"5:new a\", fromList [(3, \"b\"), (5, \"5:new a\")])\n updateLookupWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\")])\n updateLookupWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"b\", singleton 5 \"a\")\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateLookupWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e (Maybe a, Map k a)",
          "source": "src/Data-Map-Base.html#updateLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Lookup and update See also updateWithKey The function returns changed value if it is updated Returns the original key value if the map entry is deleted let if then Just show new else Nothing updateLookupWithKey fromList Just new fromList new updateLookupWithKey fromList Nothing fromList updateLookupWithKey fromList Just singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateLookupWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003ea-\u003eMap a b-\u003e(Maybe b,Map a b)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003e(Maybe a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMax (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"Xa\")]\n updateMax (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateMax",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#updateMax",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the maximal key updateMax Just fromList fromList Xa updateMax Nothing fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateMax",
          "normalized": "(a-\u003eMaybe a)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "Max",
          "signature": "(a-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMaxWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"b\"), (5,\"5:a\")]\n updateMaxWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateMaxWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#updateMaxWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the maximal key updateMaxWithKey Just show fromList fromList updateMaxWithKey Nothing fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateMaxWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "Max With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateMaxWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMin (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"Xb\"), (5, \"a\")]\n updateMin (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateMin",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#updateMin",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the minimal key updateMin Just fromList fromList Xb updateMin Nothing fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateMin",
          "normalized": "(a-\u003eMaybe a)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "Min",
          "signature": "(a-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMinWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"3:b\"), (5,\"a\")]\n updateMinWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateMinWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#updateMinWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the minimal key updateMinWithKey Just show fromList fromList updateMinWithKey Nothing fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateMinWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "Min With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateMinWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdateWithKey\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the\n value \u003ccode\u003ex\u003c/code\u003e at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef k x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n the element is deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound\n to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n updateWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n updateWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Lazy",
          "name": "updateWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Base.html#updateWithKey",
          "type": "function"
        },
        "index": {
          "description": "log The expression updateWithKey map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just show new else Nothing updateWithKey fromList fromList new updateWithKey fromList fromList updateWithKey fromList singleton",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "updateWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003ea-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:updateWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Test if the internal map structure is valid.\n\u003c/p\u003e\u003cpre\u003e valid (fromAscList [(3,\"b\"), (5,\"a\")]) == True\n valid (fromAscList [(5,\"a\"), (3,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "[\"Data.Map.Lazy\",\"Data.Map.Strict\"]",
          "name": "valid",
          "package": "containers",
          "signature": "Map k a -\u003e Bool",
          "source": "src/Data-Map-Base.html#valid",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:valid\",\"http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:valid\"]"
        },
        "index": {
          "description": "Test if the internal map structure is valid valid fromAscList True valid fromAscList False",
          "hierarchy": "Data Map Lazy",
          "module": "Data.Map.Lazy",
          "name": "valid",
          "normalized": "Map a b-\u003eBool",
          "package": "containers",
          "signature": "Map k a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Lazy.html#v:valid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of ordered maps from keys to values\n (dictionaries).\n\u003c/p\u003e\u003cp\u003eAPI of this module is strict in both the keys and the values.\n If you need value-lazy maps, use \u003ca\u003eData.Map.Lazy\u003c/a\u003e instead.\n The \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e type is shared between the lazy and strict modules,\n meaning that the same \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e value can be passed to functions in\n both modules (although that is rarely needed).\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import qualified Data.Map.Strict as Map\n\u003c/pre\u003e\u003cp\u003eThe implementation of \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e is based on \u003cem\u003esize balanced\u003c/em\u003e binary trees (or\n trees of \u003cem\u003ebounded balance\u003c/em\u003e) as described by:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Stephen Adams, \"\u003cem\u003eEfficient sets: a balancing act\u003c/em\u003e\",\n     Journal of Functional Programming 3(4):553-562, October 1993,\n     \u003ca\u003ehttp://www.swiss.ai.mit.edu/~adams/BB/\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e J. Nievergelt and E.M. Reingold,\n      \"\u003cem\u003eBinary search trees of bounded balance\u003c/em\u003e\",\n      SIAM journal of computing 2(1), March 1973.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote that the implementation is \u003cem\u003eleft-biased\u003c/em\u003e -- the elements of a\n first argument are always preferred to the second, for example in\n \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOperation comments contain the operation time complexity in\n the Big-O notation (\u003ca\u003ehttp://en.wikipedia.org/wiki/Big_O_notation\u003c/a\u003e).\n\u003c/p\u003e\u003cp\u003eBe aware that the \u003ccode\u003e\u003ca\u003eFunctor\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003eTraversable\u003c/code\u003e and \u003ccode\u003eData\u003c/code\u003e instances\n are the same as for the \u003ca\u003eData.Map.Lazy\u003c/a\u003e module, so if they are used\n on strict maps, the resulting maps will be lazy.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Map.Strict",
          "name": "Strict",
          "package": "containers",
          "source": "src/Data-Map-Strict.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of ordered maps from keys to values dictionaries API of this module is strict in both the keys and the values If you need value-lazy maps use Data.Map.Lazy instead The Map type is shared between the lazy and strict modules meaning that the same Map value can be passed to functions in both modules although that is rarely needed These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import qualified Data.Map.Strict as Map The implementation of Map is based on size balanced binary trees or trees of bounded balance as described by Stephen Adams Efficient sets balancing act Journal of Functional Programming October http www.swiss.ai.mit.edu adams BB Nievergelt and E.M Reingold Binary search trees of bounded balance SIAM journal of computing March Note that the implementation is left-biased the elements of first argument are always preferred to the second for example in union or insert Operation comments contain the operation time complexity in the Big-O notation http en.wikipedia.org wiki Big notation Be aware that the Functor Traversable and Data instances are the same as for the Data.Map.Lazy module so if they are used on strict maps the resulting maps will be lazy",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "Strict",
          "package": "containers",
          "partial": "Strict",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Map from keys \u003ccode\u003ek\u003c/code\u003e to values \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Map.Strict",
          "name": "Map",
          "package": "containers",
          "source": "src/Data-Map-Base.html#Map",
          "type": "data"
        },
        "index": {
          "description": "Map from keys to values",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "Map",
          "package": "containers",
          "partial": "Map",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#t:Map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update a value at a specific key with the result of the provided function.\n When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e adjust (\"new \" ++) 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n adjust (\"new \" ++) 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjust (\"new \" ++) 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "adjust",
          "package": "containers",
          "signature": "(a -\u003e a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#adjust",
          "type": "function"
        },
        "index": {
          "description": "log Update value at specific key with the result of the provided function When the key is not member of the map the original map is returned adjust new fromList fromList new adjust new fromList fromList adjust new empty empty",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(a-\u003ea)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Adjust a value at a specific key. When the key is not\n a member of the map, the original map is returned.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":new \" ++ x\n adjustWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n adjustWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n adjustWithKey f 7 empty                         == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "adjustWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#adjustWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Adjust value at specific key When the key is not member of the map the original map is returned let key show key new adjustWithKey fromList fromList new adjustWithKey fromList fromList adjustWithKey empty empty",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "adjustWithKey",
          "normalized": "(a-\u003eb-\u003eb)-\u003ea-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003ea)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:adjustWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) alters the value \u003ccode\u003ex\u003c/code\u003e at \u003ccode\u003ek\u003c/code\u003e, or absence thereof.\n \u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e can be used to insert, delete, or update a value in a \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e.\n In short : \u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k (\u003ccode\u003e\u003ca\u003ealter\u003c/a\u003e\u003c/code\u003e f k m) = f (\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k m)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f _ = Nothing\n alter f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n alter f 5 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\n let f _ = Just \"c\"\n alter f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"c\")]\n alter f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"c\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "alter",
          "package": "containers",
          "signature": "(Maybe a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#alter",
          "type": "function"
        },
        "index": {
          "description": "log The expression alter map alters the value at or absence thereof alter can be used to insert delete or update value in Map In short lookup alter lookup let Nothing alter fromList fromList alter fromList singleton let Just alter fromList fromList alter fromList fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "alter",
          "normalized": "(Maybe a-\u003eMaybe a)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(Maybe a-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:alter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function.\n When two equal keys are\n encountered, the combining function is applied to the values of these keys.\n If it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is discarded (proper set difference). If\n it returns (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the element is updated with a new value \u003ccode\u003ey\u003c/code\u003e.\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let f al ar = if al == \"b\" then Just (al ++ \":\" ++ ar) else Nothing\n differenceWith f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (7, \"C\")])\n     == singleton 3 \"b:B\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "differenceWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e Maybe a) -\u003e Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#differenceWith",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function When two equal keys are encountered the combining function is applied to the values of these keys If it returns Nothing the element is discarded proper set difference If it returns Just the element is updated with new value The implementation uses an efficient hedge algorithm comparable with hedge-union let al ar if al then Just al ar else Nothing differenceWith fromList fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "differenceWith",
          "normalized": "(a-\u003eb-\u003eMaybe a)-\u003eMap c a-\u003eMap c b-\u003eMap c a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003eMaybe a)-\u003eMap k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:differenceWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference with a combining function. When two equal keys are\n encountered, the combining function is applied to the key and both values.\n If it returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is discarded (proper set difference). If\n it returns (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the element is updated with a new value \u003ccode\u003ey\u003c/code\u003e.\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = if al == \"b\" then Just ((show k) ++ \":\" ++ al ++ \"|\" ++ ar) else Nothing\n differenceWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (3, \"B\"), (10, \"C\")])\n     == singleton 3 \"3:b|B\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "differenceWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e Maybe a) -\u003e Map k a -\u003e Map k b -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#differenceWithKey",
          "type": "function"
        },
        "index": {
          "description": "Difference with combining function When two equal keys are encountered the combining function is applied to the key and both values If it returns Nothing the element is discarded proper set difference If it returns Just the element is updated with new value The implementation uses an efficient hedge algorithm comparable with hedge-union let al ar if al then Just show al ar else Nothing differenceWithKey fromList fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "differenceWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003eMaybe b)-\u003eMap a b-\u003eMap a c-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003eMaybe a)-\u003eMap k a-\u003eMap k b-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:differenceWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression \u003ccode\u003e(\u003ccode\u003e\u003ca\u003efindWithDefault\u003c/a\u003e\u003c/code\u003e def k map)\u003c/code\u003e returns\n the value at key \u003ccode\u003ek\u003c/code\u003e or returns default value \u003ccode\u003edef\u003c/code\u003e\n when the key is not in the map.\n\u003c/p\u003e\u003cpre\u003e findWithDefault 'x' 1 (fromList [(5,'a'), (3,'b')]) == 'x'\n findWithDefault 'x' 5 (fromList [(5,'a'), (3,'b')]) == 'a'\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "findWithDefault",
          "package": "containers",
          "signature": "a -\u003e k -\u003e Map k a -\u003e a",
          "source": "src/Data-Map-Strict.html#findWithDefault",
          "type": "function"
        },
        "index": {
          "description": "log The expression findWithDefault def map returns the value at key or returns default value def when the key is not in the map findWithDefault fromList findWithDefault fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "findWithDefault",
          "normalized": "a-\u003eb-\u003eMap b a-\u003ea",
          "package": "containers",
          "partial": "With Default",
          "signature": "a-\u003ek-\u003eMap k a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:findWithDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list in linear time.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscList [(3,\"b\"), (5,\"a\")]          == fromList [(3, \"b\"), (5, \"a\")]\n fromAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"b\")]\n valid (fromAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")]) == True\n valid (fromAscList [(5,\"a\"), (3,\"b\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromAscList",
          "package": "containers",
          "signature": "[(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list in linear time The precondition input list is ascending is not checked fromAscList fromList fromAscList fromList valid fromAscList True valid fromAscList False",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromAscList",
          "normalized": "[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "Asc List",
          "signature": "[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list in linear time with a combining function for equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"ba\")]\n valid (fromAscListWith (++) [(3,\"b\"), (5,\"a\"), (5,\"b\")]) == True\n valid (fromAscListWith (++) [(5,\"a\"), (3,\"b\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromAscListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromAscListWith",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list in linear time with combining function for equal keys The precondition input list is ascending is not checked fromAscListWith fromList ba valid fromAscListWith True valid fromAscListWith False",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromAscListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003eMap b a",
          "package": "containers",
          "partial": "Asc List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromAscListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list in linear time with a\n combining function for equal keys.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e let f k a1 a2 = (show k) ++ \":\" ++ a1 ++ a2\n fromAscListWithKey f [(3,\"b\"), (5,\"a\"), (5,\"b\"), (5,\"b\")] == fromList [(3, \"b\"), (5, \"5:b5:ba\")]\n valid (fromAscListWithKey f [(3,\"b\"), (5,\"a\"), (5,\"b\"), (5,\"b\")]) == True\n valid (fromAscListWithKey f [(5,\"a\"), (3,\"b\"), (5,\"b\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromAscListWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromAscListWithKey",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list in linear time with combining function for equal keys The precondition input list is ascending is not checked let a1 a2 show a1 a2 fromAscListWithKey fromList b5 ba valid fromAscListWithKey True valid fromAscListWithKey False",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromAscListWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003e[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "Asc List With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromAscListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from an ascending list of distinct elements in linear time.\n \u003cem\u003eThe precondition is not checked.\u003c/em\u003e\n\u003c/p\u003e\u003cpre\u003e fromDistinctAscList [(3,\"b\"), (5,\"a\")] == fromList [(3, \"b\"), (5, \"a\")]\n valid (fromDistinctAscList [(3,\"b\"), (5,\"a\")])          == True\n valid (fromDistinctAscList [(3,\"b\"), (5,\"a\"), (5,\"b\")]) == False\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromDistinctAscList",
          "package": "containers",
          "signature": "[(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "description": "Build map from an ascending list of distinct elements in linear time The precondition is not checked fromDistinctAscList fromList valid fromDistinctAscList True valid fromDistinctAscList False",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromDistinctAscList",
          "normalized": "[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "Distinct Asc List",
          "signature": "[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Build a map from a list of key/value pairs. See also \u003ccode\u003e\u003ca\u003efromAscList\u003c/a\u003e\u003c/code\u003e.\n If the list contains more than one value for the same key, the last value\n for the key is retained.\n\u003c/p\u003e\u003cp\u003eIf the keys of the list are ordered, linear-time implementation is used,\n with the performance equal to \u003ccode\u003e\u003ca\u003efromDistinctAscList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e fromList [] == empty\n fromList [(5,\"a\"), (3,\"b\"), (5, \"c\")] == fromList [(5,\"c\"), (3,\"b\")]\n fromList [(5,\"c\"), (3,\"b\"), (5, \"a\")] == fromList [(5,\"a\"), (3,\"b\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromList",
          "package": "containers",
          "signature": "[(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "log Build map from list of key value pairs See also fromAscList If the list contains more than one value for the same key the last value for the key is retained If the keys of the list are ordered linear-time implementation is used with the performance equal to fromDistinctAscList fromList empty fromList fromList fromList fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromList",
          "normalized": "[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "List",
          "signature": "[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Build a map from a list of key/value pairs with a combining function. See also \u003ccode\u003e\u003ca\u003efromAscListWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e fromListWith (++) [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"a\")] == fromList [(3, \"ab\"), (5, \"aba\")]\n fromListWith (++) [] == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromListWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromListWith",
          "type": "function"
        },
        "index": {
          "description": "log Build map from list of key value pairs with combining function See also fromAscListWith fromListWith fromList ab aba fromListWith empty",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromListWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[(b,a)]-\u003eMap b a",
          "package": "containers",
          "partial": "List With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromListWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Build a map from a list of key/value pairs with a combining function. See also \u003ccode\u003e\u003ca\u003efromAscListWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k a1 a2 = (show k) ++ a1 ++ a2\n fromListWithKey f [(5,\"a\"), (5,\"b\"), (3,\"b\"), (3,\"a\"), (5,\"a\")] == fromList [(3, \"3ab\"), (5, \"5a5ba\")]\n fromListWithKey f [] == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromListWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e [(k, a)] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromListWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Build map from list of key value pairs with combining function See also fromAscListWithKey let a1 a2 show a1 a2 fromListWithKey fromList ab a5ba fromListWithKey empty",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromListWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003e[(a,b)]-\u003eMap a b",
          "package": "containers",
          "partial": "List With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003e[(k,a)]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromListWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a map from a set of keys and a function which for each key\n computes its value.\n\u003c/p\u003e\u003cpre\u003e fromSet (\\k -\u003e replicate k 'a') (Data.Set.fromList [3, 5]) == fromList [(5,\"aaaaa\"), (3,\"aaa\")]\n fromSet undefined Data.Set.empty == empty\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "fromSet",
          "package": "containers",
          "signature": "(k -\u003e a) -\u003e Set k -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#fromSet",
          "type": "function"
        },
        "index": {
          "description": "Build map from set of keys and function which for each key computes its value fromSet replicate Data.Set.fromList fromList aaaaa aaa fromSet undefined Data.Set.empty empty",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "fromSet",
          "normalized": "(a-\u003eb)-\u003eSet a-\u003eMap a b",
          "package": "containers",
          "partial": "Set",
          "signature": "(k-\u003ea)-\u003eSet k-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:fromSet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert a new key and value in the map.\n If the key is already present in the map, the associated value is\n replaced with the supplied value. \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e is equivalent to\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]\n insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]\n insert 5 'x' empty                         == singleton 5 'x'\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "insert",
          "package": "containers",
          "signature": "k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#insert",
          "type": "function"
        },
        "index": {
          "description": "log Insert new key and value in the map If the key is already present in the map the associated value is replaced with the supplied value insert is equivalent to insertWith const insert fromList fromList insert fromList fromList insert empty singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "insert",
          "normalized": "a-\u003eb-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "signature": "k-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Combines insert operation with old value retrieval.\n The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertLookupWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e)\n is a pair where the first element is equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003elookup\u003c/a\u003e\u003c/code\u003e k map\u003c/code\u003e)\n and the second element equal to (\u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f k x map\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertLookupWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"5:xxx|a\")])\n insertLookupWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")])\n insertLookupWithKey f 5 \"xxx\" empty                         == (Nothing,  singleton 5 \"xxx\")\n\u003c/pre\u003e\u003cp\u003eThis is how to define \u003ccode\u003einsertLookup\u003c/code\u003e using \u003ccode\u003einsertLookupWithKey\u003c/code\u003e:\n\u003c/p\u003e\u003cpre\u003e let insertLookup kx x t = insertLookupWithKey (\\_ a _ -\u003e a) kx x t\n insertLookup 5 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"a\", fromList [(3, \"b\"), (5, \"x\")])\n insertLookup 7 \"x\" (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\"), (7, \"x\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "insertLookupWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e (Maybe a, Map k a)",
          "source": "src/Data-Map-Strict.html#insertLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Combines insert operation with old value retrieval The expression insertLookupWithKey map is pair where the first element is equal to lookup map and the second element equal to insertWithKey map let key new value old value show key new value old value insertLookupWithKey xxx fromList Just fromList xxx insertLookupWithKey xxx fromList Nothing fromList xxx insertLookupWithKey xxx empty Nothing singleton xxx This is how to define insertLookup using insertLookupWithKey let insertLookup kx insertLookupWithKey kx insertLookup fromList Just fromList insertLookup fromList Nothing fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "insertLookupWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eMap a b-\u003e(Maybe b,Map a b)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003e(Maybe a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:insertLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert with a function, combining new value and old value.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert the pair \u003ccode\u003e(key, f new_value old_value)\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e insertWith (++) 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"xxxa\")]\n insertWith (++) 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWith (++) 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "insertWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#insertWith",
          "type": "function"
        },
        "index": {
          "description": "log Insert with function combining new value and old value insertWith key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert the pair key new value old value insertWith xxx fromList fromList xxxa insertWith xxx fromList fromList xxx insertWith xxx empty singleton xxx",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "insertWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:insertWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert with a function, combining key, new value and old value.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e f key value mp\u003c/code\u003e\n will insert the pair (key, value) into \u003ccode\u003emp\u003c/code\u003e if key does\n not exist in the map. If the key does exist, the function will\n insert the pair \u003ccode\u003e(key,f key new_value old_value)\u003c/code\u003e.\n Note that the key passed to f is the same key passed to \u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f key new_value old_value = (show key) ++ \":\" ++ new_value ++ \"|\" ++ old_value\n insertWithKey f 5 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:xxx|a\")]\n insertWithKey f 7 \"xxx\" (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\"), (7, \"xxx\")]\n insertWithKey f 5 \"xxx\" empty                         == singleton 5 \"xxx\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "insertWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#insertWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Insert with function combining key new value and old value insertWithKey key value mp will insert the pair key value into mp if key does not exist in the map If the key does exist the function will insert the pair key key new value old value Note that the key passed to is the same key passed to insertWithKey let key new value old value show key new value old value insertWithKey xxx fromList fromList xxx insertWithKey xxx fromList fromList xxx insertWithKey xxx empty singleton xxx",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "insertWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:insertWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Intersection with a combining function.  The implementation uses\n an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e intersectionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"aA\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "intersectionWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c) -\u003e Map k a -\u003e Map k b -\u003e Map k c",
          "source": "src/Data-Map-Strict.html#intersectionWith",
          "type": "function"
        },
        "index": {
          "description": "Intersection with combining function The implementation uses an efficient hedge algorithm comparable with hedge-union intersectionWith fromList fromList singleton aA",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "intersectionWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap d a-\u003eMap d b-\u003eMap d c",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eMap k a-\u003eMap k b-\u003eMap k c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:intersectionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Intersection with a combining function.  The implementation uses\n an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k al ar = (show k) ++ \":\" ++ al ++ \"|\" ++ ar\n intersectionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == singleton 5 \"5:a|A\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "intersectionWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e c) -\u003e Map k a -\u003e Map k b -\u003e Map k c",
          "source": "src/Data-Map-Strict.html#intersectionWithKey",
          "type": "function"
        },
        "index": {
          "description": "Intersection with combining function The implementation uses an efficient hedge algorithm comparable with hedge-union let al ar show al ar intersectionWithKey fromList fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "intersectionWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eMap a b-\u003eMap a c-\u003eMap a d",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003ec)-\u003eMap k a-\u003eMap k b-\u003eMap k c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:intersectionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e map (++ \"x\") (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"bx\"), (5, \"ax\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "map",
          "package": "containers",
          "signature": "(a -\u003e b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Strict.html#map",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map map fromList fromList bx ax",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eMap c a-\u003eMap c b",
          "package": "containers",
          "signature": "(a-\u003eb)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ca\u003emapAccum\u003c/a\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a b = (a ++ b, b ++ \"X\")\n mapAccum f \"Everything: \" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: ba\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapAccum",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e (a, c)) -\u003e a -\u003e Map k b -\u003e (a, Map k c)",
          "source": "src/Data-Map-Strict.html#mapAccum",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccum threads an accumulating argument through the map in ascending order of keys let mapAccum Everything fromList Everything ba fromList bX aX",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapAccum",
          "normalized": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eMap d b-\u003e(a,Map d c)",
          "package": "containers",
          "partial": "Accum",
          "signature": "(a-\u003eb-\u003e(a,c))-\u003ea-\u003eMap k b-\u003e(a,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapAccum"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003emapAccumR\u003c/code\u003e threads an accumulating\n argument through the map in descending order of keys.\n\u003c/p\u003e",
          "module": "Data.Map.Strict",
          "name": "mapAccumRWithKey",
          "package": "containers",
          "signature": "(a -\u003e k -\u003e b -\u003e (a, c)) -\u003e a -\u003e Map k b -\u003e (a, Map k c)",
          "source": "src/Data-Map-Strict.html#mapAccumRWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumR threads an accumulating argument through the map in descending order of keys",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapAccumRWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003e(a,d))-\u003ea-\u003eMap b c-\u003e(a,Map b d)",
          "package": "containers",
          "partial": "Accum RWith Key",
          "signature": "(a-\u003ek-\u003eb-\u003e(a,c))-\u003ea-\u003eMap k b-\u003e(a,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapAccumRWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The function \u003ccode\u003e\u003ca\u003emapAccumWithKey\u003c/a\u003e\u003c/code\u003e threads an accumulating\n argument through the map in ascending order of keys.\n\u003c/p\u003e\u003cpre\u003e let f a k b = (a ++ \" \" ++ (show k) ++ \"-\" ++ b, b ++ \"X\")\n mapAccumWithKey f \"Everything:\" (fromList [(5,\"a\"), (3,\"b\")]) == (\"Everything: 3-b 5-a\", fromList [(3, \"bX\"), (5, \"aX\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapAccumWithKey",
          "package": "containers",
          "signature": "(a -\u003e k -\u003e b -\u003e (a, c)) -\u003e a -\u003e Map k b -\u003e (a, Map k c)",
          "source": "src/Data-Map-Strict.html#mapAccumWithKey",
          "type": "function"
        },
        "index": {
          "description": "The function mapAccumWithKey threads an accumulating argument through the map in ascending order of keys let show mapAccumWithKey Everything fromList Everything fromList bX aX",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapAccumWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003e(a,d))-\u003ea-\u003eMap b c-\u003e(a,Map b d)",
          "package": "containers",
          "partial": "Accum With Key",
          "signature": "(a-\u003ek-\u003eb-\u003e(a,c))-\u003ea-\u003eMap k b-\u003e(a,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapAccumWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f a = if a \u003c \"c\" then Left a else Right a\n mapEither f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(3,\"b\"), (5,\"a\")], fromList [(1,\"x\"), (7,\"z\")])\n\n mapEither (\\ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapEither",
          "package": "containers",
          "signature": "(a -\u003e Either b c) -\u003e Map k a -\u003e (Map k b, Map k c)",
          "source": "src/Data-Map-Strict.html#mapEither",
          "type": "function"
        },
        "index": {
          "description": "Map values and separate the Left and Right results let if then Left else Right mapEither fromList fromList fromList mapEither Right fromList empty fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapEither",
          "normalized": "(a-\u003eEither b c)-\u003eMap d a-\u003e(Map d b,Map d c)",
          "package": "containers",
          "partial": "Either",
          "signature": "(a-\u003eEither b c)-\u003eMap k a-\u003e(Map k b,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and separate the \u003ccode\u003e\u003ca\u003eLeft\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eRight\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k a = if k \u003c 5 then Left (k * 2) else Right (a ++ a)\n mapEitherWithKey f (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (fromList [(1,2), (3,6)], fromList [(5,\"aa\"), (7,\"zz\")])\n\n mapEitherWithKey (\\_ a -\u003e Right a) (fromList [(5,\"a\"), (3,\"b\"), (1,\"x\"), (7,\"z\")])\n     == (empty, fromList [(1,\"x\"), (3,\"b\"), (5,\"a\"), (7,\"z\")])\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapEitherWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Either b c) -\u003e Map k a -\u003e (Map k b, Map k c)",
          "source": "src/Data-Map-Strict.html#mapEitherWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and separate the Left and Right results let if then Left else Right mapEitherWithKey fromList fromList fromList aa zz mapEitherWithKey Right fromList empty fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapEitherWithKey",
          "normalized": "(a-\u003eb-\u003eEither c d)-\u003eMap a b-\u003e(Map a c,Map a d)",
          "package": "containers",
          "partial": "Either With Key",
          "signature": "(k-\u003ea-\u003eEither b c)-\u003eMap k a-\u003e(Map k b,Map k c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapEitherWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emapKeysWith\u003c/a\u003e\u003c/code\u003e c f s\u003c/code\u003e is the map obtained by applying \u003ccode\u003ef\u003c/code\u003e to each key of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe size of the result may be smaller if \u003ccode\u003ef\u003c/code\u003e maps two or more distinct\n keys to the same new key.  In this case the associated values will be\n combined using \u003ccode\u003ec\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e mapKeysWith (++) (\\ _ -\u003e 1) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 1 \"cdab\"\n mapKeysWith (++) (\\ _ -\u003e 3) (fromList [(1,\"b\"), (2,\"a\"), (3,\"d\"), (4,\"c\")]) == singleton 3 \"cdab\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapKeysWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e (k1 -\u003e k2) -\u003e Map k1 a -\u003e Map k2 a",
          "source": "src/Data-Map-Strict.html#mapKeysWith",
          "type": "function"
        },
        "index": {
          "description": "log mapKeysWith is the map obtained by applying to each key of The size of the result may be smaller if maps two or more distinct keys to the same new key In this case the associated values will be combined using mapKeysWith fromList singleton cdab mapKeysWith fromList singleton cdab",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapKeysWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e(b-\u003eb)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "Keys With",
          "signature": "(a-\u003ea-\u003ea)-\u003e(k-\u003ek)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapKeysWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n mapMaybe f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"new a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapMaybe",
          "package": "containers",
          "signature": "(a -\u003e Maybe b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Strict.html#mapMaybe",
          "type": "function"
        },
        "index": {
          "description": "Map values and collect the Just results let if then Just new else Nothing mapMaybe fromList singleton new",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapMaybe",
          "normalized": "(a-\u003eMaybe b)-\u003eMap c a-\u003eMap c b",
          "package": "containers",
          "partial": "Maybe",
          "signature": "(a-\u003eMaybe b)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map keys/values and collect the \u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e results.\n\u003c/p\u003e\u003cpre\u003e let f k _ = if k \u003c 5 then Just (\"key : \" ++ (show k)) else Nothing\n mapMaybeWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"key : 3\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapMaybeWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Strict.html#mapMaybeWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map keys values and collect the Just results let if then Just key show else Nothing mapMaybeWithKey fromList singleton key",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapMaybeWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe c)-\u003eMap a b-\u003eMap a c",
          "package": "containers",
          "partial": "Maybe With Key",
          "signature": "(k-\u003ea-\u003eMaybe b)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapMaybeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Map a function over all values in the map.\n\u003c/p\u003e\u003cpre\u003e let f key x = (show key) ++ \":\" ++ x\n mapWithKey f (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"3:b\"), (5, \"5:a\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "mapWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b) -\u003e Map k a -\u003e Map k b",
          "source": "src/Data-Map-Strict.html#mapWithKey",
          "type": "function"
        },
        "index": {
          "description": "Map function over all values in the map let key show key mapWithKey fromList fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mapWithKey",
          "normalized": "(a-\u003eb-\u003ec)-\u003eMap a b-\u003eMap a c",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb)-\u003eMap k a-\u003eMap k b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mapWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. A high-performance universal combining function. This function\n is used to define \u003ccode\u003e\u003ca\u003eunionWith\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunionWithKey\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003edifferenceWith\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003edifferenceWithKey\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eintersectionWith\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eintersectionWithKey\u003c/a\u003e\u003c/code\u003e and can be\n used to define other custom combine functions.\n\u003c/p\u003e\u003cp\u003ePlease make sure you know what is going on when using \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e,\n otherwise you can be surprised by unexpected code growth or even\n corruption of the data structure.\n\u003c/p\u003e\u003cp\u003eWhen \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e is given three arguments, it is inlined to the call\n site. You should therefore use \u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e only to define your custom\n combining functions. For example, you could define \u003ccode\u003e\u003ca\u003eunionWithKey\u003c/a\u003e\u003c/code\u003e,\n \u003ccode\u003e\u003ca\u003edifferenceWithKey\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eintersectionWithKey\u003c/a\u003e\u003c/code\u003e as\n\u003c/p\u003e\u003cpre\u003e myUnionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) id id m1 m2\n myDifferenceWithKey f m1 m2 = mergeWithKey f id (const empty) m1 m2\n myIntersectionWithKey f m1 m2 = mergeWithKey (\\k x1 x2 -\u003e Just (f k x1 x2)) (const empty) (const empty) m1 m2\n\u003c/pre\u003e\u003cp\u003eWhen calling \u003ccode\u003e\u003ccode\u003e\u003ca\u003emergeWithKey\u003c/a\u003e\u003c/code\u003e combine only1 only2\u003c/code\u003e, a function combining two\n \u003ccode\u003eIntMap\u003c/code\u003es is created, such that\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e if a key is present in both maps, it is passed with both corresponding\n   values to the \u003ccode\u003ecombine\u003c/code\u003e function. Depending on the result, the key is either\n   present in the result with specified value, or is left out;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the first map is passed to \u003ccode\u003eonly1\u003c/code\u003e and\n   the output is added to the result;\n\u003c/li\u003e\u003cli\u003e a nonempty subtree present only in the second map is passed to \u003ccode\u003eonly2\u003c/code\u003e and\n   the output is added to the result.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe \u003ccode\u003eonly1\u003c/code\u003e and \u003ccode\u003eonly2\u003c/code\u003e methods \u003cem\u003emust return a map with a subset (possibly empty) of the keys of the given map\u003c/em\u003e.\n The values can be modified arbitrarily. Most common variants of \u003ccode\u003eonly1\u003c/code\u003e and\n \u003ccode\u003eonly2\u003c/code\u003e are \u003ccode\u003e\u003ca\u003eid\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ccode\u003e\u003ca\u003econst\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e, but for example \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e or\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003efilterWithKey\u003c/a\u003e\u003c/code\u003e f\u003c/code\u003e could be used for any \u003ccode\u003ef\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Map.Strict",
          "name": "mergeWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e Maybe c) -\u003e (Map k a -\u003e Map k c) -\u003e (Map k b -\u003e Map k c) -\u003e Map k a -\u003e Map k b -\u003e Map k c",
          "source": "src/Data-Map-Strict.html#mergeWithKey",
          "type": "function"
        },
        "index": {
          "description": "high-performance universal combining function This function is used to define unionWith unionWithKey differenceWith differenceWithKey intersectionWith intersectionWithKey and can be used to define other custom combine functions Please make sure you know what is going on when using mergeWithKey otherwise you can be surprised by unexpected code growth or even corruption of the data structure When mergeWithKey is given three arguments it is inlined to the call site You should therefore use mergeWithKey only to define your custom combining functions For example you could define unionWithKey differenceWithKey and intersectionWithKey as myUnionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 id id m1 m2 myDifferenceWithKey m1 m2 mergeWithKey id const empty m1 m2 myIntersectionWithKey m1 m2 mergeWithKey x1 x2 Just x1 x2 const empty const empty m1 m2 When calling mergeWithKey combine only1 only2 function combining two IntMap is created such that if key is present in both maps it is passed with both corresponding values to the combine function Depending on the result the key is either present in the result with specified value or is left out nonempty subtree present only in the first map is passed to only1 and the output is added to the result nonempty subtree present only in the second map is passed to only2 and the output is added to the result The only1 and only2 methods must return map with subset possibly empty of the keys of the given map The values can be modified arbitrarily Most common variants of only1 and only2 are id and const empty but for example map or filterWithKey could be used for any",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "mergeWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003eMaybe d)-\u003e(Map a b-\u003eMap a d)-\u003e(Map a c-\u003eMap a d)-\u003eMap a b-\u003eMap a c-\u003eMap a d",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003eMaybe c)-\u003e(Map k a-\u003eMap k c)-\u003e(Map k b-\u003eMap k c)-\u003eMap k a-\u003eMap k b-\u003eMap k c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:mergeWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. A map with a single element.\n\u003c/p\u003e\u003cpre\u003e singleton 1 'a'        == fromList [(1, 'a')]\n size (singleton 1 'a') == 1\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "singleton",
          "package": "containers",
          "signature": "k -\u003e a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "map with single element singleton fromList size singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "singleton",
          "normalized": "a-\u003eb-\u003eMap a b",
          "package": "containers",
          "signature": "k-\u003ea-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Union with a combining function. The implementation uses the efficient \u003cem\u003ehedge-union\u003c/em\u003e algorithm.\n\u003c/p\u003e\u003cpre\u003e unionWith (++) (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"aA\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "unionWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Map k a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#unionWith",
          "type": "function"
        },
        "index": {
          "description": "Union with combining function The implementation uses the efficient hedge-union algorithm unionWith fromList fromList fromList aA",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "unionWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003eMap b a-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003eMap k a-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:unionWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e.\n Union with a combining function. The implementation uses the efficient \u003cem\u003ehedge-union\u003c/em\u003e algorithm.\n\u003c/p\u003e\u003cpre\u003e let f key left_value right_value = (show key) ++ \":\" ++ left_value ++ \"|\" ++ right_value\n unionWithKey f (fromList [(5, \"a\"), (3, \"b\")]) (fromList [(5, \"A\"), (7, \"C\")]) == fromList [(3, \"b\"), (5, \"5:a|A\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "unionWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e Map k a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#unionWithKey",
          "type": "function"
        },
        "index": {
          "description": "Union with combining function The implementation uses the efficient hedge-union algorithm let key left value right value show key left value right value unionWithKey fromList fromList fromList",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "unionWithKey",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003eMap a b-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003eMap k a-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:unionWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of maps, with a combining operation:\n   (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunionsWith\u003c/a\u003e\u003c/code\u003e f == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eunionWith\u003c/a\u003e\u003c/code\u003e f) \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e\u003cpre\u003e unionsWith (++) [(fromList [(5, \"a\"), (3, \"b\")]), (fromList [(5, \"A\"), (7, \"C\")]), (fromList [(5, \"A3\"), (3, \"B3\")])]\n     == fromList [(3, \"bB3\"), (5, \"aAA3\"), (7, \"C\")]\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "unionsWith",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e [Map k a] -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#unionsWith",
          "type": "function"
        },
        "index": {
          "description": "The union of list of maps with combining operation unionsWith foldl unionWith empty unionsWith fromList fromList fromList A3 B3 fromList bB3 aAA3",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "unionsWith",
          "normalized": "(a-\u003ea-\u003ea)-\u003e[Map b a]-\u003eMap b a",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003ea-\u003ea)-\u003e[Map k a]-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:unionsWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdate\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the value \u003ccode\u003ex\u003c/code\u003e\n at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e, the element is\n deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f x = if x == \"a\" then Just \"new a\" else Nothing\n update f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"new a\")]\n update f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n update f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "update",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#update",
          "type": "function"
        },
        "index": {
          "description": "log The expression update map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just new else Nothing update fromList fromList new update fromList fromList update fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "update",
          "normalized": "(a-\u003eMaybe a)-\u003eb-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "signature": "(a-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the element at \u003cem\u003eindex\u003c/em\u003e. Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e when an\n invalid index is used.\n\u003c/p\u003e\u003cpre\u003e updateAt (\\ _ _ -\u003e Just \"x\") 0    (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"x\"), (5, \"a\")]\n updateAt (\\ _ _ -\u003e Just \"x\") 1    (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"x\")]\n updateAt (\\ _ _ -\u003e Just \"x\") 2    (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n updateAt (\\ _ _ -\u003e Just \"x\") (-1) (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n updateAt (\\_ _  -\u003e Nothing)  0    (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n updateAt (\\_ _  -\u003e Nothing)  1    (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n updateAt (\\_ _  -\u003e Nothing)  2    (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n updateAt (\\_ _  -\u003e Nothing)  (-1) (fromList [(5,\"a\"), (3,\"b\")])    Error: index out of range\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateAt",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e Int -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#updateAt",
          "type": "function"
        },
        "index": {
          "description": "log Update the element at index Calls error when an invalid index is used updateAt Just fromList fromList updateAt Just fromList fromList updateAt Just fromList Error index out of range updateAt Just fromList Error index out of range updateAt Nothing fromList singleton updateAt Nothing fromList singleton updateAt Nothing fromList Error index out of range updateAt Nothing fromList Error index out of range",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateAt",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eInt-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "At",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003eInt-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Lookup and update. See also \u003ccode\u003e\u003ca\u003eupdateWithKey\u003c/a\u003e\u003c/code\u003e.\n The function returns changed value, if it is updated.\n Returns the original key value if the map entry is deleted.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateLookupWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"5:new a\", fromList [(3, \"b\"), (5, \"5:new a\")])\n updateLookupWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == (Nothing,  fromList [(3, \"b\"), (5, \"a\")])\n updateLookupWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == (Just \"b\", singleton 5 \"a\")\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateLookupWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e (Maybe a, Map k a)",
          "source": "src/Data-Map-Strict.html#updateLookupWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Lookup and update See also updateWithKey The function returns changed value if it is updated Returns the original key value if the map entry is deleted let if then Just show new else Nothing updateLookupWithKey fromList Just new fromList new updateLookupWithKey fromList Nothing fromList updateLookupWithKey fromList Just singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateLookupWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003ea-\u003eMap a b-\u003e(Maybe b,Map a b)",
          "package": "containers",
          "partial": "Lookup With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003e(Maybe a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateLookupWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMax (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"Xa\")]\n updateMax (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateMax",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#updateMax",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the maximal key updateMax Just fromList fromList Xa updateMax Nothing fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateMax",
          "normalized": "(a-\u003eMaybe a)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "Max",
          "signature": "(a-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the maximal key.\n\u003c/p\u003e\u003cpre\u003e updateMaxWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"b\"), (5,\"5:a\")]\n updateMaxWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 3 \"b\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateMaxWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#updateMaxWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the maximal key updateMaxWithKey Just show fromList fromList updateMaxWithKey Nothing fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateMaxWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "Max With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateMaxWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMin (\\ a -\u003e Just (\"X\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"Xb\"), (5, \"a\")]\n updateMin (\\ _ -\u003e Nothing)         (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateMin",
          "package": "containers",
          "signature": "(a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#updateMin",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the minimal key updateMin Just fromList fromList Xb updateMin Nothing fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateMin",
          "normalized": "(a-\u003eMaybe a)-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "Min",
          "signature": "(a-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Update the value at the minimal key.\n\u003c/p\u003e\u003cpre\u003e updateMinWithKey (\\ k a -\u003e Just ((show k) ++ \":\" ++ a)) (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3,\"3:b\"), (5,\"a\")]\n updateMinWithKey (\\ _ _ -\u003e Nothing)                     (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateMinWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#updateMinWithKey",
          "type": "function"
        },
        "index": {
          "description": "log Update the value at the minimal key updateMinWithKey Just show fromList fromList updateMinWithKey Nothing fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateMinWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "Min With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateMinWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eupdateWithKey\u003c/a\u003e\u003c/code\u003e f k map\u003c/code\u003e) updates the\n value \u003ccode\u003ex\u003c/code\u003e at \u003ccode\u003ek\u003c/code\u003e (if it is in the map). If (\u003ccode\u003ef k x\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e,\n the element is deleted. If it is (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eJust\u003c/a\u003e\u003c/code\u003e y\u003c/code\u003e), the key \u003ccode\u003ek\u003c/code\u003e is bound\n to the new value \u003ccode\u003ey\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e let f k x = if x == \"a\" then Just ((show k) ++ \":new a\") else Nothing\n updateWithKey f 5 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"5:new a\")]\n updateWithKey f 7 (fromList [(5,\"a\"), (3,\"b\")]) == fromList [(3, \"b\"), (5, \"a\")]\n updateWithKey f 3 (fromList [(5,\"a\"), (3,\"b\")]) == singleton 5 \"a\"\n\u003c/pre\u003e",
          "module": "Data.Map.Strict",
          "name": "updateWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e Maybe a) -\u003e k -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map-Strict.html#updateWithKey",
          "type": "function"
        },
        "index": {
          "description": "log The expression updateWithKey map updates the value at if it is in the map If is Nothing the element is deleted If it is Just the key is bound to the new value let if then Just show new else Nothing updateWithKey fromList fromList new updateWithKey fromList fromList updateWithKey fromList singleton",
          "hierarchy": "Data Map Strict",
          "module": "Data.Map.Strict",
          "name": "updateWithKey",
          "normalized": "(a-\u003eb-\u003eMaybe b)-\u003ea-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eMaybe a)-\u003ek-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map-Strict.html#v:updateWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e You should use \u003ca\u003eData.Map.Strict\u003c/a\u003e instead of this module if:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e You will eventually need all the values stored.\n\u003c/li\u003e\u003cli\u003e The stored values don't represent large virtual data structures\n to be lazily computed.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAn efficient implementation of ordered maps from keys to values\n (dictionaries).\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import qualified Data.Map as Map\n\u003c/pre\u003e\u003cp\u003eThe implementation of \u003ccode\u003e\u003ca\u003eMap\u003c/a\u003e\u003c/code\u003e is based on \u003cem\u003esize balanced\u003c/em\u003e binary trees (or\n trees of \u003cem\u003ebounded balance\u003c/em\u003e) as described by:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Stephen Adams, \"\u003cem\u003eEfficient sets: a balancing act\u003c/em\u003e\",\n     Journal of Functional Programming 3(4):553-562, October 1993,\n     \u003ca\u003ehttp://www.swiss.ai.mit.edu/~adams/BB/\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e J. Nievergelt and E.M. Reingold,\n      \"\u003cem\u003eBinary search trees of bounded balance\u003c/em\u003e\",\n      SIAM journal of computing 2(1), March 1973.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote that the implementation is \u003cem\u003eleft-biased\u003c/em\u003e -- the elements of a\n first argument are always preferred to the second, for example in\n \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eOperation comments contain the operation time complexity in\n the Big-O notation (\u003ca\u003ehttp://en.wikipedia.org/wiki/Big_O_notation\u003c/a\u003e).\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Map",
          "name": "Map",
          "package": "containers",
          "source": "src/Data-Map.html",
          "type": "module"
        },
        "index": {
          "description": "Note You should use Data.Map.Strict instead of this module if You will eventually need all the values stored The stored values don represent large virtual data structures to be lazily computed An efficient implementation of ordered maps from keys to values dictionaries These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import qualified Data.Map as Map The implementation of Map is based on size balanced binary trees or trees of bounded balance as described by Stephen Adams Efficient sets balancing act Journal of Functional Programming October http www.swiss.ai.mit.edu adams BB Nievergelt and E.M Reingold Binary search trees of bounded balance SIAM journal of computing March Note that the implementation is left-biased the elements of first argument are always preferred to the second for example in union or insert Operation comments contain the operation time complexity in the Big-O notation http en.wikipedia.org wiki Big notation",
          "hierarchy": "Data Map",
          "module": "Data.Map",
          "name": "Map",
          "package": "containers",
          "partial": "Map",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the values in the map using the given right-associative\n binary operator. This function is an equivalent of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e and is present\n for compatibility only.\n\u003c/p\u003e",
          "module": "Data.Map",
          "name": "fold",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Map k a -\u003e b",
          "source": "src/Data-Map.html#fold",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by foldr Fold the values in the map using the given right-associative binary operator This function is an equivalent of foldr and is present for compatibility only",
          "hierarchy": "Data Map",
          "module": "Data.Map",
          "name": "fold",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eMap c a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eMap k a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.4, replaced by \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the keys and values in the map using the given right-associative\n binary operator. This function is an equivalent of \u003ccode\u003e\u003ca\u003efoldrWithKey\u003c/a\u003e\u003c/code\u003e and is present\n for compatibility only.\n\u003c/p\u003e",
          "module": "Data.Map",
          "name": "foldWithKey",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Map k a -\u003e b",
          "source": "src/Data-Map.html#foldWithKey",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by foldrWithKey Fold the keys and values in the map using the given right-associative binary operator This function is an equivalent of foldrWithKey and is present for compatibility only",
          "hierarchy": "Data Map",
          "module": "Data.Map",
          "name": "foldWithKey",
          "normalized": "(a-\u003eb-\u003ec-\u003ec)-\u003ec-\u003eMap a b-\u003ec",
          "package": "containers",
          "partial": "With Key",
          "signature": "(k-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eMap k a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map.html#v:foldWithKey"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by\n \u003ccode\u003e\u003ca\u003einsertLookupWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Same as \u003ccode\u003e\u003ca\u003einsertLookupWithKey\u003c/a\u003e\u003c/code\u003e, but the value being inserted to\n the map is evaluated to WHNF beforehand.\n\u003c/p\u003e",
          "module": "Data.Map",
          "name": "insertLookupWithKey'",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e (Maybe a, Map k a)",
          "source": "src/Data-Map.html#insertLookupWithKey%27",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by insertLookupWithKey log Same as insertLookupWithKey but the value being inserted to the map is evaluated to WHNF beforehand",
          "hierarchy": "Data Map",
          "module": "Data.Map",
          "name": "insertLookupWithKey'",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eMap a b-\u003e(Maybe b,Map a b)",
          "package": "containers",
          "partial": "Lookup With Key'",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003e(Maybe a,Map k a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map.html#v:insertLookupWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by \u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Same as \u003ccode\u003e\u003ca\u003einsertWith\u003c/a\u003e\u003c/code\u003e, but the value being inserted to the map is\n evaluated to WHNF beforehand.\n\u003c/p\u003e\u003cp\u003eFor example, to update a counter:\n\u003c/p\u003e\u003cpre\u003e insertWith' (+) k 1 m\n\u003c/pre\u003e",
          "module": "Data.Map",
          "name": "insertWith'",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map.html#insertWith%27",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by insertWith log Same as insertWith but the value being inserted to the map is evaluated to WHNF beforehand For example to update counter insertWith",
          "hierarchy": "Data Map",
          "module": "Data.Map",
          "name": "insertWith'",
          "normalized": "(a-\u003ea-\u003ea)-\u003eb-\u003ea-\u003eMap b a-\u003eMap b a",
          "package": "containers",
          "partial": "With'",
          "signature": "(a-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map.html#v:insertWith-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eDeprecated.\u003c/em\u003e As of version 0.5, replaced by\n \u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Same as \u003ccode\u003e\u003ca\u003einsertWithKey\u003c/a\u003e\u003c/code\u003e, but the value being inserted to the map is\n evaluated to WHNF beforehand.\n\u003c/p\u003e",
          "module": "Data.Map",
          "name": "insertWithKey'",
          "package": "containers",
          "signature": "(k -\u003e a -\u003e a -\u003e a) -\u003e k -\u003e a -\u003e Map k a -\u003e Map k a",
          "source": "src/Data-Map.html#insertWithKey%27",
          "type": "function"
        },
        "index": {
          "description": "Deprecated As of version replaced by insertWithKey log Same as insertWithKey but the value being inserted to the map is evaluated to WHNF beforehand",
          "hierarchy": "Data Map",
          "module": "Data.Map",
          "name": "insertWithKey'",
          "normalized": "(a-\u003eb-\u003eb-\u003eb)-\u003ea-\u003eb-\u003eMap a b-\u003eMap a b",
          "package": "containers",
          "partial": "With Key'",
          "signature": "(k-\u003ea-\u003ea-\u003ea)-\u003ek-\u003ea-\u003eMap k a-\u003eMap k a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Map.html#v:insertWithKey-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eGeneral purpose finite sequences.\n Apart from being finite and having strict operations, sequences\n also differ from lists in supporting a wider variety of operations\n efficiently.\n\u003c/p\u003e\u003cp\u003eAn amortized running time is given for each operation, with \u003cem\u003en\u003c/em\u003e referring\n to the length of the sequence and \u003cem\u003ei\u003c/em\u003e being the integral index used by\n some operations.  These bounds hold even in a persistent (shared) setting.\n\u003c/p\u003e\u003cp\u003eThe implementation uses 2-3 finger trees annotated with sizes,\n as described in section 4.2 of\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Ralf Hinze and Ross Paterson,\n      \"Finger trees: a simple general-purpose data structure\",\n      \u003cem\u003eJournal of Functional Programming\u003c/em\u003e 16:2 (2006) pp 197-217.\n      \u003ca\u003ehttp://www.soi.city.ac.uk/~ross/papers/FingerTree.html\u003c/a\u003e\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cem\u003eNote\u003c/em\u003e: Many of these operations have the same names as similar\n operations on lists in the \u003ca\u003ePrelude\u003c/a\u003e.  The ambiguity may be resolved\n using either qualification or the \u003ccode\u003ehiding\u003c/code\u003e clause.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Sequence",
          "name": "Sequence",
          "package": "containers",
          "source": "src/Data-Sequence.html",
          "type": "module"
        },
        "index": {
          "description": "General purpose finite sequences Apart from being finite and having strict operations sequences also differ from lists in supporting wider variety of operations efficiently An amortized running time is given for each operation with referring to the length of the sequence and being the integral index used by some operations These bounds hold even in persistent shared setting The implementation uses finger trees annotated with sizes as described in section of Ralf Hinze and Ross Paterson Finger trees simple general-purpose data structure Journal of Functional Programming pp http www.soi.city.ac.uk ross papers FingerTree.html Note Many of these operations have the same names as similar operations on lists in the Prelude The ambiguity may be resolved using either qualification or the hiding clause",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "Sequence",
          "package": "containers",
          "partial": "Sequence",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGeneral-purpose finite sequences.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "Seq",
          "package": "containers",
          "source": "src/Data-Sequence.html#Seq",
          "type": "data"
        },
        "index": {
          "description": "General-purpose finite sequences",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "Seq",
          "package": "containers",
          "partial": "Seq",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#t:Seq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView of the left end of a sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "ViewL",
          "package": "containers",
          "source": "src/Data-Sequence.html#ViewL",
          "type": "data"
        },
        "index": {
          "description": "View of the left end of sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "ViewL",
          "package": "containers",
          "partial": "View",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#t:ViewL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eView of the right end of a sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "ViewR",
          "package": "containers",
          "source": "src/Data-Sequence.html#ViewR",
          "type": "data"
        },
        "index": {
          "description": "View of the right end of sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "ViewR",
          "package": "containers",
          "partial": "View",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#t:ViewR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Add an element to the right end of a sequence.\n Mnemonic: a triangle with the single element at the pointy end.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "(|\u003e)",
          "package": "containers",
          "signature": "Seq a -\u003e a -\u003e Seq a",
          "source": "src/Data-Sequence.html#%7C%3E",
          "type": "function"
        },
        "index": {
          "description": "Add an element to the right end of sequence Mnemonic triangle with the single element at the pointy end",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "(|\u003e) |\u003e",
          "normalized": "Seq a-\u003ea-\u003eSeq a",
          "package": "containers",
          "signature": "Seq a-\u003ea-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:-124--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Add an element to the left end of a sequence.\n Mnemonic: a triangle with the single element at the pointy end.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "(\u003c|)",
          "package": "containers",
          "signature": "a -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#%3C%7C",
          "type": "function"
        },
        "index": {
          "description": "Add an element to the left end of sequence Mnemonic triangle with the single element at the pointy end",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "(\u003c|) \u003c|",
          "normalized": "a-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "a-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:-60--124-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(n1,n2)))\u003c/em\u003e. Concatenate two sequences.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "(\u003e\u003c)",
          "package": "containers",
          "signature": "Seq a -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#%3E%3C",
          "type": "function"
        },
        "index": {
          "description": "log min n1 n2 Concatenate two sequences",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "(\u003e\u003c) \u003e\u003c",
          "normalized": "Seq a-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "Seq a-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:-62--60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleftmost element and the rest of the sequence\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": ":\u003c",
          "package": "containers",
          "signature": "a :\u003c (Seq a)",
          "source": "src/Data-Sequence.html#ViewL",
          "type": "function"
        },
        "index": {
          "description": "leftmost element and the rest of the sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": ":\u003c",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v::-60-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ethe sequence minus the rightmost element,\n and the rightmost element\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": ":\u003e",
          "package": "containers",
          "signature": "(Seq a) :\u003e a",
          "source": "src/Data-Sequence.html#ViewR",
          "type": "function"
        },
        "index": {
          "description": "the sequence minus the rightmost element and the rightmost element",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": ":\u003e",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v::-62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty sequence\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "EmptyL",
          "package": "containers",
          "signature": "EmptyL",
          "source": "src/Data-Sequence.html#ViewL",
          "type": "function"
        },
        "index": {
          "description": "empty sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "EmptyL",
          "package": "containers",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:EmptyL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty sequence\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "EmptyR",
          "package": "containers",
          "signature": "EmptyR",
          "source": "src/Data-Sequence.html#ViewR",
          "type": "function"
        },
        "index": {
          "description": "empty sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "EmptyR",
          "package": "containers",
          "partial": "Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:EmptyR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(i,n-i)))\u003c/em\u003e. Update the element at the specified position.\n If the position is out of range, the original sequence is returned.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "adjust",
          "package": "containers",
          "signature": "(a -\u003e a) -\u003e Int -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#adjust",
          "type": "function"
        },
        "index": {
          "description": "log min n-i Update the element at the specified position If the position is out of range the original sequence is returned",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "adjust",
          "normalized": "(a-\u003ea)-\u003eInt-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "(a-\u003ea)-\u003eInt-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:adjust"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the breakpoint index.  \u003ccode\u003e\u003ca\u003ebreakl\u003c/a\u003e\u003c/code\u003e, applied to a\n predicate \u003ccode\u003ep\u003c/code\u003e and a sequence \u003ccode\u003exs\u003c/code\u003e, returns a pair whose first element\n is the longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n \u003cem\u003edo not satisfy\u003c/em\u003e \u003ccode\u003ep\u003c/code\u003e and the second element is the remainder of\n the sequence.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ebreakl\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espanl\u003c/a\u003e\u003c/code\u003e (not . p)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "breakl",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e (Seq a, Seq a)",
          "source": "src/Data-Sequence.html#breakl",
          "type": "function"
        },
        "index": {
          "description": "where is the breakpoint index breakl applied to predicate and sequence xs returns pair whose first element is the longest prefix possibly empty of xs of elements that do not satisfy and the second element is the remainder of the sequence breakl is equivalent to spanl not",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "breakl",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:breakl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003ebreakr\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003espanr\u003c/a\u003e\u003c/code\u003e (not . p)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "breakr",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e (Seq a, Seq a)",
          "source": "src/Data-Sequence.html#breakr",
          "type": "function"
        },
        "index": {
          "description": "breakr is equivalent to spanr not",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "breakr",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:breakr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(i,n-i)))\u003c/em\u003e. Elements of a sequence after the first \u003ccode\u003ei\u003c/code\u003e.\n If \u003ccode\u003ei\u003c/code\u003e is negative, \u003ccode\u003e\u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e i s\u003c/code\u003e yields the whole sequence.\n If the sequence contains fewer than \u003ccode\u003ei\u003c/code\u003e elements, the empty sequence\n is returned.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "drop",
          "package": "containers",
          "signature": "Int -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#drop",
          "type": "function"
        },
        "index": {
          "description": "log min n-i Elements of sequence after the first If is negative drop yields the whole sequence If the sequence contains fewer than elements the empty sequence is returned",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "drop",
          "normalized": "Int-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "Int-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the prefix length.  \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropWhileL\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e returns\n the suffix remaining after \u003ccode\u003e\u003ccode\u003e\u003ca\u003etakeWhileL\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "dropWhileL",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#dropWhileL",
          "type": "function"
        },
        "index": {
          "description": "where is the prefix length dropWhileL xs returns the suffix remaining after takeWhileL xs",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "dropWhileL",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:dropWhileL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the suffix length.  \u003ccode\u003e\u003ccode\u003e\u003ca\u003edropWhileR\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e returns\n the prefix remaining after \u003ccode\u003e\u003ccode\u003e\u003ca\u003etakeWhileR\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003edropWhileR\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003edropWhileL\u003c/a\u003e\u003c/code\u003e p (\u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e xs))\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "dropWhileR",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#dropWhileR",
          "type": "function"
        },
        "index": {
          "description": "where is the suffix length dropWhileR xs returns the prefix remaining after takeWhileR xs dropWhileR xs is equivalent to reverse dropWhileL reverse xs",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "dropWhileR",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:dropWhileR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eelemIndexL\u003c/a\u003e\u003c/code\u003e finds the leftmost index of the specified element,\n if it is present, and otherwise \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "elemIndexL",
          "package": "containers",
          "signature": "a -\u003e Seq a -\u003e Maybe Int",
          "source": "src/Data-Sequence.html#elemIndexL",
          "type": "function"
        },
        "index": {
          "description": "elemIndexL finds the leftmost index of the specified element if it is present and otherwise Nothing",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "elemIndexL",
          "normalized": "a-\u003eSeq a-\u003eMaybe Int",
          "package": "containers",
          "partial": "Index",
          "signature": "a-\u003eSeq a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:elemIndexL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eelemIndexR\u003c/a\u003e\u003c/code\u003e finds the rightmost index of the specified element,\n if it is present, and otherwise \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "elemIndexR",
          "package": "containers",
          "signature": "a -\u003e Seq a -\u003e Maybe Int",
          "source": "src/Data-Sequence.html#elemIndexR",
          "type": "function"
        },
        "index": {
          "description": "elemIndexR finds the rightmost index of the specified element if it is present and otherwise Nothing",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "elemIndexR",
          "normalized": "a-\u003eSeq a-\u003eMaybe Int",
          "package": "containers",
          "partial": "Index",
          "signature": "a-\u003eSeq a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:elemIndexR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eelemIndicesL\u003c/a\u003e\u003c/code\u003e finds the indices of the specified element, from\n left to right (i.e. in ascending order).\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "elemIndicesL",
          "package": "containers",
          "signature": "a -\u003e Seq a -\u003e [Int]",
          "source": "src/Data-Sequence.html#elemIndicesL",
          "type": "function"
        },
        "index": {
          "description": "elemIndicesL finds the indices of the specified element from left to right i.e in ascending order",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "elemIndicesL",
          "normalized": "a-\u003eSeq a-\u003e[Int]",
          "package": "containers",
          "partial": "Indices",
          "signature": "a-\u003eSeq a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:elemIndicesL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eelemIndicesR\u003c/a\u003e\u003c/code\u003e finds the indices of the specified element, from\n right to left (i.e. in descending order).\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "elemIndicesR",
          "package": "containers",
          "signature": "a -\u003e Seq a -\u003e [Int]",
          "source": "src/Data-Sequence.html#elemIndicesR",
          "type": "function"
        },
        "index": {
          "description": "elemIndicesR finds the indices of the specified element from right to left i.e in descending order",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "elemIndicesR",
          "normalized": "a-\u003eSeq a-\u003e[Int]",
          "package": "containers",
          "partial": "Indices",
          "signature": "a-\u003eSeq a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:elemIndicesR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The empty sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "empty",
          "package": "containers",
          "signature": "Seq a",
          "source": "src/Data-Sequence.html#empty",
          "type": "function"
        },
        "index": {
          "description": "The empty sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "empty",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.  The \u003ccode\u003e\u003ca\u003efilter\u003c/a\u003e\u003c/code\u003e function takes a predicate \u003ccode\u003ep\u003c/code\u003e and a sequence\n \u003ccode\u003exs\u003c/code\u003e and returns a sequence of those elements which satisfy the\n predicate.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "filter",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#filter",
          "type": "function"
        },
        "index": {
          "description": "The filter function takes predicate and sequence xs and returns sequence of those elements which satisfy the predicate",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efindIndexL\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e finds the index of the leftmost element that\n satisfies \u003ccode\u003ep\u003c/code\u003e, if any exist.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "findIndexL",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Maybe Int",
          "source": "src/Data-Sequence.html#findIndexL",
          "type": "function"
        },
        "index": {
          "description": "findIndexL xs finds the index of the leftmost element that satisfies if any exist",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "findIndexL",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eMaybe Int",
          "package": "containers",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:findIndexL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efindIndexR\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e finds the index of the rightmost element that\n satisfies \u003ccode\u003ep\u003c/code\u003e, if any exist.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "findIndexR",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Maybe Int",
          "source": "src/Data-Sequence.html#findIndexR",
          "type": "function"
        },
        "index": {
          "description": "findIndexR xs finds the index of the rightmost element that satisfies if any exist",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "findIndexR",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eMaybe Int",
          "package": "containers",
          "partial": "Index",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:findIndexR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efindIndicesL\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e finds all indices of elements that satisfy \u003ccode\u003ep\u003c/code\u003e,\n in ascending order.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "findIndicesL",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e [Int]",
          "source": "src/Data-Sequence.html#findIndicesL",
          "type": "function"
        },
        "index": {
          "description": "findIndicesL finds all indices of elements that satisfy in ascending order",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "findIndicesL",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e[Int]",
          "package": "containers",
          "partial": "Indices",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:findIndicesL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003efindIndicesR\u003c/a\u003e\u003c/code\u003e p\u003c/code\u003e finds all indices of elements that satisfy \u003ccode\u003ep\u003c/code\u003e,\n in descending order.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "findIndicesR",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e [Int]",
          "source": "src/Data-Sequence.html#findIndicesR",
          "type": "function"
        },
        "index": {
          "description": "findIndicesR finds all indices of elements that satisfy in descending order",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "findIndicesR",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e[Int]",
          "package": "containers",
          "partial": "Indices",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e[Int]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:findIndicesR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldlWithIndex\u003c/a\u003e\u003c/code\u003e is a version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e that also provides access\n to the index of each element.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "foldlWithIndex",
          "package": "containers",
          "signature": "(b -\u003e Int -\u003e a -\u003e b) -\u003e b -\u003e Seq a -\u003e b",
          "source": "src/Data-Sequence.html#foldlWithIndex",
          "type": "function"
        },
        "index": {
          "description": "foldlWithIndex is version of foldl that also provides access to the index of each element",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "foldlWithIndex",
          "normalized": "(a-\u003eInt-\u003eb-\u003ea)-\u003ea-\u003eSeq b-\u003ea",
          "package": "containers",
          "partial": "With Index",
          "signature": "(b-\u003eInt-\u003ea-\u003eb)-\u003eb-\u003eSeq a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:foldlWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003efoldrWithIndex\u003c/a\u003e\u003c/code\u003e is a version of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e that also provides access\n to the index of each element.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "foldrWithIndex",
          "package": "containers",
          "signature": "(Int -\u003e a -\u003e b -\u003e b) -\u003e b -\u003e Seq a -\u003e b",
          "source": "src/Data-Sequence.html#foldrWithIndex",
          "type": "function"
        },
        "index": {
          "description": "foldrWithIndex is version of foldr that also provides access to the index of each element",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "foldrWithIndex",
          "normalized": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eSeq a-\u003eb",
          "package": "containers",
          "partial": "With Index",
          "signature": "(Int-\u003ea-\u003eb-\u003eb)-\u003eb-\u003eSeq a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:foldrWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Create a sequence from a finite list of elements.\n There is a function \u003ccode\u003e\u003ca\u003etoList\u003c/a\u003e\u003c/code\u003e in the opposite direction for all\n instances of the \u003ccode\u003e\u003ca\u003eFoldable\u003c/a\u003e\u003c/code\u003e class, including \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "fromList",
          "package": "containers",
          "signature": "[a] -\u003e Seq a",
          "source": "src/Data-Sequence.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "Create sequence from finite list of elements There is function toList in the opposite direction for all instances of the Foldable class including Seq",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "fromList",
          "normalized": "[a]-\u003eSeq a",
          "package": "containers",
          "partial": "List",
          "signature": "[a]-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(i,n-i)))\u003c/em\u003e. The element at the specified position,\n counting from 0.  The argument should thus be a non-negative\n integer less than the size of the sequence.\n If the position is out of range, \u003ccode\u003e\u003ca\u003eindex\u003c/a\u003e\u003c/code\u003e fails with an error.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "index",
          "package": "containers",
          "signature": "Seq a -\u003e Int -\u003e a",
          "source": "src/Data-Sequence.html#index",
          "type": "function"
        },
        "index": {
          "description": "log min n-i The element at the specified position counting from The argument should thus be non-negative integer less than the size of the sequence If the position is out of range index fails with an error",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "index",
          "normalized": "Seq a-\u003eInt-\u003ea",
          "package": "containers",
          "signature": "Seq a-\u003eInt-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:index"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.  Returns a sequence of all prefixes of this sequence,\n shortest first.  For example,\n\u003c/p\u003e\u003cpre\u003e inits (fromList \"abc\") = fromList [fromList \"\", fromList \"a\", fromList \"ab\", fromList \"abc\"]\n\u003c/pre\u003e\u003cp\u003eEvaluating the \u003cem\u003ei\u003c/em\u003eth prefix takes \u003cem\u003eO(log(min(i, n-i)))\u003c/em\u003e, but evaluating\n every prefix in the sequence takes \u003cem\u003eO(n)\u003c/em\u003e due to sharing.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "inits",
          "package": "containers",
          "signature": "Seq a -\u003e Seq (Seq a)",
          "source": "src/Data-Sequence.html#inits",
          "type": "function"
        },
        "index": {
          "description": "Returns sequence of all prefixes of this sequence shortest first For example inits fromList abc fromList fromList fromList fromList ab fromList abc Evaluating the th prefix takes log min n-i but evaluating every prefix in the sequence takes due to sharing",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "inits",
          "normalized": "Seq a-\u003eSeq(Seq a)",
          "package": "containers",
          "signature": "Seq a-\u003eSeq(Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:inits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.  Constructs a sequence by repeated application of a function\n to a seed value.\n\u003c/p\u003e\u003cpre\u003e iterateN n f x = fromList (Prelude.take n (Prelude.iterate f x))\n\u003c/pre\u003e",
          "module": "Data.Sequence",
          "name": "iterateN",
          "package": "containers",
          "signature": "Int -\u003e (a -\u003e a) -\u003e a -\u003e Seq a",
          "source": "src/Data-Sequence.html#iterateN",
          "type": "function"
        },
        "index": {
          "description": "Constructs sequence by repeated application of function to seed value iterateN fromList Prelude.take Prelude.iterate",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "iterateN",
          "normalized": "Int-\u003e(a-\u003ea)-\u003ea-\u003eSeq a",
          "package": "containers",
          "signature": "Int-\u003e(a-\u003ea)-\u003ea-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:iterateN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The number of elements in the sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "length",
          "package": "containers",
          "signature": "Seq a -\u003e Int",
          "source": "src/Data-Sequence.html#length",
          "type": "function"
        },
        "index": {
          "description": "The number of elements in the sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "length",
          "normalized": "Seq a-\u003eInt",
          "package": "containers",
          "signature": "Seq a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:length"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generalization of \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003emapWithIndex\u003c/a\u003e\u003c/code\u003e takes a mapping function\n that also depends on the element's index, and applies it to every\n element in the sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "mapWithIndex",
          "package": "containers",
          "signature": "(Int -\u003e a -\u003e b) -\u003e Seq a -\u003e Seq b",
          "source": "src/Data-Sequence.html#mapWithIndex",
          "type": "function"
        },
        "index": {
          "description": "generalization of fmap mapWithIndex takes mapping function that also depends on the element index and applies it to every element in the sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "mapWithIndex",
          "normalized": "(Int-\u003ea-\u003eb)-\u003eSeq a-\u003eSeq b",
          "package": "containers",
          "partial": "With Index",
          "signature": "(Int-\u003ea-\u003eb)-\u003eSeq a-\u003eSeq b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:mapWithIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Is this the empty sequence?\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "null",
          "package": "containers",
          "signature": "Seq a -\u003e Bool",
          "source": "src/Data-Sequence.html#null",
          "type": "function"
        },
        "index": {
          "description": "Is this the empty sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "null",
          "normalized": "Seq a-\u003eBool",
          "package": "containers",
          "signature": "Seq a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.  The \u003ccode\u003e\u003ca\u003epartition\u003c/a\u003e\u003c/code\u003e function takes a predicate \u003ccode\u003ep\u003c/code\u003e and a\n sequence \u003ccode\u003exs\u003c/code\u003e and returns sequences of those elements which do and\n do not satisfy the predicate.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "partition",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e (Seq a, Seq a)",
          "source": "src/Data-Sequence.html#partition",
          "type": "function"
        },
        "index": {
          "description": "The partition function takes predicate and sequence xs and returns sequences of those elements which do and do not satisfy the predicate",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. \u003ccode\u003ereplicate n x\u003c/code\u003e is a sequence consisting of \u003ccode\u003en\u003c/code\u003e copies of \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "replicate",
          "package": "containers",
          "signature": "Int -\u003e a -\u003e Seq a",
          "source": "src/Data-Sequence.html#replicate",
          "type": "function"
        },
        "index": {
          "description": "log replicate is sequence consisting of copies of",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "replicate",
          "normalized": "Int-\u003ea-\u003eSeq a",
          "package": "containers",
          "signature": "Int-\u003ea-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:replicate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereplicateA\u003c/a\u003e\u003c/code\u003e is an \u003ccode\u003e\u003ca\u003eApplicative\u003c/a\u003e\u003c/code\u003e version of \u003ccode\u003e\u003ca\u003ereplicate\u003c/a\u003e\u003c/code\u003e, and makes\n \u003cem\u003eO(log n)\u003c/em\u003e calls to \u003ccode\u003e\u003ca\u003e\u003c*\u003e\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003epure\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e replicateA n x = sequenceA (replicate n x)\n\u003c/pre\u003e",
          "module": "Data.Sequence",
          "name": "replicateA",
          "package": "containers",
          "signature": "Int -\u003e f a -\u003e f (Seq a)",
          "source": "src/Data-Sequence.html#replicateA",
          "type": "function"
        },
        "index": {
          "description": "replicateA is an Applicative version of replicate and makes log calls to and pure replicateA sequenceA replicate",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "replicateA",
          "normalized": "Int-\u003ea b-\u003ea(Seq b)",
          "package": "containers",
          "signature": "Int-\u003ef a-\u003ef(Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:replicateA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003ereplicateM\u003c/a\u003e\u003c/code\u003e is a sequence counterpart of \u003ccode\u003e\u003ca\u003ereplicateM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cpre\u003e replicateM n x = sequence (replicate n x)\n\u003c/pre\u003e",
          "module": "Data.Sequence",
          "name": "replicateM",
          "package": "containers",
          "signature": "Int -\u003e m a -\u003e m (Seq a)",
          "source": "src/Data-Sequence.html#replicateM",
          "type": "function"
        },
        "index": {
          "description": "replicateM is sequence counterpart of replicateM replicateM sequence replicate",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "replicateM",
          "normalized": "Int-\u003ea b-\u003ea(Seq b)",
          "package": "containers",
          "signature": "Int-\u003em a-\u003em(Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:replicateM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The reverse of a sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "reverse",
          "package": "containers",
          "signature": "Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#reverse",
          "type": "function"
        },
        "index": {
          "description": "The reverse of sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "reverse",
          "normalized": "Seq a-\u003eSeq a",
          "package": "containers",
          "signature": "Seq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:reverse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e is similar to \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e, but returns a sequence of reduced\n values from the left:\n\u003c/p\u003e\u003cpre\u003e scanl f z (fromList [x1, x2, ...]) = fromList [z, z `f` x1, (z `f` x1) `f` x2, ...]\n\u003c/pre\u003e",
          "module": "Data.Sequence",
          "name": "scanl",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Seq b -\u003e Seq a",
          "source": "src/Data-Sequence.html#scanl",
          "type": "function"
        },
        "index": {
          "description": "scanl is similar to foldl but returns sequence of reduced values from the left scanl fromList x1 x2 fromList x1 x1 x2",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "scanl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eSeq b-\u003eSeq a",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eSeq b-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:scanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanl1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e that has no starting value argument:\n\u003c/p\u003e\u003cpre\u003e scanl1 f (fromList [x1, x2, ...]) = fromList [x1, x1 `f` x2, ...]\n\u003c/pre\u003e",
          "module": "Data.Sequence",
          "name": "scanl1",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#scanl1",
          "type": "function"
        },
        "index": {
          "description": "scanl1 is variant of scanl that has no starting value argument scanl1 fromList x1 x2 fromList x1 x1 x2",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "scanl1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "(a-\u003ea-\u003ea)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:scanl1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e is the right-to-left dual of \u003ccode\u003e\u003ca\u003escanl\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "scanr",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Seq a -\u003e Seq b",
          "source": "src/Data-Sequence.html#scanr",
          "type": "function"
        },
        "index": {
          "description": "scanr is the right-to-left dual of scanl",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "scanr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eSeq a-\u003eSeq b",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eSeq a-\u003eSeq b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:scanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003escanr1\u003c/a\u003e\u003c/code\u003e is a variant of \u003ccode\u003e\u003ca\u003escanr\u003c/a\u003e\u003c/code\u003e that has no starting value argument.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "scanr1",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e a) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#scanr1",
          "type": "function"
        },
        "index": {
          "description": "scanr1 is variant of scanr that has no starting value argument",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "scanr1",
          "normalized": "(a-\u003ea-\u003ea)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "(a-\u003ea-\u003ea)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:scanr1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. A singleton sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "singleton",
          "package": "containers",
          "signature": "a -\u003e Seq a",
          "source": "src/Data-Sequence.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "singleton sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "singleton",
          "normalized": "a-\u003eSeq a",
          "package": "containers",
          "signature": "a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e sorts the specified \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e by the natural\n ordering of its elements.  The sort is stable.\n If stability is not required, \u003ccode\u003e\u003ca\u003eunstableSort\u003c/a\u003e\u003c/code\u003e can be considerably\n faster, and in particular uses less memory.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "sort",
          "package": "containers",
          "signature": "Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#sort",
          "type": "function"
        },
        "index": {
          "description": "log sort sorts the specified Seq by the natural ordering of its elements The sort is stable If stability is not required unstableSort can be considerably faster and in particular uses less memory",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "sort",
          "normalized": "Seq a-\u003eSeq a",
          "package": "containers",
          "signature": "Seq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:sort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e sorts the specified \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e according to the\n specified comparator.  The sort is stable.\n If stability is not required, \u003ccode\u003e\u003ca\u003eunstableSortBy\u003c/a\u003e\u003c/code\u003e can be considerably\n faster, and in particular uses less memory.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "sortBy",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#sortBy",
          "type": "function"
        },
        "index": {
          "description": "log sortBy sorts the specified Seq according to the specified comparator The sort is stable If stability is not required unstableSortBy can be considerably faster and in particular uses less memory",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "sortBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "partial": "By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:sortBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the prefix length.  \u003ccode\u003e\u003ca\u003espanl\u003c/a\u003e\u003c/code\u003e, applied to\n a predicate \u003ccode\u003ep\u003c/code\u003e and a sequence \u003ccode\u003exs\u003c/code\u003e, returns a pair whose first\n element is the longest prefix (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e and the second element is the remainder of the sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "spanl",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e (Seq a, Seq a)",
          "source": "src/Data-Sequence.html#spanl",
          "type": "function"
        },
        "index": {
          "description": "where is the prefix length spanl applied to predicate and sequence xs returns pair whose first element is the longest prefix possibly empty of xs of elements that satisfy and the second element is the remainder of the sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "spanl",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:spanl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the suffix length.  \u003ccode\u003e\u003ca\u003espanr\u003c/a\u003e\u003c/code\u003e, applied to a\n predicate \u003ccode\u003ep\u003c/code\u003e and a sequence \u003ccode\u003exs\u003c/code\u003e, returns a pair whose \u003cem\u003efirst\u003c/em\u003e element\n is the longest \u003cem\u003esuffix\u003c/em\u003e (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that\n satisfy \u003ccode\u003ep\u003c/code\u003e and the second element is the remainder of the sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "spanr",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e (Seq a, Seq a)",
          "source": "src/Data-Sequence.html#spanr",
          "type": "function"
        },
        "index": {
          "description": "where is the suffix length spanr applied to predicate and sequence xs returns pair whose first element is the longest suffix possibly empty of xs of elements that satisfy and the second element is the remainder of the sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "spanr",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003e(Seq a,Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:spanr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(i,n-i)))\u003c/em\u003e. Split a sequence at a given position.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003esplitAt\u003c/a\u003e\u003c/code\u003e i s = (\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e i s, \u003ccode\u003e\u003ca\u003edrop\u003c/a\u003e\u003c/code\u003e i s)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "splitAt",
          "package": "containers",
          "signature": "Int -\u003e Seq a -\u003e (Seq a, Seq a)",
          "source": "src/Data-Sequence.html#splitAt",
          "type": "function"
        },
        "index": {
          "description": "log min n-i Split sequence at given position splitAt take drop",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "splitAt",
          "normalized": "Int-\u003eSeq a-\u003e(Seq a,Seq a)",
          "package": "containers",
          "partial": "At",
          "signature": "Int-\u003eSeq a-\u003e(Seq a,Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:splitAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e.  Returns a sequence of all suffixes of this sequence,\n longest first.  For example,\n\u003c/p\u003e\u003cpre\u003e tails (fromList \"abc\") = fromList [fromList \"abc\", fromList \"bc\", fromList \"c\", fromList \"\"]\n\u003c/pre\u003e\u003cp\u003eEvaluating the \u003cem\u003ei\u003c/em\u003eth suffix takes \u003cem\u003eO(log(min(i, n-i)))\u003c/em\u003e, but evaluating\n every suffix in the sequence takes \u003cem\u003eO(n)\u003c/em\u003e due to sharing.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "tails",
          "package": "containers",
          "signature": "Seq a -\u003e Seq (Seq a)",
          "source": "src/Data-Sequence.html#tails",
          "type": "function"
        },
        "index": {
          "description": "Returns sequence of all suffixes of this sequence longest first For example tails fromList abc fromList fromList abc fromList bc fromList fromList Evaluating the th suffix takes log min n-i but evaluating every suffix in the sequence takes due to sharing",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "tails",
          "normalized": "Seq a-\u003eSeq(Seq a)",
          "package": "containers",
          "signature": "Seq a-\u003eSeq(Seq a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:tails"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(i,n-i)))\u003c/em\u003e. The first \u003ccode\u003ei\u003c/code\u003e elements of a sequence.\n If \u003ccode\u003ei\u003c/code\u003e is negative, \u003ccode\u003e\u003ccode\u003e\u003ca\u003etake\u003c/a\u003e\u003c/code\u003e i s\u003c/code\u003e yields the empty sequence.\n If the sequence contains fewer than \u003ccode\u003ei\u003c/code\u003e elements, the whole sequence\n is returned.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "take",
          "package": "containers",
          "signature": "Int -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#take",
          "type": "function"
        },
        "index": {
          "description": "log min n-i The first elements of sequence If is negative take yields the empty sequence If the sequence contains fewer than elements the whole sequence is returned",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "take",
          "normalized": "Int-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "Int-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:take"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the prefix length.  \u003ccode\u003e\u003ca\u003etakeWhileL\u003c/a\u003e\u003c/code\u003e, applied\n to a predicate \u003ccode\u003ep\u003c/code\u003e and a sequence \u003ccode\u003exs\u003c/code\u003e, returns the longest prefix\n (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that satisfy \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "takeWhileL",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#takeWhileL",
          "type": "function"
        },
        "index": {
          "description": "where is the prefix length takeWhileL applied to predicate and sequence xs returns the longest prefix possibly empty of xs of elements that satisfy",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "takeWhileL",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:takeWhileL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(i)\u003c/em\u003e where \u003cem\u003ei\u003c/em\u003e is the suffix length.  \u003ccode\u003e\u003ca\u003etakeWhileR\u003c/a\u003e\u003c/code\u003e, applied\n to a predicate \u003ccode\u003ep\u003c/code\u003e and a sequence \u003ccode\u003exs\u003c/code\u003e, returns the longest suffix\n (possibly empty) of \u003ccode\u003exs\u003c/code\u003e of elements that satisfy \u003ccode\u003ep\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003etakeWhileR\u003c/a\u003e\u003c/code\u003e p xs\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003etakeWhileL\u003c/a\u003e\u003c/code\u003e p (\u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e xs))\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "takeWhileR",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#takeWhileR",
          "type": "function"
        },
        "index": {
          "description": "where is the suffix length takeWhileR applied to predicate and sequence xs returns the longest suffix possibly empty of xs of elements that satisfy takeWhileR xs is equivalent to reverse takeWhileL reverse xs",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "takeWhileR",
          "normalized": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "partial": "While",
          "signature": "(a-\u003eBool)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:takeWhileR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunfoldl\u003c/a\u003e\u003c/code\u003e f x\u003c/code\u003e is equivalent to \u003ccode\u003e\u003ccode\u003e\u003ca\u003ereverse\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eunfoldr\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e swap . f) x)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "unfoldl",
          "package": "containers",
          "signature": "(b -\u003e Maybe (b, a)) -\u003e b -\u003e Seq a",
          "source": "src/Data-Sequence.html#unfoldl",
          "type": "function"
        },
        "index": {
          "description": "unfoldl is equivalent to reverse unfoldr fmap swap",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "unfoldl",
          "normalized": "(a-\u003eMaybe(a,b))-\u003ea-\u003eSeq b",
          "package": "containers",
          "signature": "(b-\u003eMaybe(b,a))-\u003eb-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:unfoldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilds a sequence from a seed value.  Takes time linear in the\n number of generated elements.  \u003cem\u003eWARNING:\u003c/em\u003e If the number of generated\n elements is infinite, this method will not terminate.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "unfoldr",
          "package": "containers",
          "signature": "(b -\u003e Maybe (a, b)) -\u003e b -\u003e Seq a",
          "source": "src/Data-Sequence.html#unfoldr",
          "type": "function"
        },
        "index": {
          "description": "Builds sequence from seed value Takes time linear in the number of generated elements WARNING If the number of generated elements is infinite this method will not terminate",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "unfoldr",
          "normalized": "(a-\u003eMaybe(b,a))-\u003ea-\u003eSeq b",
          "package": "containers",
          "signature": "(b-\u003eMaybe(a,b))-\u003eb-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:unfoldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003eunstableSort\u003c/a\u003e\u003c/code\u003e sorts the specified \u003ccode\u003e\u003ca\u003eSeq\u003c/a\u003e\u003c/code\u003e by\n the natural ordering of its elements, but the sort is not stable.\n This algorithm is frequently faster and uses less memory than \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e,\n and performs extremely well -- frequently twice as fast as \u003ccode\u003e\u003ca\u003esort\u003c/a\u003e\u003c/code\u003e --\n when the sequence is already nearly sorted.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "unstableSort",
          "package": "containers",
          "signature": "Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#unstableSort",
          "type": "function"
        },
        "index": {
          "description": "log unstableSort sorts the specified Seq by the natural ordering of its elements but the sort is not stable This algorithm is frequently faster and uses less memory than sort and performs extremely well frequently twice as fast as sort when the sequence is already nearly sorted",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "unstableSort",
          "normalized": "Seq a-\u003eSeq a",
          "package": "containers",
          "partial": "Sort",
          "signature": "Seq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:unstableSort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n log n)\u003c/em\u003e.  A generalization of \u003ccode\u003e\u003ca\u003eunstableSort\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eunstableSortBy\u003c/a\u003e\u003c/code\u003e\n takes an arbitrary comparator and sorts the specified sequence.\n The sort is not stable.  This algorithm is frequently faster and\n uses less memory than \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e, and performs extremely well --\n frequently twice as fast as \u003ccode\u003e\u003ca\u003esortBy\u003c/a\u003e\u003c/code\u003e -- when the sequence is already\n nearly sorted.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "unstableSortBy",
          "package": "containers",
          "signature": "(a -\u003e a -\u003e Ordering) -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#unstableSortBy",
          "type": "function"
        },
        "index": {
          "description": "log generalization of unstableSort unstableSortBy takes an arbitrary comparator and sorts the specified sequence The sort is not stable This algorithm is frequently faster and uses less memory than sortBy and performs extremely well frequently twice as fast as sortBy when the sequence is already nearly sorted",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "unstableSortBy",
          "normalized": "(a-\u003ea-\u003eOrdering)-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "partial": "Sort By",
          "signature": "(a-\u003ea-\u003eOrdering)-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:unstableSortBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log(min(i,n-i)))\u003c/em\u003e. Replace the element at the specified position.\n If the position is out of range, the original sequence is returned.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "update",
          "package": "containers",
          "signature": "Int -\u003e a -\u003e Seq a -\u003e Seq a",
          "source": "src/Data-Sequence.html#update",
          "type": "function"
        },
        "index": {
          "description": "log min n-i Replace the element at the specified position If the position is out of range the original sequence is returned",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "update",
          "normalized": "Int-\u003ea-\u003eSeq a-\u003eSeq a",
          "package": "containers",
          "signature": "Int-\u003ea-\u003eSeq a-\u003eSeq a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:update"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Analyse the left end of a sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "viewl",
          "package": "containers",
          "signature": "Seq a -\u003e ViewL a",
          "source": "src/Data-Sequence.html#viewl",
          "type": "function"
        },
        "index": {
          "description": "Analyse the left end of sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "viewl",
          "normalized": "Seq a-\u003eViewL a",
          "package": "containers",
          "signature": "Seq a-\u003eViewL a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:viewl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Analyse the right end of a sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "viewr",
          "package": "containers",
          "signature": "Seq a -\u003e ViewR a",
          "source": "src/Data-Sequence.html#viewr",
          "type": "function"
        },
        "index": {
          "description": "Analyse the right end of sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "viewr",
          "normalized": "Seq a-\u003eViewR a",
          "package": "containers",
          "signature": "Seq a-\u003eViewR a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:viewr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n1,n2))\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e takes two sequences and returns a sequence\n of corresponding pairs.  If one input is short, excess elements are\n discarded from the right end of the longer sequence.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "zip",
          "package": "containers",
          "signature": "Seq a -\u003e Seq b -\u003e Seq (a, b)",
          "source": "src/Data-Sequence.html#zip",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 zip takes two sequences and returns sequence of corresponding pairs If one input is short excess elements are discarded from the right end of the longer sequence",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "zip",
          "normalized": "Seq a-\u003eSeq b-\u003eSeq(a,b)",
          "package": "containers",
          "signature": "Seq a-\u003eSeq b-\u003eSeq(a,b)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:zip"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n1,n2,n3))\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003ezip3\u003c/a\u003e\u003c/code\u003e takes three sequences and returns a\n sequence of triples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "zip3",
          "package": "containers",
          "signature": "Seq a -\u003e Seq b -\u003e Seq c -\u003e Seq (a, b, c)",
          "source": "src/Data-Sequence.html#zip3",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 n3 zip3 takes three sequences and returns sequence of triples analogous to zip",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "zip3",
          "normalized": "Seq a-\u003eSeq b-\u003eSeq c-\u003eSeq(a,b,c)",
          "package": "containers",
          "signature": "Seq a-\u003eSeq b-\u003eSeq c-\u003eSeq(a,b,c)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:zip3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n1,n2,n3,n4))\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003ezip4\u003c/a\u003e\u003c/code\u003e takes four sequences and returns a\n sequence of quadruples, analogous to \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "zip4",
          "package": "containers",
          "signature": "Seq a -\u003e Seq b -\u003e Seq c -\u003e Seq d -\u003e Seq (a, b, c, d)",
          "source": "src/Data-Sequence.html#zip4",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 n3 n4 zip4 takes four sequences and returns sequence of quadruples analogous to zip",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "zip4",
          "normalized": "Seq a-\u003eSeq b-\u003eSeq c-\u003eSeq d-\u003eSeq(a,b,c,d)",
          "package": "containers",
          "signature": "Seq a-\u003eSeq b-\u003eSeq c-\u003eSeq d-\u003eSeq(a,b,c,d)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:zip4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n1,n2))\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e generalizes \u003ccode\u003e\u003ca\u003ezip\u003c/a\u003e\u003c/code\u003e by zipping with the\n function given as the first argument, instead of a tupling function.\n For example, \u003ccode\u003ezipWith (+)\u003c/code\u003e is applied to two sequences to take the\n sequence of corresponding sums.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "zipWith",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c) -\u003e Seq a -\u003e Seq b -\u003e Seq c",
          "source": "src/Data-Sequence.html#zipWith",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 zipWith generalizes zip by zipping with the function given as the first argument instead of tupling function For example zipWith is applied to two sequences to take the sequence of corresponding sums",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "zipWith",
          "normalized": "(a-\u003eb-\u003ec)-\u003eSeq a-\u003eSeq b-\u003eSeq c",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec)-\u003eSeq a-\u003eSeq b-\u003eSeq c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:zipWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n1,n2,n3))\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003ezipWith3\u003c/a\u003e\u003c/code\u003e takes a function which combines\n three elements, as well as three sequences and returns a sequence of\n their point-wise combinations, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "zipWith3",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c -\u003e d) -\u003e Seq a -\u003e Seq b -\u003e Seq c -\u003e Seq d",
          "source": "src/Data-Sequence.html#zipWith3",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 n3 zipWith3 takes function which combines three elements as well as three sequences and returns sequence of their point-wise combinations analogous to zipWith",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "zipWith3",
          "normalized": "(a-\u003eb-\u003ec-\u003ed)-\u003eSeq a-\u003eSeq b-\u003eSeq c-\u003eSeq d",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed)-\u003eSeq a-\u003eSeq b-\u003eSeq c-\u003eSeq d",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:zipWith3"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(min(n1,n2,n3,n4))\u003c/em\u003e.  \u003ccode\u003e\u003ca\u003ezipWith4\u003c/a\u003e\u003c/code\u003e takes a function which combines\n four elements, as well as four sequences and returns a sequence of\n their point-wise combinations, analogous to \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Sequence",
          "name": "zipWith4",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e c -\u003e d -\u003e e) -\u003e Seq a -\u003e Seq b -\u003e Seq c -\u003e Seq d -\u003e Seq e",
          "source": "src/Data-Sequence.html#zipWith4",
          "type": "function"
        },
        "index": {
          "description": "min n1 n2 n3 n4 zipWith4 takes function which combines four elements as well as four sequences and returns sequence of their point-wise combinations analogous to zipWith",
          "hierarchy": "Data Sequence",
          "module": "Data.Sequence",
          "name": "zipWith4",
          "normalized": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eSeq a-\u003eSeq b-\u003eSeq c-\u003eSeq d-\u003eSeq e",
          "package": "containers",
          "partial": "With",
          "signature": "(a-\u003eb-\u003ec-\u003ed-\u003ee)-\u003eSeq a-\u003eSeq b-\u003eSeq c-\u003eSeq d-\u003eSeq e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Sequence.html#v:zipWith4"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn efficient implementation of sets.\n\u003c/p\u003e\u003cp\u003eThese modules are intended to be imported qualified, to avoid name\n clashes with Prelude functions, e.g.\n\u003c/p\u003e\u003cpre\u003e  import Data.Set (Set)\n  import qualified Data.Set as Set\n\u003c/pre\u003e\u003cp\u003eThe implementation of \u003ccode\u003e\u003ca\u003eSet\u003c/a\u003e\u003c/code\u003e is based on \u003cem\u003esize balanced\u003c/em\u003e binary trees (or\n trees of \u003cem\u003ebounded balance\u003c/em\u003e) as described by:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Stephen Adams, \"\u003cem\u003eEfficient sets: a balancing act\u003c/em\u003e\",\n      Journal of Functional Programming 3(4):553-562, October 1993,\n      \u003ca\u003ehttp://www.swiss.ai.mit.edu/~adams/BB/\u003c/a\u003e.\n\u003c/li\u003e\u003cli\u003e J. Nievergelt and E.M. Reingold,\n      \"\u003cem\u003eBinary search trees of bounded balance\u003c/em\u003e\",\n      SIAM journal of computing 2(1), March 1973.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eNote that the implementation is \u003cem\u003eleft-biased\u003c/em\u003e -- the elements of a\n first argument are always preferred to the second, for example in\n \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003einsert\u003c/a\u003e\u003c/code\u003e.  Of course, left-biasing can only be observed\n when equality is an equivalence relation instead of structural\n equality.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Set",
          "name": "Set",
          "package": "containers",
          "source": "src/Data-Set.html",
          "type": "module"
        },
        "index": {
          "description": "An efficient implementation of sets These modules are intended to be imported qualified to avoid name clashes with Prelude functions e.g import Data.Set Set import qualified Data.Set as Set The implementation of Set is based on size balanced binary trees or trees of bounded balance as described by Stephen Adams Efficient sets balancing act Journal of Functional Programming October http www.swiss.ai.mit.edu adams BB Nievergelt and E.M Reingold Binary search trees of bounded balance SIAM journal of computing March Note that the implementation is left-biased the elements of first argument are always preferred to the second for example in union or insert Of course left-biasing can only be observed when equality is an equivalence relation instead of structural equality",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "Set",
          "package": "containers",
          "partial": "Set",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of values \u003ccode\u003ea\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "Set",
          "package": "containers",
          "source": "src/Data-Set-Base.html#Set",
          "type": "data"
        },
        "index": {
          "description": "set of values",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "Set",
          "package": "containers",
          "partial": "Set",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#t:Set"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. See \u003ccode\u003e\u003ca\u003edifference\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "(\\\\)",
          "package": "containers",
          "signature": "Set a -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#%5C%5C",
          "type": "function"
        },
        "index": {
          "description": "See difference",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "(\\\\) \\\\",
          "normalized": "Set a-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "Set a-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:-92--92-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete an element from a set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "delete",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#delete",
          "type": "function"
        },
        "index": {
          "description": "log Delete an element from set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "delete",
          "normalized": "a-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "a-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:delete"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete the element at \u003cem\u003eindex\u003c/em\u003e, i.e. by its zero-based index in\n the sorted sequence of elements. If the \u003cem\u003eindex\u003c/em\u003e is out of range (less than zero,\n greater or equal to \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the set), \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e\u003cpre\u003e deleteAt 0    (fromList [5,3]) == singleton 5\n deleteAt 1    (fromList [5,3]) == singleton 3\n deleteAt 2    (fromList [5,3])    Error: index out of range\n deleteAt (-1) (fromList [5,3])    Error: index out of range\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "deleteAt",
          "package": "containers",
          "signature": "Int -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#deleteAt",
          "type": "function"
        },
        "index": {
          "description": "log Delete the element at index i.e by its zero-based index in the sorted sequence of elements If the index is out of range less than zero greater or equal to size of the set error is called deleteAt fromList singleton deleteAt fromList singleton deleteAt fromList Error index out of range deleteAt fromList Error index out of range",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "deleteAt",
          "normalized": "Int-\u003eSet a-\u003eSet a",
          "package": "containers",
          "partial": "At",
          "signature": "Int-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:deleteAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete and find the maximal element.\n\u003c/p\u003e\u003cpre\u003e deleteFindMax set = (findMax set, deleteMax set)\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "deleteFindMax",
          "package": "containers",
          "signature": "Set a -\u003e (a, Set a)",
          "source": "src/Data-Set-Base.html#deleteFindMax",
          "type": "function"
        },
        "index": {
          "description": "log Delete and find the maximal element deleteFindMax set findMax set deleteMax set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "deleteFindMax",
          "normalized": "Set a-\u003e(a,Set a)",
          "package": "containers",
          "partial": "Find Max",
          "signature": "Set a-\u003e(a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:deleteFindMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete and find the minimal element.\n\u003c/p\u003e\u003cpre\u003e deleteFindMin set = (findMin set, deleteMin set)\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "deleteFindMin",
          "package": "containers",
          "signature": "Set a -\u003e (a, Set a)",
          "source": "src/Data-Set-Base.html#deleteFindMin",
          "type": "function"
        },
        "index": {
          "description": "log Delete and find the minimal element deleteFindMin set findMin set deleteMin set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "deleteFindMin",
          "normalized": "Set a-\u003e(a,Set a)",
          "package": "containers",
          "partial": "Find Min",
          "signature": "Set a-\u003e(a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:deleteFindMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete the maximal element. Returns an empty set if the set is empty.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "deleteMax",
          "package": "containers",
          "signature": "Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#deleteMax",
          "type": "function"
        },
        "index": {
          "description": "log Delete the maximal element Returns an empty set if the set is empty",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "deleteMax",
          "normalized": "Set a-\u003eSet a",
          "package": "containers",
          "partial": "Max",
          "signature": "Set a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:deleteMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Delete the minimal element. Returns an empty set if the set is empty.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "deleteMin",
          "package": "containers",
          "signature": "Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#deleteMin",
          "type": "function"
        },
        "index": {
          "description": "log Delete the minimal element Returns an empty set if the set is empty",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "deleteMin",
          "normalized": "Set a-\u003eSet a",
          "package": "containers",
          "partial": "Min",
          "signature": "Set a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:deleteMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Difference of two sets.\n The implementation uses an efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "difference",
          "package": "containers",
          "signature": "Set a -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#difference",
          "type": "function"
        },
        "index": {
          "description": "Difference of two sets The implementation uses an efficient hedge algorithm comparable with hedge-union",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "difference",
          "normalized": "Set a-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "Set a-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:difference"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieve an element by its \u003cem\u003eindex\u003c/em\u003e, i.e. by its zero-based\n index in the sorted sequence of elements. If the \u003cem\u003eindex\u003c/em\u003e is out of range (less\n than zero, greater or equal to \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the set), \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e is called.\n\u003c/p\u003e\u003cpre\u003e elemAt 0 (fromList [5,3]) == 3\n elemAt 1 (fromList [5,3]) == 5\n elemAt 2 (fromList [5,3])    Error: index out of range\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "elemAt",
          "package": "containers",
          "signature": "Int -\u003e Set a -\u003e a",
          "source": "src/Data-Set-Base.html#elemAt",
          "type": "function"
        },
        "index": {
          "description": "log Retrieve an element by its index i.e by its zero-based index in the sorted sequence of elements If the index is out of range less than zero greater or equal to size of the set error is called elemAt fromList elemAt fromList elemAt fromList Error index out of range",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "elemAt",
          "normalized": "Int-\u003eSet a-\u003ea",
          "package": "containers",
          "partial": "At",
          "signature": "Int-\u003eSet a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:elemAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. An alias of \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e. The elements of a set in ascending order.\n Subject to list fusion.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "elems",
          "package": "containers",
          "signature": "Set a -\u003e [a]",
          "source": "src/Data-Set-Base.html#elems",
          "type": "function"
        },
        "index": {
          "description": "An alias of toAscList The elements of set in ascending order Subject to list fusion",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "elems",
          "normalized": "Set a-\u003e[a]",
          "package": "containers",
          "signature": "Set a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:elems"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The empty set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "empty",
          "package": "containers",
          "signature": "Set a",
          "source": "src/Data-Set-Base.html#empty",
          "type": "function"
        },
        "index": {
          "description": "The empty set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "empty",
          "package": "containers",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Filter all elements that satisfy the predicate.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "filter",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#filter",
          "type": "function"
        },
        "index": {
          "description": "Filter all elements that satisfy the predicate",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "filter",
          "normalized": "(a-\u003eBool)-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:filter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Return the \u003cem\u003eindex\u003c/em\u003e of an element, which is its zero-based\n index in the sorted sequence of elements. The index is a number from \u003cem\u003e0\u003c/em\u003e up\n to, but not including, the \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the set. Calls \u003ccode\u003e\u003ca\u003eerror\u003c/a\u003e\u003c/code\u003e when the element\n is not a \u003ccode\u003e\u003ca\u003emember\u003c/a\u003e\u003c/code\u003e of the set.\n\u003c/p\u003e\u003cpre\u003e findIndex 2 (fromList [5,3])    Error: element is not in the set\n findIndex 3 (fromList [5,3]) == 0\n findIndex 5 (fromList [5,3]) == 1\n findIndex 6 (fromList [5,3])    Error: element is not in the set\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "findIndex",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Int",
          "source": "src/Data-Set-Base.html#findIndex",
          "type": "function"
        },
        "index": {
          "description": "log Return the index of an element which is its zero-based index in the sorted sequence of elements The index is number from up to but not including the size of the set Calls error when the element is not member of the set findIndex fromList Error element is not in the set findIndex fromList findIndex fromList findIndex fromList Error element is not in the set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "findIndex",
          "normalized": "a-\u003eSet a-\u003eInt",
          "package": "containers",
          "partial": "Index",
          "signature": "a-\u003eSet a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:findIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The maximal element of a set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "findMax",
          "package": "containers",
          "signature": "Set a -\u003e a",
          "source": "src/Data-Set-Base.html#findMax",
          "type": "function"
        },
        "index": {
          "description": "log The maximal element of set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "findMax",
          "normalized": "Set a-\u003ea",
          "package": "containers",
          "partial": "Max",
          "signature": "Set a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:findMax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The minimal element of a set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "findMin",
          "package": "containers",
          "signature": "Set a -\u003e a",
          "source": "src/Data-Set-Base.html#findMin",
          "type": "function"
        },
        "index": {
          "description": "log The minimal element of set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "findMin",
          "normalized": "Set a-\u003ea",
          "package": "containers",
          "partial": "Min",
          "signature": "Set a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:findMin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the elements in the set using the given right-associative\n binary operator. This function is an equivalent of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e and is present\n for compatibility only.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003ePlease note that fold will be deprecated in the future and removed.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "fold",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Set a -\u003e b",
          "source": "src/Data-Set-Base.html#fold",
          "type": "function"
        },
        "index": {
          "description": "Fold the elements in the set using the given right-associative binary operator This function is an equivalent of foldr and is present for compatibility only Please note that fold will be deprecated in the future and removed",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "fold",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eSet a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eSet a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:fold"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the elements in the set using the given left-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e toDescList set = foldl (flip (:)) [] set\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "foldl",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Set b -\u003e a",
          "source": "src/Data-Set-Base.html#foldl",
          "type": "function"
        },
        "index": {
          "description": "Fold the elements in the set using the given left-associative binary operator such that foldl foldl toAscList For example toDescList set foldl flip set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "foldl",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eSet b-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eSet b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:foldl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "foldl'",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e a) -\u003e a -\u003e Set b -\u003e a",
          "source": "src/Data-Set-Base.html#foldl%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of foldl Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "foldl'",
          "normalized": "(a-\u003eb-\u003ea)-\u003ea-\u003eSet b-\u003ea",
          "package": "containers",
          "signature": "(a-\u003eb-\u003ea)-\u003ea-\u003eSet b-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:foldl-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Fold the elements in the set using the given right-associative\n binary operator, such that \u003ccode\u003e\u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z == \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e f z . \u003ccode\u003e\u003ca\u003etoAscList\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eFor example,\n\u003c/p\u003e\u003cpre\u003e toAscList set = foldr (:) [] set\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "foldr",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Set a -\u003e b",
          "source": "src/Data-Set-Base.html#foldr",
          "type": "function"
        },
        "index": {
          "description": "Fold the elements in the set using the given right-associative binary operator such that foldr foldr toAscList For example toAscList set foldr set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "foldr",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eSet a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eSet a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:foldr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. A strict version of \u003ccode\u003e\u003ca\u003efoldr\u003c/a\u003e\u003c/code\u003e. Each application of the operator is\n evaluated before using the result in the next application. This\n function is strict in the starting value.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "foldr'",
          "package": "containers",
          "signature": "(a -\u003e b -\u003e b) -\u003e b -\u003e Set a -\u003e b",
          "source": "src/Data-Set-Base.html#foldr%27",
          "type": "function"
        },
        "index": {
          "description": "strict version of foldr Each application of the operator is evaluated before using the result in the next application This function is strict in the starting value",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "foldr'",
          "normalized": "(a-\u003eb-\u003eb)-\u003eb-\u003eSet a-\u003eb",
          "package": "containers",
          "signature": "(a-\u003eb-\u003eb)-\u003eb-\u003eSet a-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:foldr-39-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a set from an ascending list in linear time.\n \u003cem\u003eThe precondition (input list is ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "fromAscList",
          "package": "containers",
          "signature": "[a] -\u003e Set a",
          "source": "src/Data-Set-Base.html#fromAscList",
          "type": "function"
        },
        "index": {
          "description": "Build set from an ascending list in linear time The precondition input list is ascending is not checked",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "fromAscList",
          "normalized": "[a]-\u003eSet a",
          "package": "containers",
          "partial": "Asc List",
          "signature": "[a]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:fromAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Build a set from an ascending list of distinct elements in linear time.\n \u003cem\u003eThe precondition (input list is strictly ascending) is not checked.\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "fromDistinctAscList",
          "package": "containers",
          "signature": "[a] -\u003e Set a",
          "source": "src/Data-Set-Base.html#fromDistinctAscList",
          "type": "function"
        },
        "index": {
          "description": "Build set from an ascending list of distinct elements in linear time The precondition input list is strictly ascending is not checked",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "fromDistinctAscList",
          "normalized": "[a]-\u003eSet a",
          "package": "containers",
          "partial": "Distinct Asc List",
          "signature": "[a]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:fromDistinctAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e. Create a set from a list of elements.\n\u003c/p\u003e\u003cp\u003eIf the elemens are ordered, linear-time implementation is used,\n with the performance equal to \u003ccode\u003e\u003ca\u003efromDistinctAscList\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "fromList",
          "package": "containers",
          "signature": "[a] -\u003e Set a",
          "source": "src/Data-Set-Base.html#fromList",
          "type": "function"
        },
        "index": {
          "description": "log Create set from list of elements If the elemens are ordered linear-time implementation is used with the performance equal to fromDistinctAscList",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "fromList",
          "normalized": "[a]-\u003eSet a",
          "package": "containers",
          "partial": "List",
          "signature": "[a]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:fromList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Insert an element in a set.\n If the set already contains an element equal to the given value,\n it is replaced with the new value.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "insert",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#insert",
          "type": "function"
        },
        "index": {
          "description": "log Insert an element in set If the set already contains an element equal to the given value it is replaced with the new value",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "insert",
          "normalized": "a-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "a-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:insert"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The intersection of two sets.  The implementation uses an\n efficient \u003cem\u003ehedge\u003c/em\u003e algorithm comparable with \u003cem\u003ehedge-union\u003c/em\u003e.  Elements of the\n result come from the first set, so for example\n\u003c/p\u003e\u003cpre\u003e import qualified Data.Set as S\n data AB = A | B deriving Show\n instance Ord AB where compare _ _ = EQ\n instance Eq AB where _ == _ = True\n main = print (S.singleton A `S.intersection` S.singleton B,\n               S.singleton B `S.intersection` S.singleton A)\n\u003c/pre\u003e\u003cp\u003eprints \u003ccode\u003e(fromList [A],fromList [B])\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "intersection",
          "package": "containers",
          "signature": "Set a -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#intersection",
          "type": "function"
        },
        "index": {
          "description": "The intersection of two sets The implementation uses an efficient hedge algorithm comparable with hedge-union Elements of the result come from the first set so for example import qualified Data.Set as data AB deriving Show instance Ord AB where compare EQ instance Eq AB where True main print S.singleton S.intersection S.singleton S.singleton S.intersection S.singleton prints fromList fromList",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "intersection",
          "normalized": "Set a-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "Set a-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:intersection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a proper subset? (ie. a subset but not equal).\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "isProperSubsetOf",
          "package": "containers",
          "signature": "Set a -\u003e Set a -\u003e Bool",
          "source": "src/Data-Set-Base.html#isProperSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "Is this proper subset ie subset but not equal",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "isProperSubsetOf",
          "normalized": "Set a-\u003eSet a-\u003eBool",
          "package": "containers",
          "partial": "Proper Subset Of",
          "signature": "Set a-\u003eSet a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:isProperSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. Is this a subset?\n \u003ccode\u003e(s1 \u003ccode\u003e\u003ca\u003eisSubsetOf\u003c/a\u003e\u003c/code\u003e s2)\u003c/code\u003e tells whether \u003ccode\u003es1\u003c/code\u003e is a subset of \u003ccode\u003es2\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "isSubsetOf",
          "package": "containers",
          "signature": "Set a -\u003e Set a -\u003e Bool",
          "source": "src/Data-Set-Base.html#isSubsetOf",
          "type": "function"
        },
        "index": {
          "description": "Is this subset s1 isSubsetOf s2 tells whether s1 is subset of s2",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "isSubsetOf",
          "normalized": "Set a-\u003eSet a-\u003eBool",
          "package": "containers",
          "partial": "Subset Of",
          "signature": "Set a-\u003eSet a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:isSubsetOf"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest element greater or equal to the given one.\n\u003c/p\u003e\u003cpre\u003e lookupGE 3 (fromList [3, 5]) == Just 3\n lookupGE 4 (fromList [3, 5]) == Just 5\n lookupGE 6 (fromList [3, 5]) == Nothing\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "lookupGE",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Maybe a",
          "source": "src/Data-Set-Base.html#lookupGE",
          "type": "function"
        },
        "index": {
          "description": "log Find smallest element greater or equal to the given one lookupGE fromList Just lookupGE fromList Just lookupGE fromList Nothing",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "lookupGE",
          "normalized": "a-\u003eSet a-\u003eMaybe a",
          "package": "containers",
          "partial": "GE",
          "signature": "a-\u003eSet a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:lookupGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find smallest element greater than the given one.\n\u003c/p\u003e\u003cpre\u003e lookupGT 4 (fromList [3, 5]) == Just 5\n lookupGT 5 (fromList [3, 5]) == Nothing\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "lookupGT",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Maybe a",
          "source": "src/Data-Set-Base.html#lookupGT",
          "type": "function"
        },
        "index": {
          "description": "log Find smallest element greater than the given one lookupGT fromList Just lookupGT fromList Nothing",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "lookupGT",
          "normalized": "a-\u003eSet a-\u003eMaybe a",
          "package": "containers",
          "partial": "GT",
          "signature": "a-\u003eSet a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:lookupGT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Lookup the \u003cem\u003eindex\u003c/em\u003e of an element, which is its zero-based index in\n the sorted sequence of elements. The index is a number from \u003cem\u003e0\u003c/em\u003e up to, but not\n including, the \u003ccode\u003e\u003ca\u003esize\u003c/a\u003e\u003c/code\u003e of the set.\n\u003c/p\u003e\u003cpre\u003e isJust   (lookupIndex 2 (fromList [5,3])) == False\n fromJust (lookupIndex 3 (fromList [5,3])) == 0\n fromJust (lookupIndex 5 (fromList [5,3])) == 1\n isJust   (lookupIndex 6 (fromList [5,3])) == False\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "lookupIndex",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Maybe Int",
          "source": "src/Data-Set-Base.html#lookupIndex",
          "type": "function"
        },
        "index": {
          "description": "log Lookup the index of an element which is its zero-based index in the sorted sequence of elements The index is number from up to but not including the size of the set isJust lookupIndex fromList False fromJust lookupIndex fromList fromJust lookupIndex fromList isJust lookupIndex fromList False",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "lookupIndex",
          "normalized": "a-\u003eSet a-\u003eMaybe Int",
          "package": "containers",
          "partial": "Index",
          "signature": "a-\u003eSet a-\u003eMaybe Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:lookupIndex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest element smaller or equal to the given one.\n\u003c/p\u003e\u003cpre\u003e lookupLE 2 (fromList [3, 5]) == Nothing\n lookupLE 4 (fromList [3, 5]) == Just 3\n lookupLE 5 (fromList [3, 5]) == Just 5\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "lookupLE",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Maybe a",
          "source": "src/Data-Set-Base.html#lookupLE",
          "type": "function"
        },
        "index": {
          "description": "log Find largest element smaller or equal to the given one lookupLE fromList Nothing lookupLE fromList Just lookupLE fromList Just",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "lookupLE",
          "normalized": "a-\u003eSet a-\u003eMaybe a",
          "package": "containers",
          "partial": "LE",
          "signature": "a-\u003eSet a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:lookupLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Find largest element smaller than the given one.\n\u003c/p\u003e\u003cpre\u003e lookupLT 3 (fromList [3, 5]) == Nothing\n lookupLT 5 (fromList [3, 5]) == Just 3\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "lookupLT",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Maybe a",
          "source": "src/Data-Set-Base.html#lookupLT",
          "type": "function"
        },
        "index": {
          "description": "log Find largest element smaller than the given one lookupLT fromList Nothing lookupLT fromList Just",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "lookupLT",
          "normalized": "a-\u003eSet a-\u003eMaybe a",
          "package": "containers",
          "partial": "LT",
          "signature": "a-\u003eSet a-\u003eMaybe a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:lookupLT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n*log n)\u003c/em\u003e.\n \u003ccode\u003e\u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e is the set obtained by applying \u003ccode\u003ef\u003c/code\u003e to each element of \u003ccode\u003es\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIt's worth noting that the size of the result may be smaller if,\n for some \u003ccode\u003e(x,y)\u003c/code\u003e, \u003ccode\u003ex /= y && f x == f y\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "map",
          "package": "containers",
          "signature": "(a -\u003e b) -\u003e Set a -\u003e Set b",
          "source": "src/Data-Set-Base.html#map",
          "type": "function"
        },
        "index": {
          "description": "log map is the set obtained by applying to each element of It worth noting that the size of the result may be smaller if for some",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "map",
          "normalized": "(a-\u003eb)-\u003eSet a-\u003eSet b",
          "package": "containers",
          "signature": "(a-\u003eb)-\u003eSet a-\u003eSet b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:map"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003ca\u003emapMonotonic\u003c/a\u003e\u003c/code\u003e f s == \u003ccode\u003e\u003ca\u003emap\u003c/a\u003e\u003c/code\u003e f s\u003c/code\u003e, but works only when \u003ccode\u003ef\u003c/code\u003e is monotonic.\n \u003cem\u003eThe precondition is not checked.\u003c/em\u003e\n Semi-formally, we have:\n\u003c/p\u003e\u003cpre\u003e and [x \u003c y ==\u003e f x \u003c f y | x \u003c- ls, y \u003c- ls]\n                     ==\u003e mapMonotonic f s == map f s\n     where ls = toList s\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "mapMonotonic",
          "package": "containers",
          "signature": "(a -\u003e b) -\u003e Set a -\u003e Set b",
          "source": "src/Data-Set-Base.html#mapMonotonic",
          "type": "function"
        },
        "index": {
          "description": "The mapMonotonic map but works only when is monotonic The precondition is not checked Semi-formally we have and ls ls mapMonotonic map where ls toList",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "mapMonotonic",
          "normalized": "(a-\u003eb)-\u003eSet a-\u003eSet b",
          "package": "containers",
          "partial": "Monotonic",
          "signature": "(a-\u003eb)-\u003eSet a-\u003eSet b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:mapMonotonic"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieves the maximal key of the set, and the set\n stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "maxView",
          "package": "containers",
          "signature": "Set a -\u003e Maybe (a, Set a)",
          "source": "src/Data-Set-Base.html#maxView",
          "type": "function"
        },
        "index": {
          "description": "log Retrieves the maximal key of the set and the set stripped of that element or Nothing if passed an empty set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "maxView",
          "normalized": "Set a-\u003eMaybe(a,Set a)",
          "package": "containers",
          "partial": "View",
          "signature": "Set a-\u003eMaybe(a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:maxView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Is the element in the set?\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "member",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Bool",
          "source": "src/Data-Set-Base.html#member",
          "type": "function"
        },
        "index": {
          "description": "log Is the element in the set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "member",
          "normalized": "a-\u003eSet a-\u003eBool",
          "package": "containers",
          "signature": "a-\u003eSet a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:member"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Retrieves the minimal key of the set, and the set\n stripped of that element, or \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if passed an empty set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "minView",
          "package": "containers",
          "signature": "Set a -\u003e Maybe (a, Set a)",
          "source": "src/Data-Set-Base.html#minView",
          "type": "function"
        },
        "index": {
          "description": "log Retrieves the minimal key of the set and the set stripped of that element or Nothing if passed an empty set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "minView",
          "normalized": "Set a-\u003eMaybe(a,Set a)",
          "package": "containers",
          "partial": "View",
          "signature": "Set a-\u003eMaybe(a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:minView"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Is the element not in the set?\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "notMember",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e Bool",
          "source": "src/Data-Set-Base.html#notMember",
          "type": "function"
        },
        "index": {
          "description": "log Is the element not in the set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "notMember",
          "normalized": "a-\u003eSet a-\u003eBool",
          "package": "containers",
          "partial": "Member",
          "signature": "a-\u003eSet a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:notMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Is this the empty set?\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "null",
          "package": "containers",
          "signature": "Set a -\u003e Bool",
          "source": "src/Data-Set-Base.html#null",
          "type": "function"
        },
        "index": {
          "description": "Is this the empty set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "null",
          "normalized": "Set a-\u003eBool",
          "package": "containers",
          "signature": "Set a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:null"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Partition the set into two sets, one with all elements that satisfy\n the predicate and one with all elements that don't satisfy the predicate.\n See also \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "partition",
          "package": "containers",
          "signature": "(a -\u003e Bool) -\u003e Set a -\u003e (Set a, Set a)",
          "source": "src/Data-Set-Base.html#partition",
          "type": "function"
        },
        "index": {
          "description": "Partition the set into two sets one with all elements that satisfy the predicate and one with all elements that don satisfy the predicate See also split",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "partition",
          "normalized": "(a-\u003eBool)-\u003eSet a-\u003e(Set a,Set a)",
          "package": "containers",
          "signature": "(a-\u003eBool)-\u003eSet a-\u003e(Set a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:partition"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Show the tree that implements the set. The tree is shown\n in a compressed, hanging format.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "showTree",
          "package": "containers",
          "signature": "Set a -\u003e String",
          "source": "src/Data-Set-Base.html#showTree",
          "type": "function"
        },
        "index": {
          "description": "Show the tree that implements the set The tree is shown in compressed hanging format",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "showTree",
          "normalized": "Set a-\u003eString",
          "package": "containers",
          "partial": "Tree",
          "signature": "Set a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:showTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. The expression (\u003ccode\u003eshowTreeWith hang wide map\u003c/code\u003e) shows\n the tree that implements the set. If \u003ccode\u003ehang\u003c/code\u003e is\n \u003ccode\u003eTrue\u003c/code\u003e, a \u003cem\u003ehanging\u003c/em\u003e tree is shown otherwise a rotated tree is shown. If\n \u003ccode\u003ewide\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, an extra wide version is shown.\n\u003c/p\u003e\u003cpre\u003e Set\u003e putStrLn $ showTreeWith True False $ fromDistinctAscList [1..5]\n 4\n +--2\n |  +--1\n |  +--3\n +--5\n\n Set\u003e putStrLn $ showTreeWith True True $ fromDistinctAscList [1..5]\n 4\n |\n +--2\n |  |\n |  +--1\n |  |\n |  +--3\n |\n +--5\n\n Set\u003e putStrLn $ showTreeWith False True $ fromDistinctAscList [1..5]\n +--5\n |\n 4\n |\n |  +--3\n |  |\n +--2\n    |\n    +--1\n\u003c/pre\u003e",
          "module": "Data.Set",
          "name": "showTreeWith",
          "package": "containers",
          "signature": "Bool -\u003e Bool -\u003e Set a -\u003e String",
          "source": "src/Data-Set-Base.html#showTreeWith",
          "type": "function"
        },
        "index": {
          "description": "The expression showTreeWith hang wide map shows the tree that implements the set If hang is True hanging tree is shown otherwise rotated tree is shown If wide is True an extra wide version is shown Set putStrLn showTreeWith True False fromDistinctAscList Set putStrLn showTreeWith True True fromDistinctAscList Set putStrLn showTreeWith False True fromDistinctAscList",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "showTreeWith",
          "normalized": "Bool-\u003eBool-\u003eSet a-\u003eString",
          "package": "containers",
          "partial": "Tree With",
          "signature": "Bool-\u003eBool-\u003eSet a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:showTreeWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. Create a singleton set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "singleton",
          "package": "containers",
          "signature": "a -\u003e Set a",
          "source": "src/Data-Set-Base.html#singleton",
          "type": "function"
        },
        "index": {
          "description": "Create singleton set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "singleton",
          "normalized": "a-\u003eSet a",
          "package": "containers",
          "signature": "a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:singleton"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e. The number of elements in the set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "size",
          "package": "containers",
          "signature": "Set a -\u003e Int",
          "source": "src/Data-Set-Base.html#size",
          "type": "function"
        },
        "index": {
          "description": "The number of elements in the set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "size",
          "normalized": "Set a-\u003eInt",
          "package": "containers",
          "signature": "Set a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:size"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. The expression (\u003ccode\u003e\u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e x set\u003c/code\u003e) is a pair \u003ccode\u003e(set1,set2)\u003c/code\u003e\n where \u003ccode\u003eset1\u003c/code\u003e comprises the elements of \u003ccode\u003eset\u003c/code\u003e less than \u003ccode\u003ex\u003c/code\u003e and \u003ccode\u003eset2\u003c/code\u003e\n comprises the elements of \u003ccode\u003eset\u003c/code\u003e greater than \u003ccode\u003ex\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "split",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e (Set a, Set a)",
          "source": "src/Data-Set-Base.html#split",
          "type": "function"
        },
        "index": {
          "description": "log The expression split set is pair set1 set2 where set1 comprises the elements of set less than and set2 comprises the elements of set greater than",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "split",
          "normalized": "a-\u003eSet a-\u003e(Set a,Set a)",
          "package": "containers",
          "signature": "a-\u003eSet a-\u003e(Set a,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:split"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(log n)\u003c/em\u003e. Performs a \u003ccode\u003e\u003ca\u003esplit\u003c/a\u003e\u003c/code\u003e but also returns whether the pivot\n element was found in the original set.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "splitMember",
          "package": "containers",
          "signature": "a -\u003e Set a -\u003e (Set a, Bool, Set a)",
          "source": "src/Data-Set-Base.html#splitMember",
          "type": "function"
        },
        "index": {
          "description": "log Performs split but also returns whether the pivot element was found in the original set",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "splitMember",
          "normalized": "a-\u003eSet a-\u003e(Set a,Bool,Set a)",
          "package": "containers",
          "partial": "Member",
          "signature": "a-\u003eSet a-\u003e(Set a,Bool,Set a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:splitMember"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(1)\u003c/em\u003e.  Decompose a set into pieces based on the structure of the underlying\n tree.  This function is useful for consuming a set in parallel.\n\u003c/p\u003e\u003cp\u003eNo guarantee is made as to the sizes of the pieces; an internal, but\n deterministic process determines this.  However, it is guaranteed that the pieces\n returned will be in ascending order (all elements in the first subset less than all\n elements in the second, and so on).\n\u003c/p\u003e\u003cp\u003eExamples:\n\u003c/p\u003e\u003cpre\u003e splitRoot (fromList [1..6]) ==\n   [fromList [1,2,3],fromList [4],fromList [5,6]]\n\u003c/pre\u003e\u003cpre\u003e splitRoot empty == []\n\u003c/pre\u003e\u003cp\u003eNote that the current implementation does not return more than three subsets,\n  but you should not depend on this behaviour because it can change in the\n  future without notice.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "splitRoot",
          "package": "containers",
          "signature": "Set a -\u003e [Set a]",
          "source": "src/Data-Set-Base.html#splitRoot",
          "type": "function"
        },
        "index": {
          "description": "Decompose set into pieces based on the structure of the underlying tree This function is useful for consuming set in parallel No guarantee is made as to the sizes of the pieces an internal but deterministic process determines this However it is guaranteed that the pieces returned will be in ascending order all elements in the first subset less than all elements in the second and so on Examples splitRoot fromList fromList fromList fromList splitRoot empty Note that the current implementation does not return more than three subsets but you should not depend on this behaviour because it can change in the future without notice",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "splitRoot",
          "normalized": "Set a-\u003e[Set a]",
          "package": "containers",
          "partial": "Root",
          "signature": "Set a-\u003e[Set a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:splitRoot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the set to an ascending list of elements. Subject to list fusion.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "toAscList",
          "package": "containers",
          "signature": "Set a -\u003e [a]",
          "source": "src/Data-Set-Base.html#toAscList",
          "type": "function"
        },
        "index": {
          "description": "Convert the set to an ascending list of elements Subject to list fusion",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "toAscList",
          "normalized": "Set a-\u003e[a]",
          "package": "containers",
          "partial": "Asc List",
          "signature": "Set a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:toAscList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the set to a descending list of elements. Subject to list\n fusion.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "toDescList",
          "package": "containers",
          "signature": "Set a -\u003e [a]",
          "source": "src/Data-Set-Base.html#toDescList",
          "type": "function"
        },
        "index": {
          "description": "Convert the set to descending list of elements Subject to list fusion",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "toDescList",
          "normalized": "Set a-\u003e[a]",
          "package": "containers",
          "partial": "Desc List",
          "signature": "Set a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:toDescList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Convert the set to a list of elements. Subject to list fusion.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "toList",
          "package": "containers",
          "signature": "Set a -\u003e [a]",
          "source": "src/Data-Set-Base.html#toList",
          "type": "function"
        },
        "index": {
          "description": "Convert the set to list of elements Subject to list fusion",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "toList",
          "normalized": "Set a-\u003e[a]",
          "package": "containers",
          "partial": "List",
          "signature": "Set a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:toList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n+m)\u003c/em\u003e. The union of two sets, preferring the first set when\n equal elements are encountered.\n The implementation uses the efficient \u003cem\u003ehedge-union\u003c/em\u003e algorithm.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "union",
          "package": "containers",
          "signature": "Set a -\u003e Set a -\u003e Set a",
          "source": "src/Data-Set-Base.html#union",
          "type": "function"
        },
        "index": {
          "description": "The union of two sets preferring the first set when equal elements are encountered The implementation uses the efficient hedge-union algorithm",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "union",
          "normalized": "Set a-\u003eSet a-\u003eSet a",
          "package": "containers",
          "signature": "Set a-\u003eSet a-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:union"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe union of a list of sets: (\u003ccode\u003e\u003ccode\u003e\u003ca\u003eunions\u003c/a\u003e\u003c/code\u003e == \u003ccode\u003e\u003ca\u003efoldl\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eunion\u003c/a\u003e\u003c/code\u003e \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "unions",
          "package": "containers",
          "signature": "[Set a] -\u003e Set a",
          "source": "src/Data-Set-Base.html#unions",
          "type": "function"
        },
        "index": {
          "description": "The union of list of sets unions foldl union empty",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "unions",
          "normalized": "[Set a]-\u003eSet a",
          "package": "containers",
          "signature": "[Set a]-\u003eSet a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:unions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eO(n)\u003c/em\u003e. Test if the internal set structure is valid.\n\u003c/p\u003e",
          "module": "Data.Set",
          "name": "valid",
          "package": "containers",
          "signature": "Set a -\u003e Bool",
          "source": "src/Data-Set-Base.html#valid",
          "type": "function"
        },
        "index": {
          "description": "Test if the internal set structure is valid",
          "hierarchy": "Data Set",
          "module": "Data.Set",
          "name": "valid",
          "normalized": "Set a-\u003eBool",
          "package": "containers",
          "signature": "Set a-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Set.html#v:valid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eMulti-way trees (\u003cem\u003eaka\u003c/em\u003e rose trees) and forests.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Data.Tree",
          "name": "Tree",
          "package": "containers",
          "source": "src/Data-Tree.html",
          "type": "module"
        },
        "index": {
          "description": "Multi-way trees aka rose trees and forests",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "Tree",
          "package": "containers",
          "partial": "Tree",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree",
          "name": "Forest",
          "package": "containers",
          "source": "src/Data-Tree.html#Forest",
          "type": "type"
        },
        "index": {
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "Forest",
          "package": "containers",
          "partial": "Forest",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#t:Forest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMulti-way trees, also known as \u003cem\u003erose trees\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "Tree",
          "package": "containers",
          "source": "src/Data-Tree.html#Tree",
          "type": "data"
        },
        "index": {
          "description": "Multi-way trees also known as rose trees",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "Tree",
          "package": "containers",
          "partial": "Tree",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#t:Tree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Data.Tree",
          "name": "Node",
          "package": "containers",
          "signature": "Node",
          "source": "src/Data-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "Node",
          "package": "containers",
          "partial": "Node",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:Node"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNeat 2-dimensional drawing of a forest.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "drawForest",
          "package": "containers",
          "signature": "Forest String -\u003e String",
          "source": "src/Data-Tree.html#drawForest",
          "type": "function"
        },
        "index": {
          "description": "Neat dimensional drawing of forest",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "drawForest",
          "normalized": "Forest String-\u003eString",
          "package": "containers",
          "partial": "Forest",
          "signature": "Forest String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:drawForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNeat 2-dimensional drawing of a tree.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "drawTree",
          "package": "containers",
          "signature": "Tree String -\u003e String",
          "source": "src/Data-Tree.html#drawTree",
          "type": "function"
        },
        "index": {
          "description": "Neat dimensional drawing of tree",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "drawTree",
          "normalized": "Tree String-\u003eString",
          "package": "containers",
          "partial": "Tree",
          "signature": "Tree String-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:drawTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe elements of a tree in pre-order.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "flatten",
          "package": "containers",
          "signature": "Tree a -\u003e [a]",
          "source": "src/Data-Tree.html#flatten",
          "type": "function"
        },
        "index": {
          "description": "The elements of tree in pre-order",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "flatten",
          "normalized": "Tree a-\u003e[a]",
          "package": "containers",
          "signature": "Tree a-\u003e[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:flatten"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLists of nodes at each level of the tree.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "levels",
          "package": "containers",
          "signature": "Tree a -\u003e [[a]]",
          "source": "src/Data-Tree.html#levels",
          "type": "function"
        },
        "index": {
          "description": "Lists of nodes at each level of the tree",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "levels",
          "normalized": "Tree a-\u003e[[a]]",
          "package": "containers",
          "signature": "Tree a-\u003e[[a]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:levels"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elabel value\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "rootLabel",
          "package": "containers",
          "signature": "a",
          "source": "src/Data-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "description": "label value",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "rootLabel",
          "package": "containers",
          "partial": "Label",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:rootLabel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ezero or more child trees\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "subForest",
          "package": "containers",
          "signature": "Forest a",
          "source": "src/Data-Tree.html#Tree",
          "type": "function"
        },
        "index": {
          "description": "zero or more child trees",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "subForest",
          "package": "containers",
          "partial": "Forest",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:subForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a forest from a list of seed values\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "unfoldForest",
          "package": "containers",
          "signature": "(b -\u003e (a, [b])) -\u003e [b] -\u003e Forest a",
          "source": "src/Data-Tree.html#unfoldForest",
          "type": "function"
        },
        "index": {
          "description": "Build forest from list of seed values",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "unfoldForest",
          "normalized": "(a-\u003e(b,[a]))-\u003e[a]-\u003eForest b",
          "package": "containers",
          "partial": "Forest",
          "signature": "(b-\u003e(a,[b]))-\u003e[b]-\u003eForest a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:unfoldForest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic forest builder, in depth-first order\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "unfoldForestM",
          "package": "containers",
          "signature": "(b -\u003e m (a, [b])) -\u003e [b] -\u003e m (Forest a)",
          "source": "src/Data-Tree.html#unfoldForestM",
          "type": "function"
        },
        "index": {
          "description": "Monadic forest builder in depth-first order",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "unfoldForestM",
          "normalized": "(a-\u003eb(c,[a]))-\u003e[a]-\u003eb(Forest c)",
          "package": "containers",
          "partial": "Forest",
          "signature": "(b-\u003em(a,[b]))-\u003e[b]-\u003em(Forest a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:unfoldForestM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic forest builder, in breadth-first order,\n using an algorithm adapted from\n \u003cem\u003eBreadth-First Numbering: Lessons from a Small Exercise in Algorithm Design\u003c/em\u003e,\n by Chris Okasaki, \u003cem\u003eICFP'00\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "unfoldForestM_BF",
          "package": "containers",
          "signature": "(b -\u003e m (a, [b])) -\u003e [b] -\u003e m (Forest a)",
          "source": "src/Data-Tree.html#unfoldForestM_BF",
          "type": "function"
        },
        "index": {
          "description": "Monadic forest builder in breadth-first order using an algorithm adapted from Breadth-First Numbering Lessons from Small Exercise in Algorithm Design by Chris Okasaki ICFP",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "unfoldForestM_BF",
          "normalized": "(a-\u003eb(c,[a]))-\u003e[a]-\u003eb(Forest c)",
          "package": "containers",
          "partial": "Forest BF",
          "signature": "(b-\u003em(a,[b]))-\u003e[b]-\u003em(Forest a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:unfoldForestM_BF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuild a tree from a seed value\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "unfoldTree",
          "package": "containers",
          "signature": "(b -\u003e (a, [b])) -\u003e b -\u003e Tree a",
          "source": "src/Data-Tree.html#unfoldTree",
          "type": "function"
        },
        "index": {
          "description": "Build tree from seed value",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "unfoldTree",
          "normalized": "(a-\u003e(b,[a]))-\u003ea-\u003eTree b",
          "package": "containers",
          "partial": "Tree",
          "signature": "(b-\u003e(a,[b]))-\u003eb-\u003eTree a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:unfoldTree"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic tree builder, in depth-first order\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "unfoldTreeM",
          "package": "containers",
          "signature": "(b -\u003e m (a, [b])) -\u003e b -\u003e m (Tree a)",
          "source": "src/Data-Tree.html#unfoldTreeM",
          "type": "function"
        },
        "index": {
          "description": "Monadic tree builder in depth-first order",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "unfoldTreeM",
          "normalized": "(a-\u003eb(c,[a]))-\u003ea-\u003eb(Tree c)",
          "package": "containers",
          "partial": "Tree",
          "signature": "(b-\u003em(a,[b]))-\u003eb-\u003em(Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:unfoldTreeM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMonadic tree builder, in breadth-first order,\n using an algorithm adapted from\n \u003cem\u003eBreadth-First Numbering: Lessons from a Small Exercise in Algorithm Design\u003c/em\u003e,\n by Chris Okasaki, \u003cem\u003eICFP'00\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Data.Tree",
          "name": "unfoldTreeM_BF",
          "package": "containers",
          "signature": "(b -\u003e m (a, [b])) -\u003e b -\u003e m (Tree a)",
          "source": "src/Data-Tree.html#unfoldTreeM_BF",
          "type": "function"
        },
        "index": {
          "description": "Monadic tree builder in breadth-first order using an algorithm adapted from Breadth-First Numbering Lessons from Small Exercise in Algorithm Design by Chris Okasaki ICFP",
          "hierarchy": "Data Tree",
          "module": "Data.Tree",
          "name": "unfoldTreeM_BF",
          "normalized": "(a-\u003eb(c,[a]))-\u003ea-\u003eb(Tree c)",
          "package": "containers",
          "partial": "Tree BF",
          "signature": "(b-\u003em(a,[b]))-\u003eb-\u003em(Tree a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/containers/docs/Data-Tree.html#v:unfoldTreeM_BF"
      }
    }
  ]
]