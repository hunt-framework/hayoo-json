[
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCopyright (c) 2006-2009 John Goerzen, jgoerzen@complete.org\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "module",
        "fct-source": "src/HSH-Channel.html",
        "fct-type": "module",
        "title": "Channel"
      },
      "index": {
        "description": "Copyright John Goerzen jgoerzen@complete.org",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "Channel",
        "normalized": "",
        "package": "HSH",
        "partial": "Channel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#t:Channel",
      "description": {
        "fct-descr": "\u003cp\u003eThe main type for communicating between commands.  All are expected to\nbe lazy. \n\u003c/p\u003e",
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "data",
        "fct-source": "src/HSH-Channel.html#Channel",
        "fct-type": "data",
        "title": "Channel"
      },
      "index": {
        "description": "The main type for communicating between commands All are expected to be lazy",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "Channel",
        "normalized": "",
        "package": "HSH",
        "partial": "Channel",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#t:Channelizable",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "class",
        "fct-source": "src/HSH-Channel.html#Channelizable",
        "fct-type": "class",
        "title": "Channelizable"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "Channelizable",
        "normalized": "",
        "package": "HSH",
        "partial": "Channelizable",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:ChanBSL",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "ChanBSL ByteString",
        "fct-source": "src/HSH-Channel.html#Channel",
        "fct-type": "function",
        "title": "ChanBSL"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "ChanBSL",
        "normalized": "",
        "package": "HSH",
        "partial": "Chan BSL",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:ChanHandle",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "ChanHandle Handle",
        "fct-source": "src/HSH-Channel.html#Channel",
        "fct-type": "function",
        "title": "ChanHandle"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "ChanHandle",
        "normalized": "",
        "package": "HSH",
        "partial": "Chan Handle",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:ChanString",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "ChanString String",
        "fct-source": "src/HSH-Channel.html#Channel",
        "fct-type": "function",
        "title": "ChanString"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "ChanString",
        "normalized": "",
        "package": "HSH",
        "partial": "Chan String",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:chanAsBS",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "Channel -\u003e IO ByteString",
        "fct-source": "src/HSH-Channel.html#chanAsBS",
        "fct-type": "function",
        "title": "chanAsBS"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "chanAsBS",
        "normalized": "Channel-\u003eIO ByteString",
        "package": "HSH",
        "partial": "As BS",
        "signature": "Channel-\u003eIO ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:chanAsBSL",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "Channel -\u003e IO ByteString",
        "fct-source": "src/HSH-Channel.html#chanAsBSL",
        "fct-type": "function",
        "title": "chanAsBSL"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "chanAsBSL",
        "normalized": "Channel-\u003eIO ByteString",
        "package": "HSH",
        "partial": "As BSL",
        "signature": "Channel-\u003eIO ByteString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:chanAsString",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "Channel -\u003e IO String",
        "fct-source": "src/HSH-Channel.html#chanAsString",
        "fct-type": "function",
        "title": "chanAsString"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "chanAsString",
        "normalized": "Channel-\u003eIO String",
        "package": "HSH",
        "partial": "As String",
        "signature": "Channel-\u003eIO String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:chanToHandle",
      "description": {
        "fct-descr": "\u003cp\u003eWrites the Channel to the given Handle. If the first parameter is True,\n     do this in a separate thread and close the handle afterwards.\n\u003c/p\u003e",
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "Bool -\u003e Channel -\u003e Handle -\u003e IO ()",
        "fct-source": "src/HSH-Channel.html#chanToHandle",
        "fct-type": "function",
        "title": "chanToHandle"
      },
      "index": {
        "description": "Writes the Channel to the given Handle If the first parameter is True do this in separate thread and close the handle afterwards",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "chanToHandle",
        "normalized": "Bool-\u003eChannel-\u003eHandle-\u003eIO()",
        "package": "HSH",
        "partial": "To Handle",
        "signature": "Bool-\u003eChannel-\u003eHandle-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Channel.html#v:toChannel",
      "description": {
        "fct-module": "HSH.Channel",
        "fct-package": "HSH",
        "fct-signature": "a -\u003e Channel",
        "fct-source": "src/HSH-Channel.html#toChannel",
        "fct-type": "method",
        "title": "toChannel"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Channel",
        "module": "HSH.Channel",
        "name": "toChannel",
        "normalized": "a-\u003eChannel",
        "package": "HSH",
        "partial": "Channel",
        "signature": "a-\u003eChannel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCopyright (c) 2006-2009 John Goerzen, jgoerzen@complete.org\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "module",
        "fct-source": "src/HSH-Command.html",
        "fct-type": "module",
        "title": "Command"
      },
      "index": {
        "description": "Copyright John Goerzen jgoerzen@complete.org",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "Command",
        "normalized": "",
        "package": "HSH",
        "partial": "Command",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#t:Environment",
      "description": {
        "fct-descr": "\u003cp\u003eType for the environment. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "type",
        "fct-source": "src/HSH-Command.html#Environment",
        "fct-type": "type",
        "title": "Environment"
      },
      "index": {
        "description": "Type for the environment",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "Environment",
        "normalized": "",
        "package": "HSH",
        "partial": "Environment",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#t:InvokeResult",
      "description": {
        "fct-descr": "\u003cp\u003eResult type for shell commands.  The String is the text description of\nthe command, not its output. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "type",
        "fct-source": "src/HSH-Command.html#InvokeResult",
        "fct-type": "type",
        "title": "InvokeResult"
      },
      "index": {
        "description": "Result type for shell commands The String is the text description of the command not its output",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "InvokeResult",
        "normalized": "",
        "package": "HSH",
        "partial": "Invoke Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#t:PipeCommand",
      "description": {
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "data",
        "fct-source": "src/HSH-Command.html#PipeCommand",
        "fct-type": "data",
        "title": "PipeCommand"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "PipeCommand",
        "normalized": "",
        "package": "HSH",
        "partial": "Pipe Command",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#t:RunResult",
      "description": {
        "fct-descr": "\u003cp\u003eDifferent ways to get data from \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e IO () runs, throws an exception on error, and sends stdout to stdout\n\u003c/li\u003e\u003cli\u003e IO String runs, throws an exception on error, reads stdout into\n   a buffer, and returns it as a string.  Note: This output is not lazy.\n\u003c/li\u003e\u003cli\u003e IO [String] is same as IO String, but returns the results as lines.\n   Note: this output is not lazy.\n\u003c/li\u003e\u003cli\u003e IO ExitCode runs and returns an ExitCode with the exit\n   information.  stdout is sent to stdout.  Exceptions are not thrown.\n\u003c/li\u003e\u003cli\u003e IO (String, ExitCode) is like IO ExitCode, but also\n   includes a description of the last command in the pipe to have\n   an error (or the last command, if there was no error).\n\u003c/li\u003e\u003cli\u003e IO ByteString and are similar to their String counterparts.\n\u003c/li\u003e\u003cli\u003e IO (String, IO (String, ExitCode)) returns a String read lazily\n   and an IO action that, when evaluated, finishes up the process and\n   results in its exit status.  This command returns immediately.\n\u003c/li\u003e\u003cli\u003e IO (IO (String, ExitCode)) sends stdout to stdout but returns\n   immediately.  It forks off the child but does not wait for it to finish.\n   You can use \u003ccode\u003e\u003ca\u003echeckResults\u003c/a\u003e\u003c/code\u003e to wait for the finish.\n\u003c/li\u003e\u003cli\u003e IO Int returns the exit code from a program directly.  If a signal\n   caused the command to be reaped, returns 128 + SIGNUM.\n\u003c/li\u003e\u003cli\u003e IO Bool returns True if the program exited normally (exit code 0,\n   not stopped by a signal) and False otherwise.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eTo address insufficient laziness, you can process anything that needs to be\nprocessed lazily within the pipeline itself.\n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "class",
        "fct-source": "src/HSH-Command.html#RunResult",
        "fct-type": "class",
        "title": "RunResult"
      },
      "index": {
        "description": "Different ways to get data from run IO runs throws an exception on error and sends stdout to stdout IO String runs throws an exception on error reads stdout into buffer and returns it as string Note This output is not lazy IO String is same as IO String but returns the results as lines Note this output is not lazy IO ExitCode runs and returns an ExitCode with the exit information stdout is sent to stdout Exceptions are not thrown IO String ExitCode is like IO ExitCode but also includes description of the last command in the pipe to have an error or the last command if there was no error IO ByteString and are similar to their String counterparts IO String IO String ExitCode returns String read lazily and an IO action that when evaluated finishes up the process and results in its exit status This command returns immediately IO IO String ExitCode sends stdout to stdout but returns immediately It forks off the child but does not wait for it to finish You can use checkResults to wait for the finish IO Int returns the exit code from program directly If signal caused the command to be reaped returns SIGNUM IO Bool returns True if the program exited normally exit code not stopped by signal and False otherwise To address insufficient laziness you can process anything that needs to be processed lazily within the pipeline itself",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "RunResult",
        "normalized": "",
        "package": "HSH",
        "partial": "Run Result",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#t:ShellCommand",
      "description": {
        "fct-descr": "\u003cp\u003eA shell command is something we can invoke, pipe to, pipe from,\nor pipe in both directions.  All commands that can be run as shell\ncommands must define these methods.\n\u003c/p\u003e\u003cp\u003eMinimum implementation is \u003ccode\u003e\u003ca\u003efdInvoke\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eSome pre-defined instances include:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e A simple bare string, which is passed to the shell for execution. The shell\n   will then typically expand wildcards, parse parameters, etc.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003e(String, [String])\u003c/code\u003e tuple.  The first item in the tuple gives\n   the name of a program to run, and the second gives its arguments.\n   The shell is never involved.  This is ideal for passing filenames,\n   since there is no security risk involving special shell characters.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003eHandle -\u003e Handle -\u003e IO ()\u003c/code\u003e function, which reads from the first\n   handle and write to the second.\n\u003c/li\u003e\u003cli\u003e Various functions.  These functions will accept input representing\n   its standard input and output will go to standard output.  \n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSome pre-defined instance functions include:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e(String -\u003e String)\u003c/code\u003e, \u003ccode\u003e(String -\u003e IO String)\u003c/code\u003e, plus the same definitions\n   for ByteStrings.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e([String] -\u003e [String])\u003c/code\u003e, \u003ccode\u003e([String] -\u003e IO [String])\u003c/code\u003e, where each \u003ccode\u003eString\u003c/code\u003e\n   in the list represents a single line\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e(() -\u003e String)\u003c/code\u003e, \u003ccode\u003e(() -\u003e IO String)\u003c/code\u003e, for commands that explicitly\n   read no input.  Useful with closures.  Useful when you want to avoid\n   reading stdin because something else already is.  These have the unit as\n   part of the function because otherwise we would have conflicts with things\n   such as bare Strings, which represent a command name.\n\u003c/li\u003e\u003c/ul\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "class",
        "fct-source": "src/HSH-Command.html#ShellCommand",
        "fct-type": "class",
        "title": "ShellCommand"
      },
      "index": {
        "description": "shell command is something we can invoke pipe to pipe from or pipe in both directions All commands that can be run as shell commands must define these methods Minimum implementation is fdInvoke Some pre-defined instances include simple bare string which is passed to the shell for execution The shell will then typically expand wildcards parse parameters etc String String tuple The first item in the tuple gives the name of program to run and the second gives its arguments The shell is never involved This is ideal for passing filenames since there is no security risk involving special shell characters Handle Handle IO function which reads from the first handle and write to the second Various functions These functions will accept input representing its standard input and output will go to standard output Some pre-defined instance functions include String String String IO String plus the same definitions for ByteStrings String String String IO String where each String in the list represents single line String IO String for commands that explicitly read no input Useful with closures Useful when you want to avoid reading stdin because something else already is These have the unit as part of the function because otherwise we would have conflicts with things such as bare Strings which represent command name",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "ShellCommand",
        "normalized": "",
        "package": "HSH",
        "partial": "Shell Command",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:-45--124--45-",
      "description": {
        "fct-descr": "\u003cp\u003ePipe the output of the first command into the input of the second. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "a -\u003e b -\u003e PipeCommand a b",
        "fct-source": "src/HSH-Command.html#-%7C-",
        "fct-type": "function",
        "title": "(-|-)"
      },
      "index": {
        "description": "Pipe the output of the first command into the input of the second",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "(-|-) -|-",
        "normalized": "a-\u003eb-\u003ePipeCommand a b",
        "package": "HSH",
        "partial": "",
        "signature": "a-\u003eb-\u003ePipeCommand a b"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:PipeCommand",
      "description": {
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "PipeCommand a b",
        "fct-source": "src/HSH-Command.html#PipeCommand",
        "fct-type": "function",
        "title": "PipeCommand"
      },
      "index": {
        "description": "",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "PipeCommand",
        "normalized": "",
        "package": "HSH",
        "partial": "Pipe Command",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:catchEC",
      "description": {
        "fct-descr": "\u003cp\u003eCatch an exception derived from a program exiting abnormally \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "IO a -\u003e (ExitCode -\u003e IO a) -\u003e IO a",
        "fct-source": "src/HSH-Command.html#catchEC",
        "fct-type": "function",
        "title": "catchEC"
      },
      "index": {
        "description": "Catch an exception derived from program exiting abnormally",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "catchEC",
        "normalized": "IO a-\u003e(ExitCode-\u003eIO a)-\u003eIO a",
        "package": "HSH",
        "partial": "EC",
        "signature": "IO a-\u003e(ExitCode-\u003eIO a)-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:checkResults",
      "description": {
        "fct-descr": "\u003cp\u003eEvaluates result codes and raises an error for any bad ones it finds. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "(String, ExitCode) -\u003e IO ()",
        "fct-source": "src/HSH-Command.html#checkResults",
        "fct-type": "function",
        "title": "checkResults"
      },
      "index": {
        "description": "Evaluates result codes and raises an error for any bad ones it finds",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "checkResults",
        "normalized": "(String,ExitCode)-\u003eIO()",
        "package": "HSH",
        "partial": "Results",
        "signature": "(String,ExitCode)-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:fdInvoke",
      "description": {
        "fct-descr": "\u003cp\u003eInvoke a command. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "fdInvoke",
        "fct-source": "src/HSH-Command.html#fdInvoke",
        "fct-type": "method",
        "title": "fdInvoke"
      },
      "index": {
        "description": "Invoke command",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "fdInvoke",
        "normalized": "",
        "package": "HSH",
        "partial": "Invoke",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:run",
      "description": {
        "fct-descr": "\u003cp\u003eRuns a command (or pipe of commands), with results presented\n       in any number of different ways. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "b -\u003e a",
        "fct-source": "src/HSH-Command.html#run",
        "fct-type": "method",
        "title": "run"
      },
      "index": {
        "description": "Runs command or pipe of commands with results presented in any number of different ways",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "run",
        "normalized": "a-\u003eb",
        "package": "HSH",
        "partial": "",
        "signature": "b-\u003ea"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:runIO",
      "description": {
        "fct-descr": "\u003cp\u003eA convenience function.  Refers only to the version of \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e\nthat returns \u003ccode\u003eIO ()\u003c/code\u003e.  This prevents you from having to cast to it\nall the time when you do not care about the result of \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe implementation is simply:\n\u003c/p\u003e\u003cpre\u003erunIO :: (ShellCommand a) =\u003e a -\u003e IO ()\nrunIO = run\n\u003c/pre\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "a -\u003e IO ()",
        "fct-source": "src/HSH-Command.html#runIO",
        "fct-type": "function",
        "title": "runIO"
      },
      "index": {
        "description": "convenience function Refers only to the version of run that returns IO This prevents you from having to cast to it all the time when you do not care about the result of run The implementation is simply runIO ShellCommand IO runIO run",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "runIO",
        "normalized": "a-\u003eIO()",
        "package": "HSH",
        "partial": "IO",
        "signature": "a-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:runSL",
      "description": {
        "fct-descr": "\u003cp\u003eAnother convenience function.  This returns the first line of the output,\nwith any trailing newlines or whitespace stripped off.  No leading whitespace\nis stripped.  This function will raise an exception if there is not at least\none line of output.  Mnemonic: runSL means \"run single line\".\n\u003c/p\u003e\u003cp\u003eThis command exists separately from \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e because there is already a\n\u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e instance that returns a String, though that instance returns the\nentirety of the output in that String. \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "a -\u003e IO String",
        "fct-source": "src/HSH-Command.html#runSL",
        "fct-type": "function",
        "title": "runSL"
      },
      "index": {
        "description": "Another convenience function This returns the first line of the output with any trailing newlines or whitespace stripped off No leading whitespace is stripped This function will raise an exception if there is not at least one line of output Mnemonic runSL means run single line This command exists separately from run because there is already run instance that returns String though that instance returns the entirety of the output in that String",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "runSL",
        "normalized": "a-\u003eIO String",
        "package": "HSH",
        "partial": "SL",
        "signature": "a-\u003eIO String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:setenv",
      "description": {
        "fct-descr": "\u003cp\u003eSets an environment variable, replacing an existing one if it exists.\n\u003c/p\u003e\u003cp\u003eHere's a sample ghci session to illustrate.  First, let's see the defaults for\nsome variables:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ \"echo $TERM, $LANG\"\n xterm, en_US.UTF-8\n\u003c/pre\u003e\u003cp\u003eNow, let's set one:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ \"echo $TERM, $LANG\"\n foo, en_US.UTF-8\n\u003c/pre\u003e\u003cp\u003eOr two:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ setenv [(\"LANG\", \"de_DE.UTF-8\")] $ \"echo $TERM, $LANG\"\n foo, de_DE.UTF-8\n\u003c/pre\u003e\u003cp\u003eWe could also do it easier, like this:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\"), (\"LANG\", \"de_DE.UTF-8\")] $ \"echo $TERM, $LANG\"\n foo, de_DE.UTF-8\n\u003c/pre\u003e\u003cp\u003eIt can be combined with unsetenv:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ unsetenv [\"LANG\"] $ \"echo $TERM, $LANG\"\n foo,\n\u003c/pre\u003e\u003cp\u003eAnd used with pipes:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ \"echo $TERM, $LANG\" -|- \"tr a-z A-Z\"\n FOO, EN_US.UTF-8\n\u003c/pre\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003eunsetenv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "[(String, String)] -\u003e cmd -\u003e EnvironCommand cmd",
        "fct-source": "src/HSH-Command.html#setenv",
        "fct-type": "function",
        "title": "setenv"
      },
      "index": {
        "description": "Sets an environment variable replacing an existing one if it exists Here sample ghci session to illustrate First let see the defaults for some variables Prelude HSH runIO echo TERM LANG xterm en US.UTF-8 Now let set one Prelude HSH runIO setenv TERM foo echo TERM LANG foo en US.UTF-8 Or two Prelude HSH runIO setenv TERM foo setenv LANG de DE.UTF-8 echo TERM LANG foo de DE.UTF-8 We could also do it easier like this Prelude HSH runIO setenv TERM foo LANG de DE.UTF-8 echo TERM LANG foo de DE.UTF-8 It can be combined with unsetenv Prelude HSH runIO setenv TERM foo unsetenv LANG echo TERM LANG foo And used with pipes Prelude HSH runIO setenv TERM foo echo TERM LANG tr a-z A-Z FOO EN US.UTF-8 See also unsetenv",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "setenv",
        "normalized": "[(String,String)]-\u003ea-\u003eEnvironCommand a",
        "package": "HSH",
        "partial": "",
        "signature": "[(String,String)]-\u003ecmd-\u003eEnvironCommand cmd"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:tryEC",
      "description": {
        "fct-descr": "\u003cp\u003eHandle an exception derived from a program exiting abnormally \n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "IO a -\u003e IO (Either ExitCode a)",
        "fct-source": "src/HSH-Command.html#tryEC",
        "fct-type": "function",
        "title": "tryEC"
      },
      "index": {
        "description": "Handle an exception derived from program exiting abnormally",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "tryEC",
        "normalized": "IO a-\u003eIO(Either ExitCode a)",
        "package": "HSH",
        "partial": "EC",
        "signature": "IO a-\u003eIO(Either ExitCode a)"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-Command.html#v:unsetenv",
      "description": {
        "fct-descr": "\u003cp\u003eRemoves an environment variable if it exists; does nothing otherwise.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003esetenv\u003c/a\u003e\u003c/code\u003e, which has a more extensive example.\n\u003c/p\u003e",
        "fct-module": "HSH.Command",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e cmd -\u003e EnvironCommand cmd",
        "fct-source": "src/HSH-Command.html#unsetenv",
        "fct-type": "function",
        "title": "unsetenv"
      },
      "index": {
        "description": "Removes an environment variable if it exists does nothing otherwise See also setenv which has more extensive example",
        "hierarchy": "HSH Command",
        "module": "HSH.Command",
        "name": "unsetenv",
        "normalized": "[String]-\u003ea-\u003eEnvironCommand a",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003ecmd-\u003eEnvironCommand cmd"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCopyright (c) 2006-2009 John Goerzen, jgoerzen@complete.org\n\u003c/p\u003e\u003cp\u003eThis module provides shell-like commands.  Most, but not all, are designed\nto be used directly as part of a HSH pipeline.  All may be used outside\nHSH entirely as well.\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "module",
        "fct-source": "src/HSH-ShellEquivs.html",
        "fct-type": "module",
        "title": "ShellEquivs"
      },
      "index": {
        "description": "Copyright John Goerzen jgoerzen@complete.org This module provides shell-like commands Most but not all are designed to be used directly as part of HSH pipeline All may be used outside HSH entirely as well",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "ShellEquivs",
        "normalized": "",
        "package": "HSH",
        "partial": "Shell Equivs",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:abspath",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the absolute path of the arg.  Raises an error if the\ncomputation is impossible. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e IO FilePath",
        "fct-source": "src/HSH-ShellEquivs.html#abspath",
        "fct-type": "function",
        "title": "abspath"
      },
      "index": {
        "description": "Return the absolute path of the arg Raises an error if the computation is impossible",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "abspath",
        "normalized": "FilePath-\u003eIO FilePath",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eIO FilePath"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:appendTo",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ecatTo\u003c/a\u003e\u003c/code\u003e, but appends to the file. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e String -\u003e IO String",
        "fct-source": "src/HSH-ShellEquivs.html#appendTo",
        "fct-type": "function",
        "title": "appendTo"
      },
      "index": {
        "description": "Like catTo but appends to the file",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "appendTo",
        "normalized": "FilePath-\u003eString-\u003eIO String",
        "package": "HSH",
        "partial": "To",
        "signature": "FilePath-\u003eString-\u003eIO String"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:basename",
      "description": {
        "fct-descr": "\u003cp\u003eThe filename part of a path \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e FilePath",
        "fct-source": "src/HSH-ShellEquivs.html#basename",
        "fct-type": "function",
        "title": "basename"
      },
      "index": {
        "description": "The filename part of path",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "basename",
        "normalized": "FilePath-\u003eFilePath",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eFilePath"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:bracketCD",
      "description": {
        "fct-descr": "\u003cp\u003eChanges the current working directory to the given path, executes\nthe given I/O action, then changes back to the original directory,\neven if the I/O action raised an exception.\n\u003c/p\u003e\u003cp\u003eThis is an alias for the MissingH function System.Path.bracketCWD. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e IO a -\u003e IO a",
        "fct-source": "src/HSH-ShellEquivs.html#bracketCD",
        "fct-type": "function",
        "title": "bracketCD"
      },
      "index": {
        "description": "Changes the current working directory to the given path executes the given action then changes back to the original directory even if the action raised an exception This is an alias for the MissingH function System.Path.bracketCWD",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "bracketCD",
        "normalized": "FilePath-\u003eIO a-\u003eIO a",
        "package": "HSH",
        "partial": "CD",
        "signature": "FilePath-\u003eIO a-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:catBytes",
      "description": {
        "fct-descr": "\u003cp\u003eCopy data from input to output, optionally with a fixed\nmaximum size, in bytes.  Processes data using ByteStrings internally,\nso be aware of any possible UTF-8 conversions.\n\u003c/p\u003e\u003cp\u003eYou may wish to use \u003ccode\u003ehSetBuffering h (BlockBuffering Nothing)\u003c/code\u003e prior to calling\nthis function for optimal performance.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003ecatFrom\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003ecatBytesFrom\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Maybe Integer-\u003e Channel-\u003e IO Channel",
        "fct-type": "function",
        "title": "catBytes"
      },
      "index": {
        "description": "Copy data from input to output optionally with fixed maximum size in bytes Processes data using ByteStrings internally so be aware of any possible UTF-8 conversions You may wish to use hSetBuffering BlockBuffering Nothing prior to calling this function for optimal performance See also catFrom catBytesFrom",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "catBytes",
        "normalized": "Maybe Integer-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "Bytes",
        "signature": "Maybe Integer-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:catBytesFrom",
      "description": {
        "fct-descr": "\u003cp\u003eGeneric version of \u003ccode\u003e\u003ca\u003ecatBytes\u003c/a\u003e\u003c/code\u003e; reads data from specified Channel, and\nignores stdin.\n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Channel-\u003e Maybe Integer-\u003e Channel-\u003e IO Channel",
        "fct-type": "function",
        "title": "catBytesFrom"
      },
      "index": {
        "description": "Generic version of catBytes reads data from specified Channel and ignores stdin",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "catBytesFrom",
        "normalized": "Channel-\u003eMaybe Integer-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "Bytes From",
        "signature": "Channel-\u003eMaybe Integer-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:catFrom",
      "description": {
        "fct-descr": "\u003cp\u003eLoad the specified files and display them, one at a time.\n\u003c/p\u003e\u003cp\u003eThe special file \u003ccode\u003e-\u003c/code\u003e means to display the input.  If it is not given,\nno input is processed at all.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e-\u003c/code\u003e may be given a maximum of one time.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003ecatBytes\u003c/a\u003e\u003c/code\u003e . \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[FilePath] -\u003e Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#catFrom",
        "fct-type": "function",
        "title": "catFrom"
      },
      "index": {
        "description": "Load the specified files and display them one at time The special file means to display the input If it is not given no input is processed at all may be given maximum of one time See also catBytes",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "catFrom",
        "normalized": "[FilePath]-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "From",
        "signature": "[FilePath]-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:catTo",
      "description": {
        "fct-descr": "\u003cp\u003eTakes input, writes it to the specified file, and does not pass it on.\n     The return value is the empty string.  See also \u003ccode\u003ecatToBS\u003c/code\u003e, \n     \u003ccode\u003e\u003ca\u003ecatToFIFO\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#catTo",
        "fct-type": "function",
        "title": "catTo"
      },
      "index": {
        "description": "Takes input writes it to the specified file and does not pass it on The return value is the empty string See also catToBS catToFIFO",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "catTo",
        "normalized": "FilePath-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "To",
        "signature": "FilePath-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:catToFIFO",
      "description": {
        "fct-descr": "\u003cp\u003eLike \u003ccode\u003e\u003ca\u003ecatTo\u003c/a\u003e\u003c/code\u003e, but opens the destination in ReadWriteMode instead of\nReadOnlyMode.  Due to an oddity of the Haskell IO system, this is required\nwhen writing to a named pipe (FIFO) even if you will never read from it.\n\u003c/p\u003e\u003cp\u003eThis call will BLOCK all threads on open until a reader connects.\n\u003c/p\u003e\u003cp\u003eThis is provided in addition to \u003ccode\u003e\u003ca\u003ecatTo\u003c/a\u003e\u003c/code\u003e because you may want to cat to\nsomething that you do not have permission to read from.\n\u003c/p\u003e\u003cp\u003eThis function is only available on POSIX platforms.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003ecatTo\u003c/a\u003e\u003c/code\u003e \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#catToFIFO",
        "fct-type": "function",
        "title": "catToFIFO"
      },
      "index": {
        "description": "Like catTo but opens the destination in ReadWriteMode instead of ReadOnlyMode Due to an oddity of the Haskell IO system this is required when writing to named pipe FIFO even if you will never read from it This call will BLOCK all threads on open until reader connects This is provided in addition to catTo because you may want to cat to something that you do not have permission to read from This function is only available on POSIX platforms See also catTo",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "catToFIFO",
        "normalized": "FilePath-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "To FIFO",
        "signature": "FilePath-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:cd",
      "description": {
        "fct-descr": "\u003cp\u003eAn alias for System.Directory.setCurrentDirectory.\n\u003c/p\u003e\u003cp\u003eWant to change to a user's home directory?  Try this:\n\u003c/p\u003e\u003cpre\u003e glob \"~jgoerzen\" \u003e\u003e= cd . head\n\u003c/pre\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003ebracketCD\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e IO ()",
        "fct-source": "src/HSH-ShellEquivs.html#cd",
        "fct-type": "function",
        "title": "cd"
      },
      "index": {
        "description": "An alias for System.Directory.setCurrentDirectory Want to change to user home directory Try this glob jgoerzen cd head See also bracketCD",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "cd",
        "normalized": "FilePath-\u003eIO()",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:cut",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list by a given character and select the nth list.\n\u003c/p\u003e\u003cpre\u003e cut ' ' 2 \"foo bar baz quux\" -\u003e \"bar\"\n\u003c/pre\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Integer -\u003e Char -\u003e String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#cut",
        "fct-type": "function",
        "title": "cut"
      },
      "index": {
        "description": "Split list by given character and select the nth list cut foo bar baz quux bar",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "cut",
        "normalized": "Integer-\u003eChar-\u003eString-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "Integer-\u003eChar-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:cutR",
      "description": {
        "fct-descr": "\u003cp\u003eSplit a list by a given character and select ranges of the resultant lists.\n\u003c/p\u003e\u003cpre\u003e cutR [2..4] ' ' \"foo bar baz quux foobar\" -\u003e \"baz quux foobar\"\n cutR [1..1000] ' ' \"foo bar baz quux foobar\" -\u003e \"bar baz quux foobar\"\n cutR [-1000..1000] ' ' \"foo bar baz quux foobar\" -\u003e \"foo bar baz quux foobar\"\n\u003c/pre\u003e\u003cp\u003eNote that too large and too small indices are essentially ignored.\n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[Integer] -\u003e Char -\u003e String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#cutR",
        "fct-type": "function",
        "title": "cutR"
      },
      "index": {
        "description": "Split list by given character and select ranges of the resultant lists cutR foo bar baz quux foobar baz quux foobar cutR foo bar baz quux foobar bar baz quux foobar cutR foo bar baz quux foobar foo bar baz quux foobar Note that too large and too small indices are essentially ignored",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "cutR",
        "normalized": "[Integer]-\u003eChar-\u003eString-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "[Integer]-\u003eChar-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:dirname",
      "description": {
        "fct-descr": "\u003cp\u003eThe directory part of a path \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e FilePath",
        "fct-source": "src/HSH-ShellEquivs.html#dirname",
        "fct-type": "function",
        "title": "dirname"
      },
      "index": {
        "description": "The directory part of path",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "dirname",
        "normalized": "FilePath-\u003eFilePath",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eFilePath"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:discard",
      "description": {
        "fct-descr": "\u003cp\u003eRead all input and produce no output.  Discards input completely. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#discard",
        "fct-type": "function",
        "title": "discard"
      },
      "index": {
        "description": "Read all input and produce no output Discards input completely",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "discard",
        "normalized": "Channel-\u003eIO Channel",
        "package": "HSH",
        "partial": "",
        "signature": "Channel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:echo",
      "description": {
        "fct-descr": "\u003cp\u003eTakes a string and sends it on as standard output.\n\u003c/p\u003e\u003cp\u003eThe input to this function is never read.\n\u003c/p\u003e\u003cp\u003eYou can pass this thing a String, a ByteString, or even a Handle.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003eechoBS\u003c/code\u003e. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "a -\u003e Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#echo",
        "fct-type": "function",
        "title": "echo"
      },
      "index": {
        "description": "Takes string and sends it on as standard output The input to this function is never read You can pass this thing String ByteString or even Handle See also echoBS",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "echo",
        "normalized": "a-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "",
        "signature": "a-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:egrep",
      "description": {
        "fct-descr": "\u003cp\u003eSearch for the regexp in the lines.  Return those that match. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e [String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#egrep",
        "fct-type": "function",
        "title": "egrep"
      },
      "index": {
        "description": "Search for the regexp in the lines Return those that match",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "egrep",
        "normalized": "String-\u003e[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003e[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:egrepV",
      "description": {
        "fct-descr": "\u003cp\u003eSearch for the regexp in the lines.  Return those that do NOT match. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e [String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#egrepV",
        "fct-type": "function",
        "title": "egrepV"
      },
      "index": {
        "description": "Search for the regexp in the lines Return those that do NOT match",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "egrepV",
        "normalized": "String-\u003e[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003e[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:exit",
      "description": {
        "fct-descr": "\u003cp\u003eExits with the specified error code. 0 indicates no error. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Int -\u003e IO a",
        "fct-source": "src/HSH-ShellEquivs.html#exit",
        "fct-type": "function",
        "title": "exit"
      },
      "index": {
        "description": "Exits with the specified error code indicates no error",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "exit",
        "normalized": "Int-\u003eIO a",
        "package": "HSH",
        "partial": "",
        "signature": "Int-\u003eIO a"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:glob",
      "description": {
        "fct-descr": "\u003cp\u003eTakes a pattern.  Returns a list of names that match that pattern.\nHandles:\n\u003c/p\u003e\u003cpre\u003e~username at beginning of file to expand to user's home dir\n? matches exactly one character\n* matches zero or more characters\n[list] matches any character in list\n[!list] matches any character not in list\n\u003c/pre\u003e\u003cp\u003eThe result of a tilde expansion on a nonexistant username is to do no\ntilde expansion.\n\u003c/p\u003e\u003cp\u003eThe tilde with no username equates to the current user.\n\u003c/p\u003e\u003cp\u003eNon-tilde expansion is done by the MissingH module System.Path.Glob. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e IO [FilePath]",
        "fct-source": "src/HSH-ShellEquivs.html#glob",
        "fct-type": "function",
        "title": "glob"
      },
      "index": {
        "description": "Takes pattern Returns list of names that match that pattern Handles username at beginning of file to expand to user home dir matches exactly one character matches zero or more characters list matches any character in list list matches any character not in list The result of tilde expansion on nonexistant username is to do no tilde expansion The tilde with no username equates to the current user Non-tilde expansion is done by the MissingH module System.Path.Glob",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "glob",
        "normalized": "FilePath-\u003eIO[FilePath]",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eIO[FilePath]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:grep",
      "description": {
        "fct-descr": "\u003cp\u003eSearch for the string in the lines.  Return those that match.\nSame as:\n\u003c/p\u003e\u003cpre\u003e grep needle = filter (isInfixOf needle)\n\u003c/pre\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e [String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#grep",
        "fct-type": "function",
        "title": "grep"
      },
      "index": {
        "description": "Search for the string in the lines Return those that match Same as grep needle filter isInfixOf needle",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "grep",
        "normalized": "String-\u003e[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003e[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:grepV",
      "description": {
        "fct-descr": "\u003cp\u003eSearch for the string in the lines.  Return those that do NOT match. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e [String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#grepV",
        "fct-type": "function",
        "title": "grepV"
      },
      "index": {
        "description": "Search for the string in the lines Return those that do NOT match",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "grepV",
        "normalized": "String-\u003e[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003e[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:joinLines",
      "description": {
        "fct-descr": "\u003cp\u003eJoin lines of a file\n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#joinLines",
        "fct-type": "function",
        "title": "joinLines"
      },
      "index": {
        "description": "Join lines of file",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "joinLines",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "Lines",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:lower",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a string to all lower case \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#lower",
        "fct-type": "function",
        "title": "lower"
      },
      "index": {
        "description": "Convert string to all lower case",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "lower",
        "normalized": "String-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:mkdir",
      "description": {
        "fct-descr": "\u003cp\u003eCreates the given directory.  A value of 0o755 for mode would be typical.\n\u003c/p\u003e\u003cp\u003eAn alias for System.Posix.Directory.createDirectory.\n\u003c/p\u003e\u003cp\u003eThe second argument will be ignored on non-POSIX systems. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e FileMode -\u003e IO ()",
        "fct-source": "src/HSH-ShellEquivs.html#mkdir",
        "fct-type": "function",
        "title": "mkdir"
      },
      "index": {
        "description": "Creates the given directory value of o755 for mode would be typical An alias for System.Posix.Directory.createDirectory The second argument will be ignored on non-POSIX systems",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "mkdir",
        "normalized": "FilePath-\u003eFileMode-\u003eIO()",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eFileMode-\u003eIO()"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:numberLines",
      "description": {
        "fct-descr": "\u003cp\u003eNumber each line of a file \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#numberLines",
        "fct-type": "function",
        "title": "numberLines"
      },
      "index": {
        "description": "Number each line of file",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "numberLines",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "Lines",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:pwd",
      "description": {
        "fct-descr": "\u003cp\u003eAn alias for System.Directory.getCurrentDirectory. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "IO FilePath",
        "fct-source": "src/HSH-ShellEquivs.html#pwd",
        "fct-type": "function",
        "title": "pwd"
      },
      "index": {
        "description": "An alias for System.Directory.getCurrentDirectory",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "pwd",
        "normalized": "",
        "package": "HSH",
        "partial": "",
        "signature": ""
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:readlink",
      "description": {
        "fct-descr": "\u003cp\u003eReturn the destination that the given symlink points to.\n\u003c/p\u003e\u003cp\u003eAn alias for System.Posix.Files.readSymbolicLink\n\u003c/p\u003e\u003cp\u003eThis function is only available on POSIX platforms. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e IO FilePath",
        "fct-source": "src/HSH-ShellEquivs.html#readlink",
        "fct-type": "function",
        "title": "readlink"
      },
      "index": {
        "description": "Return the destination that the given symlink points to An alias for System.Posix.Files.readSymbolicLink This function is only available on POSIX platforms",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "readlink",
        "normalized": "FilePath-\u003eIO FilePath",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eIO FilePath"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:readlinkabs",
      "description": {
        "fct-descr": "\u003cp\u003eAs \u003ccode\u003e\u003ca\u003ereadlink\u003c/a\u003e\u003c/code\u003e, but turns the result into an absolute path.\n\u003c/p\u003e\u003cp\u003eThis function is only available on POSIX platforms. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "FilePath -\u003e IO FilePath",
        "fct-source": "src/HSH-ShellEquivs.html#readlinkabs",
        "fct-type": "function",
        "title": "readlinkabs"
      },
      "index": {
        "description": "As readlink but turns the result into an absolute path This function is only available on POSIX platforms",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "readlinkabs",
        "normalized": "FilePath-\u003eIO FilePath",
        "package": "HSH",
        "partial": "",
        "signature": "FilePath-\u003eIO FilePath"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:rev",
      "description": {
        "fct-descr": "\u003cp\u003eReverse characters on each line (rev) \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#rev",
        "fct-type": "function",
        "title": "rev"
      },
      "index": {
        "description": "Reverse characters on each line rev",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "rev",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:revW",
      "description": {
        "fct-descr": "\u003cp\u003eReverse words on each line \n\u003c/p\u003e\u003cp\u003eReverse characters on each line (rev) \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#revW",
        "fct-type": "function",
        "title": "revW"
      },
      "index": {
        "description": "Reverse words on each line Reverse characters on each line rev",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "revW",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:setenv",
      "description": {
        "fct-descr": "\u003cp\u003eSets an environment variable, replacing an existing one if it exists.\n\u003c/p\u003e\u003cp\u003eHere's a sample ghci session to illustrate.  First, let's see the defaults for\nsome variables:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ \"echo $TERM, $LANG\"\n xterm, en_US.UTF-8\n\u003c/pre\u003e\u003cp\u003eNow, let's set one:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ \"echo $TERM, $LANG\"\n foo, en_US.UTF-8\n\u003c/pre\u003e\u003cp\u003eOr two:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ setenv [(\"LANG\", \"de_DE.UTF-8\")] $ \"echo $TERM, $LANG\"\n foo, de_DE.UTF-8\n\u003c/pre\u003e\u003cp\u003eWe could also do it easier, like this:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\"), (\"LANG\", \"de_DE.UTF-8\")] $ \"echo $TERM, $LANG\"\n foo, de_DE.UTF-8\n\u003c/pre\u003e\u003cp\u003eIt can be combined with unsetenv:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ unsetenv [\"LANG\"] $ \"echo $TERM, $LANG\"\n foo,\n\u003c/pre\u003e\u003cp\u003eAnd used with pipes:\n\u003c/p\u003e\u003cpre\u003e Prelude HSH\u003e runIO $ setenv [(\"TERM\", \"foo\")] $ \"echo $TERM, $LANG\" -|- \"tr a-z A-Z\"\n FOO, EN_US.UTF-8\n\u003c/pre\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003eunsetenv\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[(String, String)] -\u003e cmd -\u003e EnvironCommand cmd",
        "fct-source": "src/HSH-Command.html#setenv",
        "fct-type": "function",
        "title": "setenv"
      },
      "index": {
        "description": "Sets an environment variable replacing an existing one if it exists Here sample ghci session to illustrate First let see the defaults for some variables Prelude HSH runIO echo TERM LANG xterm en US.UTF-8 Now let set one Prelude HSH runIO setenv TERM foo echo TERM LANG foo en US.UTF-8 Or two Prelude HSH runIO setenv TERM foo setenv LANG de DE.UTF-8 echo TERM LANG foo de DE.UTF-8 We could also do it easier like this Prelude HSH runIO setenv TERM foo LANG de DE.UTF-8 echo TERM LANG foo de DE.UTF-8 It can be combined with unsetenv Prelude HSH runIO setenv TERM foo unsetenv LANG echo TERM LANG foo And used with pipes Prelude HSH runIO setenv TERM foo echo TERM LANG tr a-z A-Z FOO EN US.UTF-8 See also unsetenv",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "setenv",
        "normalized": "[(String,String)]-\u003ea-\u003eEnvironCommand a",
        "package": "HSH",
        "partial": "",
        "signature": "[(String,String)]-\u003ecmd-\u003eEnvironCommand cmd"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:space",
      "description": {
        "fct-descr": "\u003cp\u003eDouble space a file; add an empty line between each line. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#space",
        "fct-type": "function",
        "title": "space"
      },
      "index": {
        "description": "Double space file add an empty line between each line",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "space",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:tac",
      "description": {
        "fct-descr": "\u003cp\u003eReverse lines in a String (like Unix tac).\n\u003c/p\u003e\u003cp\u003eImplemented as:\n\u003c/p\u003e\u003cpre\u003e tac = reverse\n\u003c/pre\u003e\u003cp\u003eSee \u003ccode\u003e\u003ca\u003euniq\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#tac",
        "fct-type": "function",
        "title": "tac"
      },
      "index": {
        "description": "Reverse lines in String like Unix tac Implemented as tac reverse See uniq",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "tac",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:tee",
      "description": {
        "fct-descr": "\u003cp\u003eTakes input, writes it to all the specified files, and passes it on.\nThis function does \u003cem\u003eNOT\u003c/em\u003e buffer input.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003ecatFrom\u003c/a\u003e\u003c/code\u003e. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[FilePath] -\u003e Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#tee",
        "fct-type": "function",
        "title": "tee"
      },
      "index": {
        "description": "Takes input writes it to all the specified files and passes it on This function does NOT buffer input See also catFrom",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "tee",
        "normalized": "[FilePath]-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "",
        "signature": "[FilePath]-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:teeFIFO",
      "description": {
        "fct-descr": "\u003cp\u003eFIFO-safe version of \u003ccode\u003e\u003ca\u003etee\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis call will BLOCK all threads on open until a reader connects.\n\u003c/p\u003e\u003cp\u003eThis function is only available on POSIX platforms. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[FilePath] -\u003e Channel -\u003e IO Channel",
        "fct-source": "src/HSH-ShellEquivs.html#teeFIFO",
        "fct-type": "function",
        "title": "teeFIFO"
      },
      "index": {
        "description": "FIFO-safe version of tee This call will BLOCK all threads on open until reader connects This function is only available on POSIX platforms",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "teeFIFO",
        "normalized": "[FilePath]-\u003eChannel-\u003eIO Channel",
        "package": "HSH",
        "partial": "FIFO",
        "signature": "[FilePath]-\u003eChannel-\u003eIO Channel"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:tr",
      "description": {
        "fct-descr": "\u003cp\u003eTranslate a character x to y, like:\n\u003c/p\u003e\u003cpre\u003etr 'e' 'f'\n\u003c/pre\u003e\u003cp\u003eOr, in sed,\n\u003c/p\u003e\u003cpre\u003ey//\n\u003c/pre\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Char -\u003e Char -\u003e String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#tr",
        "fct-type": "function",
        "title": "tr"
      },
      "index": {
        "description": "Translate character to like tr Or in sed",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "tr",
        "normalized": "Char-\u003eChar-\u003eString-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "Char-\u003eChar-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:trd",
      "description": {
        "fct-descr": "\u003cp\u003eDelete specified character in a string. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "Char -\u003e String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#trd",
        "fct-type": "function",
        "title": "trd"
      },
      "index": {
        "description": "Delete specified character in string",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "trd",
        "normalized": "Char-\u003eString-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "Char-\u003eString-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:uniq",
      "description": {
        "fct-descr": "\u003cp\u003eRemove duplicate lines from a file (like Unix uniq).\n\u003c/p\u003e\u003cp\u003eTakes a String representing a file or output and plugs it through lines and then nub to uniqify on a line basis. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#uniq",
        "fct-type": "function",
        "title": "uniq"
      },
      "index": {
        "description": "Remove duplicate lines from file like Unix uniq Takes String representing file or output and plugs it through lines and then nub to uniqify on line basis",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "uniq",
        "normalized": "String-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:unsetenv",
      "description": {
        "fct-descr": "\u003cp\u003eRemoves an environment variable if it exists; does nothing otherwise.\n\u003c/p\u003e\u003cp\u003eSee also \u003ccode\u003e\u003ca\u003esetenv\u003c/a\u003e\u003c/code\u003e, which has a more extensive example.\n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e cmd -\u003e EnvironCommand cmd",
        "fct-source": "src/HSH-Command.html#unsetenv",
        "fct-type": "function",
        "title": "unsetenv"
      },
      "index": {
        "description": "Removes an environment variable if it exists does nothing otherwise See also setenv which has more extensive example",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "unsetenv",
        "normalized": "[String]-\u003ea-\u003eEnvironCommand a",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003ecmd-\u003eEnvironCommand cmd"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:unspace",
      "description": {
        "fct-descr": "\u003cp\u003eInverse of double \u003ccode\u003e\u003ca\u003espace\u003c/a\u003e\u003c/code\u003e; drop all empty lines. \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#unspace",
        "fct-type": "function",
        "title": "unspace"
      },
      "index": {
        "description": "Inverse of double space drop all empty lines",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "unspace",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:upper",
      "description": {
        "fct-descr": "\u003cp\u003eConvert a string to all upper case \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "String -\u003e String",
        "fct-source": "src/HSH-ShellEquivs.html#upper",
        "fct-type": "function",
        "title": "upper"
      },
      "index": {
        "description": "Convert string to all upper case",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "upper",
        "normalized": "String-\u003eString",
        "package": "HSH",
        "partial": "",
        "signature": "String-\u003eString"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:wcL",
      "description": {
        "fct-descr": "\u003cp\u003eCount number of lines.  Like wc -l \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#wcL",
        "fct-type": "function",
        "title": "wcL"
      },
      "index": {
        "description": "Count number of lines Like wc",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "wcL",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH-ShellEquivs.html#v:wcW",
      "description": {
        "fct-descr": "\u003cp\u003eCount number of words in a file (like wc -w) \n\u003c/p\u003e",
        "fct-module": "HSH.ShellEquivs",
        "fct-package": "HSH",
        "fct-signature": "[String] -\u003e [String]",
        "fct-source": "src/HSH-ShellEquivs.html#wcW",
        "fct-type": "function",
        "title": "wcW"
      },
      "index": {
        "description": "Count number of words in file like wc",
        "hierarchy": "HSH ShellEquivs",
        "module": "HSH.ShellEquivs",
        "name": "wcW",
        "normalized": "[String]-\u003e[String]",
        "package": "HSH",
        "partial": "",
        "signature": "[String]-\u003e[String]"
      }
    }
  },
  {
    "cmd": "update",
    "document": {
      "uri": "http://hackage.haskell.org/package/HSH/docs/HSH.html#",
      "description": {
        "fct-descr": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCopyright (c) 2006 John Goerzen, jgoerzen@complete.org\n\u003c/p\u003e\u003cp\u003eWelcome to HSH, the Haskell Shell infrastructure.\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://software.complete.org/hsh\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eHSH is designed to let you mix and match shell expressions with Haskell\nprograms.\n\u003c/p\u003e\u003cp\u003eHere are a few examples to get you started:\n\u003c/p\u003e\u003cpre\u003erun $ \"echo /etc/pass*\" :: IO String\n -\u003e \"/etc/passwd /etc/passwd-\"\n\nrunIO $ \"ls -l\" -|- \"wc -l\"\n -\u003e 12\n\nrunIO $ \"ls -l\" -|- wcL\n -\u003e 12\n\nrunIO $ (\"ls\", [\"-l\", \"file with spaces.txt\"])\nglob \"~jgoerzen\" \u003e\u003e= cd . head\n\u003c/pre\u003e\u003cp\u003ewcL is a pure Haskell function defined in \u003ca\u003eHSH.ShellEquivs.wcL\u003c/a\u003e as:\n\u003c/p\u003e\u003cpre\u003ewcL :: [String] -\u003e [String]\nwcL inp = [show $ genericLength inp]\n\u003c/pre\u003e\u003cp\u003eHere's another example:\n\u003c/p\u003e\u003cpre\u003e let countLines = (zipWith (\\i line -\u003e printf \"%-5d %s\" i line) \n      [(1::Int)..])::([String] -\u003e [String])\n\n runIO $ (\"ls\", [\"-l\"]) -|- countLines -|- filter (isSuffixOf \"hs\")\n   6     -rw-r--r-- 1 jgoerzen jgoerzen  1285 Jun  6 09:43 HSH.hs\n   11    -rw-r--r-- 1 jgoerzen jgoerzen   565 Jun  6 09:43 test.hs\n\u003c/pre\u003e\u003cp\u003eTo use HSH, you'll just want to import the HSH module.  To learn more,\nplease see the information in \u003ca\u003eHSH.Command\u003c/a\u003e and \u003ca\u003eHSH.ShellEquivs\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eYou can run a command with HSH in several ways:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e By using \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e in a context that expects IO (), which will leave\n   the final standard output going\n   to the normal standard output of the program\n\u003c/li\u003e\u003cli\u003e By using \u003ccode\u003e\u003ca\u003erun\u003c/a\u003e\u003c/code\u003e in a context that expects a String, which will\n   capture standard output into a buffer and present it as a String\n\u003c/li\u003e\u003cli\u003e Any of the numerous other methods documented in \u003ccode\u003e\u003ca\u003eRunResult\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e The shortcut functions \u003ccode\u003e\u003ca\u003erunIO\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003erunSL\u003c/a\u003e\u003c/code\u003e.  \u003ccode\u003e\u003ca\u003erunIO\u003c/a\u003e\u003c/code\u003e lets you run \n   a command and force the context IO (), which is a frequently-useful\n   shortcut when you don't care about the result.  \u003ccode\u003e\u003ca\u003erunSL\u003c/a\u003e\u003c/code\u003e grabs the\n   first line of output in the result.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eYou can then specify a command, which could be a single command or a command\njoined together with pipes.\n\u003c/p\u003e\u003cp\u003eThere are many different items that make valid types; see the list of \ninstances of \u003ccode\u003e\u003ca\u003eShellCommand\u003c/a\u003e\u003c/code\u003e for a full list.  Here are a few:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e A simple bare string is passed to the shell for execution.  The shell\n   will then typically expand wildcards, parse parameters, etc.\n\u003c/li\u003e\u003cli\u003e A \u003ccode\u003e(String, [String])\u003c/code\u003e tuple.  The first item in the tuple gives\n   the name of a program to run, and the second gives its arguments.\n   The shell is never involved.  This is ideal for passing filenames,\n   since there is no security risk involving special shell characters.\n\u003c/li\u003e\u003cli\u003e A Haskell function.  This function will accept input representing\n   its standard input and generate output to go to stdout.  Function\n   types that are supported natively include \u003ccode\u003e(String -\u003e String)\u003c/code\u003e,\n   \u003ccode\u003e(String -\u003e IO String)\u003c/code\u003e, plus many more involving ByteStrings and functions\n   that take no input.  See \u003ccode\u003e\u003ca\u003eShellCommand\u003c/a\u003e\u003c/code\u003e for more.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003ePipes can be constructed by using the -|- operator, as illustrated above.\nIt is quite possible to pipe data between Haskell functions and\nshell commands at will.\n\u003c/p\u003e\u003cp\u003eIn addition, \u003ca\u003eHSH.ShellEquivs\u003c/a\u003e provides a number of useful pure-Haskell\nequivalents of regular shell commands.\n\u003c/p\u003e\u003cp\u003eFor more information, please consult the other modules in HSH as well as\nthe HSH wiki at:\n\u003c/p\u003e\u003cp\u003e\u003ca\u003ehttp://software.complete.org/hsh\u003c/a\u003e\n\u003c/p\u003e\u003c/div\u003e",
        "fct-module": "HSH",
        "fct-package": "HSH",
        "fct-signature": "module",
        "fct-source": "src/HSH.html",
        "fct-type": "module",
        "title": "HSH"
      },
      "index": {
        "description": "Copyright John Goerzen jgoerzen@complete.org Welcome to HSH the Haskell Shell infrastructure http software.complete.org hsh HSH is designed to let you mix and match shell expressions with Haskell programs Here are few examples to get you started run echo etc pass IO String etc passwd etc passwd runIO ls wc runIO ls wcL runIO ls file with spaces.txt glob jgoerzen cd head wcL is pure Haskell function defined in HSH.ShellEquivs.wcL as wcL String String wcL inp show genericLength inp Here another example let countLines zipWith line printf line Int String String runIO ls countLines filter isSuffixOf hs rw-r--r jgoerzen jgoerzen Jun HSH.hs rw-r--r jgoerzen jgoerzen Jun test.hs To use HSH you ll just want to import the HSH module To learn more please see the information in HSH.Command and HSH.ShellEquivs You can run command with HSH in several ways By using run in context that expects IO which will leave the final standard output going to the normal standard output of the program By using run in context that expects String which will capture standard output into buffer and present it as String Any of the numerous other methods documented in RunResult The shortcut functions runIO and runSL runIO lets you run command and force the context IO which is frequently-useful shortcut when you don care about the result runSL grabs the first line of output in the result You can then specify command which could be single command or command joined together with pipes There are many different items that make valid types see the list of instances of ShellCommand for full list Here are few simple bare string is passed to the shell for execution The shell will then typically expand wildcards parse parameters etc String String tuple The first item in the tuple gives the name of program to run and the second gives its arguments The shell is never involved This is ideal for passing filenames since there is no security risk involving special shell characters Haskell function This function will accept input representing its standard input and generate output to go to stdout Function types that are supported natively include String String String IO String plus many more involving ByteStrings and functions that take no input See ShellCommand for more Pipes can be constructed by using the operator as illustrated above It is quite possible to pipe data between Haskell functions and shell commands at will In addition HSH.ShellEquivs provides number of useful pure-Haskell equivalents of regular shell commands For more information please consult the other modules in HSH as well as the HSH wiki at http software.complete.org hsh",
        "hierarchy": "HSH",
        "module": "HSH",
        "name": "HSH",
        "normalized": "",
        "package": "HSH",
        "partial": "HSH",
        "signature": ""
      }
    }
  }
]