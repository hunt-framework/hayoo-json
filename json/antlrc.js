[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "antlrc"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "Lexer",
          "package": "antlrc",
          "source": "src/Text-Antlrc-Lexer.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "Lexer",
          "package": "antlrc",
          "partial": "Lexer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePointer to an ANTLR string.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "AntlrString",
          "package": "antlrc",
          "source": "src/Text-Antlrc-Lexer.html#AntlrString",
          "type": "newtype"
        },
        "index": {
          "description": "Pointer to an ANTLR string",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "AntlrString",
          "package": "antlrc",
          "partial": "Antlr String",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#t:AntlrString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexer token struct.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "CommonToken",
          "package": "antlrc",
          "source": "src/Text-Antlrc-Lexer.html#CommonToken",
          "type": "newtype"
        },
        "index": {
          "description": "Lexer token struct",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "CommonToken",
          "package": "antlrc",
          "partial": "Common Token",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#t:CommonToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexer input stream struct.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "InputStream",
          "package": "antlrc",
          "source": "src/Text-Antlrc-Lexer.html#InputStream",
          "type": "newtype"
        },
        "index": {
          "description": "Lexer input stream struct",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "InputStream",
          "package": "antlrc",
          "partial": "Input Stream",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#t:InputStream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLexer struct.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "Lexer",
          "package": "antlrc",
          "source": "src/Text-Antlrc-Lexer.html#Lexer",
          "type": "newtype"
        },
        "index": {
          "description": "Lexer struct",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "Lexer",
          "package": "antlrc",
          "partial": "Lexer",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#t:Lexer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "AntlrString",
          "package": "antlrc",
          "signature": "AntlrString (Ptr AntlrString)",
          "source": "src/Text-Antlrc-Lexer.html#AntlrString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "AntlrString",
          "package": "antlrc",
          "partial": "Antlr String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:AntlrString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "CommonToken",
          "package": "antlrc",
          "signature": "CommonToken (Ptr CommonToken)",
          "source": "src/Text-Antlrc-Lexer.html#CommonToken",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "CommonToken",
          "package": "antlrc",
          "partial": "Common Token",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:CommonToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "InputStream",
          "package": "antlrc",
          "signature": "InputStream (Ptr InputStream)",
          "source": "src/Text-Antlrc-Lexer.html#InputStream",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "InputStream",
          "package": "antlrc",
          "partial": "Input Stream",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:InputStream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "Lexer",
          "package": "antlrc",
          "signature": "Lexer (Ptr Lexer)",
          "source": "src/Text-Antlrc-Lexer.html#Lexer",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "Lexer",
          "package": "antlrc",
          "partial": "Lexer",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:Lexer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast from an ANTLR string to a pointer to an ANTLR string.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "fromAntlrString",
          "package": "antlrc",
          "signature": "AntlrString -\u003e Ptr b",
          "source": "src/Text-Antlrc-Lexer.html#fromAntlrString",
          "type": "function"
        },
        "index": {
          "description": "Cast from an ANTLR string to pointer to an ANTLR string",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "fromAntlrString",
          "normalized": "AntlrString-\u003ePtr a",
          "package": "antlrc",
          "partial": "Antlr String",
          "signature": "AntlrString-\u003ePtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:fromAntlrString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert an ANTLR string to a Maybe String. \n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "fromAntlrStringToMaybeString",
          "package": "antlrc",
          "signature": "AntlrString -\u003e IO (Maybe String)",
          "source": "src/Text-Antlrc-Lexer.html#fromAntlrStringToMaybeString",
          "type": "function"
        },
        "index": {
          "description": "Convert an ANTLR string to Maybe String",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "fromAntlrStringToMaybeString",
          "normalized": "AntlrString-\u003eIO(Maybe String)",
          "package": "antlrc",
          "partial": "Antlr String To Maybe String",
          "signature": "AntlrString-\u003eIO(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:fromAntlrStringToMaybeString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConvert from an ANTLR string to a String.\n   Note: the peekCStringLen function does not say what will happen if the\n   C pointer is 0.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "fromAntlrStringToString",
          "package": "antlrc",
          "signature": "AntlrString -\u003e IO String",
          "source": "src/Text-Antlrc-Lexer.html#fromAntlrStringToString",
          "type": "function"
        },
        "index": {
          "description": "Convert from an ANTLR string to String Note the peekCStringLen function does not say what will happen if the pointer is",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "fromAntlrStringToString",
          "normalized": "AntlrString-\u003eIO String",
          "package": "antlrc",
          "partial": "Antlr String To String",
          "signature": "AntlrString-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:fromAntlrStringToString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast from a token to a pointer to a token.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "fromCommonToken",
          "package": "antlrc",
          "signature": "CommonToken -\u003e Ptr b",
          "source": "src/Text-Antlrc-Lexer.html#fromCommonToken",
          "type": "function"
        },
        "index": {
          "description": "Cast from token to pointer to token",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "fromCommonToken",
          "normalized": "CommonToken-\u003ePtr a",
          "package": "antlrc",
          "partial": "Common Token",
          "signature": "CommonToken-\u003ePtr b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:fromCommonToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLookahead in the input stream at the token at the specified\n   positive offset, where:\n\u003c/p\u003e\u003cpre\u003e LT input 1 \n\u003c/pre\u003e\u003cp\u003eis the current token.  Or a negative offset may be specified, where: \n\u003c/p\u003e\u003cpre\u003e LT input (-1) \n\u003c/pre\u003e\u003cp\u003eis the previous token.\n\u003c/p\u003e\u003cpre\u003e foreign export ccall isUnsignedInt :: Ptr InputStream -\u003e IO Bool\n isUnsignedInt input =\n   do token1 \u003c- lT input 1 \u003e\u003e= tokenGetType\n      if token1 /= UNSIGNED\n        then return False\n        else \n        do \n          token2 \u003c- lT input 2 \u003e\u003e= tokenGetType\n          return ((token2 /= CHAR) && (token2 /= SHORT) && (token2 /= LONG))\n\u003c/pre\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "lT",
          "package": "antlrc",
          "signature": "Ptr InputStream -\u003e Int -\u003e IO (Ptr CommonToken)",
          "source": "src/Text-Antlrc-Lexer.html#lT",
          "type": "function"
        },
        "index": {
          "description": "Lookahead in the input stream at the token at the specified positive offset where LT input is the current token Or negative offset may be specified where LT input is the previous token foreign export ccall isUnsignedInt Ptr InputStream IO Bool isUnsignedInt input do token1 lT input tokenGetType if token1 UNSIGNED then return False else do token2 lT input tokenGetType return token2 CHAR token2 SHORT token2 LONG",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "lT",
          "normalized": "Ptr InputStream-\u003eInt-\u003eIO(Ptr CommonToken)",
          "package": "antlrc",
          "signature": "Ptr InputStream-\u003eInt-\u003eIO(Ptr CommonToken)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:lT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "lT'_",
          "package": "antlrc",
          "signature": "InputStream -\u003e CInt -\u003e IO CommonToken",
          "source": "src/Text-Antlrc-Lexer.html#lT%27_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "lT'_",
          "normalized": "InputStream-\u003eCInt-\u003eIO CommonToken",
          "package": "antlrc",
          "partial": "T'",
          "signature": "InputStream-\u003eCInt-\u003eIO CommonToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:lT-39-_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast from a pointer to a token to a token.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "toCommonToken",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e CommonToken",
          "source": "src/Text-Antlrc-Lexer.html#toCommonToken",
          "type": "function"
        },
        "index": {
          "description": "Cast from pointer to token to token",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "toCommonToken",
          "normalized": "Ptr CommonToken-\u003eCommonToken",
          "package": "antlrc",
          "partial": "Common Token",
          "signature": "Ptr CommonToken-\u003eCommonToken",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:toCommonToken"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCast from a pointer to an input stream to an input stream.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "toInputStream",
          "package": "antlrc",
          "signature": "Ptr InputStream -\u003e InputStream",
          "source": "src/Text-Antlrc-Lexer.html#toInputStream",
          "type": "function"
        },
        "index": {
          "description": "Cast from pointer to an input stream to an input stream",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "toInputStream",
          "normalized": "Ptr InputStream-\u003eInputStream",
          "package": "antlrc",
          "partial": "Input Stream",
          "signature": "Ptr InputStream-\u003eInputStream",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:toInputStream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the token name ANTLR string for the specified token.\n\u003c/p\u003e\u003cpre\u003e tokenGetAntlrString token\n\u003c/pre\u003e\u003cp\u003eFor identifier tokens, the token string is interesting.  For\n   other tokens such as operator tokens, the token string is\n   uninteresting, and may not be present, the token identifier enum \n   should be used instead.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetAntlrString",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e IO (Ptr AntlrString)",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetAntlrString",
          "type": "function"
        },
        "index": {
          "description": "Obtain the token name ANTLR string for the specified token tokenGetAntlrString token For identifier tokens the token string is interesting For other tokens such as operator tokens the token string is uninteresting and may not be present the token identifier enum should be used instead",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetAntlrString",
          "normalized": "Ptr CommonToken-\u003eIO(Ptr AntlrString)",
          "package": "antlrc",
          "partial": "Get Antlr String",
          "signature": "Ptr CommonToken-\u003eIO(Ptr AntlrString)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetAntlrString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetAntlrString'_",
          "package": "antlrc",
          "signature": "CommonToken -\u003e IO AntlrString",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetAntlrString%27_",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetAntlrString'_",
          "normalized": "CommonToken-\u003eIO AntlrString",
          "package": "antlrc",
          "partial": "Get Antlr String'",
          "signature": "CommonToken-\u003eIO AntlrString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetAntlrString-39-_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the character position in the source code line of where the token\n   was read, for non-imaginary tokens.\n\u003c/p\u003e\u003cpre\u003e foreign export ccall saTrue :: Ptr CommonToken -\u003e IO (StablePtr TermInfo)\n saTrue token =\n   do\n     -- obtain the source code line and charPosition from the token\n     l \u003c- tokenGetLine token\n     c \u003c- tokenGetCharPositionInLine token\n     -- return the TmTrue term\n     newStablePtr (TmTrue (Info l c))\n\u003c/pre\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetCharPositionInLine",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e IO Int",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetCharPositionInLine",
          "type": "function"
        },
        "index": {
          "description": "Obtain the character position in the source code line of where the token was read for non-imaginary tokens foreign export ccall saTrue Ptr CommonToken IO StablePtr TermInfo saTrue token do obtain the source code line and charPosition from the token tokenGetLine token tokenGetCharPositionInLine token return the TmTrue term newStablePtr TmTrue Info",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetCharPositionInLine",
          "normalized": "Ptr CommonToken-\u003eIO Int",
          "package": "antlrc",
          "partial": "Get Char Position In Line",
          "signature": "Ptr CommonToken-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetCharPositionInLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the the source code line of where the token was read, for non-imaginary tokens.\n\u003c/p\u003e\u003cpre\u003e foreign export ccall saFalse :: Ptr CommonToken -\u003e IO (StablePtr TermInfo)\n saFalse token =\n   do\n     -- obtain the source code line and charPosition from the token\n     l \u003c- tokenGetLine token\n     c \u003c- tokenGetCharPositionInLine token\n     -- return the TmFalse term\n     newStablePtr (TmFalse (Info l c))\n\u003c/pre\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetLine",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e IO Int",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetLine",
          "type": "function"
        },
        "index": {
          "description": "Obtain the the source code line of where the token was read for non-imaginary tokens foreign export ccall saFalse Ptr CommonToken IO StablePtr TermInfo saFalse token do obtain the source code line and charPosition from the token tokenGetLine token tokenGetCharPositionInLine token return the TmFalse term newStablePtr TmFalse Info",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetLine",
          "normalized": "Ptr CommonToken-\u003eIO Int",
          "package": "antlrc",
          "partial": "Get Line",
          "signature": "Ptr CommonToken-\u003eIO Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the token String for the specified token.\n   Note: the peekCStringLen function does not say what will happen if the\n   C pointer is 0.\n\u003c/p\u003e\u003cpre\u003e foreign export ccall saIntV :: Ptr CommonToken -\u003e IO (StablePtr TermInfo)\n saIntV token =\n   do\n     -- read the IntV integer value from the token text into n\n     t \u003c- tokenGetText token\n     n \u003c- readIO t\n     -- obtain the source code line and charPosition from the token\n     l \u003c- tokenGetLine token\n     c \u003c- tokenGetCharPositionInLine token\n     -- return the term, which is TmZero, or TmSucc TmZero, or TmSucc (TmSucc (...TmSucc TmZero))\n     newStablePtr (intV (Info l c) n)\n\u003c/pre\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetText",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e IO String",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetText",
          "type": "function"
        },
        "index": {
          "description": "Obtain the token String for the specified token Note the peekCStringLen function does not say what will happen if the pointer is foreign export ccall saIntV Ptr CommonToken IO StablePtr TermInfo saIntV token do read the IntV integer value from the token text into tokenGetText token readIO obtain the source code line and charPosition from the token tokenGetLine token tokenGetCharPositionInLine token return the term which is TmZero or TmSucc TmZero or TmSucc TmSucc TmSucc TmZero newStablePtr intV Info",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetText",
          "normalized": "Ptr CommonToken-\u003eIO String",
          "package": "antlrc",
          "partial": "Get Text",
          "signature": "Ptr CommonToken-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the token Maybe String for the specified token.\n   For identifier tokens, the token string is interesting.  For\n   other tokens such as operator tokens, the token string is\n   uninteresting, and may not be present, the token identifier enum \n   should be used instead.\n\u003c/p\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetTextMaybe",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e IO (Maybe String)",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetTextMaybe",
          "type": "function"
        },
        "index": {
          "description": "Obtain the token Maybe String for the specified token For identifier tokens the token string is interesting For other tokens such as operator tokens the token string is uninteresting and may not be present the token identifier enum should be used instead",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetTextMaybe",
          "normalized": "Ptr CommonToken-\u003eIO(Maybe String)",
          "package": "antlrc",
          "partial": "Get Text Maybe",
          "signature": "Ptr CommonToken-\u003eIO(Maybe String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetTextMaybe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the token identifier for the specified token.\n\u003c/p\u003e\u003cpre\u003e foreign export ccall isInt :: Ptr InputStream -\u003e IO Bool\n isInt input =\n   do \n     token1 \u003c- lT input 1 \u003e\u003e= tokenGetType\n     return (token1 == INT)\n\u003c/pre\u003e",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetType",
          "package": "antlrc",
          "signature": "Ptr CommonToken -\u003e IO e",
          "source": "src/Text-Antlrc-Lexer.html#tokenGetType",
          "type": "function"
        },
        "index": {
          "description": "Obtain the token identifier for the specified token foreign export ccall isInt Ptr InputStream IO Bool isInt input do token1 lT input tokenGetType return token1 INT",
          "hierarchy": "Text Antlrc Lexer",
          "module": "Text.Antlrc.Lexer",
          "name": "tokenGetType",
          "normalized": "Ptr CommonToken-\u003eIO a",
          "package": "antlrc",
          "partial": "Get Type",
          "signature": "Ptr CommonToken-\u003eIO e",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc-Lexer.html#v:tokenGetType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eANTLR C runtime library Haskell binding, for the ANTLR LL(*) parser generator.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Antlrc",
          "name": "Antlrc",
          "package": "antlrc",
          "source": "src/Text-Antlrc.html",
          "type": "module"
        },
        "index": {
          "description": "ANTLR runtime library Haskell binding for the ANTLR LL parser generator",
          "hierarchy": "Text Antlrc",
          "module": "Text.Antlrc",
          "name": "Antlrc",
          "package": "antlrc",
          "partial": "Antlrc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/antlrc/docs/Text-Antlrc.html#"
      }
    }
  ]
]