[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "lattices"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Enumerable",
          "name": "Enumerable",
          "package": "lattices",
          "source": "src/Algebra-Enumerable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "Enumerable",
          "package": "lattices",
          "partial": "Enumerable",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFinitely enumerable things\n\u003c/p\u003e",
          "module": "Algebra.Enumerable",
          "name": "Enumerable",
          "package": "lattices",
          "source": "src/Algebra-Enumerable.html#Enumerable",
          "type": "class"
        },
        "index": {
          "description": "Finitely enumerable things",
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "Enumerable",
          "package": "lattices",
          "partial": "Enumerable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#t:Enumerable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrapper used to mark where we expect to use the fact that something is Enumerable\n\u003c/p\u003e",
          "module": "Algebra.Enumerable",
          "name": "Enumerated",
          "package": "lattices",
          "source": "src/Algebra-Enumerable.html#Enumerated",
          "type": "newtype"
        },
        "index": {
          "description": "Wrapper used to mark where we expect to use the fact that something is Enumerable",
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "Enumerated",
          "package": "lattices",
          "partial": "Enumerated",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#t:Enumerated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Enumerable",
          "name": "Enumerated",
          "package": "lattices",
          "signature": "Enumerated",
          "source": "src/Algebra-Enumerable.html#Enumerated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "Enumerated",
          "package": "lattices",
          "partial": "Enumerated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#v:Enumerated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Enumerable",
          "name": "unEnumerated",
          "package": "lattices",
          "signature": "a",
          "source": "src/Algebra-Enumerable.html#Enumerated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "unEnumerated",
          "package": "lattices",
          "partial": "Enumerated",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#v:unEnumerated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Enumerable",
          "name": "universe",
          "package": "lattices",
          "signature": "[a]",
          "source": "src/Algebra-Enumerable.html#universe",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "universe",
          "normalized": "[a]",
          "package": "lattices",
          "signature": "[a]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#v:universe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Enumerable",
          "name": "universeBounded",
          "package": "lattices",
          "signature": "[a]",
          "source": "src/Algebra-Enumerable.html#universeBounded",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Enumerable",
          "module": "Algebra.Enumerable",
          "name": "universeBounded",
          "normalized": "[a]",
          "package": "lattices",
          "partial": "Bounded",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Enumerable.html#v:universeBounded"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Dropped",
          "name": "Dropped",
          "package": "lattices",
          "source": "src/Algebra-Lattice-Dropped.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Lattice Dropped",
          "module": "Algebra.Lattice.Dropped",
          "name": "Dropped",
          "package": "lattices",
          "partial": "Dropped",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Dropped.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraft a distinct top onto an otherwise unbounded lattice.\n As a bonus, the top will be an absorbing element for the join.\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Dropped",
          "name": "Dropped",
          "package": "lattices",
          "source": "src/Algebra-Lattice-Dropped.html#Dropped",
          "type": "data"
        },
        "index": {
          "description": "Graft distinct top onto an otherwise unbounded lattice As bonus the top will be an absorbing element for the join",
          "hierarchy": "Algebra Lattice Dropped",
          "module": "Algebra.Lattice.Dropped",
          "name": "Dropped",
          "package": "lattices",
          "partial": "Dropped",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Dropped.html#t:Dropped"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Dropped",
          "name": "Drop",
          "package": "lattices",
          "signature": "Drop a",
          "source": "src/Algebra-Lattice-Dropped.html#Dropped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Dropped",
          "module": "Algebra.Lattice.Dropped",
          "name": "Drop",
          "package": "lattices",
          "partial": "Drop",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Dropped.html#v:Drop"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Dropped",
          "name": "Top",
          "package": "lattices",
          "signature": "Top",
          "source": "src/Algebra-Lattice-Dropped.html#Dropped",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Dropped",
          "module": "Algebra.Lattice.Dropped",
          "name": "Top",
          "package": "lattices",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Dropped.html#v:Top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Levitated",
          "name": "Levitated",
          "package": "lattices",
          "source": "src/Algebra-Lattice-Levitated.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Lattice Levitated",
          "module": "Algebra.Lattice.Levitated",
          "name": "Levitated",
          "package": "lattices",
          "partial": "Levitated",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Levitated.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraft a distinct top and bottom onto an otherwise unbounded lattice.\n The top is the absorbing element for the join, and the bottom is the absorbing\n element for the meet.\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Levitated",
          "name": "Levitated",
          "package": "lattices",
          "source": "src/Algebra-Lattice-Levitated.html#Levitated",
          "type": "data"
        },
        "index": {
          "description": "Graft distinct top and bottom onto an otherwise unbounded lattice The top is the absorbing element for the join and the bottom is the absorbing element for the meet",
          "hierarchy": "Algebra Lattice Levitated",
          "module": "Algebra.Lattice.Levitated",
          "name": "Levitated",
          "package": "lattices",
          "partial": "Levitated",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Levitated.html#t:Levitated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Levitated",
          "name": "Bottom",
          "package": "lattices",
          "signature": "Bottom",
          "source": "src/Algebra-Lattice-Levitated.html#Levitated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Levitated",
          "module": "Algebra.Lattice.Levitated",
          "name": "Bottom",
          "package": "lattices",
          "partial": "Bottom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Levitated.html#v:Bottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Levitated",
          "name": "Levitate",
          "package": "lattices",
          "signature": "Levitate a",
          "source": "src/Algebra-Lattice-Levitated.html#Levitated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Levitated",
          "module": "Algebra.Lattice.Levitated",
          "name": "Levitate",
          "package": "lattices",
          "partial": "Levitate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Levitated.html#v:Levitate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Levitated",
          "name": "Top",
          "package": "lattices",
          "signature": "Top",
          "source": "src/Algebra-Lattice-Levitated.html#Levitated",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Levitated",
          "module": "Algebra.Lattice.Levitated",
          "name": "Top",
          "package": "lattices",
          "partial": "Top",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Levitated.html#v:Top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Lifted",
          "name": "Lifted",
          "package": "lattices",
          "source": "src/Algebra-Lattice-Lifted.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Lattice Lifted",
          "module": "Algebra.Lattice.Lifted",
          "name": "Lifted",
          "package": "lattices",
          "partial": "Lifted",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Lifted.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGraft a distinct bottom onto an otherwise unbounded lattice.\n As a bonus, the bottom will be an absorbing element for the meet.\n\u003c/p\u003e",
          "module": "Algebra.Lattice.Lifted",
          "name": "Lifted",
          "package": "lattices",
          "source": "src/Algebra-Lattice-Lifted.html#Lifted",
          "type": "data"
        },
        "index": {
          "description": "Graft distinct bottom onto an otherwise unbounded lattice As bonus the bottom will be an absorbing element for the meet",
          "hierarchy": "Algebra Lattice Lifted",
          "module": "Algebra.Lattice.Lifted",
          "name": "Lifted",
          "package": "lattices",
          "partial": "Lifted",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Lifted.html#t:Lifted"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Lifted",
          "name": "Bottom",
          "package": "lattices",
          "signature": "Bottom",
          "source": "src/Algebra-Lattice-Lifted.html#Lifted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Lifted",
          "module": "Algebra.Lattice.Lifted",
          "name": "Bottom",
          "package": "lattices",
          "partial": "Bottom",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Lifted.html#v:Bottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice.Lifted",
          "name": "Lift",
          "package": "lattices",
          "signature": "Lift a",
          "source": "src/Algebra-Lattice-Lifted.html#Lifted",
          "type": "function"
        },
        "index": {
          "hierarchy": "Algebra Lattice Lifted",
          "module": "Algebra.Lattice.Lifted",
          "name": "Lift",
          "package": "lattices",
          "partial": "Lift",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice-Lifted.html#v:Lift"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "Lattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "Lattice",
          "package": "lattices",
          "partial": "Lattice",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA join-semilattice with some element |bottom| that \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e approaches.\n\u003c/p\u003e\u003cp\u003eIdentity: x \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e bottom == x\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "BoundedJoinSemiLattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html#BoundedJoinSemiLattice",
          "type": "class"
        },
        "index": {
          "description": "join-semilattice with some element bottom that join approaches Identity join bottom",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "BoundedJoinSemiLattice",
          "package": "lattices",
          "partial": "Bounded Join Semi Lattice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#t:BoundedJoinSemiLattice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLattices with both bounds\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "BoundedLattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html#BoundedLattice",
          "type": "class"
        },
        "index": {
          "description": "Lattices with both bounds",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "BoundedLattice",
          "package": "lattices",
          "partial": "Bounded Lattice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#t:BoundedLattice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA meet-semilattice with some element |top| that \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e approaches.\n\u003c/p\u003e\u003cp\u003eIdentity: x \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e top == x\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "BoundedMeetSemiLattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html#BoundedMeetSemiLattice",
          "type": "class"
        },
        "index": {
          "description": "meet-semilattice with some element top that meet approaches Identity meet top",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "BoundedMeetSemiLattice",
          "package": "lattices",
          "partial": "Bounded Meet Semi Lattice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#t:BoundedMeetSemiLattice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA algebraic structure with element joins: \u003ca\u003ehttp://en.wikipedia.org/wiki/Semilattice\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eAssociativity: x \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e (y \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e z) == (x \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e y) \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e z\n Commutativity: x \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e y == y \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e x\n Idempotency:   x \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e x == x\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "JoinSemiLattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html#JoinSemiLattice",
          "type": "class"
        },
        "index": {
          "description": "algebraic structure with element joins http en.wikipedia.org wiki Semilattice Associativity join join join join Commutativity join join Idempotency join",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "JoinSemiLattice",
          "package": "lattices",
          "partial": "Join Semi Lattice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#t:JoinSemiLattice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe combination of two semi lattices makes a lattice if the absorption law holds:\n see \u003ca\u003ehttp://en.wikipedia.org/wiki/Absorption_law\u003c/a\u003e and \u003ca\u003ehttp://en.wikipedia.org/wiki/Lattice_(order)\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eAbsorption: a \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e (a \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e b) == a \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e (a \u003ccode\u003e\u003ca\u003ejoin\u003c/a\u003e\u003c/code\u003e b) == a\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "Lattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html#Lattice",
          "type": "class"
        },
        "index": {
          "description": "The combination of two semi lattices makes lattice if the absorption law holds see http en.wikipedia.org wiki Absorption law and http en.wikipedia.org wiki Lattice order Absorption join meet meet join",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "Lattice",
          "package": "lattices",
          "partial": "Lattice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#t:Lattice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA algebraic structure with element meets: \u003ca\u003ehttp://en.wikipedia.org/wiki/Semilattice\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eAssociativity: x \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e (y \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e z) == (x \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e y) \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e z\n Commutativity: x \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e y == y \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e x\n Idempotency:   x \u003ccode\u003e\u003ca\u003emeet\u003c/a\u003e\u003c/code\u003e x == x\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "MeetSemiLattice",
          "package": "lattices",
          "source": "src/Algebra-Lattice.html#MeetSemiLattice",
          "type": "class"
        },
        "index": {
          "description": "algebraic structure with element meets http en.wikipedia.org wiki Semilattice Associativity meet meet meet meet Commutativity meet meet Idempotency meet",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "MeetSemiLattice",
          "package": "lattices",
          "partial": "Meet Semi Lattice",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#t:MeetSemiLattice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "bottom",
          "package": "lattices",
          "signature": "a",
          "source": "src/Algebra-Lattice.html#bottom",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "bottom",
          "package": "lattices",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:bottom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of Kleene fixed-point theorem \u003ca\u003ehttp://en.wikipedia.org/wiki/Kleene_fixed-point_theorem\u003c/a\u003e.\n Forces the function to be antinone.\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "gfp",
          "package": "lattices",
          "signature": "(a -\u003e a) -\u003e a",
          "source": "src/Algebra-Lattice.html#gfp",
          "type": "function"
        },
        "index": {
          "description": "Implementation of Kleene fixed-point theorem http en.wikipedia.org wiki Kleene fixed-point theorem Forces the function to be antinone",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "gfp",
          "normalized": "(a-\u003ea)-\u003ea",
          "package": "lattices",
          "signature": "(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:gfp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of Kleene fixed-point theorem \u003ca\u003ehttp://en.wikipedia.org/wiki/Kleene_fixed-point_theorem\u003c/a\u003e.\n Forces the function to be antinone.\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "gfpFrom",
          "package": "lattices",
          "signature": "a -\u003e (a -\u003e a) -\u003e a",
          "source": "src/Algebra-Lattice.html#gfpFrom",
          "type": "function"
        },
        "index": {
          "description": "Implementation of Kleene fixed-point theorem http en.wikipedia.org wiki Kleene fixed-point theorem Forces the function to be antinone",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "gfpFrom",
          "normalized": "a-\u003e(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "From",
          "signature": "a-\u003e(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:gfpFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "join",
          "package": "lattices",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice.html#join",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "join",
          "normalized": "a-\u003ea-\u003ea",
          "package": "lattices",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:join"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe partial ordering induced by the join-semilattice structure\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "joinLeq",
          "package": "lattices",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#joinLeq",
          "type": "function"
        },
        "index": {
          "description": "The partial ordering induced by the join-semilattice structure",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "joinLeq",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "lattices",
          "partial": "Leq",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:joinLeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe join of a list of join-semilattice elements\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "joins",
          "package": "lattices",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Lattice.html#joins",
          "type": "function"
        },
        "index": {
          "description": "The join of list of join-semilattice elements",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "joins",
          "normalized": "[a]-\u003ea",
          "package": "lattices",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:joins"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe join of at a list of join-semilattice elements (of length at least one)\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "joins1",
          "package": "lattices",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Lattice.html#joins1",
          "type": "function"
        },
        "index": {
          "description": "The join of at list of join-semilattice elements of length at least one",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "joins1",
          "normalized": "[a]-\u003ea",
          "package": "lattices",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:joins1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of Kleene fixed-point theorem \u003ca\u003ehttp://en.wikipedia.org/wiki/Kleene_fixed-point_theorem\u003c/a\u003e.\n Forces the function to be monotone.\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "lfp",
          "package": "lattices",
          "signature": "(a -\u003e a) -\u003e a",
          "source": "src/Algebra-Lattice.html#lfp",
          "type": "function"
        },
        "index": {
          "description": "Implementation of Kleene fixed-point theorem http en.wikipedia.org wiki Kleene fixed-point theorem Forces the function to be monotone",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "lfp",
          "normalized": "(a-\u003ea)-\u003ea",
          "package": "lattices",
          "signature": "(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:lfp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of Kleene fixed-point theorem \u003ca\u003ehttp://en.wikipedia.org/wiki/Kleene_fixed-point_theorem\u003c/a\u003e.\n Forces the function to be monotone.\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "lfpFrom",
          "package": "lattices",
          "signature": "a -\u003e (a -\u003e a) -\u003e a",
          "source": "src/Algebra-Lattice.html#lfpFrom",
          "type": "function"
        },
        "index": {
          "description": "Implementation of Kleene fixed-point theorem http en.wikipedia.org wiki Kleene fixed-point theorem Forces the function to be monotone",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "lfpFrom",
          "normalized": "a-\u003e(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "From",
          "signature": "a-\u003e(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:lfpFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "meet",
          "package": "lattices",
          "signature": "a -\u003e a -\u003e a",
          "source": "src/Algebra-Lattice.html#meet",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "meet",
          "normalized": "a-\u003ea-\u003ea",
          "package": "lattices",
          "signature": "a-\u003ea-\u003ea",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:meet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe partial ordering induced by the meet-semilattice structure\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "meetLeq",
          "package": "lattices",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-Lattice.html#meetLeq",
          "type": "function"
        },
        "index": {
          "description": "The partial ordering induced by the meet-semilattice structure",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "meetLeq",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "lattices",
          "partial": "Leq",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:meetLeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe meet of a list of meet-semilattice elements\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "meets",
          "package": "lattices",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Lattice.html#meets",
          "type": "function"
        },
        "index": {
          "description": "The meet of list of meet-semilattice elements",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "meets",
          "normalized": "[a]-\u003ea",
          "package": "lattices",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:meets"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe meet of at a list of meet-semilattice elements (of length at least one)\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "meets1",
          "package": "lattices",
          "signature": "[a] -\u003e a",
          "source": "src/Algebra-Lattice.html#meets1",
          "type": "function"
        },
        "index": {
          "description": "The meet of at list of meet-semilattice elements of length at least one",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "meets1",
          "normalized": "[a]-\u003ea",
          "package": "lattices",
          "signature": "[a]-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:meets1"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.Lattice",
          "name": "top",
          "package": "lattices",
          "signature": "a",
          "source": "src/Algebra-Lattice.html#top",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "top",
          "package": "lattices",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:top"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of Kleene fixed-point theorem \u003ca\u003ehttp://en.wikipedia.org/wiki/Kleene_fixed-point_theorem\u003c/a\u003e.\n Assumes that the function is antinone and does not check if that is correct.\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "unsafeGfp",
          "package": "lattices",
          "signature": "(a -\u003e a) -\u003e a",
          "source": "src/Algebra-Lattice.html#unsafeGfp",
          "type": "function"
        },
        "index": {
          "description": "Implementation of Kleene fixed-point theorem http en.wikipedia.org wiki Kleene fixed-point theorem Assumes that the function is antinone and does not check if that is correct",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "unsafeGfp",
          "normalized": "(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "Gfp",
          "signature": "(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:unsafeGfp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImplementation of Kleene fixed-point theorem \u003ca\u003ehttp://en.wikipedia.org/wiki/Kleene_fixed-point_theorem\u003c/a\u003e.\n Assumes that the function is monotone and does not check if that is correct.\n\u003c/p\u003e",
          "module": "Algebra.Lattice",
          "name": "unsafeLfp",
          "package": "lattices",
          "signature": "(a -\u003e a) -\u003e a",
          "source": "src/Algebra-Lattice.html#unsafeLfp",
          "type": "function"
        },
        "index": {
          "description": "Implementation of Kleene fixed-point theorem http en.wikipedia.org wiki Kleene fixed-point theorem Assumes that the function is monotone and does not check if that is correct",
          "hierarchy": "Algebra Lattice",
          "module": "Algebra.Lattice",
          "name": "unsafeLfp",
          "normalized": "(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "Lfp",
          "signature": "(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-Lattice.html#v:unsafeLfp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PartialOrd",
          "name": "PartialOrd",
          "package": "lattices",
          "source": "src/Algebra-PartialOrd.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "PartialOrd",
          "package": "lattices",
          "partial": "Partial Ord",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA partial ordering on sets: \u003ca\u003ehttp://en.wikipedia.org/wiki/Partially_ordered_set\u003c/a\u003e\n\u003c/p\u003e\u003cp\u003eThis can be defined using either |joinLeq| or |meetLeq|, or a more efficient definition\n can be derived directly.\n\u003c/p\u003e\u003cp\u003eReflexive:     a \u003ccode\u003e\u003ca\u003eleq\u003c/a\u003e\u003c/code\u003e a\n Antisymmetric: a \u003ccode\u003e\u003ca\u003eleq\u003c/a\u003e\u003c/code\u003e b && b \u003ccode\u003e\u003ca\u003eleq\u003c/a\u003e\u003c/code\u003e a ==\u003e a == b\n Transitive:    a \u003ccode\u003e\u003ca\u003eleq\u003c/a\u003e\u003c/code\u003e b && b \u003ccode\u003e\u003ca\u003eleq\u003c/a\u003e\u003c/code\u003e c ==\u003e a \u003ccode\u003e\u003ca\u003eleq\u003c/a\u003e\u003c/code\u003e c\n\u003c/p\u003e\u003cp\u003eThe superclass equality (which can be defined using |partialOrdEq|) must obey these laws:\n\u003c/p\u003e\u003cp\u003eReflexive:  a == a\n Transitive: a == b && b == c ==\u003e a == b\n\u003c/p\u003e",
          "module": "Algebra.PartialOrd",
          "name": "PartialOrd",
          "package": "lattices",
          "source": "src/Algebra-PartialOrd.html#PartialOrd",
          "type": "class"
        },
        "index": {
          "description": "partial ordering on sets http en.wikipedia.org wiki Partially ordered set This can be defined using either joinLeq or meetLeq or more efficient definition can be derived directly Reflexive leq Antisymmetric leq leq Transitive leq leq leq The superclass equality which can be defined using partialOrdEq must obey these laws Reflexive Transitive",
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "PartialOrd",
          "package": "lattices",
          "partial": "Partial Ord",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#t:PartialOrd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreatest fixed point of a partially ordered antinone function. Checks that the function is antinone.\n\u003c/p\u003e",
          "module": "Algebra.PartialOrd",
          "name": "gfpFrom",
          "package": "lattices",
          "signature": "a -\u003e (a -\u003e a) -\u003e a",
          "source": "src/Algebra-PartialOrd.html#gfpFrom",
          "type": "function"
        },
        "index": {
          "description": "Greatest fixed point of partially ordered antinone function Checks that the function is antinone",
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "gfpFrom",
          "normalized": "a-\u003e(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "From",
          "signature": "a-\u003e(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#v:gfpFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Algebra.PartialOrd",
          "name": "leq",
          "package": "lattices",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PartialOrd.html#leq",
          "type": "method"
        },
        "index": {
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "leq",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "lattices",
          "signature": "a-\u003ea-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#v:leq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast point of a partially ordered monotone function. Checks that the function is monotone.\n\u003c/p\u003e",
          "module": "Algebra.PartialOrd",
          "name": "lfpFrom",
          "package": "lattices",
          "signature": "a -\u003e (a -\u003e a) -\u003e a",
          "source": "src/Algebra-PartialOrd.html#lfpFrom",
          "type": "function"
        },
        "index": {
          "description": "Least point of partially ordered monotone function Checks that the function is monotone",
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "lfpFrom",
          "normalized": "a-\u003e(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "From",
          "signature": "a-\u003e(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#v:lfpFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe equality relation induced by the partial-order structure\n\u003c/p\u003e",
          "module": "Algebra.PartialOrd",
          "name": "partialOrdEq",
          "package": "lattices",
          "signature": "a -\u003e a -\u003e Bool",
          "source": "src/Algebra-PartialOrd.html#partialOrdEq",
          "type": "function"
        },
        "index": {
          "description": "The equality relation induced by the partial-order structure",
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "partialOrdEq",
          "normalized": "a-\u003ea-\u003eBool",
          "package": "lattices",
          "partial": "Ord Eq",
          "signature": "a-\u003ea-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#v:partialOrdEq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGreatest fixed point of a partially ordered antinone function. Does not check that the function is antinone.\n\u003c/p\u003e",
          "module": "Algebra.PartialOrd",
          "name": "unsafeGfpFrom",
          "package": "lattices",
          "signature": "a -\u003e (a -\u003e a) -\u003e a",
          "source": "src/Algebra-PartialOrd.html#unsafeGfpFrom",
          "type": "function"
        },
        "index": {
          "description": "Greatest fixed point of partially ordered antinone function Does not check that the function is antinone",
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "unsafeGfpFrom",
          "normalized": "a-\u003e(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "Gfp From",
          "signature": "a-\u003e(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#v:unsafeGfpFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLeast point of a partially ordered monotone function. Does not checks that the function is monotone.\n\u003c/p\u003e",
          "module": "Algebra.PartialOrd",
          "name": "unsafeLfpFrom",
          "package": "lattices",
          "signature": "a -\u003e (a -\u003e a) -\u003e a",
          "source": "src/Algebra-PartialOrd.html#unsafeLfpFrom",
          "type": "function"
        },
        "index": {
          "description": "Least point of partially ordered monotone function Does not checks that the function is monotone",
          "hierarchy": "Algebra PartialOrd",
          "module": "Algebra.PartialOrd",
          "name": "unsafeLfpFrom",
          "normalized": "a-\u003e(a-\u003ea)-\u003ea",
          "package": "lattices",
          "partial": "Lfp From",
          "signature": "a-\u003e(a-\u003ea)-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/lattices/docs/Algebra-PartialOrd.html#v:unsafeLfpFrom"
      }
    }
  ]
]