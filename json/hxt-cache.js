[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "hxt-cache"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ResourceTable",
          "name": "ResourceTable",
          "package": "hxt-cache",
          "source": "src/Control-Concurrent-ResourceTable.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Concurrent ResourceTable",
          "module": "Control.Concurrent.ResourceTable",
          "name": "ResourceTable",
          "package": "hxt-cache",
          "partial": "Resource Table",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Control-Concurrent-ResourceTable.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ResourceTable",
          "name": "ResourceLock",
          "package": "hxt-cache",
          "source": "src/Control-Concurrent-ResourceTable.html#ResourceLock",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Concurrent ResourceTable",
          "module": "Control.Concurrent.ResourceTable",
          "name": "ResourceLock",
          "package": "hxt-cache",
          "partial": "Resource Lock",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Control-Concurrent-ResourceTable.html#t:ResourceLock"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ResourceTable",
          "name": "ResourceTable",
          "package": "hxt-cache",
          "source": "src/Control-Concurrent-ResourceTable.html#ResourceTable",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Concurrent ResourceTable",
          "module": "Control.Concurrent.ResourceTable",
          "name": "ResourceTable",
          "package": "hxt-cache",
          "partial": "Resource Table",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Control-Concurrent-ResourceTable.html#t:ResourceTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ResourceTable",
          "name": "newResourceTable",
          "package": "hxt-cache",
          "signature": "IO (ResourceTable a)",
          "source": "src/Control-Concurrent-ResourceTable.html#newResourceTable",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ResourceTable",
          "module": "Control.Concurrent.ResourceTable",
          "name": "newResourceTable",
          "package": "hxt-cache",
          "partial": "Resource Table",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Control-Concurrent-ResourceTable.html#v:newResourceTable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ResourceTable",
          "name": "releaseResource",
          "package": "hxt-cache",
          "signature": "ResourceTable a -\u003e a -\u003e IO ()",
          "source": "src/Control-Concurrent-ResourceTable.html#releaseResource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ResourceTable",
          "module": "Control.Concurrent.ResourceTable",
          "name": "releaseResource",
          "normalized": "ResourceTable a-\u003ea-\u003eIO()",
          "package": "hxt-cache",
          "partial": "Resource",
          "signature": "ResourceTable a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Control-Concurrent-ResourceTable.html#v:releaseResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Concurrent.ResourceTable",
          "name": "requestResource",
          "package": "hxt-cache",
          "signature": "ResourceTable a -\u003e a -\u003e IO ()",
          "source": "src/Control-Concurrent-ResourceTable.html#requestResource",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Concurrent ResourceTable",
          "module": "Control.Concurrent.ResourceTable",
          "name": "requestResource",
          "normalized": "ResourceTable a-\u003ea-\u003eIO()",
          "package": "hxt-cache",
          "partial": "Resource",
          "signature": "ResourceTable a-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Control-Concurrent-ResourceTable.html#v:requestResource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCaching of XML document trees and other binary data\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "XmlCache",
          "package": "hxt-cache",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html",
          "type": "module"
        },
        "index": {
          "description": "Caching of XML document trees and other binary data",
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "XmlCache",
          "package": "hxt-cache",
          "partial": "Xml Cache",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePredicate arrow for checking if a document is in the cache.\n The arrow fails if document not there or is not longer valid, else the file name is returned.\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "isInCache",
          "package": "hxt-cache",
          "signature": "IOStateArrow s String String",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#isInCache",
          "type": "function"
        },
        "index": {
          "description": "Predicate arrow for checking if document is in the cache The arrow fails if document not there or is not longer valid else the file name is returned",
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "isInCache",
          "package": "hxt-cache",
          "partial": "In Cache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:isInCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "lookupCache",
          "package": "hxt-cache",
          "signature": "String -\u003e IOStateArrow s a b",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#lookupCache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "lookupCache",
          "normalized": "String-\u003eIOStateArrow a b c",
          "package": "hxt-cache",
          "partial": "Cache",
          "signature": "String-\u003eIOStateArrow s a b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:lookupCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "readCache",
          "package": "hxt-cache",
          "signature": "String -\u003e IOStateArrow s b c",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#readCache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "readCache",
          "normalized": "String-\u003eIOStateArrow a b c",
          "package": "hxt-cache",
          "partial": "Cache",
          "signature": "String-\u003eIOStateArrow s b c",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:readCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "sha1HashString",
          "package": "hxt-cache",
          "signature": "a b String",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#sha1HashString",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "sha1HashString",
          "package": "hxt-cache",
          "partial": "Hash String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:sha1HashString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCompute the SHA1 hash is hexadecimal format for an arbitray serializable value\n\u003c/p\u003e",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "sha1HashValue",
          "package": "hxt-cache",
          "signature": "a b Integer",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#sha1HashValue",
          "type": "function"
        },
        "index": {
          "description": "Compute the SHA1 hash is hexadecimal format for an arbitray serializable value",
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "sha1HashValue",
          "package": "hxt-cache",
          "partial": "Hash Value",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:sha1HashValue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewithCache enables reading documents with caching.\n\u003c/p\u003e\u003cp\u003eWhen the cache is configured and enabled, every document read and parsed is serialized and stored in binary\n form in the cache. When reading the same document again, it is just deserialized, no parsing is performed.\n\u003c/p\u003e\u003cp\u003eThe cache is configured by a path pointing to a directory for storing the documents,\n by a maximal time span in second for valid documents. After that time span, the documents are read again\n and the cache is updated.\n The flag contols, whether documents returning 404 or other errors will be cached.\n If set, the cache is even activated for 404 (not found) responses, default is false.\n\u003c/p\u003e\u003cp\u003eThe serialized documents can be compressed, e.g. with bzip, to save disk space and IO time.\n The compression can be configured by \u003ccode\u003e\u003ca\u003ewithCompression\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cp\u003eexample:\n\u003c/p\u003e\u003cpre\u003e import Text.XML.HXT.Core\n import Text.XML.HXT.Cache\n import Codec.Compression.BZip (compress, decompress)\n ...\n readDocument [ withCache \"/tmp/cache\" 3600 False\n              , withCompression (compress, decompress)\n              , ....\n              ] \"http://www.haskell.org/\"\n\n\u003c/pre\u003e\u003cp\u003eIn the example the document is read and stored in binary serialized form under /tmp/cache.\n The cached document remains valid for the next hour.\n It is compressed, before written to disk.\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlCache\",\"Text.XML.HXT.Cache\"]",
          "name": "withCache",
          "package": "hxt-cache",
          "signature": "String -\u003e Int -\u003e Bool -\u003e SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#withCache",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:withCache\",\"http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Cache.html#v:withCache\"]"
        },
        "index": {
          "description": "withCache enables reading documents with caching When the cache is configured and enabled every document read and parsed is serialized and stored in binary form in the cache When reading the same document again it is just deserialized no parsing is performed The cache is configured by path pointing to directory for storing the documents by maximal time span in second for valid documents After that time span the documents are read again and the cache is updated The flag contols whether documents returning or other errors will be cached If set the cache is even activated for not found responses default is false The serialized documents can be compressed e.g with bzip to save disk space and IO time The compression can be configured by withCompression example import Text.XML.HXT.Core import Text.XML.HXT.Cache import Codec.Compression.BZip compress decompress readDocument withCache tmp cache False withCompression compress decompress http www.haskell.org In the example the document is read and stored in binary serialized form under tmp cache The cached document remains valid for the next hour It is compressed before written to disk",
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "withCache",
          "normalized": "String-\u003eInt-\u003eBool-\u003eSysConfig",
          "package": "hxt-cache",
          "partial": "Cache",
          "signature": "String-\u003eInt-\u003eBool-\u003eSysConfig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:withCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisable use of cache\n\u003c/p\u003e",
          "module": "[\"Text.XML.HXT.Arrow.XmlCache\",\"Text.XML.HXT.Cache\"]",
          "name": "withoutCache",
          "package": "hxt-cache",
          "signature": "SysConfig",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#withoutCache",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:withoutCache\",\"http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Cache.html#v:withoutCache\"]"
        },
        "index": {
          "description": "Disable use of cache",
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "withoutCache",
          "package": "hxt-cache",
          "partial": "Cache",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:withoutCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "writeCache",
          "package": "hxt-cache",
          "signature": "String -\u003e IOStateArrow s b ()",
          "source": "src/Text-XML-HXT-Arrow-XmlCache.html#writeCache",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text XML HXT Arrow XmlCache",
          "module": "Text.XML.HXT.Arrow.XmlCache",
          "name": "writeCache",
          "normalized": "String-\u003eIOStateArrow a b()",
          "package": "hxt-cache",
          "partial": "Cache",
          "signature": "String-\u003eIOStateArrow s b()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Arrow-XmlCache.html#v:writeCache"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eCaching of XML document trees and other binary data\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.XML.HXT.Cache",
          "name": "Cache",
          "package": "hxt-cache",
          "source": "src/Text-XML-HXT-Cache.html",
          "type": "module"
        },
        "index": {
          "description": "Caching of XML document trees and other binary data",
          "hierarchy": "Text XML HXT Cache",
          "module": "Text.XML.HXT.Cache",
          "name": "Cache",
          "package": "hxt-cache",
          "partial": "Cache",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/hxt-cache/docs/Text-XML-HXT-Cache.html#"
      }
    }
  ]
]