[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "haskell-src-exts"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains combinators to use when building\n Haskell source trees programmatically, as opposed to\n parsing them from a string. The contents here are quite\n experimental and will likely receive a lot of attention\n when the rest has stabilised.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "Build",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains combinators to use when building Haskell source trees programmatically as opposed to parsing them from string The contents here are quite experimental and will likely receive lot of attention when the rest has stabilised",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "Build",
          "package": "haskell-src-exts",
          "partial": "Build",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unguarded alternative in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "alt",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l -\u003e Exp l -\u003e Alt l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#alt",
          "type": "function"
        },
        "index": {
          "description": "An unguarded alternative in case expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "alt",
          "normalized": "a-\u003ePat a-\u003eExp a-\u003eAlt a",
          "package": "haskell-src-exts",
          "signature": "l-\u003ePat l-\u003eExp l-\u003eAlt l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative with a single guard in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "altGW",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l -\u003e [Stmt l] -\u003e Exp l -\u003e Binds l -\u003e Alt l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#altGW",
          "type": "function"
        },
        "index": {
          "description": "An alternative with single guard in case expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "altGW",
          "normalized": "a-\u003ePat a-\u003e[Stmt a]-\u003eExp a-\u003eBinds a-\u003eAlt a",
          "package": "haskell-src-exts",
          "partial": "GW",
          "signature": "l-\u003ePat l-\u003e[Stmt l]-\u003eExp l-\u003eBinds l-\u003eAlt l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:altGW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of expressions by juxtaposition.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "app",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l -\u003e Exp l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#app",
          "type": "function"
        },
        "index": {
          "description": "Application of expressions by juxtaposition",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "app",
          "normalized": "a-\u003eExp a-\u003eExp a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eExp l-\u003eExp l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to a list of arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "appFun",
          "package": "haskell-src-exts",
          "signature": "[l] -\u003e Exp l -\u003e [Exp l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#appFun",
          "type": "function"
        },
        "index": {
          "description": "Apply function to list of arguments",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "appFun",
          "normalized": "[a]-\u003eExp a-\u003e[Exp a]-\u003eExp a",
          "package": "haskell-src-exts",
          "partial": "Fun",
          "signature": "[l]-\u003eExp l-\u003e[Exp l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:appFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHoist a set of declarations to a binding group.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "binds",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Decl l] -\u003e Binds l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#binds",
          "type": "function"
        },
        "index": {
          "description": "Hoist set of declarations to binding group",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "binds",
          "normalized": "a-\u003e[Decl a]-\u003eBinds a",
          "package": "haskell-src-exts",
          "signature": "l-\u003e[Decl l]-\u003eBinds l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:binds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "caseE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l -\u003e [Alt l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#caseE",
          "type": "function"
        },
        "index": {
          "description": "case expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "caseE",
          "normalized": "a-\u003eExp a-\u003e[Alt a]-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eExp l-\u003e[Alt l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:caseE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal character expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "charE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Char -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#charE",
          "type": "function"
        },
        "index": {
          "description": "literal character expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "charE",
          "normalized": "a-\u003eChar-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eChar-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:charE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal character pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "charP",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Char -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#charP",
          "type": "function"
        },
        "index": {
          "description": "literal character pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "charP",
          "normalized": "a-\u003eChar-\u003ePat a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eChar-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:charP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA do block formed by the given statements.\n   The last statement in the list should be\n   a \u003ccode\u003e\u003ca\u003eQualifier\u003c/a\u003e\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "doE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Stmt l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#doE",
          "type": "function"
        },
        "index": {
          "description": "do block formed by the given statements The last statement in the list should be Qualifier expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "doE",
          "normalized": "a-\u003e[Stmt a]-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003e[Stmt l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:doE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty list expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "eList",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#eList",
          "type": "function"
        },
        "index": {
          "description": "The empty list expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "eList",
          "normalized": "a-\u003eExp a",
          "package": "haskell-src-exts",
          "partial": "List",
          "signature": "l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:eList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with a given name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "function",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#function",
          "type": "function"
        },
        "index": {
          "description": "function with given name",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "function",
          "normalized": "a-\u003eString-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eString-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate k names by appending numbers 1 through k to a given string.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "genNames",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e Int -\u003e [Name l]",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#genNames",
          "type": "function"
        },
        "index": {
          "description": "Generate names by appending numbers through to given string",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "genNames",
          "normalized": "a-\u003eString-\u003eInt-\u003e[Name a]",
          "package": "haskell-src-exts",
          "partial": "Names",
          "signature": "l-\u003eString-\u003eInt-\u003e[Name l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:genNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generator statement: \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e\u003c-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "genStmt",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l -\u003e Exp l -\u003e Stmt l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#genStmt",
          "type": "function"
        },
        "index": {
          "description": "generator statement pat exp",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "genStmt",
          "normalized": "a-\u003ePat a-\u003eExp a-\u003eStmt a",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "l-\u003ePat l-\u003eExp l-\u003eStmt l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:genStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply an operator infix.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "infixApp",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l -\u003e QOp l -\u003e Exp l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#infixApp",
          "type": "function"
        },
        "index": {
          "description": "Apply an operator infix",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "infixApp",
          "normalized": "a-\u003eExp a-\u003eQOp a-\u003eExp a-\u003eExp a",
          "package": "haskell-src-exts",
          "partial": "App",
          "signature": "l-\u003eExp l-\u003eQOp l-\u003eExp l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:infixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal integer expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "intE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Integer -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#intE",
          "type": "function"
        },
        "index": {
          "description": "literal integer expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "intE",
          "normalized": "a-\u003eInteger-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eInteger-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:intE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal integer pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "intP",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Integer -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#intP",
          "type": "function"
        },
        "index": {
          "description": "literal integer pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "intP",
          "normalized": "a-\u003eInteger-\u003ePat a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eInteger-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:intP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLambda abstraction, given a list of argument\n   patterns and an expression body.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "lamE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Pat l] -\u003e Exp l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#lamE",
          "type": "function"
        },
        "index": {
          "description": "Lambda abstraction given list of argument patterns and an expression body",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "lamE",
          "normalized": "a-\u003e[Pat a]-\u003eExp a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003e[Pat l]-\u003eExp l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:lamE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003elet\u003c/code\u003e ... \u003ccode\u003ein\u003c/code\u003e block.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "letE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Decl l] -\u003e Exp l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#letE",
          "type": "function"
        },
        "index": {
          "description": "let in block",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "letE",
          "normalized": "a-\u003e[Decl a]-\u003eExp a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003e[Decl l]-\u003eExp l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:letE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003elet\u003c/code\u003e binding group as a statement.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "letStmt",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Decl l] -\u003e Stmt l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#letStmt",
          "type": "function"
        },
        "index": {
          "description": "let binding group as statement",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "letStmt",
          "normalized": "a-\u003e[Decl a]-\u003eStmt a",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "l-\u003e[Decl l]-\u003eStmt l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:letStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "listE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Exp l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#listE",
          "type": "function"
        },
        "index": {
          "description": "list expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "listE",
          "normalized": "a-\u003e[Exp a]-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003e[Exp l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:listE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a constructor of a given name to a list of pattern\n   arguments, forming a constructor pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "metaConPat",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e [Pat l] -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#metaConPat",
          "type": "function"
        },
        "index": {
          "description": "Apply constructor of given name to list of pattern arguments forming constructor pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "metaConPat",
          "normalized": "a-\u003eString-\u003e[Pat a]-\u003ePat a",
          "package": "haskell-src-exts",
          "partial": "Con Pat",
          "signature": "l-\u003eString-\u003e[Pat l]-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:metaConPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply function of a given name to a list of arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "metaFunction",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e [Exp l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#metaFunction",
          "type": "function"
        },
        "index": {
          "description": "Apply function of given name to list of arguments",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "metaFunction",
          "normalized": "a-\u003eString-\u003e[Exp a]-\u003eExp a",
          "package": "haskell-src-exts",
          "partial": "Function",
          "signature": "l-\u003eString-\u003e[Exp l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:metaFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn identifier with the given string as its name.\n   The string should be a valid Haskell identifier.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#name",
          "type": "function"
        },
        "index": {
          "description": "An identifier with the given string as its name The string should be valid Haskell identifier",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "name",
          "normalized": "a-\u003eString-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eString-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBind an identifier to an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "nameBind",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e Exp l -\u003e Decl l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#nameBind",
          "type": "function"
        },
        "index": {
          "description": "Bind an identifier to an expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "nameBind",
          "normalized": "a-\u003eName a-\u003eExp a-\u003eDecl a",
          "package": "haskell-src-exts",
          "partial": "Bind",
          "signature": "l-\u003eName l-\u003eExp l-\u003eDecl l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:nameBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty binding group.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "noBinds",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Binds l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#noBinds",
          "type": "function"
        },
        "index": {
          "description": "An empty binding group",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "noBinds",
          "normalized": "a-\u003eBinds a",
          "package": "haskell-src-exts",
          "partial": "Binds",
          "signature": "l-\u003eBinds l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:noBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the given identifier as an operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "op",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e QOp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#op",
          "type": "function"
        },
        "index": {
          "description": "Use the given identifier as an operator",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "op",
          "normalized": "a-\u003eName a-\u003eQOp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l-\u003eQOp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA constructor pattern, with argument patterns.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pApp",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e [Pat l] -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#pApp",
          "type": "function"
        },
        "index": {
          "description": "constructor pattern with argument patterns",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pApp",
          "normalized": "a-\u003eName a-\u003e[Pat a]-\u003ePat a",
          "package": "haskell-src-exts",
          "partial": "App",
          "signature": "l-\u003eName l-\u003e[Pat l]-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:pApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut parentheses around a pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pParen",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#pParen",
          "type": "function"
        },
        "index": {
          "description": "Put parentheses around pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pParen",
          "normalized": "a-\u003ePat a-\u003ePat a",
          "package": "haskell-src-exts",
          "partial": "Paren",
          "signature": "l-\u003ePat l-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:pParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pTuple",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Pat l] -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#pTuple",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pTuple",
          "normalized": "a-\u003e[Pat a]-\u003ePat a",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "l-\u003e[Pat l]-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:pTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut parentheses around an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "paren",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#paren",
          "type": "function"
        },
        "index": {
          "description": "Put parentheses around an expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "paren",
          "normalized": "a-\u003eExp a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eExp l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern bind where the pattern is a variable, and where\n there are no guards and no 'where' clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "patBind",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l -\u003e Exp l -\u003e Decl l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#patBind",
          "type": "function"
        },
        "index": {
          "description": "pattern bind where the pattern is variable and where there are no guards and no where clause",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "patBind",
          "normalized": "a-\u003ePat a-\u003eExp a-\u003eDecl a",
          "package": "haskell-src-exts",
          "partial": "Bind",
          "signature": "l-\u003ePat l-\u003eExp l-\u003eDecl l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:patBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern bind where the pattern is a variable, and where\n there are no guards, but with a 'where' clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "patBindWhere",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l -\u003e Exp l -\u003e [Decl l] -\u003e Decl l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#patBindWhere",
          "type": "function"
        },
        "index": {
          "description": "pattern bind where the pattern is variable and where there are no guards but with where clause",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "patBindWhere",
          "normalized": "a-\u003ePat a-\u003eExp a-\u003e[Decl a]-\u003eDecl a",
          "package": "haskell-src-exts",
          "partial": "Bind Where",
          "signature": "l-\u003ePat l-\u003eExp l-\u003e[Decl l]-\u003eDecl l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:patBindWhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty list pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "peList",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#peList",
          "type": "function"
        },
        "index": {
          "description": "The empty list pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "peList",
          "normalized": "a-\u003ePat a",
          "package": "haskell-src-exts",
          "partial": "List",
          "signature": "l-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:peList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern variable.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pvar",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#pvar",
          "type": "function"
        },
        "index": {
          "description": "pattern variable",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pvar",
          "normalized": "a-\u003eName a-\u003ePat a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:pvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple pattern consisting of variables only.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pvarTuple",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Name l] -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#pvarTuple",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern consisting of variables only",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "pvarTuple",
          "normalized": "a-\u003e[Name a]-\u003ePat a",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "l-\u003e[Name l]-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:pvarTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA qualifier expression statement.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "qualStmt",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l -\u003e Stmt l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#qualStmt",
          "type": "function"
        },
        "index": {
          "description": "qualifier expression statement",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "qualStmt",
          "normalized": "a-\u003eExp a-\u003eStmt a",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "l-\u003eExp l-\u003eStmt l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:qualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA qualified variable as expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "qvar",
          "package": "haskell-src-exts",
          "signature": "l -\u003e ModuleName l -\u003e Name l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#qvar",
          "type": "function"
        },
        "index": {
          "description": "qualified variable as expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "qvar",
          "normalized": "a-\u003eModuleName a-\u003eName a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eModuleName l-\u003eName l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:qvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with a single clause\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "sfun",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e [Name l] -\u003e Rhs l -\u003e Maybe (Binds l) -\u003e Decl l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#sfun",
          "type": "function"
        },
        "index": {
          "description": "function with single clause",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "sfun",
          "normalized": "a-\u003eName a-\u003e[Name a]-\u003eRhs a-\u003eMaybe(Binds a)-\u003eDecl a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l-\u003e[Name l]-\u003eRhs l-\u003eMaybe(Binds l)-\u003eDecl l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:sfun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with a single clause, a single argument, no guards\n and no where declarations\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "simpleFun",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e Name l -\u003e Exp l -\u003e Decl l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#simpleFun",
          "type": "function"
        },
        "index": {
          "description": "function with single clause single argument no guards and no where declarations",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "simpleFun",
          "normalized": "a-\u003eName a-\u003eName a-\u003eExp a-\u003eDecl a",
          "package": "haskell-src-exts",
          "partial": "Fun",
          "signature": "l-\u003eName l-\u003eName l-\u003eExp l-\u003eDecl l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:simpleFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal string expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "strE",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#strE",
          "type": "function"
        },
        "index": {
          "description": "literal string expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "strE",
          "normalized": "a-\u003eString-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eString-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:strE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal string pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "strP",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#strP",
          "type": "function"
        },
        "index": {
          "description": "literal string pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "strP",
          "normalized": "a-\u003eString-\u003ePat a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eString-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:strP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA symbol identifier. The string should be a valid\n   Haskell symbol identifier.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "sym",
          "package": "haskell-src-exts",
          "signature": "l -\u003e String -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#sym",
          "type": "function"
        },
        "index": {
          "description": "symbol identifier The string should be valid Haskell symbol identifier",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "sym",
          "normalized": "a-\u003eString-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eString-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "tuple",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Exp l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#tuple",
          "type": "function"
        },
        "index": {
          "description": "tuple expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "tuple",
          "normalized": "a-\u003e[Exp a]-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003e[Exp l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA local variable as expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "var",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#var",
          "type": "function"
        },
        "index": {
          "description": "local variable as expression",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "var",
          "normalized": "a-\u003eName a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple expression consisting of variables only.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "varTuple",
          "package": "haskell-src-exts",
          "signature": "l -\u003e [Name l] -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#varTuple",
          "type": "function"
        },
        "index": {
          "description": "tuple expression consisting of variables only",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "varTuple",
          "normalized": "a-\u003e[Name a]-\u003eExp a",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "l-\u003e[Name l]-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:varTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe wildcard pattern: \u003ccode\u003e_\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "wildcard",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Pat l",
          "source": "src/Language-Haskell-Exts-Annotated-Build.html#wildcard",
          "type": "function"
        },
        "index": {
          "description": "The wildcard pattern",
          "hierarchy": "Language Haskell Exts Annotated Build",
          "module": "Language.Haskell.Exts.Annotated.Build",
          "name": "wildcard",
          "normalized": "a-\u003ePat a",
          "package": "haskell-src-exts",
          "signature": "l-\u003ePat l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Build.html#v:wildcard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExact-printer for Haskell abstract syntax. The input is a (semi-concrete)\n abstract syntax tree, annotated with exact source information to enable\n printing the tree exactly as it was parsed.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Annotated.ExactPrint",
          "name": "ExactPrint",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-ExactPrint.html",
          "type": "module"
        },
        "index": {
          "description": "Exact-printer for Haskell abstract syntax The input is semi-concrete abstract syntax tree annotated with exact source information to enable printing the tree exactly as it was parsed",
          "hierarchy": "Language Haskell Exts Annotated ExactPrint",
          "module": "Language.Haskell.Exts.Annotated.ExactPrint",
          "name": "ExactPrint",
          "package": "haskell-src-exts",
          "partial": "Exact Print",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-ExactPrint.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.ExactPrint",
          "name": "ExactP",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-ExactPrint.html#ExactP",
          "type": "class"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated ExactPrint",
          "module": "Language.Haskell.Exts.Annotated.ExactPrint",
          "name": "ExactP",
          "package": "haskell-src-exts",
          "partial": "Exact",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-ExactPrint.html#t:ExactP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePrint an AST exactly as specified by the annotations on the nodes in the tree.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.ExactPrint",
          "name": "exactPrint",
          "package": "haskell-src-exts",
          "signature": "ast SrcSpanInfo -\u003e [Comment] -\u003e String",
          "source": "src/Language-Haskell-Exts-Annotated-ExactPrint.html#exactPrint",
          "type": "function"
        },
        "index": {
          "description": "Print an AST exactly as specified by the annotations on the nodes in the tree",
          "hierarchy": "Language Haskell Exts Annotated ExactPrint",
          "module": "Language.Haskell.Exts.Annotated.ExactPrint",
          "name": "exactPrint",
          "normalized": "a SrcSpanInfo-\u003e[Comment]-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Print",
          "signature": "ast SrcSpanInfo-\u003e[Comment]-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-ExactPrint.html#v:exactPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFixity information to give the parser so that infix operators can\n be parsed properly.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Fixity.html",
          "type": "module"
        },
        "index": {
          "description": "Fixity information to give the parser so that infix operators can be parsed properly",
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "partial": "Fixity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll AST elements that may include expressions which in turn may\n   need fixity tweaking will be instances of this class.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "AppFixity",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Fixity.html#AppFixity",
          "type": "class"
        },
        "index": {
          "description": "All AST elements that may include expressions which in turn may need fixity tweaking will be instances of this class",
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "AppFixity",
          "package": "haskell-src-exts",
          "partial": "App Fixity",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#t:AppFixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperator fixities are represented by their associativity\n   (left, right or none) and their precedence (0-9).\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Fixity.html#Fixity",
          "type": "data"
        },
        "index": {
          "description": "Operator fixities are represented by their associativity left right or none and their precedence",
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "partial": "Fixity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#t:Fixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Fixity\",\"Language.Haskell.Exts.Fixity\"]",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "signature": "Fixity Assoc Int QName",
          "source": "src/Language-Haskell-Exts-Fixity.html#Fixity",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:Fixity\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:Fixity\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "partial": "Fixity",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:Fixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTweak any expressions in the element to account for the\n   fixities given. Assumes that all operator expressions are\n   fully left associative chains to begin with.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "applyFixities",
          "package": "haskell-src-exts",
          "signature": "applyFixities",
          "source": "src/Language-Haskell-Exts-Annotated-Fixity.html#applyFixities",
          "type": "method"
        },
        "index": {
          "description": "Tweak any expressions in the element to account for the fixities given Assumes that all operator expressions are fully left associative chains to begin with",
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "applyFixities",
          "package": "haskell-src-exts",
          "partial": "Fixities",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:applyFixities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll fixities defined in the base package.\n\u003c/p\u003e\u003cp\u003eNote that the \u003ccode\u003e+++\u003c/code\u003e operator appears in both Control.Arrows and\n   Text.ParserCombinators.ReadP. The listed precedence for \u003ccode\u003e+++\u003c/code\u003e in\n   this list is that of Control.Arrows.\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.Exts.Annotated.Fixity\",\"Language.Haskell.Exts.Fixity\"]",
          "name": "baseFixities",
          "package": "haskell-src-exts",
          "signature": "[Fixity]",
          "source": "src/Language-Haskell-Exts-Fixity.html#baseFixities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:baseFixities\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:baseFixities\"]"
        },
        "index": {
          "description": "All fixities defined in the base package Note that the operator appears in both Control.Arrows and Text.ParserCombinators.ReadP The listed precedence for in this list is that of Control.Arrows",
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "baseFixities",
          "normalized": "[Fixity]",
          "package": "haskell-src-exts",
          "partial": "Fixities",
          "signature": "[Fixity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:baseFixities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Fixity\",\"Language.Haskell.Exts.Fixity\"]",
          "name": "infix_",
          "package": "haskell-src-exts",
          "signature": "Int -\u003e [String] -\u003e [Fixity]",
          "source": "src/Language-Haskell-Exts-Fixity.html#infix_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:infix_\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:infix_\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "infix_",
          "normalized": "Int-\u003e[String]-\u003e[Fixity]",
          "package": "haskell-src-exts",
          "signature": "Int-\u003e[String]-\u003e[Fixity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:infix_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Fixity\",\"Language.Haskell.Exts.Fixity\"]",
          "name": "infixl_",
          "package": "haskell-src-exts",
          "signature": "Int -\u003e [String] -\u003e [Fixity]",
          "source": "src/Language-Haskell-Exts-Fixity.html#infixl_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:infixl_\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:infixl_\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "infixl_",
          "normalized": "Int-\u003e[String]-\u003e[Fixity]",
          "package": "haskell-src-exts",
          "signature": "Int-\u003e[String]-\u003e[Fixity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:infixl_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Fixity\",\"Language.Haskell.Exts.Fixity\"]",
          "name": "infixr_",
          "package": "haskell-src-exts",
          "signature": "Int -\u003e [String] -\u003e [Fixity]",
          "source": "src/Language-Haskell-Exts-Fixity.html#infixr_",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:infixr_\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:infixr_\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "infixr_",
          "normalized": "Int-\u003e[String]-\u003e[Fixity]",
          "package": "haskell-src-exts",
          "signature": "Int-\u003e[String]-\u003e[Fixity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:infixr_"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll fixities defined in the Prelude.\n\u003c/p\u003e",
          "module": "[\"Language.Haskell.Exts.Annotated.Fixity\",\"Language.Haskell.Exts.Fixity\"]",
          "name": "preludeFixities",
          "package": "haskell-src-exts",
          "signature": "[Fixity]",
          "source": "src/Language-Haskell-Exts-Fixity.html#preludeFixities",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:preludeFixities\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:preludeFixities\"]"
        },
        "index": {
          "description": "All fixities defined in the Prelude",
          "hierarchy": "Language Haskell Exts Annotated Fixity",
          "module": "Language.Haskell.Exts.Annotated.Fixity",
          "name": "preludeFixities",
          "normalized": "[Fixity]",
          "package": "haskell-src-exts",
          "partial": "Fixities",
          "signature": "[Fixity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Fixity.html#v:preludeFixities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains code for translating from the annotated\n complex AST in Language.Haskell.Exts.Annotated.Syntax\n to the simpler, sparsely annotated AST in Language.Haskell.Exts.Syntax.\n\u003c/p\u003e\u003cp\u003eA function \u003ccode\u003esXYZ\u003c/code\u003e translates an annotated AST node of type \u003ccode\u003eXYZ l\u003c/code\u003e into\n a simple AST node of type \u003ccode\u003eXYZ\u003c/code\u003e. I would have prefered to use a MPTC\n with an fd/type family to get a single exported function name, but\n I wish to stay Haskell 2010 compliant. Let's hope for Haskell 2011.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "Simplify",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains code for translating from the annotated complex AST in Language.Haskell.Exts.Annotated.Syntax to the simpler sparsely annotated AST in Language.Haskell.Exts.Syntax function sXYZ translates an annotated AST node of type XYZ into simple AST node of type XYZ would have prefered to use MPTC with an fd type family to get single exported function name but wish to stay Haskell compliant Let hope for Haskell",
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "Simplify",
          "package": "haskell-src-exts",
          "partial": "Simplify",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sActivation",
          "package": "haskell-src-exts",
          "signature": "Activation l -\u003e Activation",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sActivation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sActivation",
          "normalized": "Activation a-\u003eActivation",
          "package": "haskell-src-exts",
          "partial": "Activation",
          "signature": "Activation l-\u003eActivation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sActivation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAlt",
          "package": "haskell-src-exts",
          "signature": "Alt loc -\u003e Alt",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAlt",
          "normalized": "Alt a-\u003eAlt",
          "package": "haskell-src-exts",
          "partial": "Alt",
          "signature": "Alt loc-\u003eAlt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAnnotation",
          "package": "haskell-src-exts",
          "signature": "Annotation loc -\u003e Annotation",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sAnnotation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAnnotation",
          "normalized": "Annotation a-\u003eAnnotation",
          "package": "haskell-src-exts",
          "partial": "Annotation",
          "signature": "Annotation loc-\u003eAnnotation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sAnnotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAssoc",
          "package": "haskell-src-exts",
          "signature": "Assoc l -\u003e Assoc",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sAssoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAssoc",
          "normalized": "Assoc a-\u003eAssoc",
          "package": "haskell-src-exts",
          "partial": "Assoc",
          "signature": "Assoc l-\u003eAssoc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sAssoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAsst",
          "package": "haskell-src-exts",
          "signature": "Asst l -\u003e Asst",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sAsst",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sAsst",
          "normalized": "Asst a-\u003eAsst",
          "package": "haskell-src-exts",
          "partial": "Asst",
          "signature": "Asst l-\u003eAsst",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sAsst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sBangType",
          "package": "haskell-src-exts",
          "signature": "BangType l -\u003e BangType",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sBangType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sBangType",
          "normalized": "BangType a-\u003eBangType",
          "package": "haskell-src-exts",
          "partial": "Bang Type",
          "signature": "BangType l-\u003eBangType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sBangType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sBinds",
          "package": "haskell-src-exts",
          "signature": "Binds loc -\u003e Binds",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sBinds",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sBinds",
          "normalized": "Binds a-\u003eBinds",
          "package": "haskell-src-exts",
          "partial": "Binds",
          "signature": "Binds loc-\u003eBinds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sBracket",
          "package": "haskell-src-exts",
          "signature": "Bracket loc -\u003e Bracket",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sBracket",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sBracket",
          "normalized": "Bracket a-\u003eBracket",
          "package": "haskell-src-exts",
          "partial": "Bracket",
          "signature": "Bracket loc-\u003eBracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sCName",
          "package": "haskell-src-exts",
          "signature": "CName l -\u003e CName",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sCName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sCName",
          "normalized": "CName a-\u003eCName",
          "package": "haskell-src-exts",
          "partial": "CName",
          "signature": "CName l-\u003eCName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sCName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sCallConv",
          "package": "haskell-src-exts",
          "signature": "CallConv l -\u003e CallConv",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sCallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sCallConv",
          "normalized": "CallConv a-\u003eCallConv",
          "package": "haskell-src-exts",
          "partial": "Call Conv",
          "signature": "CallConv l-\u003eCallConv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sCallConv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sClassDecl",
          "package": "haskell-src-exts",
          "signature": "ClassDecl loc -\u003e ClassDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sClassDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sClassDecl",
          "normalized": "ClassDecl a-\u003eClassDecl",
          "package": "haskell-src-exts",
          "partial": "Class Decl",
          "signature": "ClassDecl loc-\u003eClassDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sClassDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sConDecl",
          "package": "haskell-src-exts",
          "signature": "ConDecl l -\u003e ConDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sConDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sConDecl",
          "normalized": "ConDecl a-\u003eConDecl",
          "package": "haskell-src-exts",
          "partial": "Con Decl",
          "signature": "ConDecl l-\u003eConDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sContext",
          "package": "haskell-src-exts",
          "signature": "Context l -\u003e Context",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sContext",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sContext",
          "normalized": "Context a-\u003eContext",
          "package": "haskell-src-exts",
          "partial": "Context",
          "signature": "Context l-\u003eContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDataOrNew",
          "package": "haskell-src-exts",
          "signature": "DataOrNew l -\u003e DataOrNew",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sDataOrNew",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDataOrNew",
          "normalized": "DataOrNew a-\u003eDataOrNew",
          "package": "haskell-src-exts",
          "partial": "Data Or New",
          "signature": "DataOrNew l-\u003eDataOrNew",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sDataOrNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate an annotated AST node representing a Haskell declaration\n   into a simpler version. Note that in the simpler version, all declaration\n   nodes are still annotated by \u003ccode\u003e\u003ca\u003eSrcLoc\u003c/a\u003e\u003c/code\u003es.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDecl",
          "package": "haskell-src-exts",
          "signature": "Decl loc -\u003e Decl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sDecl",
          "type": "function"
        },
        "index": {
          "description": "Translate an annotated AST node representing Haskell declaration into simpler version Note that in the simpler version all declaration nodes are still annotated by SrcLoc",
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDecl",
          "normalized": "Decl a-\u003eDecl",
          "package": "haskell-src-exts",
          "partial": "Decl",
          "signature": "Decl loc-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDeclHead",
          "package": "haskell-src-exts",
          "signature": "DeclHead l -\u003e (Name, [TyVarBind])",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sDeclHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDeclHead",
          "normalized": "DeclHead a-\u003e(Name,[TyVarBind])",
          "package": "haskell-src-exts",
          "partial": "Decl Head",
          "signature": "DeclHead l-\u003e(Name,[TyVarBind])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sDeclHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDeriving",
          "package": "haskell-src-exts",
          "signature": "Deriving l -\u003e [(QName, [Type])]",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sDeriving",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sDeriving",
          "normalized": "Deriving a-\u003e[(QName,[Type])]",
          "package": "haskell-src-exts",
          "partial": "Deriving",
          "signature": "Deriving l-\u003e[(QName,[Type])]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sDeriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sExp",
          "package": "haskell-src-exts",
          "signature": "Exp loc -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sExp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sExp",
          "normalized": "Exp a-\u003eExp",
          "package": "haskell-src-exts",
          "partial": "Exp",
          "signature": "Exp loc-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sExportSpec",
          "package": "haskell-src-exts",
          "signature": "ExportSpec l -\u003e ExportSpec",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sExportSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sExportSpec",
          "normalized": "ExportSpec a-\u003eExportSpec",
          "package": "haskell-src-exts",
          "partial": "Export Spec",
          "signature": "ExportSpec l-\u003eExportSpec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sExportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sExportSpecList",
          "package": "haskell-src-exts",
          "signature": "ExportSpecList l -\u003e [ExportSpec]",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sExportSpecList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sExportSpecList",
          "normalized": "ExportSpecList a-\u003e[ExportSpec]",
          "package": "haskell-src-exts",
          "partial": "Export Spec List",
          "signature": "ExportSpecList l-\u003e[ExportSpec]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sExportSpecList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sFieldDecl",
          "package": "haskell-src-exts",
          "signature": "FieldDecl l -\u003e ([Name], BangType)",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sFieldDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sFieldDecl",
          "normalized": "FieldDecl a-\u003e([Name],BangType)",
          "package": "haskell-src-exts",
          "partial": "Field Decl",
          "signature": "FieldDecl l-\u003e([Name],BangType)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sFieldDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sFieldUpdate",
          "package": "haskell-src-exts",
          "signature": "FieldUpdate loc -\u003e FieldUpdate",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sFieldUpdate",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sFieldUpdate",
          "normalized": "FieldUpdate a-\u003eFieldUpdate",
          "package": "haskell-src-exts",
          "partial": "Field Update",
          "signature": "FieldUpdate loc-\u003eFieldUpdate",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sFieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sFunDep",
          "package": "haskell-src-exts",
          "signature": "FunDep l -\u003e FunDep",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sFunDep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sFunDep",
          "normalized": "FunDep a-\u003eFunDep",
          "package": "haskell-src-exts",
          "partial": "Fun Dep",
          "signature": "FunDep l-\u003eFunDep",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sFunDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGadtDecl",
          "package": "haskell-src-exts",
          "signature": "GadtDecl loc -\u003e GadtDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sGadtDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGadtDecl",
          "normalized": "GadtDecl a-\u003eGadtDecl",
          "package": "haskell-src-exts",
          "partial": "Gadt Decl",
          "signature": "GadtDecl loc-\u003eGadtDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sGadtDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGuardedAlt",
          "package": "haskell-src-exts",
          "signature": "GuardedAlt loc -\u003e GuardedAlt",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sGuardedAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGuardedAlt",
          "normalized": "GuardedAlt a-\u003eGuardedAlt",
          "package": "haskell-src-exts",
          "partial": "Guarded Alt",
          "signature": "GuardedAlt loc-\u003eGuardedAlt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sGuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGuardedAlts",
          "package": "haskell-src-exts",
          "signature": "GuardedAlts loc -\u003e GuardedAlts",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sGuardedAlts",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGuardedAlts",
          "normalized": "GuardedAlts a-\u003eGuardedAlts",
          "package": "haskell-src-exts",
          "partial": "Guarded Alts",
          "signature": "GuardedAlts loc-\u003eGuardedAlts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sGuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGuardedRhs",
          "package": "haskell-src-exts",
          "signature": "GuardedRhs loc -\u003e GuardedRhs",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sGuardedRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sGuardedRhs",
          "normalized": "GuardedRhs a-\u003eGuardedRhs",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhs",
          "signature": "GuardedRhs loc-\u003eGuardedRhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sGuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sIPBind",
          "package": "haskell-src-exts",
          "signature": "IPBind loc -\u003e IPBind",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sIPBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sIPBind",
          "normalized": "IPBind a-\u003eIPBind",
          "package": "haskell-src-exts",
          "partial": "IPBind",
          "signature": "IPBind loc-\u003eIPBind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sIPBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sIPName",
          "package": "haskell-src-exts",
          "signature": "IPName l -\u003e IPName",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sIPName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sIPName",
          "normalized": "IPName a-\u003eIPName",
          "package": "haskell-src-exts",
          "partial": "IPName",
          "signature": "IPName l-\u003eIPName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sIPName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sImportDecl",
          "package": "haskell-src-exts",
          "signature": "ImportDecl loc -\u003e ImportDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sImportDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sImportDecl",
          "normalized": "ImportDecl a-\u003eImportDecl",
          "package": "haskell-src-exts",
          "partial": "Import Decl",
          "signature": "ImportDecl loc-\u003eImportDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sImportSpec",
          "package": "haskell-src-exts",
          "signature": "ImportSpec l -\u003e ImportSpec",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sImportSpec",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sImportSpec",
          "normalized": "ImportSpec a-\u003eImportSpec",
          "package": "haskell-src-exts",
          "partial": "Import Spec",
          "signature": "ImportSpec l-\u003eImportSpec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sImportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sImportSpecList",
          "package": "haskell-src-exts",
          "signature": "ImportSpecList l -\u003e (Bool, [ImportSpec])",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sImportSpecList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sImportSpecList",
          "normalized": "ImportSpecList a-\u003e(Bool,[ImportSpec])",
          "package": "haskell-src-exts",
          "partial": "Import Spec List",
          "signature": "ImportSpecList l-\u003e(Bool,[ImportSpec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sImportSpecList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sInstDecl",
          "package": "haskell-src-exts",
          "signature": "InstDecl loc -\u003e InstDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sInstDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sInstDecl",
          "normalized": "InstDecl a-\u003eInstDecl",
          "package": "haskell-src-exts",
          "partial": "Inst Decl",
          "signature": "InstDecl loc-\u003eInstDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sInstDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sInstHead",
          "package": "haskell-src-exts",
          "signature": "InstHead l -\u003e (QName, [Type])",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sInstHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sInstHead",
          "normalized": "InstHead a-\u003e(QName,[Type])",
          "package": "haskell-src-exts",
          "partial": "Inst Head",
          "signature": "InstHead l-\u003e(QName,[Type])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sInstHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sKind",
          "package": "haskell-src-exts",
          "signature": "Kind l -\u003e Kind",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sKind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sKind",
          "normalized": "Kind a-\u003eKind",
          "package": "haskell-src-exts",
          "partial": "Kind",
          "signature": "Kind l-\u003eKind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sLiteral",
          "package": "haskell-src-exts",
          "signature": "Literal l -\u003e Literal",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sLiteral",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sLiteral",
          "normalized": "Literal a-\u003eLiteral",
          "package": "haskell-src-exts",
          "partial": "Literal",
          "signature": "Literal l-\u003eLiteral",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sLiteral"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sMatch",
          "package": "haskell-src-exts",
          "signature": "Match loc -\u003e Match",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sMatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sMatch",
          "normalized": "Match a-\u003eMatch",
          "package": "haskell-src-exts",
          "partial": "Match",
          "signature": "Match loc-\u003eMatch",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTranslate an annotated AST node representing a Haskell module, into\n   a simpler version that retains (almost) only abstract information.\n   In particular, XML and hybrid XML pages enabled by the XmlSyntax extension\n   are translated into standard Haskell modules with a \u003ccode\u003epage\u003c/code\u003e function.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModule",
          "package": "haskell-src-exts",
          "signature": "Module loc -\u003e Module",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sModule",
          "type": "function"
        },
        "index": {
          "description": "Translate an annotated AST node representing Haskell module into simpler version that retains almost only abstract information In particular XML and hybrid XML pages enabled by the XmlSyntax extension are translated into standard Haskell modules with page function",
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModule",
          "normalized": "Module a-\u003eModule",
          "package": "haskell-src-exts",
          "partial": "Module",
          "signature": "Module loc-\u003eModule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModuleHead",
          "package": "haskell-src-exts",
          "signature": "Maybe (ModuleHead l) -\u003e (ModuleName, Maybe WarningText, Maybe [ExportSpec])",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sModuleHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModuleHead",
          "normalized": "Maybe(ModuleHead a)-\u003e(ModuleName,Maybe WarningText,Maybe[ExportSpec])",
          "package": "haskell-src-exts",
          "partial": "Module Head",
          "signature": "Maybe(ModuleHead l)-\u003e(ModuleName,Maybe WarningText,Maybe[ExportSpec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sModuleHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModuleName",
          "package": "haskell-src-exts",
          "signature": "ModuleName l -\u003e ModuleName",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sModuleName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModuleName",
          "normalized": "ModuleName a-\u003eModuleName",
          "package": "haskell-src-exts",
          "partial": "Module Name",
          "signature": "ModuleName l-\u003eModuleName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModulePragma",
          "package": "haskell-src-exts",
          "signature": "ModulePragma loc -\u003e ModulePragma",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sModulePragma",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sModulePragma",
          "normalized": "ModulePragma a-\u003eModulePragma",
          "package": "haskell-src-exts",
          "partial": "Module Pragma",
          "signature": "ModulePragma loc-\u003eModulePragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sModulePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sName",
          "package": "haskell-src-exts",
          "signature": "Name l -\u003e Name",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sName",
          "normalized": "Name a-\u003eName",
          "package": "haskell-src-exts",
          "partial": "Name",
          "signature": "Name l-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sOp",
          "package": "haskell-src-exts",
          "signature": "Op l -\u003e Op",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sOp",
          "normalized": "Op a-\u003eOp",
          "package": "haskell-src-exts",
          "partial": "Op",
          "signature": "Op l-\u003eOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sPXAttr",
          "package": "haskell-src-exts",
          "signature": "PXAttr loc -\u003e PXAttr",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sPXAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sPXAttr",
          "normalized": "PXAttr a-\u003ePXAttr",
          "package": "haskell-src-exts",
          "partial": "PXAttr",
          "signature": "PXAttr loc-\u003ePXAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sPXAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sPat",
          "package": "haskell-src-exts",
          "signature": "Pat loc -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sPat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sPat",
          "normalized": "Pat a-\u003ePat",
          "package": "haskell-src-exts",
          "partial": "Pat",
          "signature": "Pat loc-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sPatField",
          "package": "haskell-src-exts",
          "signature": "PatField loc -\u003e PatField",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sPatField",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sPatField",
          "normalized": "PatField a-\u003ePatField",
          "package": "haskell-src-exts",
          "partial": "Pat Field",
          "signature": "PatField loc-\u003ePatField",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sPatField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQName",
          "package": "haskell-src-exts",
          "signature": "QName l -\u003e QName",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sQName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQName",
          "normalized": "QName a-\u003eQName",
          "package": "haskell-src-exts",
          "partial": "QName",
          "signature": "QName l-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sQName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQOp",
          "package": "haskell-src-exts",
          "signature": "QOp l -\u003e QOp",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sQOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQOp",
          "normalized": "QOp a-\u003eQOp",
          "package": "haskell-src-exts",
          "partial": "QOp",
          "signature": "QOp l-\u003eQOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sQOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQualConDecl",
          "package": "haskell-src-exts",
          "signature": "QualConDecl loc -\u003e QualConDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sQualConDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQualConDecl",
          "normalized": "QualConDecl a-\u003eQualConDecl",
          "package": "haskell-src-exts",
          "partial": "Qual Con Decl",
          "signature": "QualConDecl loc-\u003eQualConDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sQualConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQualStmt",
          "package": "haskell-src-exts",
          "signature": "QualStmt loc -\u003e QualStmt",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sQualStmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sQualStmt",
          "normalized": "QualStmt a-\u003eQualStmt",
          "package": "haskell-src-exts",
          "partial": "Qual Stmt",
          "signature": "QualStmt loc-\u003eQualStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sQualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRPat",
          "package": "haskell-src-exts",
          "signature": "RPat loc -\u003e RPat",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sRPat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRPat",
          "normalized": "RPat a-\u003eRPat",
          "package": "haskell-src-exts",
          "partial": "RPat",
          "signature": "RPat loc-\u003eRPat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sRPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRPatOp",
          "package": "haskell-src-exts",
          "signature": "RPatOp l -\u003e RPatOp",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sRPatOp",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRPatOp",
          "normalized": "RPatOp a-\u003eRPatOp",
          "package": "haskell-src-exts",
          "partial": "RPat Op",
          "signature": "RPatOp l-\u003eRPatOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sRPatOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRhs",
          "package": "haskell-src-exts",
          "signature": "Rhs loc -\u003e Rhs",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRhs",
          "normalized": "Rhs a-\u003eRhs",
          "package": "haskell-src-exts",
          "partial": "Rhs",
          "signature": "Rhs loc-\u003eRhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRule",
          "package": "haskell-src-exts",
          "signature": "Rule loc -\u003e Rule",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sRule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRule",
          "normalized": "Rule a-\u003eRule",
          "package": "haskell-src-exts",
          "partial": "Rule",
          "signature": "Rule loc-\u003eRule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRuleVar",
          "package": "haskell-src-exts",
          "signature": "RuleVar l -\u003e RuleVar",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sRuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sRuleVar",
          "normalized": "RuleVar a-\u003eRuleVar",
          "package": "haskell-src-exts",
          "partial": "Rule Var",
          "signature": "RuleVar l-\u003eRuleVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sRuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sSafety",
          "package": "haskell-src-exts",
          "signature": "Safety l -\u003e Safety",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sSafety",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sSafety",
          "normalized": "Safety a-\u003eSafety",
          "package": "haskell-src-exts",
          "partial": "Safety",
          "signature": "Safety l-\u003eSafety",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sSafety"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sSpecialCon",
          "package": "haskell-src-exts",
          "signature": "SpecialCon l -\u003e SpecialCon",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sSpecialCon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sSpecialCon",
          "normalized": "SpecialCon a-\u003eSpecialCon",
          "package": "haskell-src-exts",
          "partial": "Special Con",
          "signature": "SpecialCon l-\u003eSpecialCon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sSpecialCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sSplice",
          "package": "haskell-src-exts",
          "signature": "Splice loc -\u003e Splice",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sSplice",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sSplice",
          "normalized": "Splice a-\u003eSplice",
          "package": "haskell-src-exts",
          "partial": "Splice",
          "signature": "Splice loc-\u003eSplice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sSplice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sStmt",
          "package": "haskell-src-exts",
          "signature": "Stmt loc -\u003e Stmt",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sStmt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sStmt",
          "normalized": "Stmt a-\u003eStmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "Stmt loc-\u003eStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sTyVarBind",
          "package": "haskell-src-exts",
          "signature": "TyVarBind l -\u003e TyVarBind",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sTyVarBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sTyVarBind",
          "normalized": "TyVarBind a-\u003eTyVarBind",
          "package": "haskell-src-exts",
          "partial": "Ty Var Bind",
          "signature": "TyVarBind l-\u003eTyVarBind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sTyVarBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sType",
          "package": "haskell-src-exts",
          "signature": "Type l -\u003e Type",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sType",
          "normalized": "Type a-\u003eType",
          "package": "haskell-src-exts",
          "partial": "Type",
          "signature": "Type l-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sWarningText",
          "package": "haskell-src-exts",
          "signature": "WarningText l -\u003e WarningText",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sWarningText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sWarningText",
          "normalized": "WarningText a-\u003eWarningText",
          "package": "haskell-src-exts",
          "partial": "Warning Text",
          "signature": "WarningText l-\u003eWarningText",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sWarningText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sXAttr",
          "package": "haskell-src-exts",
          "signature": "XAttr loc -\u003e XAttr",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sXAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sXAttr",
          "normalized": "XAttr a-\u003eXAttr",
          "package": "haskell-src-exts",
          "partial": "XAttr",
          "signature": "XAttr loc-\u003eXAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sXAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sXName",
          "package": "haskell-src-exts",
          "signature": "XName l -\u003e XName",
          "source": "src/Language-Haskell-Exts-Annotated-Simplify.html#sXName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Simplify",
          "module": "Language.Haskell.Exts.Annotated.Simplify",
          "name": "sXName",
          "normalized": "XName a-\u003eXName",
          "package": "haskell-src-exts",
          "partial": "XName",
          "signature": "XName l-\u003eXName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Simplify.html#v:sXName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA suite of datatypes describing the (semi-concrete) abstract syntax of Haskell 98\n \u003ca\u003ehttp://www.haskell.org/onlinereport/\u003c/a\u003e plus registered extensions, including:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e multi-parameter type classes with functional dependencies (MultiParamTypeClasses, FunctionalDependencies)\n\u003c/li\u003e\u003cli\u003e parameters of type class assertions are unrestricted (FlexibleContexts)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eforall\u003c/code\u003e types as universal and existential quantification (RankNTypes, ExistentialQuantification, etc)\n\u003c/li\u003e\u003cli\u003e pattern guards (PatternGuards)\n\u003c/li\u003e\u003cli\u003e implicit parameters (ImplicitParameters)\n\u003c/li\u003e\u003cli\u003e generalised algebraic data types (GADTs)\n\u003c/li\u003e\u003cli\u003e template haskell (TemplateHaskell)\n\u003c/li\u003e\u003cli\u003e empty data type declarations (EmptyDataDecls)\n\u003c/li\u003e\u003cli\u003e unboxed tuples (UnboxedTuples)\n\u003c/li\u003e\u003cli\u003e regular patterns (RegularPatterns)\n\u003c/li\u003e\u003cli\u003e HSP-style XML expressions and patterns (XmlSyntax)\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eAll nodes in the syntax tree are annotated with something of a user-definable data type.\n When parsing, this annotation will contain information about the source location that the\n particular node comes from.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Syntax",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "suite of datatypes describing the semi-concrete abstract syntax of Haskell http www.haskell.org onlinereport plus registered extensions including multi-parameter type classes with functional dependencies MultiParamTypeClasses FunctionalDependencies parameters of type class assertions are unrestricted FlexibleContexts forall types as universal and existential quantification RankNTypes ExistentialQuantification etc pattern guards PatternGuards implicit parameters ImplicitParameters generalised algebraic data types GADTs template haskell TemplateHaskell empty data type declarations EmptyDataDecls unboxed tuples UnboxedTuples regular patterns RegularPatterns HSP-style XML expressions and patterns XmlSyntax All nodes in the syntax tree are annotated with something of user-definable data type When parsing this annotation will contain information about the source location that the particular node comes from",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Syntax",
          "package": "haskell-src-exts",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActivation clause of a RULES pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Activation",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Activation",
          "type": "data"
        },
        "index": {
          "description": "Activation clause of RULES pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Activation",
          "package": "haskell-src-exts",
          "partial": "Activation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Activation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003ealt\u003c/em\u003e alternative in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Alt",
          "type": "data"
        },
        "index": {
          "description": "An alt alternative in case expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "partial": "Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAST nodes are annotated, and this class allows manipulation of the annotations.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Annotated",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Annotated",
          "type": "class"
        },
        "index": {
          "description": "AST nodes are annotated and this class allows manipulation of the annotations",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Annotated",
          "package": "haskell-src-exts",
          "partial": "Annotated",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Annotated"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation through an ANN pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Annotation",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Annotation",
          "type": "data"
        },
        "index": {
          "description": "An annotation through an ANN pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Annotation",
          "package": "haskell-src-exts",
          "partial": "Annotation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Annotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssociativity of an operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Assoc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Assoc",
          "type": "data"
        },
        "index": {
          "description": "Associativity of an operator",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Assoc",
          "package": "haskell-src-exts",
          "partial": "Assoc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Assoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass assertions.\n   In Haskell 98, the argument would be a \u003cem\u003etyvar\u003c/em\u003e, but this definition\n   allows multiple parameters, and allows them to be \u003cem\u003etype\u003c/em\u003es.\n   Also extended with support for implicit parameters and equality constraints.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Asst",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Asst",
          "type": "data"
        },
        "index": {
          "description": "Class assertions In Haskell the argument would be tyvar but this definition allows multiple parameters and allows them to be type Also extended with support for implicit parameters and equality constraints",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Asst",
          "package": "haskell-src-exts",
          "partial": "Asst",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Asst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a constructor argument or field, optionally including\n   a strictness annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BangType",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#BangType",
          "type": "data"
        },
        "index": {
          "description": "The type of constructor argument or field optionally including strictness annotation",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BangType",
          "package": "haskell-src-exts",
          "partial": "Bang Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:BangType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binding group inside a \u003ccode\u003elet\u003c/code\u003e or \u003ccode\u003ewhere\u003c/code\u003e clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Binds",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Binds",
          "type": "data"
        },
        "index": {
          "description": "binding group inside let or where clause",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Binds",
          "package": "haskell-src-exts",
          "partial": "Binds",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Binds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlag denoting whether a tuple is boxed or unboxed.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Boxed",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Boxed",
          "type": "data"
        },
        "index": {
          "description": "Flag denoting whether tuple is boxed or unboxed",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Boxed",
          "package": "haskell-src-exts",
          "partial": "Boxed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Boxed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA template haskell bracket expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Bracket",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Bracket",
          "type": "data"
        },
        "index": {
          "description": "template haskell bracket expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Bracket",
          "package": "haskell-src-exts",
          "partial": "Bracket",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA name (\u003cem\u003ecname\u003c/em\u003e) of a component of a class or data type in an \u003ccode\u003eimport\u003c/code\u003e\n or export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CName",
          "type": "data"
        },
        "index": {
          "description": "name cname of component of class or data type in an import or export specification",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CName",
          "package": "haskell-src-exts",
          "partial": "CName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:CName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe calling convention of a foreign function call.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CallConv",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "data"
        },
        "index": {
          "description": "The calling convention of foreign function call",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CallConv",
          "package": "haskell-src-exts",
          "partial": "Call Conv",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:CallConv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclarations inside a class declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClassDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ClassDecl",
          "type": "data"
        },
        "index": {
          "description": "Declarations inside class declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClassDecl",
          "package": "haskell-src-exts",
          "partial": "Class Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ClassDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaration of an ordinary data constructor.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ConDecl",
          "type": "data"
        },
        "index": {
          "description": "Declaration of an ordinary data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConDecl",
          "package": "haskell-src-exts",
          "partial": "Con Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA context is a set of assertions\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Context",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Context",
          "type": "data"
        },
        "index": {
          "description": "context is set of assertions",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Context",
          "package": "haskell-src-exts",
          "partial": "Context",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flag stating whether a declaration is a data or newtype declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataOrNew",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DataOrNew",
          "type": "data"
        },
        "index": {
          "description": "flag stating whether declaration is data or newtype declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataOrNew",
          "package": "haskell-src-exts",
          "partial": "Data Or New",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:DataOrNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA top-level declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Decl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "data"
        },
        "index": {
          "description": "top-level declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Decl",
          "package": "haskell-src-exts",
          "partial": "Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe head of a type or class declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeclHead",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DeclHead",
          "type": "data"
        },
        "index": {
          "description": "The head of type or class declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeclHead",
          "package": "haskell-src-exts",
          "partial": "Decl Head",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:DeclHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA deriving clause following a data type declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Deriving",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Deriving",
          "type": "data"
        },
        "index": {
          "description": "deriving clause following data type declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Deriving",
          "package": "haskell-src-exts",
          "partial": "Deriving",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Deriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell expressions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Exp",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "data"
        },
        "index": {
          "description": "Haskell expressions",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Exp",
          "package": "haskell-src-exts",
          "partial": "Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn item in a module's export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExportSpec",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpec",
          "type": "data"
        },
        "index": {
          "description": "An item in module export specification",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExportSpec",
          "package": "haskell-src-exts",
          "partial": "Export Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ExportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicit export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExportSpecList",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpecList",
          "type": "data"
        },
        "index": {
          "description": "An explicit export specification",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExportSpecList",
          "package": "haskell-src-exts",
          "partial": "Export Spec List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ExportSpecList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaration of a (list of) named field(s).\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FieldDecl",
          "type": "data"
        },
        "index": {
          "description": "Declaration of list of named field",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldDecl",
          "package": "haskell-src-exts",
          "partial": "Field Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:FieldDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003efbind\u003c/em\u003e in a labeled construction or update expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FieldUpdate",
          "type": "data"
        },
        "index": {
          "description": "An fbind in labeled construction or update expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "partial": "Field Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:FieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA functional dependency, given on the form\n   l1 l2 ... ln -\u003e r2 r3 .. rn\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunDep",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FunDep",
          "type": "data"
        },
        "index": {
          "description": "functional dependency given on the form l1 l2 ln r2 r3 rn",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunDep",
          "package": "haskell-src-exts",
          "partial": "Fun Dep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:FunDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single constructor declaration in a GADT data type declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GadtDecl",
          "type": "data"
        },
        "index": {
          "description": "single constructor declaration in GADT data type declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "partial": "Gadt Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:GadtDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA guarded case alternative \u003ccode\u003e|\u003c/code\u003e \u003cem\u003estmts\u003c/em\u003e \u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedAlt",
          "type": "data"
        },
        "index": {
          "description": "guarded case alternative stmts exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlt",
          "package": "haskell-src-exts",
          "partial": "Guarded Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:GuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe right-hand sides of a \u003ccode\u003ecase\u003c/code\u003e alternative,\n   which may be a single right-hand side or a\n   set of guarded ones.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlts",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedAlts",
          "type": "data"
        },
        "index": {
          "description": "The right-hand sides of case alternative which may be single right-hand side or set of guarded ones",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlts",
          "package": "haskell-src-exts",
          "partial": "Guarded Alts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:GuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA guarded right hand side \u003ccode\u003e|\u003c/code\u003e \u003cem\u003estmts\u003c/em\u003e \u003ccode\u003e=\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e.\n   The guard is a series of statements when using pattern guards,\n   otherwise it will be a single qualifier expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedRhs",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedRhs",
          "type": "data"
        },
        "index": {
          "description": "guarded right hand side stmts exp The guard is series of statements when using pattern guards otherwise it will be single qualifier expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedRhs",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:GuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binding of an implicit parameter.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#IPBind",
          "type": "data"
        },
        "index": {
          "description": "binding of an implicit parameter",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "partial": "IPBind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:IPBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn implicit parameter name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#IPName",
          "type": "data"
        },
        "index": {
          "description": "An implicit parameter name",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPName",
          "package": "haskell-src-exts",
          "partial": "IPName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:IPName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn import declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "data"
        },
        "index": {
          "description": "An import declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "partial": "Import Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn import specification, representing a single explicit item imported\n   (or hidden) from a module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportSpec",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpec",
          "type": "data"
        },
        "index": {
          "description": "An import specification representing single explicit item imported or hidden from module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportSpec",
          "package": "haskell-src-exts",
          "partial": "Import Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ImportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicit import specification list.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportSpecList",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpecList",
          "type": "data"
        },
        "index": {
          "description": "An explicit import specification list",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportSpecList",
          "package": "haskell-src-exts",
          "partial": "Import Spec List",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ImportSpecList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclarations inside an instance declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstDecl",
          "type": "data"
        },
        "index": {
          "description": "Declarations inside an instance declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstDecl",
          "package": "haskell-src-exts",
          "partial": "Inst Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:InstDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe head of an instance declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstHead",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstHead",
          "type": "data"
        },
        "index": {
          "description": "The head of an instance declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstHead",
          "package": "haskell-src-exts",
          "partial": "Inst Head",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:InstHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicit kind annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Kind",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Kind",
          "type": "data"
        },
        "index": {
          "description": "An explicit kind annotation",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Kind",
          "package": "haskell-src-exts",
          "partial": "Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eliteral\u003c/em\u003e\n Values of this type hold the abstract value of the literal, along with the\n precise string representation used.  For example, \u003ccode\u003e10\u003c/code\u003e, \u003ccode\u003e0o12\u003c/code\u003e and \u003ccode\u003e0xa\u003c/code\u003e\n have the same value representation, but each carry a different string representation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Literal",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "data"
        },
        "index": {
          "description": "literal Values of this type hold the abstract value of the literal along with the precise string representation used For example o12 and xa have the same value representation but each carry different string representation",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Literal",
          "package": "haskell-src-exts",
          "partial": "Literal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClauses of a function binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Match",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Match",
          "type": "data"
        },
        "index": {
          "description": "Clauses of function binding",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Match",
          "package": "haskell-src-exts",
          "partial": "Match",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA complete Haskell source module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Module",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Module",
          "type": "data"
        },
        "index": {
          "description": "complete Haskell source module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Module",
          "package": "haskell-src-exts",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe head of a module, including the name and export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleHead",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModuleHead",
          "type": "data"
        },
        "index": {
          "description": "The head of module including the name and export specification",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleHead",
          "package": "haskell-src-exts",
          "partial": "Module Head",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ModuleHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of a Haskell module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModuleName",
          "type": "data"
        },
        "index": {
          "description": "The name of Haskell module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "partial": "Module Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA top level options pragma, preceding the module header.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModulePragma",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModulePragma",
          "type": "data"
        },
        "index": {
          "description": "top level options pragma preceding the module header",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModulePragma",
          "package": "haskell-src-exts",
          "partial": "Module Pragma",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:ModulePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used to represent variables, and also constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Name",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Name",
          "type": "data"
        },
        "index": {
          "description": "This type is used to represent variables and also constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Name",
          "package": "haskell-src-exts",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperators appearing in \u003ccode\u003einfix\u003c/code\u003e declarations are never qualified.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Op",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Op",
          "type": "data"
        },
        "index": {
          "description": "Operators appearing in infix declarations are never qualified",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Op",
          "package": "haskell-src-exts",
          "partial": "Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn XML attribute in a pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#PXAttr",
          "type": "data"
        },
        "index": {
          "description": "An XML attribute in pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "partial": "PXAttr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:PXAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern, to be matched against a value.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Pat",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "data"
        },
        "index": {
          "description": "pattern to be matched against value",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Pat",
          "package": "haskell-src-exts",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003efpat\u003c/em\u003e in a labeled record pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatField",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#PatField",
          "type": "data"
        },
        "index": {
          "description": "An fpat in labeled record pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatField",
          "package": "haskell-src-exts",
          "partial": "Pat Field",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:PatField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used to represent qualified variables, and also\n qualified constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QName",
          "type": "data"
        },
        "index": {
          "description": "This type is used to represent qualified variables and also qualified constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QName",
          "package": "haskell-src-exts",
          "partial": "QName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:QName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly qualified infix operators (\u003cem\u003eqop\u003c/em\u003e), appearing in expressions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QOp",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QOp",
          "type": "data"
        },
        "index": {
          "description": "Possibly qualified infix operators qop appearing in expressions",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QOp",
          "package": "haskell-src-exts",
          "partial": "QOp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:QOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single constructor declaration within a data type declaration,\n   which may have an existential quantification binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualConDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualConDecl",
          "type": "data"
        },
        "index": {
          "description": "single constructor declaration within data type declaration which may have an existential quantification binding",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualConDecl",
          "package": "haskell-src-exts",
          "partial": "Qual Con Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:QualConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA general \u003cem\u003etransqual\u003c/em\u003e in a list comprehension,\n   which could potentially be a transform of the kind\n   enabled by TransformListComp.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "data"
        },
        "index": {
          "description": "general transqual in list comprehension which could potentially be transform of the kind enabled by TransformListComp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "partial": "Qual Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:QualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn entity in a regular pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPat",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "data"
        },
        "index": {
          "description": "An entity in regular pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPat",
          "package": "haskell-src-exts",
          "partial": "RPat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:RPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular pattern operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPatOp",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "data"
        },
        "index": {
          "description": "regular pattern operator",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPatOp",
          "package": "haskell-src-exts",
          "partial": "RPat Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:RPatOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe right hand side of a function or pattern binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Rhs",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Rhs",
          "type": "data"
        },
        "index": {
          "description": "The right hand side of function or pattern binding",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Rhs",
          "package": "haskell-src-exts",
          "partial": "Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Rhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe body of a RULES pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Rule",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Rule",
          "type": "data"
        },
        "index": {
          "description": "The body of RULES pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Rule",
          "package": "haskell-src-exts",
          "partial": "Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariables used in a RULES pragma, optionally annotated with types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RuleVar",
          "type": "data"
        },
        "index": {
          "description": "Variables used in RULES pragma optionally annotated with types",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "partial": "Rule Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:RuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe safety of a foreign function call.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Safety",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Safety",
          "type": "data"
        },
        "index": {
          "description": "The safety of foreign function call",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Safety",
          "package": "haskell-src-exts",
          "partial": "Safety",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Safety"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructors with special syntax.\n These names are never qualified, and always refer to builtin type or\n data constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpecialCon",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "data"
        },
        "index": {
          "description": "Constructors with special syntax These names are never qualified and always refer to builtin type or data constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpecialCon",
          "package": "haskell-src-exts",
          "partial": "Special Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:SpecialCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA template haskell splice expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Splice",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Splice",
          "type": "data"
        },
        "index": {
          "description": "template haskell splice expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Splice",
          "package": "haskell-src-exts",
          "partial": "Splice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Splice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA statement, representing both a \u003cem\u003estmt\u003c/em\u003e in a \u003ccode\u003edo\u003c/code\u003e-expression,\n   an ordinary \u003cem\u003equal\u003c/em\u003e in a list comprehension, as well as a \u003cem\u003estmt\u003c/em\u003e\n   in a pattern guard.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Stmt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Stmt",
          "type": "data"
        },
        "index": {
          "description": "statement representing both stmt in do expression an ordinary qual in list comprehension as well as stmt in pattern guard",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Stmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Stmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecognised tools for OPTIONS pragmas.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Tool",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "data"
        },
        "index": {
          "description": "Recognised tools for OPTIONS pragmas",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Tool",
          "package": "haskell-src-exts",
          "partial": "Tool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Tool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type variable declaration, optionally with an explicit kind annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyVarBind",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#TyVarBind",
          "type": "data"
        },
        "index": {
          "description": "type variable declaration optionally with an explicit kind annotation",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyVarBind",
          "package": "haskell-src-exts",
          "partial": "Ty Var Bind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:TyVarBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type qualified with a context.\n   An unqualified type has an empty context.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Type",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "data"
        },
        "index": {
          "description": "type qualified with context An unqualified type has an empty context",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Type",
          "package": "haskell-src-exts",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWarning text to optionally use in the module header of e.g.\n   a deprecated module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "WarningText",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#WarningText",
          "type": "data"
        },
        "index": {
          "description": "Warning text to optionally use in the module header of e.g deprecated module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "WarningText",
          "package": "haskell-src-exts",
          "partial": "Warning Text",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:WarningText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn xml attribute, which is a name-expression pair.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#XAttr",
          "type": "data"
        },
        "index": {
          "description": "An xml attribute which is name-expression pair",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "partial": "XAttr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:XAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of an xml element or attribute,\n   possibly qualified with a namespace.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#XName",
          "type": "data"
        },
        "index": {
          "description": "The name of an xml element or attribute possibly qualified with namespace",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "partial": "XName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:XName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if two AST elements are equal modulo annotations.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "(=~=)",
          "package": "haskell-src-exts",
          "signature": "a l1 -\u003e a l2 -\u003e Bool",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#%3D~%3D",
          "type": "function"
        },
        "index": {
          "description": "Test if two AST elements are equal modulo annotations",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "(=~=) =~=",
          "normalized": "a b-\u003ea b-\u003eBool",
          "package": "haskell-src-exts",
          "signature": "a l-\u003ea l-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:-61--126--61-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ActiveFrom",
          "package": "haskell-src-exts",
          "signature": "ActiveFrom l Int",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Activation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ActiveFrom",
          "package": "haskell-src-exts",
          "partial": "Active From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ActiveFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ActiveUntil",
          "package": "haskell-src-exts",
          "signature": "ActiveUntil l Int",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Activation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ActiveUntil",
          "package": "haskell-src-exts",
          "partial": "Active Until",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ActiveUntil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "signature": "Alt l (Pat l) (GuardedAlts l) (Maybe (Binds l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Alt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "partial": "Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation for a declared name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Ann",
          "package": "haskell-src-exts",
          "signature": "Ann l (Name l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Annotation",
          "type": "function"
        },
        "index": {
          "description": "An annotation for declared name",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Ann",
          "package": "haskell-src-exts",
          "partial": "Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eANN pragma with module scope\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AnnModulePragma",
          "package": "haskell-src-exts",
          "signature": "AnnModulePragma l (Annotation l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModulePragma",
          "type": "function"
        },
        "index": {
          "description": "ANN pragma with module scope",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AnnModulePragma",
          "package": "haskell-src-exts",
          "partial": "Ann Module Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:AnnModulePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn ANN pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AnnPragma",
          "package": "haskell-src-exts",
          "signature": "AnnPragma l (Annotation l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An ANN pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AnnPragma",
          "package": "haskell-src-exts",
          "partial": "Ann Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:AnnPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary application\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "App",
          "package": "haskell-src-exts",
          "signature": "App l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "ordinary application",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "App",
          "package": "haskell-src-exts",
          "partial": "App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:App"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft-associative operator (declared with \u003ccode\u003einfixl\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AssocLeft",
          "package": "haskell-src-exts",
          "signature": "AssocLeft l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Assoc",
          "type": "function"
        },
        "index": {
          "description": "left-associative operator declared with infixl",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AssocLeft",
          "package": "haskell-src-exts",
          "partial": "Assoc Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:AssocLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-associative operator (declared with \u003ccode\u003einfix\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AssocNone",
          "package": "haskell-src-exts",
          "signature": "AssocNone l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Assoc",
          "type": "function"
        },
        "index": {
          "description": "non-associative operator declared with infix",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AssocNone",
          "package": "haskell-src-exts",
          "partial": "Assoc None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:AssocNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eright-associative operator (declared with \u003ccode\u003einfixr\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AssocRight",
          "package": "haskell-src-exts",
          "signature": "AssocRight l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Assoc",
          "type": "function"
        },
        "index": {
          "description": "right-associative operator declared with infixr",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "AssocRight",
          "package": "haskell-src-exts",
          "partial": "Assoc Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:AssocRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn ordinary binding group\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BDecls",
          "package": "haskell-src-exts",
          "signature": "BDecls l [Decl l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Binds",
          "type": "function"
        },
        "index": {
          "description": "An ordinary binding group",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BDecls",
          "normalized": "BDecls a[Decl a]",
          "package": "haskell-src-exts",
          "partial": "BDecls",
          "signature": "BDecls l[Decl l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:BDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estrict component, marked with \"\u003ccode\u003e!\u003c/code\u003e\"\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BangedTy",
          "package": "haskell-src-exts",
          "signature": "BangedTy l (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#BangType",
          "type": "function"
        },
        "index": {
          "description": "strict component marked with",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BangedTy",
          "package": "haskell-src-exts",
          "partial": "Banged Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:BangedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "Boxed",
          "package": "haskell-src-exts",
          "signature": "Boxed",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Boxed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Boxed\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Boxed\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Boxed",
          "package": "haskell-src-exts",
          "partial": "Boxed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Boxed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etemplate haskell bracket expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BracketExp",
          "package": "haskell-src-exts",
          "signature": "BracketExp l (Bracket l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "template haskell bracket expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "BracketExp",
          "package": "haskell-src-exts",
          "partial": "Bracket Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:BracketExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CApi",
          "package": "haskell-src-exts",
          "signature": "CApi l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CApi",
          "package": "haskell-src-exts",
          "partial": "CApi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CApi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CCall",
          "package": "haskell-src-exts",
          "signature": "CCall l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CCall",
          "package": "haskell-src-exts",
          "partial": "CCall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CPlusPlus",
          "package": "haskell-src-exts",
          "signature": "CPlusPlus l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CPlusPlus",
          "package": "haskell-src-exts",
          "partial": "CPlus Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CPlusPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecase\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eof\u003c/code\u003e \u003cem\u003ealts\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Case",
          "package": "haskell-src-exts",
          "signature": "Case l (Exp l) [Alt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "case exp of alts",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Case",
          "normalized": "Case a(Exp a)[Alt a]",
          "package": "haskell-src-exts",
          "partial": "Case",
          "signature": "Case l(Exp l)[Alt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Case"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echaracter literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Char",
          "package": "haskell-src-exts",
          "signature": "Char l Char String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "character literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Char",
          "package": "haskell-src-exts",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary class assertion\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClassA",
          "package": "haskell-src-exts",
          "signature": "ClassA l (QName l) [Type l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "ordinary class assertion",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClassA",
          "normalized": "ClassA a(QName a)[Type a]",
          "package": "haskell-src-exts",
          "partial": "Class",
          "signature": "ClassA l(QName l)[Type l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ClassA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA declaration of a type class\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClassDecl",
          "package": "haskell-src-exts",
          "signature": "ClassDecl l (Maybe (Context l)) (DeclHead l) [FunDep l] (Maybe [ClassDecl l])",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "declaration of type class",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClassDecl",
          "normalized": "ClassDecl a(Maybe(Context a))(DeclHead a)[FunDep a](Maybe[ClassDecl a])",
          "package": "haskell-src-exts",
          "partial": "Class Decl",
          "signature": "ClassDecl l(Maybe(Context l))(DeclHead l)[FunDep l](Maybe[ClassDecl l])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ClassDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeclaration of an associated data type\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsDataFam",
          "package": "haskell-src-exts",
          "signature": "ClsDataFam l (Maybe (Context l)) (DeclHead l) (Maybe (Kind l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "declaration of an associated data type",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsDataFam",
          "package": "haskell-src-exts",
          "partial": "Cls Data Fam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ClsDataFam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsDecl",
          "package": "haskell-src-exts",
          "signature": "ClsDecl l (Decl l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsDecl",
          "package": "haskell-src-exts",
          "partial": "Cls Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ClsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault choice for an associated type synonym\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsTyDef",
          "package": "haskell-src-exts",
          "signature": "ClsTyDef l (Type l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "default choice for an associated type synonym",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsTyDef",
          "package": "haskell-src-exts",
          "partial": "Cls Ty Def",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ClsTyDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeclaration of an associated type synonym\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsTyFam",
          "package": "haskell-src-exts",
          "signature": "ClsTyFam l (DeclHead l) (Maybe (Kind l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "declaration of an associated type synonym",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ClsTyFam",
          "package": "haskell-src-exts",
          "partial": "Cls Ty Fam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ClsTyFam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Con",
          "package": "haskell-src-exts",
          "signature": "Con l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Con",
          "package": "haskell-src-exts",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConDecl",
          "package": "haskell-src-exts",
          "signature": "ConDecl l (Name l) [BangType l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ConDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConDecl",
          "normalized": "ConDecl a(Name a)[BangType a]",
          "package": "haskell-src-exts",
          "partial": "Con Decl",
          "signature": "ConDecl l(Name l)[BangType l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of a data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConName",
          "package": "haskell-src-exts",
          "signature": "ConName l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CName",
          "type": "function"
        },
        "index": {
          "description": "name of data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConName",
          "package": "haskell-src-exts",
          "partial": "Con Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor operator (\u003cem\u003econop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConOp",
          "package": "haskell-src-exts",
          "signature": "ConOp l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Op",
          "type": "function"
        },
        "index": {
          "description": "constructor operator conop",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ConOp",
          "package": "haskell-src-exts",
          "partial": "Con Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ConOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist data constructor \u003ccode\u003e(:)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Cons",
          "package": "haskell-src-exts",
          "signature": "Cons l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "list data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Cons",
          "package": "haskell-src-exts",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCORE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CorePragma",
          "package": "haskell-src-exts",
          "signature": "CorePragma l String (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "CORE pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CorePragma",
          "package": "haskell-src-exts",
          "partial": "Core Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CorePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxEmpty",
          "package": "haskell-src-exts",
          "signature": "CxEmpty l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxEmpty",
          "package": "haskell-src-exts",
          "partial": "Cx Empty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CxEmpty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxParen",
          "package": "haskell-src-exts",
          "signature": "CxParen l (Context l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxParen",
          "package": "haskell-src-exts",
          "partial": "Cx Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CxParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxSingle",
          "package": "haskell-src-exts",
          "signature": "CxSingle l (Asst l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxSingle",
          "package": "haskell-src-exts",
          "partial": "Cx Single",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CxSingle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxTuple",
          "package": "haskell-src-exts",
          "signature": "CxTuple l [Asst l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Context",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "CxTuple",
          "normalized": "CxTuple a[Asst a]",
          "package": "haskell-src-exts",
          "partial": "Cx Tuple",
          "signature": "CxTuple l[Asst l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:CxTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DHInfix",
          "package": "haskell-src-exts",
          "signature": "DHInfix l (TyVarBind l) (Name l) (TyVarBind l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DeclHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DHInfix",
          "package": "haskell-src-exts",
          "partial": "DHInfix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DHInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DHParen",
          "package": "haskell-src-exts",
          "signature": "DHParen l (DeclHead l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DeclHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DHParen",
          "package": "haskell-src-exts",
          "partial": "DHParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DHParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DHead",
          "package": "haskell-src-exts",
          "signature": "DHead l (Name l) [TyVarBind l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DeclHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DHead",
          "normalized": "DHead a(Name a)[TyVarBind a]",
          "package": "haskell-src-exts",
          "partial": "DHead",
          "signature": "DHead l(Name l)[TyVarBind l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data OR newtype declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataDecl",
          "package": "haskell-src-exts",
          "signature": "DataDecl l (DataOrNew l) (Maybe (Context l)) (DeclHead l) [QualConDecl l] (Maybe (Deriving l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data OR newtype declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataDecl",
          "normalized": "DataDecl a(DataOrNew a)(Maybe(Context a))(DeclHead a)[QualConDecl a](Maybe(Deriving a))",
          "package": "haskell-src-exts",
          "partial": "Data Decl",
          "signature": "DataDecl l(DataOrNew l)(Maybe(Context l))(DeclHead l)[QualConDecl l](Maybe(Deriving l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data family declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataFamDecl",
          "package": "haskell-src-exts",
          "signature": "DataFamDecl l (Maybe (Context l)) (DeclHead l) (Maybe (Kind l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data family declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataFamDecl",
          "package": "haskell-src-exts",
          "partial": "Data Fam Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DataFamDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data family instance declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataInsDecl",
          "package": "haskell-src-exts",
          "signature": "DataInsDecl l (DataOrNew l) (Type l) [QualConDecl l] (Maybe (Deriving l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data family instance declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataInsDecl",
          "normalized": "DataInsDecl a(DataOrNew a)(Type a)[QualConDecl a](Maybe(Deriving a))",
          "package": "haskell-src-exts",
          "partial": "Data Ins Decl",
          "signature": "DataInsDecl l(DataOrNew l)(Type l)[QualConDecl l](Maybe(Deriving l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DataInsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataType",
          "package": "haskell-src-exts",
          "signature": "DataType l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DataOrNew",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DataType",
          "package": "haskell-src-exts",
          "partial": "Data Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeclaration bracket: \u003ccode\u003e[d| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeclBracket",
          "package": "haskell-src-exts",
          "signature": "DeclBracket l [Decl l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "declaration bracket",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeclBracket",
          "normalized": "DeclBracket a[Decl a]",
          "package": "haskell-src-exts",
          "partial": "Decl Bracket",
          "signature": "DeclBracket l[Decl l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DeclBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA declaration of default types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DefaultDecl",
          "package": "haskell-src-exts",
          "signature": "DefaultDecl l [Type l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "declaration of default types",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DefaultDecl",
          "normalized": "DefaultDecl a[Type a]",
          "package": "haskell-src-exts",
          "partial": "Default Decl",
          "signature": "DefaultDecl l[Type l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DefaultDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA DEPRECATED pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeprPragmaDecl",
          "package": "haskell-src-exts",
          "signature": "DeprPragmaDecl l [([Name l], String)]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "DEPRECATED pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeprPragmaDecl",
          "normalized": "DeprPragmaDecl a[([Name a],String)]",
          "package": "haskell-src-exts",
          "partial": "Depr Pragma Decl",
          "signature": "DeprPragmaDecl l[([Name l],String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DeprPragmaDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeprText",
          "package": "haskell-src-exts",
          "signature": "DeprText l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#WarningText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DeprText",
          "package": "haskell-src-exts",
          "partial": "Depr Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DeprText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA standalone deriving declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DerivDecl",
          "package": "haskell-src-exts",
          "signature": "DerivDecl l (Maybe (Context l)) (InstHead l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "standalone deriving declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DerivDecl",
          "package": "haskell-src-exts",
          "partial": "Deriv Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DerivDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Deriving",
          "package": "haskell-src-exts",
          "signature": "Deriving l [InstHead l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Deriving",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Deriving",
          "normalized": "Deriving a[InstHead a]",
          "package": "haskell-src-exts",
          "partial": "Deriving",
          "signature": "Deriving l[InstHead l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Deriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edo\u003c/code\u003e-expression:\n   the last statement in the list\n   should be an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Do",
          "package": "haskell-src-exts",
          "signature": "Do l [Stmt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "do expression the last statement in the list should be an expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Do",
          "normalized": "Do a[Stmt a]",
          "package": "haskell-src-exts",
          "partial": "Do",
          "signature": "Do l[Stmt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Do"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DotNet",
          "package": "haskell-src-exts",
          "signature": "DotNet l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "DotNet",
          "package": "haskell-src-exts",
          "partial": "Dot Net",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:DotNet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e:\n   a class or datatype exported abstractly,\n   or a type synonym.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EAbs",
          "package": "haskell-src-exts",
          "signature": "EAbs l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class or datatype exported abstractly or type synonym",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EAbs",
          "package": "haskell-src-exts",
          "partial": "EAbs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodule M\u003c/code\u003e:\n   re-export a module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EModuleContents",
          "package": "haskell-src-exts",
          "signature": "EModuleContents l (ModuleName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "module re-export module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EModuleContents",
          "package": "haskell-src-exts",
          "partial": "EModule Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EModuleContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(..)\u003c/code\u003e:\n   a class exported with all of its methods, or\n   a datatype exported with all of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EThingAll",
          "package": "haskell-src-exts",
          "signature": "EThingAll l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class exported with all of its methods or datatype exported with all of its constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EThingAll",
          "package": "haskell-src-exts",
          "partial": "EThing All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EThingAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(C_1,...,C_n)\u003c/code\u003e:\n   a class exported with some of its methods, or\n   a datatype exported with some of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EThingWith",
          "package": "haskell-src-exts",
          "signature": "EThingWith l (QName l) [CName l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class exported with some of its methods or datatype exported with some of its constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EThingWith",
          "normalized": "EThingWith a(QName a)[CName a]",
          "package": "haskell-src-exts",
          "partial": "EThing With",
          "signature": "EThingWith l(QName l)[CName l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EThingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EVar",
          "package": "haskell-src-exts",
          "signature": "EVar l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EVar",
          "package": "haskell-src-exts",
          "partial": "EVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunbounded arithmetic sequence,\n   incrementing by 1: \u003ccode\u003e[from ..]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFrom",
          "package": "haskell-src-exts",
          "signature": "EnumFrom l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "unbounded arithmetic sequence incrementing by from",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFrom",
          "package": "haskell-src-exts",
          "partial": "Enum From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EnumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunbounded arithmetic sequence,\n   with first two elements given \u003ccode\u003e[from, then ..]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFromThen",
          "package": "haskell-src-exts",
          "signature": "EnumFromThen l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "unbounded arithmetic sequence with first two elements given from then",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFromThen",
          "package": "haskell-src-exts",
          "partial": "Enum From Then",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EnumFromThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounded arithmetic sequence,\n   with first two elements given \u003ccode\u003e[from, then .. to]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFromThenTo",
          "package": "haskell-src-exts",
          "signature": "EnumFromThenTo l (Exp l) (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "bounded arithmetic sequence with first two elements given from then to",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFromThenTo",
          "package": "haskell-src-exts",
          "partial": "Enum From Then To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EnumFromThenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounded arithmetic sequence,\n   incrementing by 1 \u003ccode\u003e[from .. to]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFromTo",
          "package": "haskell-src-exts",
          "signature": "EnumFromTo l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "bounded arithmetic sequence incrementing by from to",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EnumFromTo",
          "package": "haskell-src-exts",
          "partial": "Enum From To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EnumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype equality constraint\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EqualP",
          "package": "haskell-src-exts",
          "signature": "EqualP l (Type l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "type equality constraint",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "EqualP",
          "package": "haskell-src-exts",
          "partial": "Equal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:EqualP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpression bracket: \u003ccode\u003e[| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExpBracket",
          "package": "haskell-src-exts",
          "signature": "ExpBracket l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "expression bracket",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExpBracket",
          "package": "haskell-src-exts",
          "partial": "Exp Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ExpBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpression with explicit type signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExpTypeSig",
          "package": "haskell-src-exts",
          "signature": "ExpTypeSig l (Exp l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "expression with explicit type signature",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExpTypeSig",
          "package": "haskell-src-exts",
          "partial": "Exp Type Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ExpTypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExportSpecList",
          "package": "haskell-src-exts",
          "signature": "ExportSpecList l [ExportSpec l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ExportSpecList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ExportSpecList",
          "normalized": "ExportSpecList a[ExportSpec a]",
          "package": "haskell-src-exts",
          "partial": "Export Spec List",
          "signature": "ExportSpecList l[ExportSpec l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ExportSpecList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldDecl",
          "package": "haskell-src-exts",
          "signature": "FieldDecl l [Name l] (BangType l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FieldDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldDecl",
          "normalized": "FieldDecl a[Name a](BangType a)",
          "package": "haskell-src-exts",
          "partial": "Field Decl",
          "signature": "FieldDecl l[Name l](BangType l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FieldDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field pun\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldPun",
          "package": "haskell-src-exts",
          "signature": "FieldPun l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FieldUpdate",
          "type": "function"
        },
        "index": {
          "description": "record field pun",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldPun",
          "package": "haskell-src-exts",
          "partial": "Field Pun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FieldPun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary label-expresion pair\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "signature": "FieldUpdate l (QName l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FieldUpdate",
          "type": "function"
        },
        "index": {
          "description": "ordinary label-expresion pair",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "partial": "Field Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field wildcard\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldWildcard",
          "package": "haskell-src-exts",
          "signature": "FieldWildcard l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FieldUpdate",
          "type": "function"
        },
        "index": {
          "description": "record field wildcard",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FieldWildcard",
          "package": "haskell-src-exts",
          "partial": "Field Wildcard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FieldWildcard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA foreign export declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ForExp",
          "package": "haskell-src-exts",
          "signature": "ForExp l (CallConv l) (Maybe String) (Name l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "foreign export declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ForExp",
          "package": "haskell-src-exts",
          "partial": "For Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ForExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA foreign import declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ForImp",
          "package": "haskell-src-exts",
          "signature": "ForImp l (CallConv l) (Maybe (Safety l)) (Maybe String) (Name l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "foreign import declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ForImp",
          "package": "haskell-src-exts",
          "partial": "For Imp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ForImp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efloating point literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Frac",
          "package": "haskell-src-exts",
          "signature": "Frac l Rational String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "floating point literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Frac",
          "package": "haskell-src-exts",
          "partial": "Frac",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Frac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of function binding clauses\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunBind",
          "package": "haskell-src-exts",
          "signature": "FunBind l [Match l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "set of function binding clauses",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunBind",
          "normalized": "FunBind a[Match a]",
          "package": "haskell-src-exts",
          "partial": "Fun Bind",
          "signature": "FunBind l[Match l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FunBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction type constructor \u003ccode\u003e-\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunCon",
          "package": "haskell-src-exts",
          "signature": "FunCon l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "function type constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunCon",
          "package": "haskell-src-exts",
          "partial": "Fun Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FunCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunDep",
          "package": "haskell-src-exts",
          "signature": "FunDep l [Name l] [Name l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#FunDep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "FunDep",
          "normalized": "FunDep a[Name a][Name a]",
          "package": "haskell-src-exts",
          "partial": "Fun Dep",
          "signature": "FunDep l[Name l][Name l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:FunDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data OR newtype declaration, GADT style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GDataDecl",
          "package": "haskell-src-exts",
          "signature": "GDataDecl l (DataOrNew l) (Maybe (Context l)) (DeclHead l) (Maybe (Kind l)) [GadtDecl l] (Maybe (Deriving l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data OR newtype declaration GADT style",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GDataDecl",
          "normalized": "GDataDecl a(DataOrNew a)(Maybe(Context a))(DeclHead a)(Maybe(Kind a))[GadtDecl a](Maybe(Deriving a))",
          "package": "haskell-src-exts",
          "partial": "GData Decl",
          "signature": "GDataDecl l(DataOrNew l)(Maybe(Context l))(DeclHead l)(Maybe(Kind l))[GadtDecl l](Maybe(Deriving l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GDataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data family instance declaration, GADT style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GDataInsDecl",
          "package": "haskell-src-exts",
          "signature": "GDataInsDecl l (DataOrNew l) (Type l) (Maybe (Kind l)) [GadtDecl l] (Maybe (Deriving l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data family instance declaration GADT style",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GDataInsDecl",
          "normalized": "GDataInsDecl a(DataOrNew a)(Type a)(Maybe(Kind a))[GadtDecl a](Maybe(Deriving a))",
          "package": "haskell-src-exts",
          "partial": "GData Ins Decl",
          "signature": "GDataInsDecl l(DataOrNew l)(Type l)(Maybe(Kind l))[GadtDecl l](Maybe(Deriving l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GDataInsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "GHC",
          "package": "haskell-src-exts",
          "signature": "GHC",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GHC\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GHC\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GHC",
          "package": "haskell-src-exts",
          "partial": "GHC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GHC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "signature": "GadtDecl l (Name l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GadtDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "partial": "Gadt Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GadtDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGENERATED pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GenPragma",
          "package": "haskell-src-exts",
          "signature": "GenPragma l String (Int, Int) (Int, Int) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "GENERATED pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GenPragma",
          "normalized": "GenPragma a String(Int,Int)(Int,Int)(Exp a)",
          "package": "haskell-src-exts",
          "partial": "Gen Pragma",
          "signature": "GenPragma l String(Int,Int)(Int,Int)(Exp l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GenPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea generator: \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e\u003c-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Generator",
          "package": "haskell-src-exts",
          "signature": "Generator l (Pat l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "generator pat exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Generator",
          "package": "haskell-src-exts",
          "partial": "Generator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Generator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GroupBy",
          "package": "haskell-src-exts",
          "signature": "GroupBy l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then group by exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GroupBy",
          "package": "haskell-src-exts",
          "partial": "Group By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GroupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eusing\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GroupByUsing",
          "package": "haskell-src-exts",
          "signature": "GroupByUsing l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then group by exp using exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GroupByUsing",
          "package": "haskell-src-exts",
          "partial": "Group By Using",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GroupByUsing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eusing\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GroupUsing",
          "package": "haskell-src-exts",
          "signature": "GroupUsing l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then group using exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GroupUsing",
          "package": "haskell-src-exts",
          "partial": "Group Using",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GroupUsing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlt",
          "package": "haskell-src-exts",
          "signature": "GuardedAlt l [Stmt l] (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlt",
          "normalized": "GuardedAlt a[Stmt a](Exp a)",
          "package": "haskell-src-exts",
          "partial": "Guarded Alt",
          "signature": "GuardedAlt l[Stmt l](Exp l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003egdpat\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlts",
          "package": "haskell-src-exts",
          "signature": "GuardedAlts l [GuardedAlt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedAlts",
          "type": "function"
        },
        "index": {
          "description": "gdpat",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedAlts",
          "normalized": "GuardedAlts a[GuardedAlt a]",
          "package": "haskell-src-exts",
          "partial": "Guarded Alts",
          "signature": "GuardedAlts l[GuardedAlt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedRhs",
          "package": "haskell-src-exts",
          "signature": "GuardedRhs l [Stmt l] (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedRhs",
          "normalized": "GuardedRhs a[Stmt a](Exp a)",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhs",
          "signature": "GuardedRhs l[Stmt l](Exp l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eguarded right hand side (\u003cem\u003egdrhs\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedRhss",
          "package": "haskell-src-exts",
          "signature": "GuardedRhss l [GuardedRhs l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Rhs",
          "type": "function"
        },
        "index": {
          "description": "guarded right hand side gdrhs",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "GuardedRhss",
          "normalized": "GuardedRhss a[GuardedRhs a]",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhss",
          "signature": "GuardedRhss l[GuardedRhs l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:GuardedRhss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "HADDOCK",
          "package": "haskell-src-exts",
          "signature": "HADDOCK",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:HADDOCK\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:HADDOCK\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "HADDOCK",
          "package": "haskell-src-exts",
          "partial": "HADDOCK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:HADDOCK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "HUGS",
          "package": "haskell-src-exts",
          "signature": "HUGS",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:HUGS\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:HUGS\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "HUGS",
          "package": "haskell-src-exts",
          "partial": "HUGS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:HUGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e:\n   the name of a class, datatype or type synonym.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IAbs",
          "package": "haskell-src-exts",
          "signature": "IAbs l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "the name of class datatype or type synonym",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IAbs",
          "package": "haskell-src-exts",
          "partial": "IAbs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IHInfix",
          "package": "haskell-src-exts",
          "signature": "IHInfix l (Type l) (QName l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IHInfix",
          "package": "haskell-src-exts",
          "partial": "IHInfix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IHInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IHParen",
          "package": "haskell-src-exts",
          "signature": "IHParen l (InstHead l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IHParen",
          "package": "haskell-src-exts",
          "partial": "IHParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IHParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IHead",
          "package": "haskell-src-exts",
          "signature": "IHead l (QName l) [Type l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IHead",
          "normalized": "IHead a(QName a)[Type a]",
          "package": "haskell-src-exts",
          "partial": "IHead",
          "signature": "IHead l(QName l)[Type l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "signature": "IPBind l (IPName l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#IPBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "partial": "IPBind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IPBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binding group for implicit parameters\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPBinds",
          "package": "haskell-src-exts",
          "signature": "IPBinds l [IPBind l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Binds",
          "type": "function"
        },
        "index": {
          "description": "binding group for implicit parameters",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPBinds",
          "normalized": "IPBinds a[IPBind a]",
          "package": "haskell-src-exts",
          "partial": "IPBinds",
          "signature": "IPBinds l[IPBind l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IPBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e?\u003cem\u003eident\u003c/em\u003e, non-linear implicit parameter\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPDup",
          "package": "haskell-src-exts",
          "signature": "IPDup l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#IPName",
          "type": "function"
        },
        "index": {
          "description": "ident non-linear implicit parameter",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPDup",
          "package": "haskell-src-exts",
          "partial": "IPDup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IPDup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e%\u003cem\u003eident\u003c/em\u003e, linear implicit parameter\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPLin",
          "package": "haskell-src-exts",
          "signature": "IPLin l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#IPName",
          "type": "function"
        },
        "index": {
          "description": "ident linear implicit parameter",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPLin",
          "package": "haskell-src-exts",
          "partial": "IPLin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IPLin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimplicit parameter variable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPVar",
          "package": "haskell-src-exts",
          "signature": "IPVar l (IPName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "implicit parameter variable",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IPVar",
          "package": "haskell-src-exts",
          "partial": "IPVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IPVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimplicit parameter assertion\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IParam",
          "package": "haskell-src-exts",
          "signature": "IParam l (IPName l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "implicit parameter assertion",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IParam",
          "package": "haskell-src-exts",
          "partial": "IParam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(..)\u003c/code\u003e:\n   a class imported with all of its methods, or\n   a datatype imported with all of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IThingAll",
          "package": "haskell-src-exts",
          "signature": "IThingAll l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "class imported with all of its methods or datatype imported with all of its constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IThingAll",
          "package": "haskell-src-exts",
          "partial": "IThing All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IThingAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(C_1,...,C_n)\u003c/code\u003e:\n   a class imported with some of its methods, or\n   a datatype imported with some of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IThingWith",
          "package": "haskell-src-exts",
          "signature": "IThingWith l (Name l) [CName l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "class imported with some of its methods or datatype imported with some of its constructors",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IThingWith",
          "normalized": "IThingWith a(Name a)[CName a]",
          "package": "haskell-src-exts",
          "partial": "IThing With",
          "signature": "IThingWith l(Name l)[CName l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IThingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IVar",
          "package": "haskell-src-exts",
          "signature": "IVar l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IVar",
          "package": "haskell-src-exts",
          "partial": "IVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable splice: \u003ccode\u003e$var\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IdSplice",
          "package": "haskell-src-exts",
          "signature": "IdSplice l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Splice",
          "type": "function"
        },
        "index": {
          "description": "variable splice var",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "IdSplice",
          "package": "haskell-src-exts",
          "partial": "Id Splice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:IdSplice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003evarid\u003c/em\u003e or \u003cem\u003econid\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Ident",
          "package": "haskell-src-exts",
          "signature": "Ident l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Name",
          "type": "function"
        },
        "index": {
          "description": "varid or conid",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Ident",
          "package": "haskell-src-exts",
          "partial": "Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Ident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eif\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eelse\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "If",
          "package": "haskell-src-exts",
          "signature": "If l (Exp l) (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "if exp then exp else exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "If",
          "package": "haskell-src-exts",
          "partial": "If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:If"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "signature": "ImportDecl",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "partial": "Import Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportSpecList",
          "package": "haskell-src-exts",
          "signature": "ImportSpecList l Bool [ImportSpec l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportSpecList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ImportSpecList",
          "normalized": "ImportSpecList a Bool[ImportSpec a]",
          "package": "haskell-src-exts",
          "partial": "Import Spec List",
          "signature": "ImportSpecList l Bool[ImportSpec l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ImportSpecList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclass assertion where the class name is given infix\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixA",
          "package": "haskell-src-exts",
          "signature": "InfixA l (Type l) (QName l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "class assertion where the class name is given infix",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixA",
          "package": "haskell-src-exts",
          "partial": "Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InfixA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix application\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixApp",
          "package": "haskell-src-exts",
          "signature": "InfixApp l (Exp l) (QOp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "infix application",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixApp",
          "package": "haskell-src-exts",
          "partial": "Infix App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InfixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixConDecl",
          "package": "haskell-src-exts",
          "signature": "InfixConDecl l (BangType l) (Name l) (BangType l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ConDecl",
          "type": "function"
        },
        "index": {
          "description": "infix data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixConDecl",
          "package": "haskell-src-exts",
          "partial": "Infix Con Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InfixConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA declaration of operator fixity\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixDecl",
          "package": "haskell-src-exts",
          "signature": "InfixDecl l (Assoc l) (Maybe Int) [Op l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "declaration of operator fixity",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixDecl",
          "normalized": "InfixDecl a(Assoc a)(Maybe Int)[Op a]",
          "package": "haskell-src-exts",
          "partial": "Infix Decl",
          "signature": "InfixDecl l(Assoc l)(Maybe Int)[Op l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InfixDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA clause defined with infix notation, i.e. first its first argument\n  pattern, then the function name, then its following argument(s),\n  the right-hand side and an optional where clause.\n  Note that there can be more than two arguments to a function declared\n  infix, hence the list of pattern arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixMatch",
          "package": "haskell-src-exts",
          "signature": "InfixMatch l (Pat l) (Name l) [Pat l] (Rhs l) (Maybe (Binds l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Match",
          "type": "function"
        },
        "index": {
          "description": "clause defined with infix notation i.e first its first argument pattern then the function name then its following argument the right-hand side and an optional where clause Note that there can be more than two arguments to function declared infix hence the list of pattern arguments",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InfixMatch",
          "normalized": "InfixMatch a(Pat a)(Name a)[Pat a](Rhs a)(Maybe(Binds a))",
          "package": "haskell-src-exts",
          "partial": "Infix Match",
          "signature": "InfixMatch l(Pat l)(Name l)[Pat l](Rhs l)(Maybe(Binds l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InfixMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn INLINE CONLIKE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InlineConlikeSig",
          "package": "haskell-src-exts",
          "signature": "InlineConlikeSig l (Maybe (Activation l)) (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An INLINE CONLIKE pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InlineConlikeSig",
          "package": "haskell-src-exts",
          "partial": "Inline Conlike Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InlineConlikeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn INLINE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InlineSig",
          "package": "haskell-src-exts",
          "signature": "InlineSig l Bool (Maybe (Activation l)) (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An INLINE pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InlineSig",
          "package": "haskell-src-exts",
          "partial": "Inline Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InlineSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associated data type implementation\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsData",
          "package": "haskell-src-exts",
          "signature": "InsData l (DataOrNew l) (Type l) [QualConDecl l] (Maybe (Deriving l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "an associated data type implementation",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsData",
          "normalized": "InsData a(DataOrNew a)(Type a)[QualConDecl a](Maybe(Deriving a))",
          "package": "haskell-src-exts",
          "partial": "Ins Data",
          "signature": "InsData l(DataOrNew l)(Type l)[QualConDecl l](Maybe(Deriving l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InsData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsDecl",
          "package": "haskell-src-exts",
          "signature": "InsDecl l (Decl l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsDecl",
          "package": "haskell-src-exts",
          "partial": "Ins Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associated data type implemented using GADT style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsGData",
          "package": "haskell-src-exts",
          "signature": "InsGData l (DataOrNew l) (Type l) (Maybe (Kind l)) [GadtDecl l] (Maybe (Deriving l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "an associated data type implemented using GADT style",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsGData",
          "normalized": "InsGData a(DataOrNew a)(Type a)(Maybe(Kind a))[GadtDecl a](Maybe(Deriving a))",
          "package": "haskell-src-exts",
          "partial": "Ins GData",
          "signature": "InsGData l(DataOrNew l)(Type l)(Maybe(Kind l))[GadtDecl l](Maybe(Deriving l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InsGData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associated type definition\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsType",
          "package": "haskell-src-exts",
          "signature": "InsType l (Type l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "an associated type definition",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InsType",
          "package": "haskell-src-exts",
          "partial": "Ins Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InsType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn declaration of a type class instance\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstDecl",
          "package": "haskell-src-exts",
          "signature": "InstDecl l (Maybe (Context l)) (InstHead l) (Maybe [InstDecl l])",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An declaration of type class instance",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstDecl",
          "normalized": "InstDecl a(Maybe(Context a))(InstHead a)(Maybe[InstDecl a])",
          "package": "haskell-src-exts",
          "partial": "Inst Decl",
          "signature": "InstDecl l(Maybe(Context l))(InstHead l)(Maybe[InstDecl l])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InstDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SPECIALISE instance pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstSig",
          "package": "haskell-src-exts",
          "signature": "InstSig l (Maybe (Context l)) (InstHead l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "SPECIALISE instance pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "InstSig",
          "package": "haskell-src-exts",
          "partial": "Inst Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:InstSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Int",
          "package": "haskell-src-exts",
          "signature": "Int l Integer String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "integer literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Int",
          "package": "haskell-src-exts",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Js",
          "package": "haskell-src-exts",
          "signature": "Js l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Js",
          "package": "haskell-src-exts",
          "partial": "Js",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Js"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Jvm",
          "package": "haskell-src-exts",
          "signature": "Jvm l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Jvm",
          "package": "haskell-src-exts",
          "partial": "Jvm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Jvm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e!\u003c/code\u003e, the kind of unboxed types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindBang",
          "package": "haskell-src-exts",
          "signature": "KindBang l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "the kind of unboxed types",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindBang",
          "package": "haskell-src-exts",
          "partial": "Kind Bang",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:KindBang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e-\u003e\u003c/code\u003e, the kind of a type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindFn",
          "package": "haskell-src-exts",
          "signature": "KindFn l (Kind l) (Kind l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "the kind of type constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindFn",
          "package": "haskell-src-exts",
          "partial": "Kind Fn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:KindFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea parenthesised kind\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindParen",
          "package": "haskell-src-exts",
          "signature": "KindParen l (Kind l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "parenthesised kind",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindParen",
          "package": "haskell-src-exts",
          "partial": "Kind Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:KindParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e, the kind of types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindStar",
          "package": "haskell-src-exts",
          "signature": "KindStar l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "the kind of types",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindStar",
          "package": "haskell-src-exts",
          "partial": "Kind Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:KindStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea kind variable (as-of-yet unsupported by compilers)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindVar",
          "package": "haskell-src-exts",
          "signature": "KindVar l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "kind variable as-of-yet unsupported by compilers",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindVar",
          "package": "haskell-src-exts",
          "partial": "Kind Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:KindVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable binding with kind annotation\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindedVar",
          "package": "haskell-src-exts",
          "signature": "KindedVar l (Name l) (Kind l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#TyVarBind",
          "type": "function"
        },
        "index": {
          "description": "variable binding with kind annotation",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "KindedVar",
          "package": "haskell-src-exts",
          "partial": "Kinded Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:KindedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elambda expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Lambda",
          "package": "haskell-src-exts",
          "signature": "Lambda l [Pat l] (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "lambda expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Lambda",
          "normalized": "Lambda a[Pat a](Exp a)",
          "package": "haskell-src-exts",
          "partial": "Lambda",
          "signature": "Lambda l[Pat l](Exp l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLANGUAGE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LanguagePragma",
          "package": "haskell-src-exts",
          "signature": "LanguagePragma l [Name l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModulePragma",
          "type": "function"
        },
        "index": {
          "description": "LANGUAGE pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LanguagePragma",
          "normalized": "LanguagePragma a[Name a]",
          "package": "haskell-src-exts",
          "partial": "Language Pragma",
          "signature": "LanguagePragma l[Name l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:LanguagePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow application (from left): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e-\u003c\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LeftArrApp",
          "package": "haskell-src-exts",
          "signature": "LeftArrApp l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "arrow application from left exp exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LeftArrApp",
          "package": "haskell-src-exts",
          "partial": "Left Arr App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:LeftArrApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehigher-order arrow application (from left): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e-\u003c\u003c\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LeftArrHighApp",
          "package": "haskell-src-exts",
          "signature": "LeftArrHighApp l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "higher-order arrow application from left exp exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LeftArrHighApp",
          "package": "haskell-src-exts",
          "partial": "Left Arr High App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:LeftArrHighApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft section \u003ccode\u003e(\u003c/code\u003e\u003cem\u003eexp\u003c/em\u003e \u003cem\u003eqop\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LeftSection",
          "package": "haskell-src-exts",
          "signature": "LeftSection l (Exp l) (QOp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "left section exp qop",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LeftSection",
          "package": "haskell-src-exts",
          "partial": "Left Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:LeftSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal declarations with \u003ccode\u003elet\u003c/code\u003e ... \u003ccode\u003ein\u003c/code\u003e ...\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Let",
          "package": "haskell-src-exts",
          "signature": "Let l (Binds l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "local declarations with let in",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Let",
          "package": "haskell-src-exts",
          "partial": "Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal bindings\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LetStmt",
          "package": "haskell-src-exts",
          "signature": "LetStmt l (Binds l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "local bindings",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "LetStmt",
          "package": "haskell-src-exts",
          "partial": "Let Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:LetStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "List",
          "package": "haskell-src-exts",
          "signature": "List l [Exp l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "list expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "List",
          "normalized": "List a[Exp a]",
          "package": "haskell-src-exts",
          "partial": "List",
          "signature": "List l[Exp l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary list comprehension\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ListComp",
          "package": "haskell-src-exts",
          "signature": "ListComp l (Exp l) [QualStmt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "ordinary list comprehension",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ListComp",
          "normalized": "ListComp a(Exp a)[QualStmt a]",
          "package": "haskell-src-exts",
          "partial": "List Comp",
          "signature": "ListComp l(Exp l)[QualStmt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist type constructor \u003ccode\u003e[]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ListCon",
          "package": "haskell-src-exts",
          "signature": "ListCon l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "list type constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ListCon",
          "package": "haskell-src-exts",
          "partial": "List Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ListCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eliteral constant\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Lit",
          "package": "haskell-src-exts",
          "signature": "Lit l (Literal l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "literal constant",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Lit",
          "package": "haskell-src-exts",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emdo\u003c/code\u003e-expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "MDo",
          "package": "haskell-src-exts",
          "signature": "MDo l [Stmt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "mdo expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "MDo",
          "normalized": "MDo a[Stmt a]",
          "package": "haskell-src-exts",
          "partial": "MDo",
          "signature": "MDo l[Stmt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:MDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA clause defined with prefix notation, i.e. the function name\n  followed by its argument patterns, the right-hand side and an\n  optional where clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Match",
          "package": "haskell-src-exts",
          "signature": "Match l (Name l) [Pat l] (Rhs l) (Maybe (Binds l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Match",
          "type": "function"
        },
        "index": {
          "description": "clause defined with prefix notation i.e the function name followed by its argument patterns the right-hand side and an optional where clause",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Match",
          "normalized": "Match a(Name a)[Pat a](Rhs a)(Maybe(Binds a))",
          "package": "haskell-src-exts",
          "partial": "Match",
          "signature": "Match l(Name l)[Pat l](Rhs l)(Maybe(Binds l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean ordinary Haskell module\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Module",
          "package": "haskell-src-exts",
          "signature": "Module l (Maybe (ModuleHead l)) [ModulePragma l] [ImportDecl l] [Decl l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Module",
          "type": "function"
        },
        "index": {
          "description": "an ordinary Haskell module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Module",
          "normalized": "Module a(Maybe(ModuleHead a))[ModulePragma a][ImportDecl a][Decl a]",
          "package": "haskell-src-exts",
          "partial": "Module",
          "signature": "Module l(Maybe(ModuleHead l))[ModulePragma l][ImportDecl l][Decl l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation for the defining module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleAnn",
          "package": "haskell-src-exts",
          "signature": "ModuleAnn l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Annotation",
          "type": "function"
        },
        "index": {
          "description": "An annotation for the defining module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleAnn",
          "package": "haskell-src-exts",
          "partial": "Module Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ModuleAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleHead",
          "package": "haskell-src-exts",
          "signature": "ModuleHead l (ModuleName l) (Maybe (WarningText l)) (Maybe (ExportSpecList l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModuleHead",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleHead",
          "package": "haskell-src-exts",
          "partial": "Module Head",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ModuleHead"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "signature": "ModuleName l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModuleName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "partial": "Module Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "NHC98",
          "package": "haskell-src-exts",
          "signature": "NHC98",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:NHC98\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:NHC98\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "NHC98",
          "package": "haskell-src-exts",
          "partial": "NHC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:NHC98"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegation expression \u003ccode\u003e-\u003cem\u003eexp\u003c/em\u003e\u003c/code\u003e (unary minus)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "NegApp",
          "package": "haskell-src-exts",
          "signature": "NegApp l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "negation expression exp unary minus",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "NegApp",
          "package": "haskell-src-exts",
          "partial": "Neg App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:NegApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "NewType",
          "package": "haskell-src-exts",
          "signature": "NewType l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#DataOrNew",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "NewType",
          "package": "haskell-src-exts",
          "partial": "New Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:NewType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOPTIONS pragma, possibly qualified with a tool, e.g. OPTIONS_GHC\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "OptionsPragma",
          "package": "haskell-src-exts",
          "signature": "OptionsPragma l (Maybe Tool) String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ModulePragma",
          "type": "function"
        },
        "index": {
          "description": "OPTIONS pragma possibly qualified with tool e.g OPTIONS GHC",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "OptionsPragma",
          "package": "haskell-src-exts",
          "partial": "Options Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:OptionsPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor and argument patterns\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PApp",
          "package": "haskell-src-exts",
          "signature": "PApp l (QName l) [Pat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "data constructor and argument patterns",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PApp",
          "normalized": "PApp a(QName a)[Pat a]",
          "package": "haskell-src-exts",
          "partial": "PApp",
          "signature": "PApp l(QName l)[Pat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e-pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PAsPat",
          "package": "haskell-src-exts",
          "signature": "PAsPat l (Name l) (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PAsPat",
          "package": "haskell-src-exts",
          "partial": "PAs Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PAsPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estrict (bang) pattern: \u003ccode\u003ef !x = ...\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PBangPat",
          "package": "haskell-src-exts",
          "signature": "PBangPat l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "strict bang pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PBangPat",
          "package": "haskell-src-exts",
          "partial": "PBang Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PBangPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExplicit generics style type argument e.g. \u003ccode\u003ef {| Int |} x = ...\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PExplTypeArg",
          "package": "haskell-src-exts",
          "signature": "PExplTypeArg l (QName l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "Explicit generics style type argument e.g Int",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PExplTypeArg",
          "package": "haskell-src-exts",
          "partial": "PExpl Type Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PExplTypeArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary label-pattern pair\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PFieldPat",
          "package": "haskell-src-exts",
          "signature": "PFieldPat l (QName l) (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#PatField",
          "type": "function"
        },
        "index": {
          "description": "ordinary label-pattern pair",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PFieldPat",
          "package": "haskell-src-exts",
          "partial": "PField Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PFieldPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field pun\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PFieldPun",
          "package": "haskell-src-exts",
          "signature": "PFieldPun l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#PatField",
          "type": "function"
        },
        "index": {
          "description": "record field pun",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PFieldPun",
          "package": "haskell-src-exts",
          "partial": "PField Pun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PFieldPun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field wildcard\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PFieldWildcard",
          "package": "haskell-src-exts",
          "signature": "PFieldWildcard l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#PatField",
          "type": "function"
        },
        "index": {
          "description": "record field wildcard",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PFieldWildcard",
          "package": "haskell-src-exts",
          "partial": "PField Wildcard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PFieldWildcard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern with an infix data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PInfixApp",
          "package": "haskell-src-exts",
          "signature": "PInfixApp l (Pat l) (QName l) (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern with an infix data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PInfixApp",
          "package": "haskell-src-exts",
          "partial": "PInfix App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PInfixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eirrefutable pattern: \u003ccode\u003e~\u003cem\u003epat\u003c/em\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PIrrPat",
          "package": "haskell-src-exts",
          "signature": "PIrrPat l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "irrefutable pattern pat",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PIrrPat",
          "package": "haskell-src-exts",
          "partial": "PIrr Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PIrrPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PList",
          "package": "haskell-src-exts",
          "signature": "PList l [Pat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "list pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PList",
          "normalized": "PList a[Pat a]",
          "package": "haskell-src-exts",
          "partial": "PList",
          "signature": "PList l[Pat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eliteral constant\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PLit",
          "package": "haskell-src-exts",
          "signature": "PLit l (Literal l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "literal constant",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PLit",
          "package": "haskell-src-exts",
          "partial": "PLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003en+k pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PNPlusK",
          "package": "haskell-src-exts",
          "signature": "PNPlusK l (Name l) Integer",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PNPlusK",
          "package": "haskell-src-exts",
          "partial": "PNPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PNPlusK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegated pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PNeg",
          "package": "haskell-src-exts",
          "signature": "PNeg l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "negated pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PNeg",
          "package": "haskell-src-exts",
          "partial": "PNeg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesized pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PParen",
          "package": "haskell-src-exts",
          "signature": "PParen l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "parenthesized pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PParen",
          "package": "haskell-src-exts",
          "partial": "PParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equasi quote pattern: \u003ccode\u003e[$\u003cem\u003ename\u003c/em\u003e| \u003cem\u003estring\u003c/em\u003e |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PQuasiQuote",
          "package": "haskell-src-exts",
          "signature": "PQuasiQuote l String String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "quasi quote pattern name string",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PQuasiQuote",
          "package": "haskell-src-exts",
          "partial": "PQuasi Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PQuasiQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eregular list pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PRPat",
          "package": "haskell-src-exts",
          "signature": "PRPat l [RPat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "regular list pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PRPat",
          "normalized": "PRPat a[RPat a]",
          "package": "haskell-src-exts",
          "partial": "PRPat",
          "signature": "PRPat l[RPat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PRPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elabelled pattern, record style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PRec",
          "package": "haskell-src-exts",
          "signature": "PRec l (QName l) [PatField l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "labelled pattern record style",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PRec",
          "normalized": "PRec a(QName a)[PatField a]",
          "package": "haskell-src-exts",
          "partial": "PRec",
          "signature": "PRec l(QName l)[PatField l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PTuple",
          "package": "haskell-src-exts",
          "signature": "PTuple l Boxed [Pat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PTuple",
          "normalized": "PTuple a Boxed[Pat a]",
          "package": "haskell-src-exts",
          "partial": "PTuple",
          "signature": "PTuple l Boxed[Pat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PVar",
          "package": "haskell-src-exts",
          "signature": "PVar l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PVar",
          "package": "haskell-src-exts",
          "partial": "PVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eview patterns of the form \u003ccode\u003e(\u003cem\u003eexp\u003c/em\u003e -\u003e \u003cem\u003epat\u003c/em\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PViewPat",
          "package": "haskell-src-exts",
          "signature": "PViewPat l (Exp l) (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "view patterns of the form exp pat",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PViewPat",
          "package": "haskell-src-exts",
          "partial": "PView Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PViewPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewildcard pattern: \u003ccode\u003e_\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PWildCard",
          "package": "haskell-src-exts",
          "signature": "PWildCard l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "wildcard pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PWildCard",
          "package": "haskell-src-exts",
          "partial": "PWild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "signature": "PXAttr l (XName l) (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#PXAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "partial": "PXAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PXAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML singleton element pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXETag",
          "package": "haskell-src-exts",
          "signature": "PXETag l (XName l) [PXAttr l] (Maybe (Pat l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML singleton element pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXETag",
          "normalized": "PXETag a(XName a)[PXAttr a](Maybe(Pat a))",
          "package": "haskell-src-exts",
          "partial": "PXETag",
          "signature": "PXETag l(XName l)[PXAttr l](Maybe(Pat l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PXETag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML embedded pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXPatTag",
          "package": "haskell-src-exts",
          "signature": "PXPatTag l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML embedded pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXPatTag",
          "package": "haskell-src-exts",
          "partial": "PXPat Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PXPatTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML PCDATA pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXPcdata",
          "package": "haskell-src-exts",
          "signature": "PXPcdata l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML PCDATA pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXPcdata",
          "package": "haskell-src-exts",
          "partial": "PXPcdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PXPcdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML regular list pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXRPats",
          "package": "haskell-src-exts",
          "signature": "PXRPats l [RPat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML regular list pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXRPats",
          "normalized": "PXRPats a[RPat a]",
          "package": "haskell-src-exts",
          "partial": "PXRPats",
          "signature": "PXRPats l[RPat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PXRPats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML element pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXTag",
          "package": "haskell-src-exts",
          "signature": "PXTag l (XName l) [PXAttr l] (Maybe (Pat l)) [Pat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML element pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PXTag",
          "normalized": "PXTag a(XName a)[PXAttr a](Maybe(Pat a))[Pat a]",
          "package": "haskell-src-exts",
          "partial": "PXTag",
          "signature": "PXTag l(XName l)[PXAttr l](Maybe(Pat l))[Pat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PXTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparallel list comprehension\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ParComp",
          "package": "haskell-src-exts",
          "signature": "ParComp l (Exp l) [[QualStmt l]]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "parallel list comprehension",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ParComp",
          "normalized": "ParComp a(Exp a)[[QualStmt a]]",
          "package": "haskell-src-exts",
          "partial": "Par Comp",
          "signature": "ParComp l(Exp l)[[QualStmt l]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ParComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesised expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Paren",
          "package": "haskell-src-exts",
          "signature": "Paren l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "parenthesised expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Paren",
          "package": "haskell-src-exts",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesised expression splice: \u003ccode\u003e$(\u003cem\u003eexp\u003c/em\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ParenSplice",
          "package": "haskell-src-exts",
          "signature": "ParenSplice l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Splice",
          "type": "function"
        },
        "index": {
          "description": "parenthesised expression splice exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ParenSplice",
          "package": "haskell-src-exts",
          "partial": "Paren Splice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ParenSplice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern binding\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatBind",
          "package": "haskell-src-exts",
          "signature": "PatBind l (Pat l) (Maybe (Type l)) (Rhs l) (Maybe (Binds l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "pattern binding",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatBind",
          "package": "haskell-src-exts",
          "partial": "Pat Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PatBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern bracket: \u003ccode\u003e[p| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatBracket",
          "package": "haskell-src-exts",
          "signature": "PatBracket l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "pattern bracket",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatBracket",
          "package": "haskell-src-exts",
          "partial": "Pat Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PatBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern with type signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatTypeSig",
          "package": "haskell-src-exts",
          "signature": "PatTypeSig l (Pat l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern with type signature",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PatTypeSig",
          "package": "haskell-src-exts",
          "partial": "Pat Type Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PatTypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einterruptible\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PlayInterruptible",
          "package": "haskell-src-exts",
          "signature": "PlayInterruptible l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Safety",
          "type": "function"
        },
        "index": {
          "description": "interruptible",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PlayInterruptible",
          "package": "haskell-src-exts",
          "partial": "Play Interruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PlayInterruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunsafe\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PlayRisky",
          "package": "haskell-src-exts",
          "signature": "PlayRisky l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Safety",
          "type": "function"
        },
        "index": {
          "description": "unsafe",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PlayRisky",
          "package": "haskell-src-exts",
          "partial": "Play Risky",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PlayRisky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esafe (\u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) or threadsafe (\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PlaySafe",
          "package": "haskell-src-exts",
          "signature": "PlaySafe l Bool",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Safety",
          "type": "function"
        },
        "index": {
          "description": "safe False or threadsafe True",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PlaySafe",
          "package": "haskell-src-exts",
          "partial": "Play Safe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PlaySafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed character literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimChar",
          "package": "haskell-src-exts",
          "signature": "PrimChar l Char String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed character literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimChar",
          "package": "haskell-src-exts",
          "partial": "Prim Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PrimChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed double literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimDouble",
          "package": "haskell-src-exts",
          "signature": "PrimDouble l Rational String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed double literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimDouble",
          "package": "haskell-src-exts",
          "partial": "Prim Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PrimDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed float literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimFloat",
          "package": "haskell-src-exts",
          "signature": "PrimFloat l Rational String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed float literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimFloat",
          "package": "haskell-src-exts",
          "partial": "Prim Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PrimFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed integer literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimInt",
          "package": "haskell-src-exts",
          "signature": "PrimInt l Integer String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed integer literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimInt",
          "package": "haskell-src-exts",
          "partial": "Prim Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PrimInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed string literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimString",
          "package": "haskell-src-exts",
          "signature": "PrimString l String String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed string literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimString",
          "package": "haskell-src-exts",
          "partial": "Prim String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PrimString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed word literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimWord",
          "package": "haskell-src-exts",
          "signature": "PrimWord l Integer String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed word literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "PrimWord",
          "package": "haskell-src-exts",
          "partial": "Prim Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:PrimWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrows proc: \u003ccode\u003eproc\u003c/code\u003e \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Proc",
          "package": "haskell-src-exts",
          "signature": "Proc l (Pat l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "arrows proc proc pat exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Proc",
          "package": "haskell-src-exts",
          "partial": "Proc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Proc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor operator (\u003cem\u003eqconop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QConOp",
          "package": "haskell-src-exts",
          "signature": "QConOp l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QOp",
          "type": "function"
        },
        "index": {
          "description": "constructor operator qconop",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QConOp",
          "package": "haskell-src-exts",
          "partial": "QCon Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:QConOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable operator (\u003cem\u003eqvarop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QVarOp",
          "package": "haskell-src-exts",
          "signature": "QVarOp l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QOp",
          "type": "function"
        },
        "index": {
          "description": "variable operator qvarop",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QVarOp",
          "package": "haskell-src-exts",
          "partial": "QVar Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:QVarOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename qualified with a module name\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Qual",
          "package": "haskell-src-exts",
          "signature": "Qual l (ModuleName l) (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QName",
          "type": "function"
        },
        "index": {
          "description": "name qualified with module name",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Qual",
          "package": "haskell-src-exts",
          "partial": "Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Qual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualConDecl",
          "package": "haskell-src-exts",
          "signature": "QualConDecl l (Maybe [TyVarBind l]) (Maybe (Context l)) (ConDecl l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualConDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualConDecl",
          "normalized": "QualConDecl a(Maybe[TyVarBind a])(Maybe(Context a))(ConDecl a)",
          "package": "haskell-src-exts",
          "partial": "Qual Con Decl",
          "signature": "QualConDecl l(Maybe[TyVarBind l])(Maybe(Context l))(ConDecl l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:QualConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean ordinary statement\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "signature": "QualStmt l (Stmt l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "an ordinary statement",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "partial": "Qual Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:QualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean \u003cem\u003eexp\u003c/em\u003e by itself: in a \u003ccode\u003edo\u003c/code\u003e-expression,\n   an action whose result is discarded;\n   in a list comprehension and pattern guard,\n   a guard expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Qualifier",
          "package": "haskell-src-exts",
          "signature": "Qualifier l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "an exp by itself in do expression an action whose result is discarded in list comprehension and pattern guard guard expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Qualifier",
          "package": "haskell-src-exts",
          "partial": "Qualifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Qualifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equasi-quotaion: \u003ccode\u003e[$\u003cem\u003ename\u003c/em\u003e| \u003cem\u003estring\u003c/em\u003e |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QuasiQuote",
          "package": "haskell-src-exts",
          "signature": "QuasiQuote l String String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "quasi-quotaion name string",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "QuasiQuote",
          "package": "haskell-src-exts",
          "partial": "Quasi Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:QuasiQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elinear variable binding, e.g. foo@(1 | 2)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPAs",
          "package": "haskell-src-exts",
          "signature": "RPAs l (Name l) (RPat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "linear variable binding e.g foo",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPAs",
          "package": "haskell-src-exts",
          "partial": "RPAs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-linear variable binding, e.g. (foo@:(1 | 2))*\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPCAs",
          "package": "haskell-src-exts",
          "signature": "RPCAs l (Name l) (RPat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "non-linear variable binding e.g foo",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPCAs",
          "package": "haskell-src-exts",
          "partial": "RPCAs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPCAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echoice pattern, e.g. (1 | 2)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPEither",
          "package": "haskell-src-exts",
          "signature": "RPEither l (RPat l) (RPat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "choice pattern e.g",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPEither",
          "package": "haskell-src-exts",
          "partial": "RPEither",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eguarded pattern, e.g. (| p | p \u003c 3 |)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPGuard",
          "package": "haskell-src-exts",
          "signature": "RPGuard l (Pat l) [Stmt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "guarded pattern e.g",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPGuard",
          "normalized": "RPGuard a(Pat a)[Stmt a]",
          "package": "haskell-src-exts",
          "partial": "RPGuard",
          "signature": "RPGuard l(Pat l)[Stmt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPGuard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoperator pattern, e.g. pat*\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPOp",
          "package": "haskell-src-exts",
          "signature": "RPOp l (RPat l) (RPatOp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "operator pattern e.g pat",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPOp",
          "package": "haskell-src-exts",
          "partial": "RPOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e?\u003c/code\u003e = 0 or 1\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPOpt",
          "package": "haskell-src-exts",
          "signature": "RPOpt l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPOpt",
          "package": "haskell-src-exts",
          "partial": "RPOpt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e?!\u003c/code\u003e = 0 or 1, greedy\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPOptG",
          "package": "haskell-src-exts",
          "signature": "RPOptG l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or greedy",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPOptG",
          "package": "haskell-src-exts",
          "partial": "RPOpt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPOptG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesised pattern, e.g. (2*)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPParen",
          "package": "haskell-src-exts",
          "signature": "RPParen l (RPat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "parenthesised pattern e.g",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPParen",
          "package": "haskell-src-exts",
          "partial": "RPParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean ordinary pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPPat",
          "package": "haskell-src-exts",
          "signature": "RPPat l (Pat l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "an ordinary pattern",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPPat",
          "package": "haskell-src-exts",
          "partial": "RPPat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e+\u003c/code\u003e = 1 or more\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPPlus",
          "package": "haskell-src-exts",
          "signature": "RPPlus l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPPlus",
          "package": "haskell-src-exts",
          "partial": "RPPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e+!\u003c/code\u003e = 1 or more, greedy\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPPlusG",
          "package": "haskell-src-exts",
          "signature": "RPPlusG l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more greedy",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPPlusG",
          "package": "haskell-src-exts",
          "partial": "RPPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPPlusG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esequence pattern, e.g. (| 1, 2, 3 |)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPSeq",
          "package": "haskell-src-exts",
          "signature": "RPSeq l [RPat l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "sequence pattern e.g",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPSeq",
          "normalized": "RPSeq a[RPat a]",
          "package": "haskell-src-exts",
          "partial": "RPSeq",
          "signature": "RPSeq l[RPat l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e = 0 or more\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPStar",
          "package": "haskell-src-exts",
          "signature": "RPStar l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPStar",
          "package": "haskell-src-exts",
          "partial": "RPStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e*!\u003c/code\u003e = 0 or more, greedy\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPStarG",
          "package": "haskell-src-exts",
          "signature": "RPStarG l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more greedy",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RPStarG",
          "package": "haskell-src-exts",
          "partial": "RPStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RPStarG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord construction expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecConstr",
          "package": "haskell-src-exts",
          "signature": "RecConstr l (QName l) [FieldUpdate l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "record construction expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecConstr",
          "normalized": "RecConstr a(QName a)[FieldUpdate a]",
          "package": "haskell-src-exts",
          "partial": "Rec Constr",
          "signature": "RecConstr l(QName l)[FieldUpdate l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RecConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecDecl",
          "package": "haskell-src-exts",
          "signature": "RecDecl l (Name l) [FieldDecl l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ConDecl",
          "type": "function"
        },
        "index": {
          "description": "record constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecDecl",
          "normalized": "RecDecl a(Name a)[FieldDecl a]",
          "package": "haskell-src-exts",
          "partial": "Rec Decl",
          "signature": "RecDecl l(Name l)[FieldDecl l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RecDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea recursive binding group for arrows\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecStmt",
          "package": "haskell-src-exts",
          "signature": "RecStmt l [Stmt l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "recursive binding group for arrows",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecStmt",
          "normalized": "RecStmt a[Stmt a]",
          "package": "haskell-src-exts",
          "partial": "Rec Stmt",
          "signature": "RecStmt l[Stmt l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RecStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord update expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecUpdate",
          "package": "haskell-src-exts",
          "signature": "RecUpdate l (Exp l) [FieldUpdate l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "record update expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RecUpdate",
          "normalized": "RecUpdate a(Exp a)[FieldUpdate a]",
          "package": "haskell-src-exts",
          "partial": "Rec Update",
          "signature": "RecUpdate l(Exp l)[FieldUpdate l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RecUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow application (from right): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e\u003e-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RightArrApp",
          "package": "haskell-src-exts",
          "signature": "RightArrApp l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "arrow application from right exp exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RightArrApp",
          "package": "haskell-src-exts",
          "partial": "Right Arr App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RightArrApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehigher-order arrow application (from right): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e\u003e\u003e-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RightArrHighApp",
          "package": "haskell-src-exts",
          "signature": "RightArrHighApp l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "higher-order arrow application from right exp exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RightArrHighApp",
          "package": "haskell-src-exts",
          "partial": "Right Arr High App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RightArrHighApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eright section \u003ccode\u003e(\u003c/code\u003e\u003cem\u003eqop\u003c/em\u003e \u003cem\u003eexp\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RightSection",
          "package": "haskell-src-exts",
          "signature": "RightSection l (QOp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "right section qop exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RightSection",
          "package": "haskell-src-exts",
          "partial": "Right Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RightSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Rule",
          "package": "haskell-src-exts",
          "signature": "Rule l String (Maybe (Activation l)) (Maybe [RuleVar l]) (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Rule",
          "normalized": "Rule a String(Maybe(Activation a))(Maybe[RuleVar a])(Exp a)(Exp a)",
          "package": "haskell-src-exts",
          "partial": "Rule",
          "signature": "Rule l String(Maybe(Activation l))(Maybe[RuleVar l])(Exp l)(Exp l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA RULES pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RulePragmaDecl",
          "package": "haskell-src-exts",
          "signature": "RulePragmaDecl l [Rule l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "RULES pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RulePragmaDecl",
          "normalized": "RulePragmaDecl a[Rule a]",
          "package": "haskell-src-exts",
          "partial": "Rule Pragma Decl",
          "signature": "RulePragmaDecl l[Rule l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RulePragmaDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "signature": "RuleVar l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "partial": "Rule Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:RuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSCC pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SCCPragma",
          "package": "haskell-src-exts",
          "signature": "SCCPragma l String (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "SCC pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SCCPragma",
          "package": "haskell-src-exts",
          "partial": "SCCPragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:SCCPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SPECIALISE INLINE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpecInlineSig",
          "package": "haskell-src-exts",
          "signature": "SpecInlineSig l Bool (Maybe (Activation l)) (QName l) [Type l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "SPECIALISE INLINE pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpecInlineSig",
          "normalized": "SpecInlineSig a Bool(Maybe(Activation a))(QName a)[Type a]",
          "package": "haskell-src-exts",
          "partial": "Spec Inline Sig",
          "signature": "SpecInlineSig l Bool(Maybe(Activation l))(QName l)[Type l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:SpecInlineSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SPECIALISE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpecSig",
          "package": "haskell-src-exts",
          "signature": "SpecSig l (Maybe (Activation l)) (QName l) [Type l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "SPECIALISE pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpecSig",
          "normalized": "SpecSig a(Maybe(Activation a))(QName a)[Type a]",
          "package": "haskell-src-exts",
          "partial": "Spec Sig",
          "signature": "SpecSig l(Maybe(Activation l))(QName l)[Type l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:SpecSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilt-in constructor with special syntax\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Special",
          "package": "haskell-src-exts",
          "signature": "Special l (SpecialCon l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QName",
          "type": "function"
        },
        "index": {
          "description": "built-in constructor with special syntax",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Special",
          "package": "haskell-src-exts",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Template Haskell splicing declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpliceDecl",
          "package": "haskell-src-exts",
          "signature": "SpliceDecl l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "Template Haskell splicing declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpliceDecl",
          "package": "haskell-src-exts",
          "partial": "Splice Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:SpliceDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etemplate haskell splice expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpliceExp",
          "package": "haskell-src-exts",
          "signature": "SpliceExp l (Splice l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "template haskell splice expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "SpliceExp",
          "package": "haskell-src-exts",
          "partial": "Splice Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:SpliceExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "StdCall",
          "package": "haskell-src-exts",
          "signature": "StdCall l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "StdCall",
          "package": "haskell-src-exts",
          "partial": "Std Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:StdCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estring literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "String",
          "package": "haskell-src-exts",
          "signature": "String l String String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "string literal",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "String",
          "package": "haskell-src-exts",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003evarsym\u003c/em\u003e or \u003cem\u003econsym\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Symbol",
          "package": "haskell-src-exts",
          "signature": "Symbol l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Name",
          "type": "function"
        },
        "index": {
          "description": "varsym or consym",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Symbol",
          "package": "haskell-src-exts",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eby\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ThenBy",
          "package": "haskell-src-exts",
          "signature": "ThenBy l (Exp l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then exp by exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ThenBy",
          "package": "haskell-src-exts",
          "partial": "Then By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ThenBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ThenTrans",
          "package": "haskell-src-exts",
          "signature": "ThenTrans l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ThenTrans",
          "package": "haskell-src-exts",
          "partial": "Then Trans",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ThenTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Tuple",
          "package": "haskell-src-exts",
          "signature": "Tuple l Boxed [Exp l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "tuple expression",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Tuple",
          "normalized": "Tuple a Boxed[Exp a]",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "Tuple l Boxed[Exp l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e-ary tuple type and data\n   constructors \u003ccode\u003e(,)\u003c/code\u003e etc, possibly boxed \u003ccode\u003e(#,#)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TupleCon",
          "package": "haskell-src-exts",
          "signature": "TupleCon l Boxed Int",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "ary tuple type and data constructors etc possibly boxed",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TupleCon",
          "package": "haskell-src-exts",
          "partial": "Tuple Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TupleCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple section expression, e.g. \u003ccode\u003e(,,3)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TupleSection",
          "package": "haskell-src-exts",
          "signature": "TupleSection l Boxed [Maybe (Exp l)]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "tuple section expression e.g",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TupleSection",
          "normalized": "TupleSection a Boxed[Maybe(Exp a)]",
          "package": "haskell-src-exts",
          "partial": "Tuple Section",
          "signature": "TupleSection l Boxed[Maybe(Exp l)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TupleSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplication of a type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyApp",
          "package": "haskell-src-exts",
          "signature": "TyApp l (Type l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "application of type constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyApp",
          "package": "haskell-src-exts",
          "partial": "Ty App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enamed type or type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyCon",
          "package": "haskell-src-exts",
          "signature": "TyCon l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "named type or type constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyCon",
          "package": "haskell-src-exts",
          "partial": "Ty Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equalified type\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyForall",
          "package": "haskell-src-exts",
          "signature": "TyForall l (Maybe [TyVarBind l]) (Maybe (Context l)) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "qualified type",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyForall",
          "normalized": "TyForall a(Maybe[TyVarBind a])(Maybe(Context a))(Type a)",
          "package": "haskell-src-exts",
          "partial": "Ty Forall",
          "signature": "TyForall l(Maybe[TyVarBind l])(Maybe(Context l))(Type l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyForall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction type\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyFun",
          "package": "haskell-src-exts",
          "signature": "TyFun l (Type l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "function type",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyFun",
          "package": "haskell-src-exts",
          "partial": "Ty Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyInfix",
          "package": "haskell-src-exts",
          "signature": "TyInfix l (Type l) (QName l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "infix type constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyInfix",
          "package": "haskell-src-exts",
          "partial": "Ty Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype with explicit kind signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyKind",
          "package": "haskell-src-exts",
          "signature": "TyKind l (Type l) (Kind l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "type with explicit kind signature",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyKind",
          "package": "haskell-src-exts",
          "partial": "Ty Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist syntax, e.g. [a], as opposed to [] a\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyList",
          "package": "haskell-src-exts",
          "signature": "TyList l (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "list syntax e.g as opposed to",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyList",
          "package": "haskell-src-exts",
          "partial": "Ty List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype surrounded by parentheses\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyParen",
          "package": "haskell-src-exts",
          "signature": "TyParen l (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "type surrounded by parentheses",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyParen",
          "package": "haskell-src-exts",
          "partial": "Ty Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple type, possibly boxed\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyTuple",
          "package": "haskell-src-exts",
          "signature": "TyTuple l Boxed [Type l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "tuple type possibly boxed",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyTuple",
          "normalized": "TyTuple a Boxed[Type a]",
          "package": "haskell-src-exts",
          "partial": "Ty Tuple",
          "signature": "TyTuple l Boxed[Type l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype variable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyVar",
          "package": "haskell-src-exts",
          "signature": "TyVar l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "type variable",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TyVar",
          "package": "haskell-src-exts",
          "partial": "Ty Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e''T\u003c/code\u003e for template haskell reifying of types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypQuote",
          "package": "haskell-src-exts",
          "signature": "TypQuote l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "for template haskell reifying of types",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypQuote",
          "package": "haskell-src-exts",
          "partial": "Typ Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation for a declared type.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeAnn",
          "package": "haskell-src-exts",
          "signature": "TypeAnn l (Name l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Annotation",
          "type": "function"
        },
        "index": {
          "description": "An annotation for declared type",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeAnn",
          "package": "haskell-src-exts",
          "partial": "Type Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypeAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype bracket: \u003ccode\u003e[t| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeBracket",
          "package": "haskell-src-exts",
          "signature": "TypeBracket l (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "type bracket",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeBracket",
          "package": "haskell-src-exts",
          "partial": "Type Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypeBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeDecl",
          "package": "haskell-src-exts",
          "signature": "TypeDecl l (DeclHead l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeDecl",
          "package": "haskell-src-exts",
          "partial": "Type Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypeDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type family declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeFamDecl",
          "package": "haskell-src-exts",
          "signature": "TypeFamDecl l (DeclHead l) (Maybe (Kind l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type family declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeFamDecl",
          "package": "haskell-src-exts",
          "partial": "Type Fam Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypeFamDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type family instance declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeInsDecl",
          "package": "haskell-src-exts",
          "signature": "TypeInsDecl l (Type l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type family instance declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeInsDecl",
          "package": "haskell-src-exts",
          "partial": "Type Ins Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypeInsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type signature declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeSig",
          "package": "haskell-src-exts",
          "signature": "TypeSig l [Name l] (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type signature declaration",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypeSig",
          "normalized": "TypeSig a[Name a](Type a)",
          "package": "haskell-src-exts",
          "partial": "Type Sig",
          "signature": "TypeSig l[Name l](Type l)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypedRuleVar",
          "package": "haskell-src-exts",
          "signature": "TypedRuleVar l (Name l) (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#RuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "TypedRuleVar",
          "package": "haskell-src-exts",
          "partial": "Typed Rule Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:TypedRuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-strict component\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnBangedTy",
          "package": "haskell-src-exts",
          "signature": "UnBangedTy l (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#BangType",
          "type": "function"
        },
        "index": {
          "description": "non-strict component",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnBangedTy",
          "package": "haskell-src-exts",
          "partial": "Un Banged Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnBangedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnGuardedAlt",
          "package": "haskell-src-exts",
          "signature": "UnGuardedAlt l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#GuardedAlts",
          "type": "function"
        },
        "index": {
          "description": "exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnGuardedAlt",
          "package": "haskell-src-exts",
          "partial": "Un Guarded Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnGuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunguarded right hand side (\u003cem\u003eexp\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnGuardedRhs",
          "package": "haskell-src-exts",
          "signature": "UnGuardedRhs l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Rhs",
          "type": "function"
        },
        "index": {
          "description": "unguarded right hand side exp",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnGuardedRhs",
          "package": "haskell-src-exts",
          "partial": "Un Guarded Rhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnGuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunqualified local name\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnQual",
          "package": "haskell-src-exts",
          "signature": "UnQual l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#QName",
          "type": "function"
        },
        "index": {
          "description": "unqualified local name",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnQual",
          "package": "haskell-src-exts",
          "partial": "Un Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "Unboxed",
          "package": "haskell-src-exts",
          "signature": "Unboxed",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Boxed",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Unboxed\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Unboxed\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Unboxed",
          "package": "haskell-src-exts",
          "partial": "Unboxed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Unboxed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed singleton tuple constructor \u003ccode\u003e(# #)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnboxedSingleCon",
          "package": "haskell-src-exts",
          "signature": "UnboxedSingleCon l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "unboxed singleton tuple constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnboxedSingleCon",
          "package": "haskell-src-exts",
          "partial": "Unboxed Single Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnboxedSingleCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunit type and data constructor \u003ccode\u003e()\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnitCon",
          "package": "haskell-src-exts",
          "signature": "UnitCon l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "unit type and data constructor",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnitCon",
          "package": "haskell-src-exts",
          "partial": "Unit Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnitCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary variable binding\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnkindedVar",
          "package": "haskell-src-exts",
          "signature": "UnkindedVar l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#TyVarBind",
          "type": "function"
        },
        "index": {
          "description": "ordinary variable binding",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnkindedVar",
          "package": "haskell-src-exts",
          "partial": "Unkinded Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnkindedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "UnknownTool",
          "package": "haskell-src-exts",
          "signature": "UnknownTool String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnknownTool\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnknownTool\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnknownTool",
          "package": "haskell-src-exts",
          "partial": "Unknown Tool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnknownTool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed component, marked with an UNPACK pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnpackedTy",
          "package": "haskell-src-exts",
          "signature": "UnpackedTy l (Type l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#BangType",
          "type": "function"
        },
        "index": {
          "description": "unboxed component marked with an UNPACK pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "UnpackedTy",
          "package": "haskell-src-exts",
          "partial": "Unpacked Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:UnpackedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Var",
          "package": "haskell-src-exts",
          "signature": "Var l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "Var",
          "package": "haskell-src-exts",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of a method or field\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "VarName",
          "package": "haskell-src-exts",
          "signature": "VarName l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#CName",
          "type": "function"
        },
        "index": {
          "description": "name of method or field",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "VarName",
          "package": "haskell-src-exts",
          "partial": "Var Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable operator (\u003cem\u003evarop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "VarOp",
          "package": "haskell-src-exts",
          "signature": "VarOp l (Name l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Op",
          "type": "function"
        },
        "index": {
          "description": "variable operator varop",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "VarOp",
          "package": "haskell-src-exts",
          "partial": "Var Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:VarOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e'x\u003c/code\u003e for template haskell reifying of expressions\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "VarQuote",
          "package": "haskell-src-exts",
          "signature": "VarQuote l (QName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "for template haskell reifying of expressions",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "VarQuote",
          "package": "haskell-src-exts",
          "partial": "Var Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:VarQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA WARNING pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "WarnPragmaDecl",
          "package": "haskell-src-exts",
          "signature": "WarnPragmaDecl l [([Name l], String)]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "WARNING pragma",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "WarnPragmaDecl",
          "normalized": "WarnPragmaDecl a[([Name a],String)]",
          "package": "haskell-src-exts",
          "partial": "Warn Pragma Decl",
          "signature": "WarnPragmaDecl l[([Name l],String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:WarnPragmaDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "WarnText",
          "package": "haskell-src-exts",
          "signature": "WarnText l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#WarningText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "WarnText",
          "package": "haskell-src-exts",
          "partial": "Warn Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:WarnText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "signature": "XAttr l (XName l) (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#XAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "partial": "XAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echildren of an xml element\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XChildTag",
          "package": "haskell-src-exts",
          "signature": "XChildTag l [Exp l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "children of an xml element",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XChildTag",
          "normalized": "XChildTag a[Exp a]",
          "package": "haskell-src-exts",
          "partial": "XChild Tag",
          "signature": "XChildTag l[Exp l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XChildTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XDomName",
          "package": "haskell-src-exts",
          "signature": "XDomName l String String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#XName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XDomName",
          "package": "haskell-src-exts",
          "partial": "XDom Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XDomName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty xml element, with attributes\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XETag",
          "package": "haskell-src-exts",
          "signature": "XETag l (XName l) [XAttr l] (Maybe (Exp l))",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "empty xml element with attributes",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XETag",
          "normalized": "XETag a(XName a)[XAttr a](Maybe(Exp a))",
          "package": "haskell-src-exts",
          "partial": "XETag",
          "signature": "XETag l(XName l)[XAttr l](Maybe(Exp l))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XETag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eescaped haskell expression inside xml\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XExpTag",
          "package": "haskell-src-exts",
          "signature": "XExpTag l (Exp l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "escaped haskell expression inside xml",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XExpTag",
          "package": "haskell-src-exts",
          "partial": "XExp Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XExpTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "signature": "XName l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#XName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "partial": "XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePCDATA child element\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XPcdata",
          "package": "haskell-src-exts",
          "signature": "XPcdata l String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "PCDATA child element",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XPcdata",
          "package": "haskell-src-exts",
          "partial": "XPcdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XPcdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003exml element, with attributes and children\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XTag",
          "package": "haskell-src-exts",
          "signature": "XTag l (XName l) [XAttr l] (Maybe (Exp l)) [Exp l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "xml element with attributes and children",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XTag",
          "normalized": "XTag a(XName a)[XAttr a](Maybe(Exp a))[Exp a]",
          "package": "haskell-src-exts",
          "partial": "XTag",
          "signature": "XTag l(XName l)[XAttr l](Maybe(Exp l))[Exp l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea hybrid module combining an XML document with an ordinary module\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XmlHybrid",
          "package": "haskell-src-exts",
          "signature": "XmlHybrid l (Maybe (ModuleHead l)) [ModulePragma l] [ImportDecl l] [Decl l] (XName l) [XAttr l] (Maybe (Exp l)) [Exp l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Module",
          "type": "function"
        },
        "index": {
          "description": "hybrid module combining an XML document with an ordinary module",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XmlHybrid",
          "normalized": "XmlHybrid a(Maybe(ModuleHead a))[ModulePragma a][ImportDecl a][Decl a](XName a)[XAttr a](Maybe(Exp a))[Exp a]",
          "package": "haskell-src-exts",
          "partial": "Xml Hybrid",
          "signature": "XmlHybrid l(Maybe(ModuleHead l))[ModulePragma l][ImportDecl l][Decl l](XName l)[XAttr l](Maybe(Exp l))[Exp l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XmlHybrid"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea module consisting of a single XML document. The ModuleName never appears in the source\n   but is needed for semantic purposes, it will be the same as the file name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XmlPage",
          "package": "haskell-src-exts",
          "signature": "XmlPage l (ModuleName l) [ModulePragma l] (XName l) [XAttr l] (Maybe (Exp l)) [Exp l]",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Module",
          "type": "function"
        },
        "index": {
          "description": "module consisting of single XML document The ModuleName never appears in the source but is needed for semantic purposes it will be the same as the file name",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "XmlPage",
          "normalized": "XmlPage a(ModuleName a)[ModulePragma a](XName a)[XAttr a](Maybe(Exp a))[Exp a]",
          "package": "haskell-src-exts",
          "partial": "Xml Page",
          "signature": "XmlPage l(ModuleName l)[ModulePragma l](XName l)[XAttr l](Maybe(Exp l))[Exp l]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:XmlPage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Annotated.Syntax\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "YHC",
          "package": "haskell-src-exts",
          "signature": "YHC",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:YHC\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:YHC\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "YHC",
          "package": "haskell-src-exts",
          "partial": "YHC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:YHC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eChange the annotation of an AST node. Note that only the annotation of\n   the node itself is affected, and not the annotations of any child nodes.\n   if all nodes in the AST tree are to be affected, use \u003ccode\u003e\u003ca\u003efmap\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "amap",
          "package": "haskell-src-exts",
          "signature": "(l -\u003e l) -\u003e ast l -\u003e ast l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#amap",
          "type": "method"
        },
        "index": {
          "description": "Change the annotation of an AST node Note that only the annotation of the node itself is affected and not the annotations of any child nodes if all nodes in the AST tree are to be affected use fmap",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "amap",
          "normalized": "(a-\u003ea)-\u003eb a-\u003eb a",
          "package": "haskell-src-exts",
          "signature": "(l-\u003el)-\u003east l-\u003east l",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:amap"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the annotation of an AST node.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ann",
          "package": "haskell-src-exts",
          "signature": "ast l -\u003e l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ann",
          "type": "method"
        },
        "index": {
          "description": "Retrieve the annotation of an AST node",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ann",
          "normalized": "a b-\u003eb",
          "package": "haskell-src-exts",
          "signature": "ast l-\u003el",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "as_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#as_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "as_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:as_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "bang_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#bang_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "bang_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:bang_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ccall_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ccall_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "ccall_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:ccall_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "cplusplus_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#cplusplus_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "cplusplus_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:cplusplus_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "dot_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#dot_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "dot_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:dot_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "dotnet_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#dotnet_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "dotnet_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:dotnet_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "export_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#export_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "export_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:export_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "family_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#family_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "family_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:family_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "forall_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#forall_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "forall_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:forall_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "fun_tycon",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Type l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#fun_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "fun_tycon",
          "normalized": "a-\u003eType a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eType l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:fun_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "fun_tycon_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#fun_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "fun_tycon_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:fun_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "hiding_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#hiding_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "hiding_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:hiding_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eannotation, used by parser for position of the \u003ccode\u003eimport\u003c/code\u003e keyword.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importAnn",
          "package": "haskell-src-exts",
          "signature": "l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "annotation used by parser for position of the import keyword",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importAnn",
          "package": "haskell-src-exts",
          "partial": "Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional alias name in an \u003ccode\u003eas\u003c/code\u003e clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importAs",
          "package": "haskell-src-exts",
          "signature": "Maybe (ModuleName l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "optional alias name in an as clause",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importAs",
          "package": "haskell-src-exts",
          "partial": "As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of the module imported.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importModule",
          "package": "haskell-src-exts",
          "signature": "ModuleName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "name of the module imported",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importModule",
          "package": "haskell-src-exts",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported with explicit package name\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importPkg",
          "package": "haskell-src-exts",
          "signature": "Maybe String",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported with explicit package name",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importPkg",
          "package": "haskell-src-exts",
          "partial": "Pkg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importPkg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported \u003ccode\u003equalified\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importQualified",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported qualified",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importQualified",
          "package": "haskell-src-exts",
          "partial": "Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importQualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional list of import specifications.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importSpecs",
          "package": "haskell-src-exts",
          "signature": "Maybe (ImportSpecList l)",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "optional list of import specifications",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importSpecs",
          "package": "haskell-src-exts",
          "partial": "Specs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importSpecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported with \u003ccode\u003e{-# SOURCE #-}\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importSrc",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported with SOURCE",
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "importSrc",
          "package": "haskell-src-exts",
          "partial": "Src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:importSrc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "js_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#js_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "js_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:js_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "jvm_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#jvm_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "jvm_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:jvm_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "list_cons_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#list_cons_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "list_cons_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:list_cons_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "list_tycon",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Type l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#list_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "list_tycon",
          "normalized": "a-\u003eType a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eType l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:list_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "list_tycon_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#list_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "list_tycon_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:list_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "main_mod",
          "package": "haskell-src-exts",
          "signature": "l -\u003e ModuleName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#main_mod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "main_mod",
          "normalized": "a-\u003eModuleName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eModuleName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:main_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "main_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#main_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "main_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:main_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "minus_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#minus_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "minus_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:minus_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "prelude_mod",
          "package": "haskell-src-exts",
          "signature": "l -\u003e ModuleName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#prelude_mod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "prelude_mod",
          "normalized": "a-\u003eModuleName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eModuleName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:prelude_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "qualified_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#qualified_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "qualified_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:qualified_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "safe_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#safe_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "safe_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:safe_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "star_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#star_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "star_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:star_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "stdcall_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#stdcall_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "stdcall_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:stdcall_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "threadsafe_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#threadsafe_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "threadsafe_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:threadsafe_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_con",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Boxed -\u003e Int -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#tuple_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_con",
          "normalized": "a-\u003eBoxed-\u003eInt-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eBoxed-\u003eInt-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:tuple_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_con_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Boxed -\u003e Int -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#tuple_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_con_name",
          "normalized": "a-\u003eBoxed-\u003eInt-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eBoxed-\u003eInt-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:tuple_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_tycon",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Boxed -\u003e Int -\u003e Type l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#tuple_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_tycon",
          "normalized": "a-\u003eBoxed-\u003eInt-\u003eType a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eBoxed-\u003eInt-\u003eType l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:tuple_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_tycon_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Boxed -\u003e Int -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#tuple_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "tuple_tycon_name",
          "normalized": "a-\u003eBoxed-\u003eInt-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eBoxed-\u003eInt-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:tuple_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_con",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unboxed_singleton_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_con",
          "normalized": "a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unboxed_singleton_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_con_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unboxed_singleton_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_con_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unboxed_singleton_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_tycon",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Type l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unboxed_singleton_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_tycon",
          "normalized": "a-\u003eType a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eType l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unboxed_singleton_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_tycon_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unboxed_singleton_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unboxed_singleton_tycon_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unboxed_singleton_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_con",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Exp l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unit_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_con",
          "normalized": "a-\u003eExp a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eExp l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unit_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_con_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unit_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_con_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unit_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_tycon",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Type l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unit_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_tycon",
          "normalized": "a-\u003eType a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eType l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unit_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_tycon_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e QName l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unit_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unit_tycon_name",
          "normalized": "a-\u003eQName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eQName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unit_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unsafe_name",
          "package": "haskell-src-exts",
          "signature": "l -\u003e Name l",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#unsafe_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated Syntax",
          "module": "Language.Haskell.Exts.Annotated.Syntax",
          "name": "unsafe_name",
          "normalized": "a-\u003eName a",
          "package": "haskell-src-exts",
          "signature": "l-\u003eName l",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated-Syntax.html#v:unsafe_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn umbrella module for the various functionality\n of the package. Also provides some convenient\n functionality for dealing directly with source files.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "Annotated",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated.html",
          "type": "module"
        },
        "index": {
          "description": "An umbrella module for the various functionality of the package Also provides some convenient functionality for dealing directly with source files",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "Annotated",
          "package": "haskell-src-exts",
          "partial": "Annotated",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell top-level declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseDecl",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Decl SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseDecl",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell top-level declaration",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseDecl",
          "normalized": "String-\u003eParseResult(Decl SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Decl",
          "signature": "String-\u003eParseResult(Decl SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseDeclWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Decl SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseDeclWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseDeclWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Decl SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Decl With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Decl SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseDeclWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell top-level declaration, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseDeclWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Decl SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseDeclWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell top-level declaration using an explicit mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseDeclWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Decl SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Decl With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Decl SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseDeclWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseExp",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Exp SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseExp",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell expression",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseExp",
          "normalized": "String-\u003eParseResult(Exp SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Exp",
          "signature": "String-\u003eParseResult(Exp SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseExpWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Exp SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseExpWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseExpWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Exp SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Exp With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Exp SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseExpWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell expression, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseExpWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Exp SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseExpWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell expression using an explicit mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseExpWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Exp SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Exp With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Exp SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseExpWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, using the default parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFile",
          "package": "haskell-src-exts",
          "signature": "FilePath -\u003e IO (ParseResult (Module SrcSpanInfo))",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFile",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk using the default parse mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFile",
          "normalized": "FilePath-\u003eIO(ParseResult(Module SrcSpanInfo))",
          "package": "haskell-src-exts",
          "partial": "File",
          "signature": "FilePath-\u003eIO(ParseResult(Module SrcSpanInfo))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string using the default parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContents",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Module SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileContents",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string using the default parse mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContents",
          "normalized": "String-\u003eParseResult(Module SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "File Contents",
          "signature": "String-\u003eParseResult(Module SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContentsWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Module SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileContentsWithComments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContentsWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "File Contents With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileContentsWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string, with an extra set of extensions to know about\n   on top of what the file itself declares.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContentsWithExts",
          "package": "haskell-src-exts",
          "signature": "[Extension] -\u003e String -\u003e ParseResult (Module SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileContentsWithExts",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string with an extra set of extensions to know about on top of what the file itself declares",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContentsWithExts",
          "normalized": "[Extension]-\u003eString-\u003eParseResult(Module SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "File Contents With Exts",
          "signature": "[Extension]-\u003eString-\u003eParseResult(Module SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileContentsWithExts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string using a custom parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContentsWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Module SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileContentsWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string using custom parse mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileContentsWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "File Contents With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileContentsWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e FilePath -\u003e IO (ParseResult (Module SrcSpanInfo, [Comment]))",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileWithComments",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileWithComments",
          "normalized": "ParseMode-\u003eFilePath-\u003eIO(ParseResult(Module SrcSpanInfo,[Comment]))",
          "package": "haskell-src-exts",
          "partial": "File With Comments",
          "signature": "ParseMode-\u003eFilePath-\u003eIO(ParseResult(Module SrcSpanInfo,[Comment]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, with an extra set of extensions to know about\n   on top of what the file itself declares.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileWithExts",
          "package": "haskell-src-exts",
          "signature": "[Extension] -\u003e FilePath -\u003e IO (ParseResult (Module SrcSpanInfo))",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileWithExts",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk with an extra set of extensions to know about on top of what the file itself declares",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileWithExts",
          "normalized": "[Extension]-\u003eFilePath-\u003eIO(ParseResult(Module SrcSpanInfo))",
          "package": "haskell-src-exts",
          "partial": "File With Exts",
          "signature": "[Extension]-\u003eFilePath-\u003eIO(ParseResult(Module SrcSpanInfo))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileWithExts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, supplying a custom parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e FilePath -\u003e IO (ParseResult (Module SrcSpanInfo))",
          "source": "src/Language-Haskell-Exts-Annotated.html#parseFileWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk supplying custom parse mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseFileWithMode",
          "normalized": "ParseMode-\u003eFilePath-\u003eIO(ParseResult(Module SrcSpanInfo))",
          "package": "haskell-src-exts",
          "partial": "File With Mode",
          "signature": "ParseMode-\u003eFilePath-\u003eIO(ParseResult(Module SrcSpanInfo))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseFileWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string, which should contain a complete Haskell module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseModule",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Module SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseModule",
          "type": "function"
        },
        "index": {
          "description": "Parse of string which should contain complete Haskell module",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseModule",
          "normalized": "String-\u003eParseResult(Module SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Module",
          "signature": "String-\u003eParseResult(Module SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseModuleWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Module SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseModuleWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseModuleWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Module With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseModuleWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseModuleWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Module SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseModuleWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseModuleWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Module With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Module SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseModuleWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parsePat",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Pat SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parsePat",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell pattern",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parsePat",
          "normalized": "String-\u003eParseResult(Pat SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Pat",
          "signature": "String-\u003eParseResult(Pat SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parsePat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parsePatWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Pat SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parsePatWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parsePatWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Pat SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Pat With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Pat SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parsePatWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell pattern, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parsePatWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Pat SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parsePatWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell pattern using an explicit mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parsePatWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Pat SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Pat With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Pat SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parsePatWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell statement.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseStmt",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Stmt SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseStmt",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell statement",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseStmt",
          "normalized": "String-\u003eParseResult(Stmt SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "String-\u003eParseResult(Stmt SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseStmtWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Stmt SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseStmtWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseStmtWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Stmt SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Stmt With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Stmt SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseStmtWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseStmtWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Stmt SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseStmtWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type using an explicit mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseStmtWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Stmt SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Stmt With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Stmt SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseStmtWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseType",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult (Type SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseType",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseType",
          "normalized": "String-\u003eParseResult(Type SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Type",
          "signature": "String-\u003eParseResult(Type SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseTypeWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Type SrcSpanInfo, [Comment])",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseTypeWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseTypeWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Type SrcSpanInfo,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Type With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Type SrcSpanInfo,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseTypeWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseTypeWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Type SrcSpanInfo)",
          "source": "src/Language-Haskell-Exts-InternalParser.html#parseTypeWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type using an explicit mode",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "parseTypeWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Type SrcSpanInfo)",
          "package": "haskell-src-exts",
          "partial": "Type With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Type SrcSpanInfo)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:parseTypeWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGather the extensions declared in LANGUAGE pragmas\n   at the top of the file. Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the\n   parse of the pragmas fails.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "readExtensions",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Maybe (Maybe Language, [Extension])",
          "source": "src/Language-Haskell-Exts-Annotated.html#readExtensions",
          "type": "function"
        },
        "index": {
          "description": "Gather the extensions declared in LANGUAGE pragmas at the top of the file Returns Nothing if the parse of the pragmas fails",
          "hierarchy": "Language Haskell Exts Annotated",
          "module": "Language.Haskell.Exts.Annotated",
          "name": "readExtensions",
          "normalized": "String-\u003eMaybe(Maybe Language,[Extension])",
          "package": "haskell-src-exts",
          "partial": "Extensions",
          "signature": "String-\u003eMaybe(Maybe Language,[Extension])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Annotated.html#v:readExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module contains combinators to use when building\n Haskell source trees programmatically, as opposed to\n parsing them from a string. The contents here are quite\n experimental and will likely receive a lot of attention\n when the rest has stabilised.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "Build",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Build.html",
          "type": "module"
        },
        "index": {
          "description": "This module contains combinators to use when building Haskell source trees programmatically as opposed to parsing them from string The contents here are quite experimental and will likely receive lot of attention when the rest has stabilised",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "Build",
          "package": "haskell-src-exts",
          "partial": "Build",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unguarded alternative in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "alt",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Pat -\u003e Exp -\u003e Alt",
          "source": "src/Language-Haskell-Exts-Build.html#alt",
          "type": "function"
        },
        "index": {
          "description": "An unguarded alternative in case expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "alt",
          "normalized": "SrcLoc-\u003ePat-\u003eExp-\u003eAlt",
          "package": "haskell-src-exts",
          "signature": "SrcLoc-\u003ePat-\u003eExp-\u003eAlt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn alternative with a single guard in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "altGW",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Pat -\u003e [Stmt] -\u003e Exp -\u003e Binds -\u003e Alt",
          "source": "src/Language-Haskell-Exts-Build.html#altGW",
          "type": "function"
        },
        "index": {
          "description": "An alternative with single guard in case expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "altGW",
          "normalized": "SrcLoc-\u003ePat-\u003e[Stmt]-\u003eExp-\u003eBinds-\u003eAlt",
          "package": "haskell-src-exts",
          "partial": "GW",
          "signature": "SrcLoc-\u003ePat-\u003e[Stmt]-\u003eExp-\u003eBinds-\u003eAlt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:altGW"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApplication of expressions by juxtaposition.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "app",
          "package": "haskell-src-exts",
          "signature": "Exp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#app",
          "type": "function"
        },
        "index": {
          "description": "Application of expressions by juxtaposition",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "app",
          "normalized": "Exp-\u003eExp-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Exp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:app"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a function to a list of arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "appFun",
          "package": "haskell-src-exts",
          "signature": "Exp -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#appFun",
          "type": "function"
        },
        "index": {
          "description": "Apply function to list of arguments",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "appFun",
          "normalized": "Exp-\u003e[Exp]-\u003eExp",
          "package": "haskell-src-exts",
          "partial": "Fun",
          "signature": "Exp-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:appFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHoist a set of declarations to a binding group.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "binds",
          "package": "haskell-src-exts",
          "signature": "[Decl] -\u003e Binds",
          "source": "src/Language-Haskell-Exts-Build.html#binds",
          "type": "function"
        },
        "index": {
          "description": "Hoist set of declarations to binding group",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "binds",
          "normalized": "[Decl]-\u003eBinds",
          "package": "haskell-src-exts",
          "signature": "[Decl]-\u003eBinds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:binds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "caseE",
          "package": "haskell-src-exts",
          "signature": "Exp -\u003e [Alt] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#caseE",
          "type": "function"
        },
        "index": {
          "description": "case expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "caseE",
          "normalized": "Exp-\u003e[Alt]-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Exp-\u003e[Alt]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:caseE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal character expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "charE",
          "package": "haskell-src-exts",
          "signature": "Char -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#charE",
          "type": "function"
        },
        "index": {
          "description": "literal character expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "charE",
          "normalized": "Char-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Char-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:charE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal character pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "charP",
          "package": "haskell-src-exts",
          "signature": "Char -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#charP",
          "type": "function"
        },
        "index": {
          "description": "literal character pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "charP",
          "normalized": "Char-\u003ePat",
          "package": "haskell-src-exts",
          "signature": "Char-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:charP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA do block formed by the given statements.\n   The last statement in the list should be\n   a \u003ccode\u003e\u003ca\u003eQualifier\u003c/a\u003e\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "doE",
          "package": "haskell-src-exts",
          "signature": "[Stmt] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#doE",
          "type": "function"
        },
        "index": {
          "description": "do block formed by the given statements The last statement in the list should be Qualifier expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "doE",
          "normalized": "[Stmt]-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "[Stmt]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:doE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty list expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "eList",
          "package": "haskell-src-exts",
          "signature": "Exp",
          "source": "src/Language-Haskell-Exts-Build.html#eList",
          "type": "function"
        },
        "index": {
          "description": "The empty list expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "eList",
          "package": "haskell-src-exts",
          "partial": "List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:eList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with a given name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "function",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#function",
          "type": "function"
        },
        "index": {
          "description": "function with given name",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "function",
          "normalized": "String-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "String-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:function"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate k names by appending numbers 1 through k to a given string.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "genNames",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Int -\u003e [Name]",
          "source": "src/Language-Haskell-Exts-Build.html#genNames",
          "type": "function"
        },
        "index": {
          "description": "Generate names by appending numbers through to given string",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "genNames",
          "normalized": "String-\u003eInt-\u003e[Name]",
          "package": "haskell-src-exts",
          "partial": "Names",
          "signature": "String-\u003eInt-\u003e[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:genNames"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA generator statement: \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e\u003c-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "genStmt",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Pat -\u003e Exp -\u003e Stmt",
          "source": "src/Language-Haskell-Exts-Build.html#genStmt",
          "type": "function"
        },
        "index": {
          "description": "generator statement pat exp",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "genStmt",
          "normalized": "SrcLoc-\u003ePat-\u003eExp-\u003eStmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "SrcLoc-\u003ePat-\u003eExp-\u003eStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:genStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply an operator infix.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "infixApp",
          "package": "haskell-src-exts",
          "signature": "Exp -\u003e QOp -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#infixApp",
          "type": "function"
        },
        "index": {
          "description": "Apply an operator infix",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "infixApp",
          "normalized": "Exp-\u003eQOp-\u003eExp-\u003eExp",
          "package": "haskell-src-exts",
          "partial": "App",
          "signature": "Exp-\u003eQOp-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:infixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal integer expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "intE",
          "package": "haskell-src-exts",
          "signature": "Integer -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#intE",
          "type": "function"
        },
        "index": {
          "description": "literal integer expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "intE",
          "normalized": "Integer-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Integer-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:intE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal integer pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "intP",
          "package": "haskell-src-exts",
          "signature": "Integer -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#intP",
          "type": "function"
        },
        "index": {
          "description": "literal integer pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "intP",
          "normalized": "Integer-\u003ePat",
          "package": "haskell-src-exts",
          "signature": "Integer-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:intP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLambda abstraction, given a list of argument\n   patterns and an expression body.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "lamE",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e [Pat] -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#lamE",
          "type": "function"
        },
        "index": {
          "description": "Lambda abstraction given list of argument patterns and an expression body",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "lamE",
          "normalized": "SrcLoc-\u003e[Pat]-\u003eExp-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "SrcLoc-\u003e[Pat]-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:lamE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003elet\u003c/code\u003e ... \u003ccode\u003ein\u003c/code\u003e block.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "letE",
          "package": "haskell-src-exts",
          "signature": "[Decl] -\u003e Exp -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#letE",
          "type": "function"
        },
        "index": {
          "description": "let in block",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "letE",
          "normalized": "[Decl]-\u003eExp-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "[Decl]-\u003eExp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:letE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA \u003ccode\u003elet\u003c/code\u003e binding group as a statement.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "letStmt",
          "package": "haskell-src-exts",
          "signature": "[Decl] -\u003e Stmt",
          "source": "src/Language-Haskell-Exts-Build.html#letStmt",
          "type": "function"
        },
        "index": {
          "description": "let binding group as statement",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "letStmt",
          "normalized": "[Decl]-\u003eStmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "[Decl]-\u003eStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:letStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA list expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "listE",
          "package": "haskell-src-exts",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#listE",
          "type": "function"
        },
        "index": {
          "description": "list expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "listE",
          "normalized": "[Exp]-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:listE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply a constructor of a given name to a list of pattern\n   arguments, forming a constructor pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "metaConPat",
          "package": "haskell-src-exts",
          "signature": "String -\u003e [Pat] -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#metaConPat",
          "type": "function"
        },
        "index": {
          "description": "Apply constructor of given name to list of pattern arguments forming constructor pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "metaConPat",
          "normalized": "String-\u003e[Pat]-\u003ePat",
          "package": "haskell-src-exts",
          "partial": "Con Pat",
          "signature": "String-\u003e[Pat]-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:metaConPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eApply function of a given name to a list of arguments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "metaFunction",
          "package": "haskell-src-exts",
          "signature": "String -\u003e [Exp] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#metaFunction",
          "type": "function"
        },
        "index": {
          "description": "Apply function of given name to list of arguments",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "metaFunction",
          "normalized": "String-\u003e[Exp]-\u003eExp",
          "package": "haskell-src-exts",
          "partial": "Function",
          "signature": "String-\u003e[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:metaFunction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn identifier with the given string as its name.\n   The string should be a valid Haskell identifier.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "name",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Name",
          "source": "src/Language-Haskell-Exts-Build.html#name",
          "type": "function"
        },
        "index": {
          "description": "An identifier with the given string as its name The string should be valid Haskell identifier",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "name",
          "normalized": "String-\u003eName",
          "package": "haskell-src-exts",
          "signature": "String-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBind an identifier to an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "nameBind",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Name -\u003e Exp -\u003e Decl",
          "source": "src/Language-Haskell-Exts-Build.html#nameBind",
          "type": "function"
        },
        "index": {
          "description": "Bind an identifier to an expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "nameBind",
          "normalized": "SrcLoc-\u003eName-\u003eExp-\u003eDecl",
          "package": "haskell-src-exts",
          "partial": "Bind",
          "signature": "SrcLoc-\u003eName-\u003eExp-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:nameBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn empty binding group.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "noBinds",
          "package": "haskell-src-exts",
          "signature": "Binds",
          "source": "src/Language-Haskell-Exts-Build.html#noBinds",
          "type": "function"
        },
        "index": {
          "description": "An empty binding group",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "noBinds",
          "package": "haskell-src-exts",
          "partial": "Binds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:noBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUse the given identifier as an operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "op",
          "package": "haskell-src-exts",
          "signature": "Name -\u003e QOp",
          "source": "src/Language-Haskell-Exts-Build.html#op",
          "type": "function"
        },
        "index": {
          "description": "Use the given identifier as an operator",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "op",
          "normalized": "Name-\u003eQOp",
          "package": "haskell-src-exts",
          "signature": "Name-\u003eQOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA constructor pattern, with argument patterns.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "pApp",
          "package": "haskell-src-exts",
          "signature": "Name -\u003e [Pat] -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#pApp",
          "type": "function"
        },
        "index": {
          "description": "constructor pattern with argument patterns",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "pApp",
          "normalized": "Name-\u003e[Pat]-\u003ePat",
          "package": "haskell-src-exts",
          "partial": "App",
          "signature": "Name-\u003e[Pat]-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:pApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut parentheses around a pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "pParen",
          "package": "haskell-src-exts",
          "signature": "Pat -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#pParen",
          "type": "function"
        },
        "index": {
          "description": "Put parentheses around pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "pParen",
          "normalized": "Pat-\u003ePat",
          "package": "haskell-src-exts",
          "partial": "Paren",
          "signature": "Pat-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:pParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "pTuple",
          "package": "haskell-src-exts",
          "signature": "[Pat] -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#pTuple",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "pTuple",
          "normalized": "[Pat]-\u003ePat",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "[Pat]-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:pTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePut parentheses around an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "paren",
          "package": "haskell-src-exts",
          "signature": "Exp -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#paren",
          "type": "function"
        },
        "index": {
          "description": "Put parentheses around an expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "paren",
          "normalized": "Exp-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Exp-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern bind where the pattern is a variable, and where\n there are no guards and no 'where' clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "patBind",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Pat -\u003e Exp -\u003e Decl",
          "source": "src/Language-Haskell-Exts-Build.html#patBind",
          "type": "function"
        },
        "index": {
          "description": "pattern bind where the pattern is variable and where there are no guards and no where clause",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "patBind",
          "normalized": "SrcLoc-\u003ePat-\u003eExp-\u003eDecl",
          "package": "haskell-src-exts",
          "partial": "Bind",
          "signature": "SrcLoc-\u003ePat-\u003eExp-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:patBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern bind where the pattern is a variable, and where\n there are no guards, but with a 'where' clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "patBindWhere",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Pat -\u003e Exp -\u003e [Decl] -\u003e Decl",
          "source": "src/Language-Haskell-Exts-Build.html#patBindWhere",
          "type": "function"
        },
        "index": {
          "description": "pattern bind where the pattern is variable and where there are no guards but with where clause",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "patBindWhere",
          "normalized": "SrcLoc-\u003ePat-\u003eExp-\u003e[Decl]-\u003eDecl",
          "package": "haskell-src-exts",
          "partial": "Bind Where",
          "signature": "SrcLoc-\u003ePat-\u003eExp-\u003e[Decl]-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:patBindWhere"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe empty list pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "peList",
          "package": "haskell-src-exts",
          "signature": "Pat",
          "source": "src/Language-Haskell-Exts-Build.html#peList",
          "type": "function"
        },
        "index": {
          "description": "The empty list pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "peList",
          "package": "haskell-src-exts",
          "partial": "List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:peList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern variable.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "pvar",
          "package": "haskell-src-exts",
          "signature": "Name -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#pvar",
          "type": "function"
        },
        "index": {
          "description": "pattern variable",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "pvar",
          "normalized": "Name-\u003ePat",
          "package": "haskell-src-exts",
          "signature": "Name-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:pvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple pattern consisting of variables only.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "pvarTuple",
          "package": "haskell-src-exts",
          "signature": "[Name] -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#pvarTuple",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern consisting of variables only",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "pvarTuple",
          "normalized": "[Name]-\u003ePat",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "[Name]-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:pvarTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA qualifier expression statement.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "qualStmt",
          "package": "haskell-src-exts",
          "signature": "Exp -\u003e Stmt",
          "source": "src/Language-Haskell-Exts-Build.html#qualStmt",
          "type": "function"
        },
        "index": {
          "description": "qualifier expression statement",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "qualStmt",
          "normalized": "Exp-\u003eStmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "Exp-\u003eStmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:qualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA qualified variable as expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "qvar",
          "package": "haskell-src-exts",
          "signature": "ModuleName -\u003e Name -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#qvar",
          "type": "function"
        },
        "index": {
          "description": "qualified variable as expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "qvar",
          "normalized": "ModuleName-\u003eName-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "ModuleName-\u003eName-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:qvar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with a single clause\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "sfun",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Name -\u003e [Name] -\u003e Rhs -\u003e Binds -\u003e Decl",
          "source": "src/Language-Haskell-Exts-Build.html#sfun",
          "type": "function"
        },
        "index": {
          "description": "function with single clause",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "sfun",
          "normalized": "SrcLoc-\u003eName-\u003e[Name]-\u003eRhs-\u003eBinds-\u003eDecl",
          "package": "haskell-src-exts",
          "signature": "SrcLoc-\u003eName-\u003e[Name]-\u003eRhs-\u003eBinds-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:sfun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA function with a single clause, a single argument, no guards\n and no where declarations\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "simpleFun",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e Name -\u003e Name -\u003e Exp -\u003e Decl",
          "source": "src/Language-Haskell-Exts-Build.html#simpleFun",
          "type": "function"
        },
        "index": {
          "description": "function with single clause single argument no guards and no where declarations",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "simpleFun",
          "normalized": "SrcLoc-\u003eName-\u003eName-\u003eExp-\u003eDecl",
          "package": "haskell-src-exts",
          "partial": "Fun",
          "signature": "SrcLoc-\u003eName-\u003eName-\u003eExp-\u003eDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:simpleFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal string expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "strE",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#strE",
          "type": "function"
        },
        "index": {
          "description": "literal string expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "strE",
          "normalized": "String-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "String-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:strE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA literal string pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "strP",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Pat",
          "source": "src/Language-Haskell-Exts-Build.html#strP",
          "type": "function"
        },
        "index": {
          "description": "literal string pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "strP",
          "normalized": "String-\u003ePat",
          "package": "haskell-src-exts",
          "signature": "String-\u003ePat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:strP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA symbol identifier. The string should be a valid\n   Haskell symbol identifier.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "sym",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Name",
          "source": "src/Language-Haskell-Exts-Build.html#sym",
          "type": "function"
        },
        "index": {
          "description": "symbol identifier The string should be valid Haskell symbol identifier",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "sym",
          "normalized": "String-\u003eName",
          "package": "haskell-src-exts",
          "signature": "String-\u003eName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:sym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "tuple",
          "package": "haskell-src-exts",
          "signature": "[Exp] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#tuple",
          "type": "function"
        },
        "index": {
          "description": "tuple expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "tuple",
          "normalized": "[Exp]-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "[Exp]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA local variable as expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "var",
          "package": "haskell-src-exts",
          "signature": "Name -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#var",
          "type": "function"
        },
        "index": {
          "description": "local variable as expression",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "var",
          "normalized": "Name-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Name-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA tuple expression consisting of variables only.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "varTuple",
          "package": "haskell-src-exts",
          "signature": "[Name] -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Build.html#varTuple",
          "type": "function"
        },
        "index": {
          "description": "tuple expression consisting of variables only",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "varTuple",
          "normalized": "[Name]-\u003eExp",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "[Name]-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:varTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe wildcard pattern: \u003ccode\u003e_\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Build",
          "name": "wildcard",
          "package": "haskell-src-exts",
          "signature": "Pat",
          "source": "src/Language-Haskell-Exts-Build.html#wildcard",
          "type": "function"
        },
        "index": {
          "description": "The wildcard pattern",
          "hierarchy": "Language Haskell Exts Build",
          "module": "Language.Haskell.Exts.Build",
          "name": "wildcard",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Build.html#v:wildcard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Comments",
          "name": "Comments",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Comments.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Comments",
          "module": "Language.Haskell.Exts.Comments",
          "name": "Comments",
          "package": "haskell-src-exts",
          "partial": "Comments",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Comments.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Haskell comment. The \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the comment is multi-line, i.e. \u003ccode\u003e{- -}\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Comments",
          "name": "Comment",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Comments.html#Comment",
          "type": "data"
        },
        "index": {
          "description": "Haskell comment The Bool is True if the comment is multi-line i.e",
          "hierarchy": "Language Haskell Exts Comments",
          "module": "Language.Haskell.Exts.Comments",
          "name": "Comment",
          "package": "haskell-src-exts",
          "partial": "Comment",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Comments.html#t:Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Comments",
          "name": "Comment",
          "package": "haskell-src-exts",
          "signature": "Comment Bool SrcSpan String",
          "source": "src/Language-Haskell-Exts-Comments.html#Comment",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Comments",
          "module": "Language.Haskell.Exts.Comments",
          "name": "Comment",
          "package": "haskell-src-exts",
          "partial": "Comment",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Comments.html#v:Comment"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines the list of recognized modular features\n of Haskell, most often (sloppily) referred to as \u003ca\u003eextensions\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eClosely mimicking the Language.Haskell.Extension module from\n the Cabal library, this package also includes functionality for\n \u003ca\u003ecomputing\u003c/a\u003e languages as sets of features. Also, we make no\n promise not to add extensions not yet recognized by Cabal.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Extension",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Extension.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines the list of recognized modular features of Haskell most often sloppily referred to as extensions Closely mimicking the Language.Haskell.Extension module from the Cabal library this package also includes functionality for computing languages as sets of features Also we make no promise not to add extensions not yet recognized by Cabal",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Extension",
          "package": "haskell-src-exts",
          "partial": "Extension",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis represents language extensions beyond a base \u003ccode\u003e\u003ca\u003eLanguage\u003c/a\u003e\u003c/code\u003e definition\n (such as \u003ccode\u003e\u003ca\u003eHaskell98\u003c/a\u003e\u003c/code\u003e) that are supported by some implementations, usually\n in some special mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Extension",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Extension.html#Extension",
          "type": "data"
        },
        "index": {
          "description": "This represents language extensions beyond base Language definition such as Haskell98 that are supported by some implementations usually in some special mode",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Extension",
          "package": "haskell-src-exts",
          "partial": "Extension",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#t:Extension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "KnownExtension",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "KnownExtension",
          "package": "haskell-src-exts",
          "partial": "Known Extension",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#t:KnownExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "Language",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Extension.html#Language",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Language",
          "package": "haskell-src-exts",
          "partial": "Language",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#t:Language"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.10\u003c/dt\u003e\u003cdd\u003e Enable arrow notation.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Arrows",
          "package": "haskell-src-exts",
          "signature": "Arrows",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable arrow notation",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Arrows",
          "package": "haskell-src-exts",
          "partial": "Arrows",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:Arrows"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.11\u003c/dt\u003e\u003cdd\u003e Enable a form of pattern which forces evaluation\n before an attempted match, and a form of strict \u003ccode\u003elet\u003c/code\u003e/\u003ccode\u003ewhere\u003c/code\u003e\n binding.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "BangPatterns",
          "package": "haskell-src-exts",
          "signature": "BangPatterns",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable form of pattern which forces evaluation before an attempted match and form of strict let where binding",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "BangPatterns",
          "package": "haskell-src-exts",
          "partial": "Bang Patterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:BangPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 8.1.5\u003c/dt\u003e\u003cdd\u003e Enable the \u003ccode\u003ecapi\u003c/code\u003e calling convention in the\n foreign function interface.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "CApiFFI",
          "package": "haskell-src-exts",
          "signature": "CApiFFI",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable the capi calling convention in the foreign function interface",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "CApiFFI",
          "package": "haskell-src-exts",
          "partial": "CApi FFI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:CApiFFI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 4.10.3\u003c/dt\u003e\u003cdd\u003e Run the C preprocessor on Haskell source code.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "CPP",
          "package": "haskell-src-exts",
          "signature": "CPP",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Run the preprocessor on Haskell source code",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "CPP",
          "package": "haskell-src-exts",
          "partial": "CPP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:CPP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.1.3\u003c/dt\u003e\u003cdd\u003e Allow a class method's type to place\n additional constraints on a class type variable.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ConstrainedClassMethods",
          "package": "haskell-src-exts",
          "signature": "ConstrainedClassMethods",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow class method type to place additional constraints on class type variable",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ConstrainedClassMethods",
          "package": "haskell-src-exts",
          "partial": "Constrained Class Methods",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ConstrainedClassMethods"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow contexts to be put on datatypes, e.g. the \u003ccode\u003eEq a\u003c/code\u003e in\n \u003ccode\u003edata Eq a =\u003e Set a = NilSet | ConsSet a (Set a)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DatatypeContexts",
          "package": "haskell-src-exts",
          "signature": "DatatypeContexts",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Allow contexts to be put on datatypes e.g the Eq in data Eq Set NilSet ConsSet Set",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DatatypeContexts",
          "package": "haskell-src-exts",
          "partial": "Datatype Contexts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DatatypeContexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.5.3\u003c/dt\u003e\u003cdd\u003e Enable \u003ccode\u003ederiving\u003c/code\u003e for classes\n \u003ccode\u003eData.Typeable.Typeable\u003c/code\u003e and \u003ccode\u003eData.Generics.Data\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveDataTypeable",
          "package": "haskell-src-exts",
          "signature": "DeriveDataTypeable",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable deriving for classes Data.Typeable.Typeable and Data.Generics.Data",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveDataTypeable",
          "package": "haskell-src-exts",
          "partial": "Derive Data Typeable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DeriveDataTypeable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnable \u003ccode\u003ederiving\u003c/code\u003e for the \u003ccode\u003eData.Foldable.Foldable\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveFoldable",
          "package": "haskell-src-exts",
          "signature": "DeriveFoldable",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Enable deriving for the Data.Foldable.Foldable class",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveFoldable",
          "package": "haskell-src-exts",
          "partial": "Derive Foldable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DeriveFoldable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnable \u003ccode\u003ederiving\u003c/code\u003e for the \u003ccode\u003eData.Functor.Functor\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveFunctor",
          "package": "haskell-src-exts",
          "signature": "DeriveFunctor",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Enable deriving for the Data.Functor.Functor class",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveFunctor",
          "package": "haskell-src-exts",
          "partial": "Derive Functor",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DeriveFunctor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnable \u003ccode\u003ederiving\u003c/code\u003e for the \u003ccode\u003eData.Traversable.Traversable\u003c/code\u003e class.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveTraversable",
          "package": "haskell-src-exts",
          "signature": "DeriveTraversable",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Enable deriving for the Data.Traversable.Traversable class",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DeriveTraversable",
          "package": "haskell-src-exts",
          "partial": "Derive Traversable",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DeriveTraversable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDisable a known extension\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DisableExtension",
          "package": "haskell-src-exts",
          "signature": "DisableExtension KnownExtension",
          "source": "src/Language-Haskell-Exts-Extension.html#Extension",
          "type": "function"
        },
        "index": {
          "description": "Disable known extension",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DisableExtension",
          "package": "haskell-src-exts",
          "partial": "Disable Extension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DisableExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.14\u003c/dt\u003e\u003cdd\u003e Allow a record field name to be disambiguated\n by the type of the record it's in.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DisambiguateRecordFields",
          "package": "haskell-src-exts",
          "signature": "DisambiguateRecordFields",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow record field name to be disambiguated by the type of the record it in",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DisambiguateRecordFields",
          "package": "haskell-src-exts",
          "partial": "Disambiguate Record Fields",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DisambiguateRecordFields"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eImprove the layout rule when \u003ccode\u003eif\u003c/code\u003e expressions are used in a \u003ccode\u003edo\u003c/code\u003e\n block.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DoAndIfThenElse",
          "package": "haskell-src-exts",
          "signature": "DoAndIfThenElse",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Improve the layout rule when if expressions are used in do block",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "DoAndIfThenElse",
          "package": "haskell-src-exts",
          "partial": "Do And If Then Else",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:DoAndIfThenElse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.4.1\u003c/dt\u003e\u003cdd\u003e Allow data type declarations with no constructors.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "EmptyDataDecls",
          "package": "haskell-src-exts",
          "signature": "EmptyDataDecls",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow data type declarations with no constructors",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "EmptyDataDecls",
          "package": "haskell-src-exts",
          "partial": "Empty Data Decls",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:EmptyDataDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnable a known extension\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "EnableExtension",
          "package": "haskell-src-exts",
          "signature": "EnableExtension KnownExtension",
          "source": "src/Language-Haskell-Exts-Extension.html#Extension",
          "type": "function"
        },
        "index": {
          "description": "Enable known extension",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "EnableExtension",
          "package": "haskell-src-exts",
          "partial": "Enable Extension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:EnableExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.4.4\u003c/dt\u003e\u003cdd\u003e Allow existentially-quantified data constructors.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExistentialQuantification",
          "package": "haskell-src-exts",
          "signature": "ExistentialQuantification",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow existentially-quantified data constructors",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExistentialQuantification",
          "package": "haskell-src-exts",
          "partial": "Existential Quantification",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ExistentialQuantification"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMake \u003ccode\u003eforall\u003c/code\u003e a keyword in types, which can be used to give the\n generalisation explicitly.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExplicitForAll",
          "package": "haskell-src-exts",
          "signature": "ExplicitForAll",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Make forall keyword in types which can be used to give the generalisation explicitly",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExplicitForAll",
          "package": "haskell-src-exts",
          "partial": "Explicit For All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ExplicitForAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 2.4.5\u003c/dt\u003e\u003cdd\u003e Allow default instantiation of polymorphic\n types in more situations.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExtendedDefaultRules",
          "package": "haskell-src-exts",
          "signature": "ExtendedDefaultRules",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow default instantiation of polymorphic types in more situations",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExtendedDefaultRules",
          "package": "haskell-src-exts",
          "partial": "Extended Default Rules",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ExtendedDefaultRules"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eHugs &#167; 7.1\u003c/dt\u003e\u003cdd\u003e Enable the \"Trex\" extensible records system.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExtensibleRecords",
          "package": "haskell-src-exts",
          "signature": "ExtensibleRecords",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Hugs Enable the Trex extensible records system",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ExtensibleRecords",
          "package": "haskell-src-exts",
          "partial": "Extensible Records",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ExtensibleRecords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.2\u003c/dt\u003e\u003cdd\u003e Relax some restrictions on the form of the context\n of a type signature.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "FlexibleContexts",
          "package": "haskell-src-exts",
          "signature": "FlexibleContexts",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Relax some restrictions on the form of the context of type signature",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "FlexibleContexts",
          "package": "haskell-src-exts",
          "partial": "Flexible Contexts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:FlexibleContexts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.3.2\u003c/dt\u003e\u003cdd\u003e Relax some restrictions on the form of the\n context of an instance declaration.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "FlexibleInstances",
          "package": "haskell-src-exts",
          "signature": "FlexibleInstances",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Relax some restrictions on the form of the context of an instance declaration",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "FlexibleInstances",
          "package": "haskell-src-exts",
          "partial": "Flexible Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:FlexibleInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 8\u003c/dt\u003e\u003cdd\u003e Enable the Foreign Function Interface.  In GHC,\n implements the standard Haskell 98 Foreign Function Interface\n Addendum, plus some GHC-specific extensions.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ForeignFunctionInterface",
          "package": "haskell-src-exts",
          "signature": "ForeignFunctionInterface",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable the Foreign Function Interface In GHC implements the standard Haskell Foreign Function Interface Addendum plus some GHC-specific extensions",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ForeignFunctionInterface",
          "package": "haskell-src-exts",
          "partial": "Foreign Function Interface",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ForeignFunctionInterface"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.2\u003c/dt\u003e\u003cdd\u003e Allow a specification attached to a\n multi-parameter type class which indicates that some parameters\n are entirely determined by others. The implementation will check\n that this property holds for the declared instances, and will use\n this property to reduce ambiguity in instance resolution.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "FunctionalDependencies",
          "package": "haskell-src-exts",
          "signature": "FunctionalDependencies",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow specification attached to multi-parameter type class which indicates that some parameters are entirely determined by others The implementation will check that this property holds for the declared instances and will use this property to reduce ambiguity in instance resolution",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "FunctionalDependencies",
          "package": "haskell-src-exts",
          "partial": "Functional Dependencies",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:FunctionalDependencies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.4.6\u003c/dt\u003e\u003cdd\u003e Enable generalized algebraic data types, in\n which type variables may be instantiated on a per-constructor\n basis. Implies GADTSyntax.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "GADTs",
          "package": "haskell-src-exts",
          "signature": "GADTs",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable generalized algebraic data types in which type variables may be instantiated on per-constructor basis Implies GADTSyntax",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "GADTs",
          "package": "haskell-src-exts",
          "partial": "GADTs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:GADTs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllows GHC primops, written in C--, to be imported into a Haskell\n file.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "GHCForeignImportPrim",
          "package": "haskell-src-exts",
          "signature": "GHCForeignImportPrim",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Allows GHC primops written in to be imported into Haskell file",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "GHCForeignImportPrim",
          "package": "haskell-src-exts",
          "partial": "GHCForeign Import Prim",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:GHCForeignImportPrim"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.5.4\u003c/dt\u003e\u003cdd\u003e Allow a type declared with \u003ccode\u003enewtype\u003c/code\u003e to use\n \u003ccode\u003ederiving\u003c/code\u003e for any class with an instance for the underlying type.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "GeneralizedNewtypeDeriving",
          "package": "haskell-src-exts",
          "signature": "GeneralizedNewtypeDeriving",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow type declared with newtype to use deriving for any class with an instance for the underlying type",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "GeneralizedNewtypeDeriving",
          "package": "haskell-src-exts",
          "partial": "Generalized Newtype Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:GeneralizedNewtypeDeriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.16\u003c/dt\u003e\u003cdd\u003e Enable generic type classes, with default instances\n defined in terms of the algebraic structure of a type.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Generics",
          "package": "haskell-src-exts",
          "signature": "Generics",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable generic type classes with default instances defined in terms of the algebraic structure of type",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Generics",
          "package": "haskell-src-exts",
          "partial": "Generics",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:Generics"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Haskell 2010 language as defined by the Haskell 2010 report.\n \u003ca\u003ehttp://www.haskell.org/onlinereport/haskell2010\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Haskell2010",
          "package": "haskell-src-exts",
          "signature": "Haskell2010",
          "source": "src/Language-Haskell-Exts-Extension.html#Language",
          "type": "function"
        },
        "index": {
          "description": "The Haskell language as defined by the Haskell report http www.haskell.org onlinereport haskell2010",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Haskell2010",
          "package": "haskell-src-exts",
          "partial": "Haskell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:Haskell2010"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Haskell 98 language as defined by the Haskell 98 report.\n \u003ca\u003ehttp://haskell.org/onlinereport/\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Haskell98",
          "package": "haskell-src-exts",
          "signature": "Haskell98",
          "source": "src/Language-Haskell-Exts-Extension.html#Language",
          "type": "function"
        },
        "index": {
          "description": "The Haskell language as defined by the Haskell report http haskell.org onlinereport",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Haskell98",
          "package": "haskell-src-exts",
          "partial": "Haskell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:Haskell98"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe minimal language resulting from disabling all recognized\n extensions - including ones that are part of all known language\n definitions e.g. MonomorphismRestriction.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "HaskellAllDisabled",
          "package": "haskell-src-exts",
          "signature": "HaskellAllDisabled",
          "source": "src/Language-Haskell-Exts-Extension.html#Language",
          "type": "function"
        },
        "index": {
          "description": "The minimal language resulting from disabling all recognized extensions including ones that are part of all known language definitions e.g MonomorphismRestriction",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "HaskellAllDisabled",
          "package": "haskell-src-exts",
          "partial": "Haskell All Disabled",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:HaskellAllDisabled"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eHugs &#167; 7.3\u003c/dt\u003e\u003cdd\u003e Enable an alternate syntax for string literals,\n with string templating.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "HereDocuments",
          "package": "haskell-src-exts",
          "signature": "HereDocuments",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Hugs Enable an alternate syntax for string literals with string templating",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "HereDocuments",
          "package": "haskell-src-exts",
          "partial": "Here Documents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:HereDocuments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.3\u003c/dt\u003e\u003cdd\u003e Enable implicit function parameters with dynamic\n scope.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ImplicitParams",
          "package": "haskell-src-exts",
          "signature": "ImplicitParams",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable implicit function parameters with dynamic scope",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ImplicitParams",
          "package": "haskell-src-exts",
          "partial": "Implicit Params",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ImplicitParams"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.11\u003c/dt\u003e\u003cdd\u003e Enable the implicit importing of the module\n \u003ccode\u003ePrelude\u003c/code\u003e.  When disabled, when desugaring certain built-in syntax\n into ordinary identifiers, use whatever is in scope rather than the\n \u003ccode\u003ePrelude\u003c/code\u003e -- version.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ImplicitPrelude",
          "package": "haskell-src-exts",
          "signature": "ImplicitPrelude",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable the implicit importing of the module Prelude When disabled when desugaring certain built-in syntax into ordinary identifiers use whatever is in scope rather than the Prelude version",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ImplicitPrelude",
          "package": "haskell-src-exts",
          "partial": "Implicit Prelude",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ImplicitPrelude"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.6\u003c/dt\u003e\u003cdd\u003e Deprecated in GHC 6.12 and will be removed in\n GHC 7.  Allow a type variable to be instantiated at a\n polymorphic type.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ImpredicativeTypes",
          "package": "haskell-src-exts",
          "signature": "ImpredicativeTypes",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Deprecated in GHC and will be removed in GHC Allow type variable to be instantiated at polymorphic type",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ImpredicativeTypes",
          "package": "haskell-src-exts",
          "partial": "Impredicative Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ImpredicativeTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.3.4\u003c/dt\u003e\u003cdd\u003e Implies \u003ccode\u003e\u003ca\u003eOverlappingInstances\u003c/a\u003e\u003c/code\u003e.  Allow the\n implementation to choose an instance even when it is possible\n that further instantiation of types will lead to a more specific\n instance being applicable.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "IncoherentInstances",
          "package": "haskell-src-exts",
          "signature": "IncoherentInstances",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Implies OverlappingInstances Allow the implementation to choose an instance even when it is possible that further instantiation of types will lead to more specific instance being applicable",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "IncoherentInstances",
          "package": "haskell-src-exts",
          "partial": "Incoherent Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:IncoherentInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 8.1.4\u003c/dt\u003e\u003cdd\u003e Enable interruptible FFI.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "InterruptibleFFI",
          "package": "haskell-src-exts",
          "signature": "InterruptibleFFI",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable interruptible FFI",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "InterruptibleFFI",
          "package": "haskell-src-exts",
          "partial": "Interruptible FFI",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:InterruptibleFFI"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.4\u003c/dt\u003e\u003cdd\u003e Allow an explicit kind signature giving the kind of\n types over which a type variable ranges.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "KindSignatures",
          "package": "haskell-src-exts",
          "signature": "KindSignatures",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow an explicit kind signature giving the kind of types over which type variable ranges",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "KindSignatures",
          "package": "haskell-src-exts",
          "partial": "Kind Signatures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:KindSignatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.4.3\u003c/dt\u003e\u003cdd\u003e Defer validity checking of types until after\n expanding type synonyms, relaxing the constraints on how synonyms\n may be used.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "LiberalTypeSynonyms",
          "package": "haskell-src-exts",
          "signature": "LiberalTypeSynonyms",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Defer validity checking of types until after expanding type synonyms relaxing the constraints on how synonyms may be used",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "LiberalTypeSynonyms",
          "package": "haskell-src-exts",
          "partial": "Liberal Type Synonyms",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:LiberalTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.2\u003c/dt\u003e\u003cdd\u003e Allow the character \u003ccode\u003e#\u003c/code\u003e as a postfix modifier on\n identifiers.  Also enables literal syntax for unboxed values.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MagicHash",
          "package": "haskell-src-exts",
          "signature": "MagicHash",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow the character as postfix modifier on identifiers Also enables literal syntax for unboxed values",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MagicHash",
          "package": "haskell-src-exts",
          "partial": "Magic Hash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:MagicHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLocal (\u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003ewhere\u003c/code\u003e) bindings are monomorphic.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MonoLocalBinds",
          "package": "haskell-src-exts",
          "signature": "MonoLocalBinds",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Local let and where bindings are monomorphic",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MonoLocalBinds",
          "package": "haskell-src-exts",
          "partial": "Mono Local Binds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:MonoLocalBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.17.2\u003c/dt\u003e\u003cdd\u003e Make pattern bindings monomorphic.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MonoPatBinds",
          "package": "haskell-src-exts",
          "signature": "MonoPatBinds",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Make pattern bindings monomorphic",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MonoPatBinds",
          "package": "haskell-src-exts",
          "partial": "Mono Pat Binds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:MonoPatBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.17\u003c/dt\u003e\u003cdd\u003e Enable the dreaded monomorphism restriction.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MonomorphismRestriction",
          "package": "haskell-src-exts",
          "signature": "MonomorphismRestriction",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable the dreaded monomorphism restriction",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MonomorphismRestriction",
          "package": "haskell-src-exts",
          "partial": "Monomorphism Restriction",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:MonomorphismRestriction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.1.1\u003c/dt\u003e\u003cdd\u003e Allow multiple parameters in a type class.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MultiParamTypeClasses",
          "package": "haskell-src-exts",
          "signature": "MultiParamTypeClasses",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow multiple parameters in type class",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "MultiParamTypeClasses",
          "package": "haskell-src-exts",
          "partial": "Multi Param Type Classes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:MultiParamTypeClasses"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSupport for patterns of the form \u003ccode\u003en + k\u003c/code\u003e, where \u003ccode\u003ek\u003c/code\u003e is an\n integer literal.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NPlusKPatterns",
          "package": "haskell-src-exts",
          "signature": "NPlusKPatterns",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Support for patterns of the form where is an integer literal",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NPlusKPatterns",
          "package": "haskell-src-exts",
          "partial": "NPlus KPatterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:NPlusKPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.15\u003c/dt\u003e\u003cdd\u003e Enable syntax for implicitly binding local names\n corresponding to the field names of a record.  Puns bind specific\n names, unlike \u003ccode\u003e\u003ca\u003eRecordWildCards\u003c/a\u003e\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NamedFieldPuns",
          "package": "haskell-src-exts",
          "signature": "NamedFieldPuns",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable syntax for implicitly binding local names corresponding to the field names of record Puns bind specific names unlike RecordWildCards",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NamedFieldPuns",
          "package": "haskell-src-exts",
          "partial": "Named Field Puns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:NamedFieldPuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.3\u003c/dt\u003e\u003cdd\u003e Change the syntax for qualified infix\n operators.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NewQualifiedOperators",
          "package": "haskell-src-exts",
          "signature": "NewQualifiedOperators",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Change the syntax for qualified infix operators",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NewQualifiedOperators",
          "package": "haskell-src-exts",
          "partial": "New Qualified Operators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:NewQualifiedOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnable non-decreasing indentation for 'do' blocks.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NondecreasingIndentation",
          "package": "haskell-src-exts",
          "signature": "NondecreasingIndentation",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Enable non-decreasing indentation for do blocks",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "NondecreasingIndentation",
          "package": "haskell-src-exts",
          "partial": "Nondecreasing Indentation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:NondecreasingIndentation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.3.4\u003c/dt\u003e\u003cdd\u003e Allow overlapping class instances,\n provided there is a unique most specific instance for each use.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "OverlappingInstances",
          "package": "haskell-src-exts",
          "signature": "OverlappingInstances",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow overlapping class instances provided there is unique most specific instance for each use",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "OverlappingInstances",
          "package": "haskell-src-exts",
          "partial": "Overlapping Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:OverlappingInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.4\u003c/dt\u003e\u003cdd\u003e Enable overloading of string literals using a\n type class, much like integer literals.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "OverloadedStrings",
          "package": "haskell-src-exts",
          "signature": "OverloadedStrings",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable overloading of string literals using type class much like integer literals",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "OverloadedStrings",
          "package": "haskell-src-exts",
          "partial": "Overloaded Strings",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:OverloadedStrings"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.18\u003c/dt\u003e\u003cdd\u003e Allow imports to be qualified by the package\n name the module is intended to be imported from, e.g.\n\u003c/dd\u003e\u003c/dl\u003e\u003cpre\u003e import \"network\" Network.Socket\n\u003c/pre\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PackageImports",
          "package": "haskell-src-exts",
          "signature": "PackageImports",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow imports to be qualified by the package name the module is intended to be imported from e.g import network Network.Socket",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PackageImports",
          "package": "haskell-src-exts",
          "partial": "Package Imports",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:PackageImports"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.9\u003c/dt\u003e\u003cdd\u003e Provide syntax for writing list\n comprehensions which iterate over several lists together, like\n the \u003ccode\u003e\u003ca\u003ezipWith\u003c/a\u003e\u003c/code\u003e family of functions.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ParallelListComp",
          "package": "haskell-src-exts",
          "signature": "ParallelListComp",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Provide syntax for writing list comprehensions which iterate over several lists together like the zipWith family of functions",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ParallelListComp",
          "package": "haskell-src-exts",
          "partial": "Parallel List Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ParallelListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.5\u003c/dt\u003e\u003cdd\u003e Enable a form of guard which matches a pattern and\n binds variables.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PatternGuards",
          "package": "haskell-src-exts",
          "signature": "PatternGuards",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable form of guard which matches pattern and binds variables",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PatternGuards",
          "package": "haskell-src-exts",
          "partial": "Pattern Guards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:PatternGuards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated, use \u003ccode\u003e\u003ca\u003eScopedTypeVariables\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PatternSignatures",
          "package": "haskell-src-exts",
          "signature": "PatternSignatures",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use ScopedTypeVariables instead",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PatternSignatures",
          "package": "haskell-src-exts",
          "partial": "Pattern Signatures",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:PatternSignatures"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.5\u003c/dt\u003e\u003cdd\u003e Allow data constructors to have polymorphic\n arguments.  Unlike \u003ccode\u003e\u003ca\u003eRankNTypes\u003c/a\u003e\u003c/code\u003e, does not allow this for ordinary\n functions.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PolymorphicComponents",
          "package": "haskell-src-exts",
          "signature": "PolymorphicComponents",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow data constructors to have polymorphic arguments Unlike RankNTypes does not allow this for ordinary functions",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PolymorphicComponents",
          "package": "haskell-src-exts",
          "partial": "Polymorphic Components",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:PolymorphicComponents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.12\u003c/dt\u003e\u003cdd\u003e Relax the interpretation of left operator\n sections to allow unary postfix operators.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PostfixOperators",
          "package": "haskell-src-exts",
          "signature": "PostfixOperators",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Relax the interpretation of left operator sections to allow unary postfix operators",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "PostfixOperators",
          "package": "haskell-src-exts",
          "partial": "Postfix Operators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:PostfixOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.9.5\u003c/dt\u003e\u003cdd\u003e Enable quasi-quotation, a mechanism for defining\n new concrete syntax for expressions and patterns.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "QuasiQuotes",
          "package": "haskell-src-exts",
          "signature": "QuasiQuotes",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable quasi-quotation mechanism for defining new concrete syntax for expressions and patterns",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "QuasiQuotes",
          "package": "haskell-src-exts",
          "partial": "Quasi Quotes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:QuasiQuotes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.5\u003c/dt\u003e\u003cdd\u003e Like \u003ccode\u003e\u003ca\u003eRankNTypes\u003c/a\u003e\u003c/code\u003e but does not allow a\n higher-rank type to itself appear on the left of a function\n arrow.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Rank2Types",
          "package": "haskell-src-exts",
          "signature": "Rank2Types",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Like RankNTypes but does not allow higher-rank type to itself appear on the left of function arrow",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "Rank2Types",
          "package": "haskell-src-exts",
          "partial": "Rank Types",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:Rank2Types"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.5\u003c/dt\u003e\u003cdd\u003e Allow a universally-quantified type to occur on\n the left of a function arrow.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RankNTypes",
          "package": "haskell-src-exts",
          "signature": "RankNTypes",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow universally-quantified type to occur on the left of function arrow",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RankNTypes",
          "package": "haskell-src-exts",
          "partial": "Rank NTypes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RankNTypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMakes much of the Haskell sugar be desugared into calls to the\n function with a particular name that is in scope.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RebindableSyntax",
          "package": "haskell-src-exts",
          "signature": "RebindableSyntax",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Makes much of the Haskell sugar be desugared into calls to the function with particular name that is in scope",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RebindableSyntax",
          "package": "haskell-src-exts",
          "partial": "Rebindable Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RebindableSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeprecated, use \u003ccode\u003e\u003ca\u003eNamedFieldPuns\u003c/a\u003e\u003c/code\u003e instead.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RecordPuns",
          "package": "haskell-src-exts",
          "signature": "RecordPuns",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Deprecated use NamedFieldPuns instead",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RecordPuns",
          "package": "haskell-src-exts",
          "partial": "Record Puns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RecordPuns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.16\u003c/dt\u003e\u003cdd\u003e Enable syntax for implicitly binding local names\n corresponding to the field names of a record.  A wildcard binds\n all unmentioned names, unlike \u003ccode\u003e\u003ca\u003eNamedFieldPuns\u003c/a\u003e\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RecordWildCards",
          "package": "haskell-src-exts",
          "signature": "RecordWildCards",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable syntax for implicitly binding local names corresponding to the field names of record wildcard binds all unmentioned names unlike NamedFieldPuns",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RecordWildCards",
          "package": "haskell-src-exts",
          "partial": "Record Wild Cards",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RecordWildCards"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.8.2\u003c/dt\u003e\u003cdd\u003e Deprecated in GHC.  Allows recursive bindings\n using \u003ccode\u003emdo\u003c/code\u003e, a variant of \u003ccode\u003edo\u003c/code\u003e.  \u003ccode\u003eDoRec\u003c/code\u003e provides a different,\n preferred syntax.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RecursiveDo",
          "package": "haskell-src-exts",
          "signature": "RecursiveDo",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Deprecated in GHC Allows recursive bindings using mdo variant of do DoRec provides different preferred syntax",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RecursiveDo",
          "package": "haskell-src-exts",
          "partial": "Recursive Do",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RecursiveDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow regular pattern matching over lists, as discussed in the\n paper \"Regular Expression Patterns\" by Niklas Broberg, Andreas Farre\n and Josef Svenningsson, from ICFP '04.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RegularPatterns",
          "package": "haskell-src-exts",
          "signature": "RegularPatterns",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Allow regular pattern matching over lists as discussed in the paper Regular Expression Patterns by Niklas Broberg Andreas Farre and Josef Svenningsson from ICFP",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RegularPatterns",
          "package": "haskell-src-exts",
          "partial": "Regular Patterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RegularPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.8\u003c/dt\u003e\u003cdd\u003e Relax the requirements on mutually-recursive\n polymorphic functions.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RelaxedPolyRec",
          "package": "haskell-src-exts",
          "signature": "RelaxedPolyRec",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Relax the requirements on mutually-recursive polymorphic functions",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RelaxedPolyRec",
          "package": "haskell-src-exts",
          "partial": "Relaxed Poly Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RelaxedPolyRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eHugs &#167; 7.2\u003c/dt\u003e\u003cdd\u003e Enable type synonyms which are transparent in\n some definitions and opaque elsewhere, as a way of implementing \n abstract datatypes.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RestrictedTypeSynonyms",
          "package": "haskell-src-exts",
          "signature": "RestrictedTypeSynonyms",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Hugs Enable type synonyms which are transparent in some definitions and opaque elsewhere as way of implementing abstract datatypes",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "RestrictedTypeSynonyms",
          "package": "haskell-src-exts",
          "partial": "Restricted Type Synonyms",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:RestrictedTypeSynonyms"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.8.7\u003c/dt\u003e\u003cdd\u003e Cause a type variable in a signature, which has an\n explicit \u003ccode\u003eforall\u003c/code\u003e quantifier, to scope over the definition of the\n accompanying value declaration.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ScopedTypeVariables",
          "package": "haskell-src-exts",
          "signature": "ScopedTypeVariables",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Cause type variable in signature which has an explicit forall quantifier to scope over the definition of the accompanying value declaration",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ScopedTypeVariables",
          "package": "haskell-src-exts",
          "partial": "Scoped Type Variables",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ScopedTypeVariables"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.5.2\u003c/dt\u003e\u003cdd\u003e Allow a standalone declaration which invokes the\n type class \u003ccode\u003ederiving\u003c/code\u003e mechanism.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "StandaloneDeriving",
          "package": "haskell-src-exts",
          "signature": "StandaloneDeriving",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow standalone declaration which invokes the type class deriving mechanism",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "StandaloneDeriving",
          "package": "haskell-src-exts",
          "partial": "Standalone Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:StandaloneDeriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.9\u003c/dt\u003e\u003cdd\u003e Enable Template Haskell, a system for compile-time\n metaprogramming.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TemplateHaskell",
          "package": "haskell-src-exts",
          "signature": "TemplateHaskell",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable Template Haskell system for compile-time metaprogramming",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TemplateHaskell",
          "package": "haskell-src-exts",
          "partial": "Template Haskell",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:TemplateHaskell"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.10\u003c/dt\u003e\u003cdd\u003e Enable generalized list comprehensions,\n supporting operations such as sorting and grouping.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TransformListComp",
          "package": "haskell-src-exts",
          "signature": "TransformListComp",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable generalized list comprehensions supporting operations such as sorting and grouping",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TransformListComp",
          "package": "haskell-src-exts",
          "partial": "Transform List Comp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:TransformListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnables the use of tuple sections, e.g. \u003ccode\u003e(, True)\u003c/code\u003e desugars into\n \u003ccode\u003ex -\u003e (x, True)\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TupleSections",
          "package": "haskell-src-exts",
          "signature": "TupleSections",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Enables the use of tuple sections e.g True desugars into True",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TupleSections",
          "package": "haskell-src-exts",
          "partial": "Tuple Sections",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:TupleSections"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.7\u003c/dt\u003e\u003cdd\u003e Allow data types and type synonyms which are\n indexed by types, i.e. ad-hoc polymorphism for types.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TypeFamilies",
          "package": "haskell-src-exts",
          "signature": "TypeFamilies",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow data types and type synonyms which are indexed by types i.e ad-hoc polymorphism for types",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TypeFamilies",
          "package": "haskell-src-exts",
          "partial": "Type Families",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:TypeFamilies"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.4.2\u003c/dt\u003e\u003cdd\u003e Allow the name of a type constructor, type class,\n or type variable to be an infix operator.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TypeOperators",
          "package": "haskell-src-exts",
          "signature": "TypeOperators",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow the name of type constructor type class or type variable to be an infix operator",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TypeOperators",
          "package": "haskell-src-exts",
          "partial": "Type Operators",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:TypeOperators"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.3.1\u003c/dt\u003e\u003cdd\u003e Allow type synonyms in instance heads.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TypeSynonymInstances",
          "package": "haskell-src-exts",
          "signature": "TypeSynonymInstances",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow type synonyms in instance heads",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "TypeSynonymInstances",
          "package": "haskell-src-exts",
          "partial": "Type Synonym Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:TypeSynonymInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.2.2\u003c/dt\u003e\u003cdd\u003e Enable unboxed tuples.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnboxedTuples",
          "package": "haskell-src-exts",
          "signature": "UnboxedTuples",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable unboxed tuples",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnboxedTuples",
          "package": "haskell-src-exts",
          "partial": "Unboxed Tuples",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:UnboxedTuples"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.6.3.3\u003c/dt\u003e\u003cdd\u003e Ignore structural rules guaranteeing the\n termination of class instance resolution.  Termination is\n guaranteed by a fixed-depth recursion stack, and compilation\n may fail if this depth is exceeded.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UndecidableInstances",
          "package": "haskell-src-exts",
          "signature": "UndecidableInstances",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Ignore structural rules guaranteeing the termination of class instance resolution Termination is guaranteed by fixed-depth recursion stack and compilation may fail if this depth is exceeded",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UndecidableInstances",
          "package": "haskell-src-exts",
          "partial": "Undecidable Instances",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:UndecidableInstances"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.1\u003c/dt\u003e\u003cdd\u003e Allow certain Unicode characters to stand for\n certain ASCII character sequences, e.g. keywords and punctuation.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnicodeSyntax",
          "package": "haskell-src-exts",
          "signature": "UnicodeSyntax",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow certain Unicode characters to stand for certain ASCII character sequences e.g keywords and punctuation",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnicodeSyntax",
          "package": "haskell-src-exts",
          "partial": "Unicode Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:UnicodeSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unknown extension, identified by the name of its \u003ccode\u003eLANGUAGE\u003c/code\u003e\n pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnknownExtension",
          "package": "haskell-src-exts",
          "signature": "UnknownExtension String",
          "source": "src/Language-Haskell-Exts-Extension.html#Extension",
          "type": "function"
        },
        "index": {
          "description": "An unknown extension identified by the name of its LANGUAGE pragma",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnknownExtension",
          "package": "haskell-src-exts",
          "partial": "Unknown Extension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:UnknownExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn unknown language, identified by its name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnknownLanguage",
          "package": "haskell-src-exts",
          "signature": "UnknownLanguage String",
          "source": "src/Language-Haskell-Exts-Extension.html#Language",
          "type": "function"
        },
        "index": {
          "description": "An unknown language identified by its name",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnknownLanguage",
          "package": "haskell-src-exts",
          "partial": "Unknown Language",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:UnknownLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 8.1.1\u003c/dt\u003e\u003cdd\u003e Allow the use of unboxed types as foreign types,\n e.g. in \u003ccode\u003eforeign import\u003c/code\u003e and \u003ccode\u003eforeign export\u003c/code\u003e.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnliftedFFITypes",
          "package": "haskell-src-exts",
          "signature": "UnliftedFFITypes",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Allow the use of unboxed types as foreign types e.g in foreign import and foreign export",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "UnliftedFFITypes",
          "package": "haskell-src-exts",
          "partial": "Unlifted FFITypes",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:UnliftedFFITypes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdl\u003e\u003cdt\u003eGHC &#167; 7.3.6\u003c/dt\u003e\u003cdd\u003e Enable view patterns, which match a value by\n applying a function and matching on the result.\n\u003c/dd\u003e\u003c/dl\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ViewPatterns",
          "package": "haskell-src-exts",
          "signature": "ViewPatterns",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "GHC Enable view patterns which match value by applying function and matching on the result",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ViewPatterns",
          "package": "haskell-src-exts",
          "partial": "View Patterns",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ViewPatterns"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllow concrete XML syntax to be used in expressions and patterns,\n as per the Haskell Server Pages extension language:\n \u003ca\u003ehttp://www.haskell.org/haskellwiki/HSP\u003c/a\u003e. The ideas behind it are\n discussed in the paper \"Haskell Server Pages through Dynamic Loading\"\n by Niklas Broberg, from Haskell Workshop '05.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "XmlSyntax",
          "package": "haskell-src-exts",
          "signature": "XmlSyntax",
          "source": "src/Language-Haskell-Exts-Extension.html#KnownExtension",
          "type": "function"
        },
        "index": {
          "description": "Allow concrete XML syntax to be used in expressions and patterns as per the Haskell Server Pages extension language http www.haskell.org haskellwiki HSP The ideas behind it are discussed in the paper Haskell Server Pages through Dynamic Loading by Niklas Broberg from Haskell Workshop",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "XmlSyntax",
          "package": "haskell-src-exts",
          "partial": "Xml Syntax",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:XmlSyntax"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA clever version of read that returns an \u003ccode\u003e\u003ca\u003eUnknownExtension\u003c/a\u003e\u003c/code\u003e\n   if the string is not recognised.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "classifyExtension",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Extension",
          "source": "src/Language-Haskell-Exts-Extension.html#classifyExtension",
          "type": "function"
        },
        "index": {
          "description": "clever version of read that returns an UnknownExtension if the string is not recognised",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "classifyExtension",
          "normalized": "String-\u003eExtension",
          "package": "haskell-src-exts",
          "partial": "Extension",
          "signature": "String-\u003eExtension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:classifyExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "classifyLanguage",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Language",
          "source": "src/Language-Haskell-Exts-Extension.html#classifyLanguage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "classifyLanguage",
          "normalized": "String-\u003eLanguage",
          "package": "haskell-src-exts",
          "partial": "Language",
          "signature": "String-\u003eLanguage",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:classifyLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtensions that have been deprecated, possibly paired with another\n extension that replaces it.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "deprecatedExtensions",
          "package": "haskell-src-exts",
          "signature": "[(Extension, Maybe Extension)]",
          "source": "src/Language-Haskell-Exts-Extension.html#deprecatedExtensions",
          "type": "function"
        },
        "index": {
          "description": "Extensions that have been deprecated possibly paired with another extension that replaces it",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "deprecatedExtensions",
          "normalized": "[(Extension,Maybe Extension)]",
          "package": "haskell-src-exts",
          "partial": "Extensions",
          "signature": "[(Extension,Maybe Extension)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:deprecatedExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "ghcDefault",
          "package": "haskell-src-exts",
          "signature": "[Extension]",
          "source": "src/Language-Haskell-Exts-Extension.html#ghcDefault",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "ghcDefault",
          "normalized": "[Extension]",
          "package": "haskell-src-exts",
          "partial": "Default",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:ghcDefault"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe list of extensions enabled by\n   GHC's portmanteau -fglasgow-exts flag.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "glasgowExts",
          "package": "haskell-src-exts",
          "signature": "[Extension]",
          "source": "src/Language-Haskell-Exts-Extension.html#glasgowExts",
          "type": "function"
        },
        "index": {
          "description": "The list of extensions enabled by GHC portmanteau fglasgow-exts flag",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "glasgowExts",
          "normalized": "[Extension]",
          "package": "haskell-src-exts",
          "partial": "Exts",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:glasgowExts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCertain extensions imply other extensions, and this function\n   makes the implication explicit. This also handles deprecated\n   extensions, which imply their replacements.\n   The returned value is the transitive closure of implied\n   extensions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "impliesExts",
          "package": "haskell-src-exts",
          "signature": "[KnownExtension] -\u003e [KnownExtension]",
          "source": "src/Language-Haskell-Exts-Extension.html#impliesExts",
          "type": "function"
        },
        "index": {
          "description": "Certain extensions imply other extensions and this function makes the implication explicit This also handles deprecated extensions which imply their replacements The returned value is the transitive closure of implied extensions",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "impliesExts",
          "normalized": "[KnownExtension]-\u003e[KnownExtension]",
          "package": "haskell-src-exts",
          "partial": "Exts",
          "signature": "[KnownExtension]-\u003e[KnownExtension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:impliesExts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eList of all known extensions, all enabled.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "knownExtensions",
          "package": "haskell-src-exts",
          "signature": "[Extension]",
          "source": "src/Language-Haskell-Exts-Extension.html#knownExtensions",
          "type": "function"
        },
        "index": {
          "description": "List of all known extensions all enabled",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "knownExtensions",
          "normalized": "[Extension]",
          "package": "haskell-src-exts",
          "partial": "Extensions",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:knownExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "knownLanguages",
          "package": "haskell-src-exts",
          "signature": "[Language]",
          "source": "src/Language-Haskell-Exts-Extension.html#knownLanguages",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "knownLanguages",
          "normalized": "[Language]",
          "package": "haskell-src-exts",
          "partial": "Languages",
          "signature": "[Language]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:knownLanguages"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse an enabled or disabled extension; returns\n \u003ccode\u003e\u003ca\u003eUnknownExtension\u003c/a\u003e\u003c/code\u003e if the parse fails.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "parseExtension",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Extension",
          "source": "src/Language-Haskell-Exts-Extension.html#parseExtension",
          "type": "function"
        },
        "index": {
          "description": "Parse an enabled or disabled extension returns UnknownExtension if the parse fails",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "parseExtension",
          "normalized": "String-\u003eExtension",
          "package": "haskell-src-exts",
          "partial": "Extension",
          "signature": "String-\u003eExtension",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:parseExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty print an extension. Disabled extensions are prefixed with\n 'No'.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Extension",
          "name": "prettyExtension",
          "package": "haskell-src-exts",
          "signature": "Extension -\u003e String",
          "source": "src/Language-Haskell-Exts-Extension.html#prettyExtension",
          "type": "function"
        },
        "index": {
          "description": "Pretty print an extension Disabled extensions are prefixed with No",
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "prettyExtension",
          "normalized": "Extension-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Extension",
          "signature": "Extension-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:prettyExtension"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "prettyLanguage",
          "package": "haskell-src-exts",
          "signature": "Language -\u003e String",
          "source": "src/Language-Haskell-Exts-Extension.html#prettyLanguage",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "prettyLanguage",
          "normalized": "Language-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Language",
          "signature": "Language-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:prettyLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Extension",
          "name": "toExtensionList",
          "package": "haskell-src-exts",
          "signature": "Language -\u003e [Extension] -\u003e [KnownExtension]",
          "source": "src/Language-Haskell-Exts-Extension.html#toExtensionList",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Extension",
          "module": "Language.Haskell.Exts.Extension",
          "name": "toExtensionList",
          "normalized": "Language-\u003e[Extension]-\u003e[KnownExtension]",
          "package": "haskell-src-exts",
          "partial": "Extension List",
          "signature": "Language-\u003e[Extension]-\u003e[KnownExtension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Extension.html#v:toExtensionList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eFixity information to give the parser so that infix operators can\n be parsed properly.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Fixity.html",
          "type": "module"
        },
        "index": {
          "description": "Fixity information to give the parser so that infix operators can be parsed properly",
          "hierarchy": "Language Haskell Exts Fixity",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "partial": "Fixity",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll AST elements that may include expressions which in turn may\n   need fixity tweaking will be instances of this class.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "AppFixity",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Fixity.html#AppFixity",
          "type": "class"
        },
        "index": {
          "description": "All AST elements that may include expressions which in turn may need fixity tweaking will be instances of this class",
          "hierarchy": "Language Haskell Exts Fixity",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "AppFixity",
          "package": "haskell-src-exts",
          "partial": "App Fixity",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#t:AppFixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperator fixities are represented by their associativity\n   (left, right or none) and their precedence (0-9).\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Fixity.html#Fixity",
          "type": "data"
        },
        "index": {
          "description": "Operator fixities are represented by their associativity left right or none and their precedence",
          "hierarchy": "Language Haskell Exts Fixity",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "Fixity",
          "package": "haskell-src-exts",
          "partial": "Fixity",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#t:Fixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTweak any expressions in the element to account for the\n   fixities given. Assumes that all operator expressions are\n   fully left associative chains to begin with.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "applyFixities",
          "package": "haskell-src-exts",
          "signature": "applyFixities",
          "source": "src/Language-Haskell-Exts-Fixity.html#applyFixities",
          "type": "method"
        },
        "index": {
          "description": "Tweak any expressions in the element to account for the fixities given Assumes that all operator expressions are fully left associative chains to begin with",
          "hierarchy": "Language Haskell Exts Fixity",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "applyFixities",
          "package": "haskell-src-exts",
          "partial": "Fixities",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:applyFixities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilt-in fixity for prefix minus\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "prefixMinusFixity",
          "package": "haskell-src-exts",
          "signature": "(Assoc, Int)",
          "source": "src/Language-Haskell-Exts-Fixity.html#prefixMinusFixity",
          "type": "function"
        },
        "index": {
          "description": "Built-in fixity for prefix minus",
          "hierarchy": "Language Haskell Exts Fixity",
          "module": "Language.Haskell.Exts.Fixity",
          "name": "prefixMinusFixity",
          "normalized": "(Assoc,Int)",
          "package": "haskell-src-exts",
          "partial": "Minus Fixity",
          "signature": "(Assoc,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Fixity.html#v:prefixMinusFixity"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eLexer for Haskell with extensions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Lexer",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Lexer.html",
          "type": "module"
        },
        "index": {
          "description": "Lexer for Haskell with extensions",
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Lexer",
          "package": "haskell-src-exts",
          "partial": "Lexer",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn entity located in the source.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Loc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#Loc",
          "type": "data"
        },
        "index": {
          "description": "An entity located in the source",
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Loc",
          "package": "haskell-src-exts",
          "partial": "Loc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#t:Loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Token",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "data"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Token",
          "package": "haskell-src-exts",
          "partial": "Token",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#t:Token"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ANN",
          "package": "haskell-src-exts",
          "signature": "ANN",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ANN",
          "package": "haskell-src-exts",
          "partial": "ANN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:ANN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "At",
          "package": "haskell-src-exts",
          "signature": "At",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "At",
          "package": "haskell-src-exts",
          "partial": "At",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:At"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "BackQuote",
          "package": "haskell-src-exts",
          "signature": "BackQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "BackQuote",
          "package": "haskell-src-exts",
          "partial": "Back Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:BackQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Backslash",
          "package": "haskell-src-exts",
          "signature": "Backslash",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Backslash",
          "package": "haskell-src-exts",
          "partial": "Backslash",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Backslash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Bar",
          "package": "haskell-src-exts",
          "signature": "Bar",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Bar",
          "package": "haskell-src-exts",
          "partial": "Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Bar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "CORE",
          "package": "haskell-src-exts",
          "signature": "CORE",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "CORE",
          "package": "haskell-src-exts",
          "partial": "CORE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:CORE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Character",
          "package": "haskell-src-exts",
          "signature": "Character (Char, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Character",
          "normalized": "Character(Char,String)",
          "package": "haskell-src-exts",
          "partial": "Character",
          "signature": "Character(Char,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Character"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "CharacterHash",
          "package": "haskell-src-exts",
          "signature": "CharacterHash (Char, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "CharacterHash",
          "normalized": "CharacterHash(Char,String)",
          "package": "haskell-src-exts",
          "partial": "Character Hash",
          "signature": "CharacterHash(Char,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:CharacterHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Colon",
          "package": "haskell-src-exts",
          "signature": "Colon",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Colon",
          "package": "haskell-src-exts",
          "partial": "Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Colon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Comma",
          "package": "haskell-src-exts",
          "signature": "Comma",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Comma",
          "package": "haskell-src-exts",
          "partial": "Comma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Comma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ConId",
          "package": "haskell-src-exts",
          "signature": "ConId String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ConId",
          "package": "haskell-src-exts",
          "partial": "Con Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:ConId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ConSym",
          "package": "haskell-src-exts",
          "signature": "ConSym String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ConSym",
          "package": "haskell-src-exts",
          "partial": "Con Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:ConSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DEPRECATED",
          "package": "haskell-src-exts",
          "signature": "DEPRECATED",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DEPRECATED",
          "package": "haskell-src-exts",
          "partial": "DEPRECATED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:DEPRECATED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DVarId",
          "package": "haskell-src-exts",
          "signature": "DVarId [String]",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DVarId",
          "normalized": "DVarId[String]",
          "package": "haskell-src-exts",
          "partial": "DVar Id",
          "signature": "DVarId[String]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:DVarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Dot",
          "package": "haskell-src-exts",
          "signature": "Dot",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Dot",
          "package": "haskell-src-exts",
          "partial": "Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Dot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DotDot",
          "package": "haskell-src-exts",
          "signature": "DotDot",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DotDot",
          "package": "haskell-src-exts",
          "partial": "Dot Dot",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:DotDot"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DoubleArrow",
          "package": "haskell-src-exts",
          "signature": "DoubleArrow",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DoubleArrow",
          "package": "haskell-src-exts",
          "partial": "Double Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:DoubleArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DoubleColon",
          "package": "haskell-src-exts",
          "signature": "DoubleColon",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DoubleColon",
          "package": "haskell-src-exts",
          "partial": "Double Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:DoubleColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DoubleTokHash",
          "package": "haskell-src-exts",
          "signature": "DoubleTokHash (Rational, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "DoubleTokHash",
          "normalized": "DoubleTokHash(Rational,String)",
          "package": "haskell-src-exts",
          "partial": "Double Tok Hash",
          "signature": "DoubleTokHash(Rational,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:DoubleTokHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "EOF",
          "package": "haskell-src-exts",
          "signature": "EOF",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "EOF",
          "package": "haskell-src-exts",
          "partial": "EOF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:EOF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Equals",
          "package": "haskell-src-exts",
          "signature": "Equals",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Equals",
          "package": "haskell-src-exts",
          "partial": "Equals",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Equals"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Exclamation",
          "package": "haskell-src-exts",
          "signature": "Exclamation",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Exclamation",
          "package": "haskell-src-exts",
          "partial": "Exclamation",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Exclamation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "FloatTok",
          "package": "haskell-src-exts",
          "signature": "FloatTok (Rational, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "FloatTok",
          "normalized": "FloatTok(Rational,String)",
          "package": "haskell-src-exts",
          "partial": "Float Tok",
          "signature": "FloatTok(Rational,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:FloatTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "FloatTokHash",
          "package": "haskell-src-exts",
          "signature": "FloatTokHash (Rational, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "FloatTokHash",
          "normalized": "FloatTokHash(Rational,String)",
          "package": "haskell-src-exts",
          "partial": "Float Tok Hash",
          "signature": "FloatTokHash(Rational,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:FloatTokHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "GENERATED",
          "package": "haskell-src-exts",
          "signature": "GENERATED",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "GENERATED",
          "package": "haskell-src-exts",
          "partial": "GENERATED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:GENERATED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "IDupVarId",
          "package": "haskell-src-exts",
          "signature": "IDupVarId String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "IDupVarId",
          "package": "haskell-src-exts",
          "partial": "IDup Var Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:IDupVarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ILinVarId",
          "package": "haskell-src-exts",
          "signature": "ILinVarId String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "ILinVarId",
          "package": "haskell-src-exts",
          "partial": "ILin Var Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:ILinVarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "INLINE",
          "package": "haskell-src-exts",
          "signature": "INLINE Bool",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "INLINE",
          "package": "haskell-src-exts",
          "partial": "INLINE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:INLINE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "INLINE_CONLIKE",
          "package": "haskell-src-exts",
          "signature": "INLINE_CONLIKE",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "INLINE_CONLIKE",
          "package": "haskell-src-exts",
          "partial": "INLINE CONLIKE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:INLINE_CONLIKE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "IntTok",
          "package": "haskell-src-exts",
          "signature": "IntTok (Integer, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "IntTok",
          "normalized": "IntTok(Integer,String)",
          "package": "haskell-src-exts",
          "partial": "Int Tok",
          "signature": "IntTok(Integer,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:IntTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "IntTokHash",
          "package": "haskell-src-exts",
          "signature": "IntTokHash (Integer, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "IntTokHash",
          "normalized": "IntTokHash(Integer,String)",
          "package": "haskell-src-exts",
          "partial": "Int Tok Hash",
          "signature": "IntTokHash(Integer,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:IntTokHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_As",
          "package": "haskell-src-exts",
          "signature": "KW_As",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_As",
          "package": "haskell-src-exts",
          "partial": "KW As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_As"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_By",
          "package": "haskell-src-exts",
          "signature": "KW_By",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_By",
          "package": "haskell-src-exts",
          "partial": "KW By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_By"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_CApi",
          "package": "haskell-src-exts",
          "signature": "KW_CApi",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_CApi",
          "package": "haskell-src-exts",
          "partial": "KW CApi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_CApi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_CCall",
          "package": "haskell-src-exts",
          "signature": "KW_CCall",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_CCall",
          "package": "haskell-src-exts",
          "partial": "KW CCall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_CCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_CPlusPlus",
          "package": "haskell-src-exts",
          "signature": "KW_CPlusPlus",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_CPlusPlus",
          "package": "haskell-src-exts",
          "partial": "KW CPlus Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_CPlusPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Case",
          "package": "haskell-src-exts",
          "signature": "KW_Case",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Case",
          "package": "haskell-src-exts",
          "partial": "KW Case",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Case"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Class",
          "package": "haskell-src-exts",
          "signature": "KW_Class",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Class",
          "package": "haskell-src-exts",
          "partial": "KW Class",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Class"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Data",
          "package": "haskell-src-exts",
          "signature": "KW_Data",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Data",
          "package": "haskell-src-exts",
          "partial": "KW Data",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Data"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Default",
          "package": "haskell-src-exts",
          "signature": "KW_Default",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Default",
          "package": "haskell-src-exts",
          "partial": "KW Default",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Default"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Deriving",
          "package": "haskell-src-exts",
          "signature": "KW_Deriving",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Deriving",
          "package": "haskell-src-exts",
          "partial": "KW Deriving",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Deriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Do",
          "package": "haskell-src-exts",
          "signature": "KW_Do",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Do",
          "package": "haskell-src-exts",
          "partial": "KW Do",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Do"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_DotNet",
          "package": "haskell-src-exts",
          "signature": "KW_DotNet",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_DotNet",
          "package": "haskell-src-exts",
          "partial": "KW Dot Net",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_DotNet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Else",
          "package": "haskell-src-exts",
          "signature": "KW_Else",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Else",
          "package": "haskell-src-exts",
          "partial": "KW Else",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Else"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Export",
          "package": "haskell-src-exts",
          "signature": "KW_Export",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Export",
          "package": "haskell-src-exts",
          "partial": "KW Export",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Export"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Family",
          "package": "haskell-src-exts",
          "signature": "KW_Family",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Family",
          "package": "haskell-src-exts",
          "partial": "KW Family",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Family"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Forall",
          "package": "haskell-src-exts",
          "signature": "KW_Forall",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Forall",
          "package": "haskell-src-exts",
          "partial": "KW Forall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Forall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Foreign",
          "package": "haskell-src-exts",
          "signature": "KW_Foreign",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Foreign",
          "package": "haskell-src-exts",
          "partial": "KW Foreign",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Foreign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Group",
          "package": "haskell-src-exts",
          "signature": "KW_Group",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Group",
          "package": "haskell-src-exts",
          "partial": "KW Group",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Group"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Hiding",
          "package": "haskell-src-exts",
          "signature": "KW_Hiding",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Hiding",
          "package": "haskell-src-exts",
          "partial": "KW Hiding",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Hiding"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_If",
          "package": "haskell-src-exts",
          "signature": "KW_If",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_If",
          "package": "haskell-src-exts",
          "partial": "KW If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_If"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Import",
          "package": "haskell-src-exts",
          "signature": "KW_Import",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Import",
          "package": "haskell-src-exts",
          "partial": "KW Import",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Import"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_In",
          "package": "haskell-src-exts",
          "signature": "KW_In",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_In",
          "package": "haskell-src-exts",
          "partial": "KW In",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_In"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Infix",
          "package": "haskell-src-exts",
          "signature": "KW_Infix",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Infix",
          "package": "haskell-src-exts",
          "partial": "KW Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Infix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_InfixL",
          "package": "haskell-src-exts",
          "signature": "KW_InfixL",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_InfixL",
          "package": "haskell-src-exts",
          "partial": "KW Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_InfixL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_InfixR",
          "package": "haskell-src-exts",
          "signature": "KW_InfixR",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_InfixR",
          "package": "haskell-src-exts",
          "partial": "KW Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_InfixR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Instance",
          "package": "haskell-src-exts",
          "signature": "KW_Instance",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Instance",
          "package": "haskell-src-exts",
          "partial": "KW Instance",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Instance"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Interruptible",
          "package": "haskell-src-exts",
          "signature": "KW_Interruptible",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Interruptible",
          "package": "haskell-src-exts",
          "partial": "KW Interruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Interruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Js",
          "package": "haskell-src-exts",
          "signature": "KW_Js",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Js",
          "package": "haskell-src-exts",
          "partial": "KW Js",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Js"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Jvm",
          "package": "haskell-src-exts",
          "signature": "KW_Jvm",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Jvm",
          "package": "haskell-src-exts",
          "partial": "KW Jvm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Jvm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Let",
          "package": "haskell-src-exts",
          "signature": "KW_Let",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Let",
          "package": "haskell-src-exts",
          "partial": "KW Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_MDo",
          "package": "haskell-src-exts",
          "signature": "KW_MDo",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_MDo",
          "package": "haskell-src-exts",
          "partial": "KW MDo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_MDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Module",
          "package": "haskell-src-exts",
          "signature": "KW_Module",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Module",
          "package": "haskell-src-exts",
          "partial": "KW Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_NewType",
          "package": "haskell-src-exts",
          "signature": "KW_NewType",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_NewType",
          "package": "haskell-src-exts",
          "partial": "KW New Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_NewType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Of",
          "package": "haskell-src-exts",
          "signature": "KW_Of",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Of",
          "package": "haskell-src-exts",
          "partial": "KW Of",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Of"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Proc",
          "package": "haskell-src-exts",
          "signature": "KW_Proc",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Proc",
          "package": "haskell-src-exts",
          "partial": "KW Proc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Proc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Qualified",
          "package": "haskell-src-exts",
          "signature": "KW_Qualified",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Qualified",
          "package": "haskell-src-exts",
          "partial": "KW Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Qualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Rec",
          "package": "haskell-src-exts",
          "signature": "KW_Rec",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Rec",
          "package": "haskell-src-exts",
          "partial": "KW Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Safe",
          "package": "haskell-src-exts",
          "signature": "KW_Safe",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Safe",
          "package": "haskell-src-exts",
          "partial": "KW Safe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Safe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_StdCall",
          "package": "haskell-src-exts",
          "signature": "KW_StdCall",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_StdCall",
          "package": "haskell-src-exts",
          "partial": "KW Std Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_StdCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Then",
          "package": "haskell-src-exts",
          "signature": "KW_Then",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Then",
          "package": "haskell-src-exts",
          "partial": "KW Then",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Then"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Threadsafe",
          "package": "haskell-src-exts",
          "signature": "KW_Threadsafe",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Threadsafe",
          "package": "haskell-src-exts",
          "partial": "KW Threadsafe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Threadsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Type",
          "package": "haskell-src-exts",
          "signature": "KW_Type",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Type",
          "package": "haskell-src-exts",
          "partial": "KW Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Unsafe",
          "package": "haskell-src-exts",
          "signature": "KW_Unsafe",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Unsafe",
          "package": "haskell-src-exts",
          "partial": "KW Unsafe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Unsafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Using",
          "package": "haskell-src-exts",
          "signature": "KW_Using",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Using",
          "package": "haskell-src-exts",
          "partial": "KW Using",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Using"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Where",
          "package": "haskell-src-exts",
          "signature": "KW_Where",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "KW_Where",
          "package": "haskell-src-exts",
          "partial": "KW Where",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:KW_Where"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LANGUAGE",
          "package": "haskell-src-exts",
          "signature": "LANGUAGE",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LANGUAGE",
          "package": "haskell-src-exts",
          "partial": "LANGUAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LANGUAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftArrow",
          "package": "haskell-src-exts",
          "signature": "LeftArrow",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftArrow",
          "package": "haskell-src-exts",
          "partial": "Left Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftArrowTail",
          "package": "haskell-src-exts",
          "signature": "LeftArrowTail",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftArrowTail",
          "package": "haskell-src-exts",
          "partial": "Left Arrow Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftArrowTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftCurly",
          "package": "haskell-src-exts",
          "signature": "LeftCurly",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftCurly",
          "package": "haskell-src-exts",
          "partial": "Left Curly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftCurly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftCurlyBar",
          "package": "haskell-src-exts",
          "signature": "LeftCurlyBar",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftCurlyBar",
          "package": "haskell-src-exts",
          "partial": "Left Curly Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftCurlyBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftDblArrowTail",
          "package": "haskell-src-exts",
          "signature": "LeftDblArrowTail",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftDblArrowTail",
          "package": "haskell-src-exts",
          "partial": "Left Dbl Arrow Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftDblArrowTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftHashParen",
          "package": "haskell-src-exts",
          "signature": "LeftHashParen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftHashParen",
          "package": "haskell-src-exts",
          "partial": "Left Hash Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftHashParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftParen",
          "package": "haskell-src-exts",
          "signature": "LeftParen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftParen",
          "package": "haskell-src-exts",
          "partial": "Left Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftSquare",
          "package": "haskell-src-exts",
          "signature": "LeftSquare",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "LeftSquare",
          "package": "haskell-src-exts",
          "partial": "Left Square",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:LeftSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Lexer\",\"Language.Haskell.Exts.SrcLoc\"]",
          "name": "Loc",
          "package": "haskell-src-exts",
          "signature": "Loc",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#Loc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Loc\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:Loc\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Loc",
          "package": "haskell-src-exts",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Minus",
          "package": "haskell-src-exts",
          "signature": "Minus",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Minus",
          "package": "haskell-src-exts",
          "partial": "Minus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Minus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "OPTIONS",
          "package": "haskell-src-exts",
          "signature": "OPTIONS (Maybe String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "OPTIONS",
          "normalized": "OPTIONS(Maybe String,String)",
          "package": "haskell-src-exts",
          "partial": "OPTIONS",
          "signature": "OPTIONS(Maybe String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:OPTIONS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "PragmaEnd",
          "package": "haskell-src-exts",
          "signature": "PragmaEnd",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "PragmaEnd",
          "package": "haskell-src-exts",
          "partial": "Pragma End",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:PragmaEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QConId",
          "package": "haskell-src-exts",
          "signature": "QConId (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QConId",
          "normalized": "QConId(String,String)",
          "package": "haskell-src-exts",
          "partial": "QCon Id",
          "signature": "QConId(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:QConId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QConSym",
          "package": "haskell-src-exts",
          "signature": "QConSym (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QConSym",
          "normalized": "QConSym(String,String)",
          "package": "haskell-src-exts",
          "partial": "QCon Sym",
          "signature": "QConSym(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:QConSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QVarId",
          "package": "haskell-src-exts",
          "signature": "QVarId (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QVarId",
          "normalized": "QVarId(String,String)",
          "package": "haskell-src-exts",
          "partial": "QVar Id",
          "signature": "QVarId(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:QVarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QVarSym",
          "package": "haskell-src-exts",
          "signature": "QVarSym (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "QVarSym",
          "normalized": "QVarSym(String,String)",
          "package": "haskell-src-exts",
          "partial": "QVar Sym",
          "signature": "QVarSym(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:QVarSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RPCAt",
          "package": "haskell-src-exts",
          "signature": "RPCAt",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RPCAt",
          "package": "haskell-src-exts",
          "partial": "RPCAt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RPCAt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RPGuardClose",
          "package": "haskell-src-exts",
          "signature": "RPGuardClose",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RPGuardClose",
          "package": "haskell-src-exts",
          "partial": "RPGuard Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RPGuardClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RPGuardOpen",
          "package": "haskell-src-exts",
          "signature": "RPGuardOpen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RPGuardOpen",
          "package": "haskell-src-exts",
          "partial": "RPGuard Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RPGuardOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RULES",
          "package": "haskell-src-exts",
          "signature": "RULES",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RULES",
          "package": "haskell-src-exts",
          "partial": "RULES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RULES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightArrow",
          "package": "haskell-src-exts",
          "signature": "RightArrow",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightArrow",
          "package": "haskell-src-exts",
          "partial": "Right Arrow",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightArrow"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightArrowTail",
          "package": "haskell-src-exts",
          "signature": "RightArrowTail",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightArrowTail",
          "package": "haskell-src-exts",
          "partial": "Right Arrow Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightArrowTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightCurly",
          "package": "haskell-src-exts",
          "signature": "RightCurly",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightCurly",
          "package": "haskell-src-exts",
          "partial": "Right Curly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightCurly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightCurlyBar",
          "package": "haskell-src-exts",
          "signature": "RightCurlyBar",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightCurlyBar",
          "package": "haskell-src-exts",
          "partial": "Right Curly Bar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightCurlyBar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightDblArrowTail",
          "package": "haskell-src-exts",
          "signature": "RightDblArrowTail",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightDblArrowTail",
          "package": "haskell-src-exts",
          "partial": "Right Dbl Arrow Tail",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightDblArrowTail"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightHashParen",
          "package": "haskell-src-exts",
          "signature": "RightHashParen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightHashParen",
          "package": "haskell-src-exts",
          "partial": "Right Hash Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightHashParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightParen",
          "package": "haskell-src-exts",
          "signature": "RightParen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightParen",
          "package": "haskell-src-exts",
          "partial": "Right Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightSquare",
          "package": "haskell-src-exts",
          "signature": "RightSquare",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "RightSquare",
          "package": "haskell-src-exts",
          "partial": "Right Square",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:RightSquare"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SCC",
          "package": "haskell-src-exts",
          "signature": "SCC",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SCC",
          "package": "haskell-src-exts",
          "partial": "SCC",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:SCC"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SOURCE",
          "package": "haskell-src-exts",
          "signature": "SOURCE",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SOURCE",
          "package": "haskell-src-exts",
          "partial": "SOURCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:SOURCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SPECIALISE",
          "package": "haskell-src-exts",
          "signature": "SPECIALISE",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SPECIALISE",
          "package": "haskell-src-exts",
          "partial": "SPECIALISE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:SPECIALISE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SPECIALISE_INLINE",
          "package": "haskell-src-exts",
          "signature": "SPECIALISE_INLINE Bool",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SPECIALISE_INLINE",
          "package": "haskell-src-exts",
          "partial": "SPECIALISE INLINE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:SPECIALISE_INLINE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SemiColon",
          "package": "haskell-src-exts",
          "signature": "SemiColon",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "SemiColon",
          "package": "haskell-src-exts",
          "partial": "Semi Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:SemiColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Star",
          "package": "haskell-src-exts",
          "signature": "Star",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Star",
          "package": "haskell-src-exts",
          "partial": "Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Star"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "StringHash",
          "package": "haskell-src-exts",
          "signature": "StringHash (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "StringHash",
          "normalized": "StringHash(String,String)",
          "package": "haskell-src-exts",
          "partial": "String Hash",
          "signature": "StringHash(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:StringHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "StringTok",
          "package": "haskell-src-exts",
          "signature": "StringTok (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "StringTok",
          "normalized": "StringTok(String,String)",
          "package": "haskell-src-exts",
          "partial": "String Tok",
          "signature": "StringTok(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:StringTok"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THCloseQuote",
          "package": "haskell-src-exts",
          "signature": "THCloseQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THCloseQuote",
          "package": "haskell-src-exts",
          "partial": "THClose Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THCloseQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THDecQuote",
          "package": "haskell-src-exts",
          "signature": "THDecQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THDecQuote",
          "package": "haskell-src-exts",
          "partial": "THDec Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THDecQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THExpQuote",
          "package": "haskell-src-exts",
          "signature": "THExpQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THExpQuote",
          "package": "haskell-src-exts",
          "partial": "THExp Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THExpQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e]\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THIdEscape",
          "package": "haskell-src-exts",
          "signature": "THIdEscape String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THIdEscape",
          "package": "haskell-src-exts",
          "partial": "THId Escape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THIdEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THParenEscape",
          "package": "haskell-src-exts",
          "signature": "THParenEscape",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THParenEscape",
          "package": "haskell-src-exts",
          "partial": "THParen Escape",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THParenEscape"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THPatQuote",
          "package": "haskell-src-exts",
          "signature": "THPatQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THPatQuote",
          "package": "haskell-src-exts",
          "partial": "THPat Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THPatQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THQuasiQuote",
          "package": "haskell-src-exts",
          "signature": "THQuasiQuote (String, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THQuasiQuote",
          "normalized": "THQuasiQuote(String,String)",
          "package": "haskell-src-exts",
          "partial": "THQuasi Quote",
          "signature": "THQuasiQuote(String,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THQuasiQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THTyQuote",
          "package": "haskell-src-exts",
          "signature": "THTyQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THTyQuote",
          "package": "haskell-src-exts",
          "partial": "THTy Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THTyQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THTypQuote",
          "package": "haskell-src-exts",
          "signature": "THTypQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THTypQuote",
          "package": "haskell-src-exts",
          "partial": "THTyp Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THTypQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THVarQuote",
          "package": "haskell-src-exts",
          "signature": "THVarQuote",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "THVarQuote",
          "package": "haskell-src-exts",
          "partial": "THVar Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:THVarQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Tilde",
          "package": "haskell-src-exts",
          "signature": "Tilde",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Tilde",
          "package": "haskell-src-exts",
          "partial": "Tilde",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Tilde"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "UNPACK",
          "package": "haskell-src-exts",
          "signature": "UNPACK",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "UNPACK",
          "package": "haskell-src-exts",
          "partial": "UNPACK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:UNPACK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Underscore",
          "package": "haskell-src-exts",
          "signature": "Underscore",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "Underscore",
          "package": "haskell-src-exts",
          "partial": "Underscore",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:Underscore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "VRightCurly",
          "package": "haskell-src-exts",
          "signature": "VRightCurly",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "VRightCurly",
          "package": "haskell-src-exts",
          "partial": "VRight Curly",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:VRightCurly"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "VarId",
          "package": "haskell-src-exts",
          "signature": "VarId String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "VarId",
          "package": "haskell-src-exts",
          "partial": "Var Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:VarId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "VarSym",
          "package": "haskell-src-exts",
          "signature": "VarSym String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "VarSym",
          "package": "haskell-src-exts",
          "partial": "Var Sym",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:VarSym"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "WARNING",
          "package": "haskell-src-exts",
          "signature": "WARNING",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "WARNING",
          "package": "haskell-src-exts",
          "partial": "WARNING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:WARNING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "WordTokHash",
          "package": "haskell-src-exts",
          "signature": "WordTokHash (Integer, String)",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "WordTokHash",
          "normalized": "WordTokHash(Integer,String)",
          "package": "haskell-src-exts",
          "partial": "Word Tok Hash",
          "signature": "WordTokHash(Integer,String)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:WordTokHash"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XChildTagOpen",
          "package": "haskell-src-exts",
          "signature": "XChildTagOpen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XChildTagOpen",
          "package": "haskell-src-exts",
          "partial": "XChild Tag Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XChildTagOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XCloseTagOpen",
          "package": "haskell-src-exts",
          "signature": "XCloseTagOpen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XCloseTagOpen",
          "package": "haskell-src-exts",
          "partial": "XClose Tag Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XCloseTagOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XCodeTagClose",
          "package": "haskell-src-exts",
          "signature": "XCodeTagClose",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XCodeTagClose",
          "package": "haskell-src-exts",
          "partial": "XCode Tag Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XCodeTagClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XCodeTagOpen",
          "package": "haskell-src-exts",
          "signature": "XCodeTagOpen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XCodeTagOpen",
          "package": "haskell-src-exts",
          "partial": "XCode Tag Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XCodeTagOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XEmptyTagClose",
          "package": "haskell-src-exts",
          "signature": "XEmptyTagClose",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XEmptyTagClose",
          "package": "haskell-src-exts",
          "partial": "XEmpty Tag Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XEmptyTagClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XPCDATA",
          "package": "haskell-src-exts",
          "signature": "XPCDATA String",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XPCDATA",
          "package": "haskell-src-exts",
          "partial": "XPCDATA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XPCDATA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XRPatClose",
          "package": "haskell-src-exts",
          "signature": "XRPatClose",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XRPatClose",
          "package": "haskell-src-exts",
          "partial": "XRPat Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XRPatClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XRPatOpen",
          "package": "haskell-src-exts",
          "signature": "XRPatOpen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XRPatOpen",
          "package": "haskell-src-exts",
          "partial": "XRPat Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XRPatOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XStdTagClose",
          "package": "haskell-src-exts",
          "signature": "XStdTagClose",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XStdTagClose",
          "package": "haskell-src-exts",
          "partial": "XStd Tag Close",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XStdTagClose"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XStdTagOpen",
          "package": "haskell-src-exts",
          "signature": "XStdTagOpen",
          "source": "src/Language-Haskell-Exts-InternalLexer.html#Token",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "XStdTagOpen",
          "package": "haskell-src-exts",
          "partial": "XStd Tag Open",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:XStdTagOpen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLex a string into a list of Haskell 2010 source tokens.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "lexTokenStream",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult [Loc Token]",
          "source": "src/Language-Haskell-Exts-Lexer.html#lexTokenStream",
          "type": "function"
        },
        "index": {
          "description": "Lex string into list of Haskell source tokens",
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "lexTokenStream",
          "normalized": "String-\u003eParseResult[Loc Token]",
          "package": "haskell-src-exts",
          "partial": "Token Stream",
          "signature": "String-\u003eParseResult[Loc Token]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:lexTokenStream"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLex a string into a list of Haskell source tokens, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "lexTokenStreamWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult [Loc Token]",
          "source": "src/Language-Haskell-Exts-Lexer.html#lexTokenStreamWithMode",
          "type": "function"
        },
        "index": {
          "description": "Lex string into list of Haskell source tokens using an explicit mode",
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "lexTokenStreamWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult[Loc Token]",
          "package": "haskell-src-exts",
          "partial": "Token Stream With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult[Loc Token]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:lexTokenStreamWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Lexer\",\"Language.Haskell.Exts.SrcLoc\"]",
          "name": "loc",
          "package": "haskell-src-exts",
          "signature": "SrcSpan",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#Loc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:loc\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:loc\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "loc",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.Lexer\",\"Language.Haskell.Exts.SrcLoc\"]",
          "name": "unLoc",
          "package": "haskell-src-exts",
          "signature": "a",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#Loc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:unLoc\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:unLoc\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Lexer",
          "module": "Language.Haskell.Exts.Lexer",
          "name": "unLoc",
          "package": "haskell-src-exts",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Lexer.html#v:unLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eParser for Haskell with extensions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "Parser",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Parser.html",
          "type": "module"
        },
        "index": {
          "description": "Parser for Haskell with extensions",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "Parser",
          "package": "haskell-src-exts",
          "partial": "Parser",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStatic parameters governing a parse.\n   Note that the various parse functions in \u003ca\u003eLanguage.Haskell.Exts.Parser\u003c/a\u003e\n   never look at LANGUAGE pragmas, regardless of\n   what the \u003ccode\u003eignoreLanguagePragmas\u003c/code\u003e flag is set to.\n   Only the various \u003ccode\u003eparseFile\u003c/code\u003e functions in \u003ca\u003eLanguage.Haskell.Exts\u003c/a\u003e will\n   act on it, when set to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseMode",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "data"
        },
        "index": {
          "description": "Static parameters governing parse Note that the various parse functions in Language.Haskell.Exts.Parser never look at LANGUAGE pragmas regardless of what the ignoreLanguagePragmas flag is set to Only the various parseFile functions in Language.Haskell.Exts will act on it when set to False",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseMode",
          "package": "haskell-src-exts",
          "partial": "Parse Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#t:ParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe result of a parse.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseResult",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseResult",
          "type": "data"
        },
        "index": {
          "description": "The result of parse",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseResult",
          "package": "haskell-src-exts",
          "partial": "Parse Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#t:ParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass to reuse the parse function at many different types.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "Parseable",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Parser.html#Parseable",
          "type": "class"
        },
        "index": {
          "description": "Class to reuse the parse function at many different types",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "Parseable",
          "package": "haskell-src-exts",
          "partial": "Parseable",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#t:Parseable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parse failed at the specified\n source location, with an error message.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseFailed",
          "package": "haskell-src-exts",
          "signature": "ParseFailed SrcLoc String",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseResult",
          "type": "function"
        },
        "index": {
          "description": "The parse failed at the specified source location with an error message",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseFailed",
          "package": "haskell-src-exts",
          "partial": "Parse Failed",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:ParseFailed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseMode",
          "package": "haskell-src-exts",
          "partial": "Parse Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:ParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe parse succeeded, yielding a value.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseOk",
          "package": "haskell-src-exts",
          "signature": "ParseOk a",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseResult",
          "type": "function"
        },
        "index": {
          "description": "The parse succeeded yielding value",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ParseOk",
          "package": "haskell-src-exts",
          "partial": "Parse Ok",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:ParseOk"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebase language (e.g. Haskell98, Haskell2010)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "baseLanguage",
          "package": "haskell-src-exts",
          "signature": "Language",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "description": "base language e.g Haskell98 Haskell2010",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "baseLanguage",
          "package": "haskell-src-exts",
          "partial": "Language",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:baseLanguage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDefault parameters for a parse.\n   The default is an unknown filename,\n   no extensions (i.e. Haskell 98),\n   don't ignore LANGUAGE pragmas, do ignore LINE pragmas,\n   and be aware of fixities from the \u003ccode\u003ePrelude\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "defaultParseMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#defaultParseMode",
          "type": "function"
        },
        "index": {
          "description": "Default parameters for parse The default is an unknown filename no extensions i.e Haskell don ignore LANGUAGE pragmas do ignore LINE pragmas and be aware of fixities from the Prelude",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "defaultParseMode",
          "package": "haskell-src-exts",
          "partial": "Parse Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:defaultParseMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist of extensions enabled for parsing\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "extensions",
          "package": "haskell-src-exts",
          "signature": "[Extension]",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "description": "list of extensions enabled for parsing",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "extensions",
          "normalized": "[Extension]",
          "package": "haskell-src-exts",
          "signature": "[Extension]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:extensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist of fixities to be aware of\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "fixities",
          "package": "haskell-src-exts",
          "signature": "Maybe [Fixity]",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "description": "list of fixities to be aware of",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "fixities",
          "normalized": "Maybe[Fixity]",
          "package": "haskell-src-exts",
          "signature": "Maybe[Fixity]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:fixities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRetrieve the result of a successful parse, throwing an\n   error if the parse is actually not successful.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "fromParseResult",
          "package": "haskell-src-exts",
          "signature": "ParseResult a -\u003e a",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#fromParseResult",
          "type": "function"
        },
        "index": {
          "description": "Retrieve the result of successful parse throwing an error if the parse is actually not successful",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "fromParseResult",
          "normalized": "ParseResult a-\u003ea",
          "package": "haskell-src-exts",
          "partial": "Parse Result",
          "signature": "ParseResult a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:fromParseResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Parser",
          "name": "getTopPragmas",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult [ModulePragma]",
          "source": "src/Language-Haskell-Exts-Parser.html#getTopPragmas",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "getTopPragmas",
          "normalized": "String-\u003eParseResult[ModulePragma]",
          "package": "haskell-src-exts",
          "partial": "Top Pragmas",
          "signature": "String-\u003eParseResult[ModulePragma]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:getTopPragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, the parser won't care about further extensions\n   in LANGUAGE pragmas in source files\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ignoreLanguagePragmas",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "description": "if True the parser won care about further extensions in LANGUAGE pragmas in source files",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ignoreLanguagePragmas",
          "package": "haskell-src-exts",
          "partial": "Language Pragmas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:ignoreLanguagePragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eif \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, the parser won't read line position information\n   from LINE pragmas in source files\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ignoreLinePragmas",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "description": "if True the parser won read line position information from LINE pragmas in source files",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "ignoreLinePragmas",
          "package": "haskell-src-exts",
          "partial": "Line Pragmas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:ignoreLinePragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string with default mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parse",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult ast",
          "source": "src/Language-Haskell-Exts-Parser.html#parse",
          "type": "method"
        },
        "index": {
          "description": "Parse string with default mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parse",
          "normalized": "String-\u003eParseResult a",
          "package": "haskell-src-exts",
          "signature": "String-\u003eParseResult ast",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parse"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell top-level declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseDecl",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Decl",
          "source": "src/Language-Haskell-Exts-Parser.html#parseDecl",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell top-level declaration",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseDecl",
          "normalized": "String-\u003eParseResult Decl",
          "package": "haskell-src-exts",
          "partial": "Decl",
          "signature": "String-\u003eParseResult Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseDeclWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Decl, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parseDeclWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseDeclWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Decl,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Decl With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Decl,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseDeclWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell top-level declaration, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseDeclWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Decl",
          "source": "src/Language-Haskell-Exts-Parser.html#parseDeclWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell top-level declaration using an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseDeclWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Decl",
          "package": "haskell-src-exts",
          "partial": "Decl With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseDeclWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseExp",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Exp",
          "source": "src/Language-Haskell-Exts-Parser.html#parseExp",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell expression",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseExp",
          "normalized": "String-\u003eParseResult Exp",
          "package": "haskell-src-exts",
          "partial": "Exp",
          "signature": "String-\u003eParseResult Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseExpWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Exp, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parseExpWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseExpWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Exp,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Exp With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Exp,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseExpWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell expression, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseExpWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Exp",
          "source": "src/Language-Haskell-Exts-Parser.html#parseExpWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell expression using an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseExpWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Exp",
          "package": "haskell-src-exts",
          "partial": "Exp With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseExpWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoriginal name of the file being parsed\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseFilename",
          "package": "haskell-src-exts",
          "signature": "String",
          "source": "src/Language-Haskell-Exts-ParseMonad.html#ParseMode",
          "type": "function"
        },
        "index": {
          "description": "original name of the file being parsed",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseFilename",
          "package": "haskell-src-exts",
          "partial": "Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string, which should contain a complete Haskell module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseModule",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Module",
          "source": "src/Language-Haskell-Exts-Parser.html#parseModule",
          "type": "function"
        },
        "index": {
          "description": "Parse of string which should contain complete Haskell module",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseModule",
          "normalized": "String-\u003eParseResult Module",
          "package": "haskell-src-exts",
          "partial": "Module",
          "signature": "String-\u003eParseResult Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseModuleWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Module, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parseModuleWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseModuleWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Module,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Module With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Module,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseModuleWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseModuleWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Module",
          "source": "src/Language-Haskell-Exts-Parser.html#parseModuleWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseModuleWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Module",
          "package": "haskell-src-exts",
          "partial": "Module With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseModuleWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parsePat",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Pat",
          "source": "src/Language-Haskell-Exts-Parser.html#parsePat",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell pattern",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parsePat",
          "normalized": "String-\u003eParseResult Pat",
          "package": "haskell-src-exts",
          "partial": "Pat",
          "signature": "String-\u003eParseResult Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parsePat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parsePatWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Pat, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parsePatWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parsePatWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Pat,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Pat With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Pat,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parsePatWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell pattern, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parsePatWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Pat",
          "source": "src/Language-Haskell-Exts-Parser.html#parsePatWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell pattern using an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parsePatWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Pat",
          "package": "haskell-src-exts",
          "partial": "Pat With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parsePatWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseStmt",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Stmt",
          "source": "src/Language-Haskell-Exts-Parser.html#parseStmt",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseStmt",
          "normalized": "String-\u003eParseResult Stmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "signature": "String-\u003eParseResult Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseStmtWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Stmt, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parseStmtWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseStmtWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Stmt,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Stmt With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Stmt,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseStmtWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseStmtWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Stmt",
          "source": "src/Language-Haskell-Exts-Parser.html#parseStmtWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type using an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseStmtWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Stmt",
          "package": "haskell-src-exts",
          "partial": "Stmt With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseStmtWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseType",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Type",
          "source": "src/Language-Haskell-Exts-Parser.html#parseType",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseType",
          "normalized": "String-\u003eParseResult Type",
          "package": "haskell-src-exts",
          "partial": "Type",
          "signature": "String-\u003eParseResult Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a complete Haskell module, using an explicit mode, retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseTypeWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Type, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parseTypeWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing complete Haskell module using an explicit mode retaining comments",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseTypeWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Type,[Comment])",
          "package": "haskell-src-exts",
          "partial": "Type With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Type,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseTypeWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse of a string containing a Haskell type, using an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseTypeWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Type",
          "source": "src/Language-Haskell-Exts-Parser.html#parseTypeWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse of string containing Haskell type using an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseTypeWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Type",
          "package": "haskell-src-exts",
          "partial": "Type With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseTypeWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string with an explicit mode, returning all comments along the AST\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (ast, [Comment])",
          "source": "src/Language-Haskell-Exts-Parser.html#parseWithComments",
          "type": "method"
        },
        "index": {
          "description": "Parse string with an explicit mode returning all comments along the AST",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(a,[Comment])",
          "package": "haskell-src-exts",
          "partial": "With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(ast,[Comment])",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a string with an explicit mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult ast",
          "source": "src/Language-Haskell-Exts-Parser.html#parseWithMode",
          "type": "method"
        },
        "index": {
          "description": "Parse string with an explicit mode",
          "hierarchy": "Language Haskell Exts Parser",
          "module": "Language.Haskell.Exts.Parser",
          "name": "parseWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult a",
          "package": "haskell-src-exts",
          "partial": "With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult ast",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Parser.html#v:parseWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003ePretty printer for Haskell with extensions.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Pretty",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Pretty.html",
          "type": "module"
        },
        "index": {
          "description": "Pretty printer for Haskell with extensions",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Pretty",
          "package": "haskell-src-exts",
          "partial": "Pretty",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Indent",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Pretty.html#Indent",
          "type": "type"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Indent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#t:Indent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRendering mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Mode",
          "package": "haskell-src-exts",
          "type": "data"
        },
        "index": {
          "description": "Rendering mode",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Mode",
          "package": "haskell-src-exts",
          "partial": "Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#t:Mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty-printing parameters.\n\u003c/p\u003e\u003cp\u003e\u003cem\u003eNote:\u003c/em\u003e the \u003ccode\u003e\u003ca\u003eonsideIndent\u003c/a\u003e\u003c/code\u003e must be positive and less than all other indents.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "data"
        },
        "index": {
          "description": "Pretty-printing parameters Note the onsideIndent must be positive and less than all other indents",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src-exts",
          "partial": "PPHs Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#t:PPHsMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVarieties of layout we can use.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPLayout",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPLayout",
          "type": "data"
        },
        "index": {
          "description": "Varieties of layout we can use",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPLayout",
          "package": "haskell-src-exts",
          "partial": "PPLayout",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#t:PPLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThings that can be pretty-printed, including all the syntactic objects\n in \u003ca\u003eLanguage.Haskell.Exts.Syntax\u003c/a\u003e and \u003ca\u003eLanguage.Haskell.Exts.Annotated.Syntax\u003c/a\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Pretty",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Pretty.html#Pretty",
          "type": "class"
        },
        "index": {
          "description": "Things that can be pretty-printed including all the syntactic objects in Language.Haskell.Exts.Syntax and Language.Haskell.Exts.Annotated.Syntax",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Pretty",
          "package": "haskell-src-exts",
          "partial": "Pretty",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#t:Pretty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA rendering style.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Style",
          "package": "haskell-src-exts",
          "type": "data"
        },
        "index": {
          "description": "rendering style",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Style",
          "package": "haskell-src-exts",
          "partial": "Style",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#t:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo indentation, infinitely long lines\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "LeftMode",
          "package": "haskell-src-exts",
          "signature": "LeftMode",
          "type": "function"
        },
        "index": {
          "description": "No indentation infinitely long lines",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "LeftMode",
          "package": "haskell-src-exts",
          "partial": "Left Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:LeftMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAll on one line\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "OneLineMode",
          "package": "haskell-src-exts",
          "signature": "OneLineMode",
          "type": "function"
        },
        "index": {
          "description": "All on one line",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "OneLineMode",
          "package": "haskell-src-exts",
          "partial": "One Line Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:OneLineMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src-exts",
          "signature": "PPHsMode",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPHsMode",
          "package": "haskell-src-exts",
          "partial": "PPHs Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:PPHsMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einline decls, with newlines between them\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPInLine",
          "package": "haskell-src-exts",
          "signature": "PPInLine",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "inline decls with newlines between them",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPInLine",
          "package": "haskell-src-exts",
          "partial": "PPIn Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:PPInLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eeverything on a single line\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPNoLayout",
          "package": "haskell-src-exts",
          "signature": "PPNoLayout",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "everything on single line",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPNoLayout",
          "package": "haskell-src-exts",
          "partial": "PPNo Layout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:PPNoLayout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclassical layout\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPOffsideRule",
          "package": "haskell-src-exts",
          "signature": "PPOffsideRule",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "classical layout",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPOffsideRule",
          "package": "haskell-src-exts",
          "partial": "PPOffside Rule",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:PPOffsideRule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclassical layout made explicit\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPSemiColon",
          "package": "haskell-src-exts",
          "signature": "PPSemiColon",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPLayout",
          "type": "function"
        },
        "index": {
          "description": "classical layout made explicit",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PPSemiColon",
          "package": "haskell-src-exts",
          "partial": "PPSemi Colon",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:PPSemiColon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNormal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PageMode",
          "package": "haskell-src-exts",
          "signature": "PageMode",
          "type": "function"
        },
        "index": {
          "description": "Normal",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "PageMode",
          "package": "haskell-src-exts",
          "partial": "Page Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:PageMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Style",
          "package": "haskell-src-exts",
          "signature": "Style",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "Style",
          "package": "haskell-src-exts",
          "partial": "Style",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:Style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWith zig-zag cuts\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "ZigZagMode",
          "package": "haskell-src-exts",
          "signature": "ZigZagMode",
          "type": "function"
        },
        "index": {
          "description": "With zig-zag cuts",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "ZigZagMode",
          "package": "haskell-src-exts",
          "partial": "Zig Zag Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:ZigZagMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of the body of a\n \u003ccode\u003ecase\u003c/code\u003e expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "caseIndent",
          "package": "haskell-src-exts",
          "signature": "Indent",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of the body of case expression",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "caseIndent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:caseIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of a class or instance\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "classIndent",
          "package": "haskell-src-exts",
          "signature": "Indent",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of class or instance",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "classIndent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:classIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default mode: pretty-print using the offside rule and sensible\n defaults.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "defaultMode",
          "package": "haskell-src-exts",
          "signature": "PPHsMode",
          "source": "src/Language-Haskell-Exts-Pretty.html#defaultMode",
          "type": "function"
        },
        "index": {
          "description": "The default mode pretty-print using the offside rule and sensible defaults",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "defaultMode",
          "package": "haskell-src-exts",
          "partial": "Mode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:defaultMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of a \u003ccode\u003edo\u003c/code\u003e-expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "doIndent",
          "package": "haskell-src-exts",
          "signature": "Indent",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of do expression",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "doIndent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:doIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePretty-printing style to use\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "layout",
          "package": "haskell-src-exts",
          "signature": "PPLayout",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "Pretty-printing style to use",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "layout",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:layout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of the declarations in a\n \u003ccode\u003elet\u003c/code\u003e expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "letIndent",
          "package": "haskell-src-exts",
          "signature": "Indent",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of the declarations in let expression",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "letIndent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:letIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLength of line, in chars\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "lineLength",
          "package": "haskell-src-exts",
          "signature": "Int",
          "type": "function"
        },
        "index": {
          "description": "Length of line in chars",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "lineLength",
          "package": "haskell-src-exts",
          "partial": "Length",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:lineLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eadd GHC-style \u003ccode\u003eLINE\u003c/code\u003e pragmas to output?\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "linePragmas",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "add GHC-style LINE pragmas to output",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "linePragmas",
          "package": "haskell-src-exts",
          "partial": "Pragmas",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:linePragmas"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe rendering mode\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "mode",
          "package": "haskell-src-exts",
          "signature": "Mode",
          "type": "function"
        },
        "index": {
          "description": "The rendering mode",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "mode",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:mode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation added for continuation\n lines that would otherwise be offside\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "onsideIndent",
          "package": "haskell-src-exts",
          "signature": "Indent",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation added for continuation lines that would otherwise be offside",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "onsideIndent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:onsideIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epretty-print with the default style and \u003ccode\u003e\u003ca\u003edefaultMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "prettyPrint",
          "package": "haskell-src-exts",
          "signature": "a -\u003e String",
          "source": "src/Language-Haskell-Exts-Pretty.html#prettyPrint",
          "type": "function"
        },
        "index": {
          "description": "pretty-print with the default style and defaultMode",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "prettyPrint",
          "normalized": "a-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Print",
          "signature": "a-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:prettyPrint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epretty-print with a given style and mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "prettyPrintStyleMode",
          "package": "haskell-src-exts",
          "signature": "Style -\u003e PPHsMode -\u003e a -\u003e String",
          "source": "src/Language-Haskell-Exts-Pretty.html#prettyPrintStyleMode",
          "type": "function"
        },
        "index": {
          "description": "pretty-print with given style and mode",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "prettyPrintStyleMode",
          "normalized": "Style-\u003ePPHsMode-\u003ea-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Print Style Mode",
          "signature": "Style-\u003ePPHsMode-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:prettyPrintStyleMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epretty-print with the default style and a given mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "prettyPrintWithMode",
          "package": "haskell-src-exts",
          "signature": "PPHsMode -\u003e a -\u003e String",
          "source": "src/Language-Haskell-Exts-Pretty.html#prettyPrintWithMode",
          "type": "function"
        },
        "index": {
          "description": "pretty-print with the default style and given mode",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "prettyPrintWithMode",
          "normalized": "PPHsMode-\u003ea-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Print With Mode",
          "signature": "PPHsMode-\u003ea-\u003eString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:prettyPrintWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRatio of ribbon length to line length\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "ribbonsPerLine",
          "package": "haskell-src-exts",
          "signature": "Float",
          "type": "function"
        },
        "index": {
          "description": "Ratio of ribbon length to line length",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "ribbonsPerLine",
          "package": "haskell-src-exts",
          "partial": "Per Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:ribbonsPerLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eblank lines between statements?\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "spacing",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "blank lines between statements",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "spacing",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:spacing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default style (\u003ccode\u003emode=PageMode, lineLength=100, ribbonsPerLine=1.5\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "style",
          "package": "haskell-src-exts",
          "signature": "Style",
          "type": "function"
        },
        "index": {
          "description": "The default style mode PageMode lineLength ribbonsPerLine",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "style",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:style"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eindentation of the declarations in a\n \u003ccode\u003ewhere\u003c/code\u003e clause\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "whereIndent",
          "package": "haskell-src-exts",
          "signature": "Indent",
          "source": "src/Language-Haskell-Exts-Pretty.html#PPHsMode",
          "type": "function"
        },
        "index": {
          "description": "indentation of the declarations in where clause",
          "hierarchy": "Language Haskell Exts Pretty",
          "module": "Language.Haskell.Exts.Pretty",
          "name": "whereIndent",
          "package": "haskell-src-exts",
          "partial": "Indent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Pretty.html#v:whereIndent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis module defines various data types representing source location\n information, of varying degree of preciseness.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html",
          "type": "module"
        },
        "index": {
          "description": "This module defines various data types representing source location information of varying degree of preciseness",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "partial": "Src Loc",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn entity located in the source.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "Loc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#Loc",
          "type": "data"
        },
        "index": {
          "description": "An entity located in the source",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "Loc",
          "package": "haskell-src-exts",
          "partial": "Loc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#t:Loc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA class to work over all kinds of source location information.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcInfo",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcInfo",
          "type": "class"
        },
        "index": {
          "description": "class to work over all kinds of source location information",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcInfo",
          "package": "haskell-src-exts",
          "partial": "Src Info",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#t:SrcInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single position in the source.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcLoc",
          "type": "data"
        },
        "index": {
          "description": "single position in the source",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "partial": "Src Loc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#t:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA portion of the source, spanning one or more lines and zero or more columns.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpan",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "data"
        },
        "index": {
          "description": "portion of the source spanning one or more lines and zero or more columns",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpan",
          "package": "haskell-src-exts",
          "partial": "Src Span",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#t:SrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA portion of the source, extended with information on the position of entities within the span.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpanInfo",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpanInfo",
          "type": "data"
        },
        "index": {
          "description": "portion of the source extended with information on the position of entities within the span",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpanInfo",
          "package": "haskell-src-exts",
          "partial": "Src Span Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#t:SrcSpanInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdd more positional information for entities of a span.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c**)",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo -\u003e [SrcSpan] -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#%3C%2A%2A",
          "type": "function"
        },
        "index": {
          "description": "Add more positional information for entities of span",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c**) \u003c**",
          "normalized": "SrcSpanInfo-\u003e[SrcSpan]-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo-\u003e[SrcSpan]-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:-60--42--42-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShort name for \u003ccode\u003e\u003ca\u003ecombSpanInfo\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c++\u003e)",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo -\u003e SrcSpanInfo -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#%3C%2B%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Short name for combSpanInfo",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c++\u003e) \u003c++\u003e",
          "normalized": "SrcSpanInfo-\u003eSrcSpanInfo-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo-\u003eSrcSpanInfo-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:-60--43--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptionally combine the first argument with the second,\n   or return it unchanged if the second argument is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c+?\u003e)",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo -\u003e Maybe SrcSpanInfo -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#%3C%2B%3F%3E",
          "type": "function"
        },
        "index": {
          "description": "Optionally combine the first argument with the second or return it unchanged if the second argument is Nothing",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c+?\u003e) \u003c+?\u003e",
          "normalized": "SrcSpanInfo-\u003eMaybe SrcSpanInfo-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo-\u003eMaybe SrcSpanInfo-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:-60--43--63--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptionally combine the second argument with the first,\n   or return it unchanged if the first argument is \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c?+\u003e)",
          "package": "haskell-src-exts",
          "signature": "Maybe SrcSpanInfo -\u003e SrcSpanInfo -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#%3C%3F%2B%3E",
          "type": "function"
        },
        "index": {
          "description": "Optionally combine the second argument with the first or return it unchanged if the first argument is Nothing",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c?+\u003e) \u003c?+\u003e",
          "normalized": "Maybe SrcSpanInfo-\u003eSrcSpanInfo-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "signature": "Maybe SrcSpanInfo-\u003eSrcSpanInfo-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:-60--63--43--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge two \u003ccode\u003e\u003ca\u003eSrcSpan\u003c/a\u003e\u003c/code\u003es and lift them to a \u003ccode\u003eSrcInfoSpan\u003c/code\u003e with\n   no positional information for entities.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c^^\u003e)",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e SrcSpan -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#%3C%5E%5E%3E",
          "type": "function"
        },
        "index": {
          "description": "Merge two SrcSpan and lift them to SrcInfoSpan with no positional information for entities",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "(\u003c^^\u003e) \u003c^^\u003e",
          "normalized": "SrcSpan-\u003eSrcSpan-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpan-\u003eSrcSpan-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:-60--94--94--62-"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.SrcLoc\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "signature": "SrcLoc",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcLoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:SrcLoc\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:SrcLoc\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "partial": "Src Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpan",
          "package": "haskell-src-exts",
          "signature": "SrcSpan",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpan",
          "package": "haskell-src-exts",
          "partial": "Src Span",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:SrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpanInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpanInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "SrcSpanInfo",
          "package": "haskell-src-exts",
          "partial": "Src Span Info",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:SrcSpanInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two \u003ccode\u003e\u003ca\u003eSrcSpanInfo\u003c/a\u003e\u003c/code\u003es into one that spans the combined source area of\n   the two arguments, leaving positional information blank.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "combSpanInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo -\u003e SrcSpanInfo -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#combSpanInfo",
          "type": "function"
        },
        "index": {
          "description": "Combine two SrcSpanInfo into one that spans the combined source area of the two arguments leaving positional information blank",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "combSpanInfo",
          "normalized": "SrcSpanInfo-\u003eSrcSpanInfo-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "partial": "Span Info",
          "signature": "SrcSpanInfo-\u003eSrcSpanInfo-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:combSpanInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "fileName",
          "package": "haskell-src-exts",
          "signature": "si -\u003e String",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#fileName",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "fileName",
          "normalized": "a-\u003eString",
          "package": "haskell-src-exts",
          "partial": "Name",
          "signature": "si-\u003eString",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:fileName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "fromSrcInfo",
          "package": "haskell-src-exts",
          "signature": "SrcSpanInfo -\u003e si",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#fromSrcInfo",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "fromSrcInfo",
          "normalized": "SrcSpanInfo-\u003ea",
          "package": "haskell-src-exts",
          "partial": "Src Info",
          "signature": "SrcSpanInfo-\u003esi",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:fromSrcInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "getPointLoc",
          "package": "haskell-src-exts",
          "signature": "si -\u003e SrcLoc",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#getPointLoc",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "getPointLoc",
          "normalized": "a-\u003eSrcLoc",
          "package": "haskell-src-exts",
          "partial": "Point Loc",
          "signature": "si-\u003eSrcLoc",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:getPointLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eSrcSpanInfo\u003c/a\u003e\u003c/code\u003e with the supplied positional information for entities.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "infoSpan",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e [SrcSpan] -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#infoSpan",
          "type": "function"
        },
        "index": {
          "description": "Generate SrcSpanInfo with the supplied positional information for entities",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "infoSpan",
          "normalized": "SrcSpan-\u003e[SrcSpan]-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "partial": "Span",
          "signature": "SrcSpan-\u003e[SrcSpan]-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:infoSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTest if a given span starts and ends at the same location.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "isNullSpan",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e Bool",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#isNullSpan",
          "type": "function"
        },
        "index": {
          "description": "Test if given span starts and ends at the same location",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "isNullSpan",
          "normalized": "SrcSpan-\u003eBool",
          "package": "haskell-src-exts",
          "partial": "Null Span",
          "signature": "SrcSpan-\u003eBool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:isNullSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMerge two source spans into a single span from the start of the first\n   to the end of the second. Assumes that the two spans relate to the\n   same source file.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "mergeSrcSpan",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e SrcSpan -\u003e SrcSpan",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#mergeSrcSpan",
          "type": "function"
        },
        "index": {
          "description": "Merge two source spans into single span from the start of the first to the end of the second Assumes that the two spans relate to the same source file",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "mergeSrcSpan",
          "normalized": "SrcSpan-\u003eSrcSpan-\u003eSrcSpan",
          "package": "haskell-src-exts",
          "partial": "Src Span",
          "signature": "SrcSpan-\u003eSrcSpan-\u003eSrcSpan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:mergeSrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCombine two locations in the source to denote a span.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "mkSrcSpan",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e SrcLoc -\u003e SrcSpan",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#mkSrcSpan",
          "type": "function"
        },
        "index": {
          "description": "Combine two locations in the source to denote span",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "mkSrcSpan",
          "normalized": "SrcLoc-\u003eSrcLoc-\u003eSrcSpan",
          "package": "haskell-src-exts",
          "partial": "Src Span",
          "signature": "SrcLoc-\u003eSrcLoc-\u003eSrcSpan",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:mkSrcSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGenerate a \u003ccode\u003e\u003ca\u003eSrcSpanInfo\u003c/a\u003e\u003c/code\u003e with no positional information for entities.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "noInfoSpan",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e SrcSpanInfo",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#noInfoSpan",
          "type": "function"
        },
        "index": {
          "description": "Generate SrcSpanInfo with no positional information for entities",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "noInfoSpan",
          "normalized": "SrcSpan-\u003eSrcSpanInfo",
          "package": "haskell-src-exts",
          "partial": "Info Span",
          "signature": "SrcSpan-\u003eSrcSpanInfo",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:noInfoSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "noLoc",
          "package": "haskell-src-exts",
          "signature": "SrcLoc",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#noLoc",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "noLoc",
          "package": "haskell-src-exts",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:noLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "spanSize",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e (Int, Int)",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#spanSize",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "spanSize",
          "normalized": "SrcSpan-\u003e(Int,Int)",
          "package": "haskell-src-exts",
          "partial": "Size",
          "signature": "SrcSpan-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:spanSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.SrcLoc\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "srcColumn",
          "package": "haskell-src-exts",
          "signature": "Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcLoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcColumn\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:srcColumn\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcColumn",
          "package": "haskell-src-exts",
          "partial": "Column",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.SrcLoc\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "srcFilename",
          "package": "haskell-src-exts",
          "signature": "String",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcLoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcFilename\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:srcFilename\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcFilename",
          "package": "haskell-src-exts",
          "partial": "Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcInfoPoints",
          "package": "haskell-src-exts",
          "signature": "[SrcSpan]",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpanInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcInfoPoints",
          "normalized": "[SrcSpan]",
          "package": "haskell-src-exts",
          "partial": "Info Points",
          "signature": "[SrcSpan]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcInfoPoints"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcInfoSpan",
          "package": "haskell-src-exts",
          "signature": "SrcSpan",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpanInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcInfoSpan",
          "package": "haskell-src-exts",
          "partial": "Info Span",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcInfoSpan"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "[\"Language.Haskell.Exts.SrcLoc\",\"Language.Haskell.Exts.Syntax\"]",
          "name": "srcLine",
          "package": "haskell-src-exts",
          "signature": "Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcLoc",
          "type": "function",
          "uris": "[\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcLine\",\"http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:srcLine\"]"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcLine",
          "package": "haskell-src-exts",
          "partial": "Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003esrcSpanEndLine\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esrcSpanEndColumn\u003c/a\u003e\u003c/code\u003e in a pair.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanEnd",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e (Int, Int)",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#srcSpanEnd",
          "type": "function"
        },
        "index": {
          "description": "Returns srcSpanEndLine and srcSpanEndColumn in pair",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanEnd",
          "normalized": "SrcSpan-\u003e(Int,Int)",
          "package": "haskell-src-exts",
          "partial": "Span End",
          "signature": "SrcSpan-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanEnd"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanEndColumn",
          "package": "haskell-src-exts",
          "signature": "Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanEndColumn",
          "package": "haskell-src-exts",
          "partial": "Span End Column",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanEndColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanEndLine",
          "package": "haskell-src-exts",
          "signature": "Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanEndLine",
          "package": "haskell-src-exts",
          "partial": "Span End Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanEndLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanFilename",
          "package": "haskell-src-exts",
          "signature": "String",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanFilename",
          "package": "haskell-src-exts",
          "partial": "Span Filename",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanFilename"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns \u003ccode\u003e\u003ca\u003esrcSpanStartLine\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003esrcSpanStartColumn\u003c/a\u003e\u003c/code\u003e in a pair.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanStart",
          "package": "haskell-src-exts",
          "signature": "SrcSpan -\u003e (Int, Int)",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#srcSpanStart",
          "type": "function"
        },
        "index": {
          "description": "Returns srcSpanStartLine and srcSpanStartColumn in pair",
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanStart",
          "normalized": "SrcSpan-\u003e(Int,Int)",
          "package": "haskell-src-exts",
          "partial": "Span Start",
          "signature": "SrcSpan-\u003e(Int,Int)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanStart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanStartColumn",
          "package": "haskell-src-exts",
          "signature": "Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanStartColumn",
          "package": "haskell-src-exts",
          "partial": "Span Start Column",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanStartColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanStartLine",
          "package": "haskell-src-exts",
          "signature": "Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcSpan",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "srcSpanStartLine",
          "package": "haskell-src-exts",
          "partial": "Span Start Line",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:srcSpanStartLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "startColumn",
          "package": "haskell-src-exts",
          "signature": "si -\u003e Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#startColumn",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "startColumn",
          "normalized": "a-\u003eInt",
          "package": "haskell-src-exts",
          "partial": "Column",
          "signature": "si-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:startColumn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "startLine",
          "package": "haskell-src-exts",
          "signature": "si -\u003e Int",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#startLine",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "startLine",
          "normalized": "a-\u003eInt",
          "package": "haskell-src-exts",
          "partial": "Line",
          "signature": "si-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:startLine"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "toSrcInfo",
          "package": "haskell-src-exts",
          "signature": "SrcLoc -\u003e [SrcSpan] -\u003e SrcLoc -\u003e si",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#toSrcInfo",
          "type": "method"
        },
        "index": {
          "hierarchy": "Language Haskell Exts SrcLoc",
          "module": "Language.Haskell.Exts.SrcLoc",
          "name": "toSrcInfo",
          "normalized": "SrcLoc-\u003e[SrcSpan]-\u003eSrcLoc-\u003ea",
          "package": "haskell-src-exts",
          "partial": "Src Info",
          "signature": "SrcLoc-\u003e[SrcSpan]-\u003eSrcLoc-\u003esi",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-SrcLoc.html#v:toSrcInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eA suite of datatypes describing the abstract syntax of Haskell 98\n \u003ca\u003ehttp://www.haskell.org/onlinereport/\u003c/a\u003e plus registered extensions, including:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e multi-parameter type classes with functional dependencies (MultiParamTypeClasses, FunctionalDependencies)\n\u003c/li\u003e\u003cli\u003e parameters of type class assertions are unrestricted (FlexibleContexts)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eforall\u003c/code\u003e types as universal and existential quantification (RankNTypes, ExistentialQuantification, etc)\n\u003c/li\u003e\u003cli\u003e pattern guards (PatternGuards)\n\u003c/li\u003e\u003cli\u003e implicit parameters (ImplicitParameters)\n\u003c/li\u003e\u003cli\u003e generalised algebraic data types (GADTs)\n\u003c/li\u003e\u003cli\u003e template haskell (TemplateHaskell)\n\u003c/li\u003e\u003cli\u003e empty data type declarations (EmptyDataDecls)\n\u003c/li\u003e\u003cli\u003e unboxed tuples (UnboxedTuples)\n\u003c/li\u003e\u003cli\u003e regular patterns (RegularPatterns)\n\u003c/li\u003e\u003cli\u003e HSP-style XML expressions and patterns (XmlSyntax)\n\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Syntax",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html",
          "type": "module"
        },
        "index": {
          "description": "suite of datatypes describing the abstract syntax of Haskell http www.haskell.org onlinereport plus registered extensions including multi-parameter type classes with functional dependencies MultiParamTypeClasses FunctionalDependencies parameters of type class assertions are unrestricted FlexibleContexts forall types as universal and existential quantification RankNTypes ExistentialQuantification etc pattern guards PatternGuards implicit parameters ImplicitParameters generalised algebraic data types GADTs template haskell TemplateHaskell empty data type declarations EmptyDataDecls unboxed tuples UnboxedTuples regular patterns RegularPatterns HSP-style XML expressions and patterns XmlSyntax",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Syntax",
          "package": "haskell-src-exts",
          "partial": "Syntax",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eActivation clause of a RULES pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Activation",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Activation",
          "type": "data"
        },
        "index": {
          "description": "Activation clause of RULES pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Activation",
          "package": "haskell-src-exts",
          "partial": "Activation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Activation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003ealt\u003c/em\u003e alternative in a \u003ccode\u003ecase\u003c/code\u003e expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Alt",
          "type": "data"
        },
        "index": {
          "description": "An alt alternative in case expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "partial": "Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation through an ANN pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Annotation",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Annotation",
          "type": "data"
        },
        "index": {
          "description": "An annotation through an ANN pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Annotation",
          "package": "haskell-src-exts",
          "partial": "Annotation",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Annotation"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAssociativity of an operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Assoc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Assoc",
          "type": "data"
        },
        "index": {
          "description": "Associativity of an operator",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Assoc",
          "package": "haskell-src-exts",
          "partial": "Assoc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Assoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClass assertions.\n   In Haskell 98, the argument would be a \u003cem\u003etyvar\u003c/em\u003e, but this definition\n   allows multiple parameters, and allows them to be \u003cem\u003etype\u003c/em\u003es.\n   Also extended with support for implicit parameters and equality constraints.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Asst",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Asst",
          "type": "data"
        },
        "index": {
          "description": "Class assertions In Haskell the argument would be tyvar but this definition allows multiple parameters and allows them to be type Also extended with support for implicit parameters and equality constraints",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Asst",
          "package": "haskell-src-exts",
          "partial": "Asst",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Asst"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe type of a constructor argument or field, optionally including\n   a strictness annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BangType",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#BangType",
          "type": "data"
        },
        "index": {
          "description": "The type of constructor argument or field optionally including strictness annotation",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BangType",
          "package": "haskell-src-exts",
          "partial": "Bang Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:BangType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binding group inside a \u003ccode\u003elet\u003c/code\u003e or \u003ccode\u003ewhere\u003c/code\u003e clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Binds",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Binds",
          "type": "data"
        },
        "index": {
          "description": "binding group inside let or where clause",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Binds",
          "package": "haskell-src-exts",
          "partial": "Binds",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Binds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFlag denoting whether a tuple is boxed or unboxed.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Boxed",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Boxed",
          "type": "data"
        },
        "index": {
          "description": "Flag denoting whether tuple is boxed or unboxed",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Boxed",
          "package": "haskell-src-exts",
          "partial": "Boxed",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Boxed"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA template haskell bracket expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Bracket",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Bracket",
          "type": "data"
        },
        "index": {
          "description": "template haskell bracket expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Bracket",
          "package": "haskell-src-exts",
          "partial": "Bracket",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Bracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA name (\u003cem\u003ecname\u003c/em\u003e) of a component of a class or data type in an \u003ccode\u003eimport\u003c/code\u003e\n   or export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#CName",
          "type": "data"
        },
        "index": {
          "description": "name cname of component of class or data type in an import or export specification",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CName",
          "package": "haskell-src-exts",
          "partial": "CName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:CName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe calling convention of a foreign function call.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CallConv",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "data"
        },
        "index": {
          "description": "The calling convention of foreign function call",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CallConv",
          "package": "haskell-src-exts",
          "partial": "Call Conv",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:CallConv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclarations inside a class declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClassDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ClassDecl",
          "type": "data"
        },
        "index": {
          "description": "Declarations inside class declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClassDecl",
          "package": "haskell-src-exts",
          "partial": "Class Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ClassDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclaration of an ordinary data constructor.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ConDecl",
          "type": "data"
        },
        "index": {
          "description": "Declaration of an ordinary data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConDecl",
          "package": "haskell-src-exts",
          "partial": "Con Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA context is a set of assertions\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Context",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Context",
          "type": "type"
        },
        "index": {
          "description": "context is set of assertions",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Context",
          "package": "haskell-src-exts",
          "partial": "Context",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Context"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA flag stating whether a declaration is a data or newtype declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataOrNew",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#DataOrNew",
          "type": "data"
        },
        "index": {
          "description": "flag stating whether declaration is data or newtype declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataOrNew",
          "package": "haskell-src-exts",
          "partial": "Data Or New",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:DataOrNew"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA top-level declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Decl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "data"
        },
        "index": {
          "description": "top-level declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Decl",
          "package": "haskell-src-exts",
          "partial": "Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Decl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single derived instance, which may have arguments since it may be a MPTC.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Deriving",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Deriving",
          "type": "type"
        },
        "index": {
          "description": "single derived instance which may have arguments since it may be MPTC",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Deriving",
          "package": "haskell-src-exts",
          "partial": "Deriving",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Deriving"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eHaskell expressions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Exp",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "data"
        },
        "index": {
          "description": "Haskell expressions",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Exp",
          "package": "haskell-src-exts",
          "partial": "Exp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Exp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn item in a module's export specification.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ExportSpec",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ExportSpec",
          "type": "data"
        },
        "index": {
          "description": "An item in module export specification",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ExportSpec",
          "package": "haskell-src-exts",
          "partial": "Export Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ExportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003efbind\u003c/em\u003e in a labeled construction or update expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#FieldUpdate",
          "type": "data"
        },
        "index": {
          "description": "An fbind in labeled construction or update expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "partial": "Field Update",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:FieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA functional dependency, given on the form\n   l1 l2 ... ln -\u003e r2 r3 .. rn\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunDep",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#FunDep",
          "type": "data"
        },
        "index": {
          "description": "functional dependency given on the form l1 l2 ln r2 r3 rn",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunDep",
          "package": "haskell-src-exts",
          "partial": "Fun Dep",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:FunDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single constructor declaration in a GADT data type declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#GadtDecl",
          "type": "data"
        },
        "index": {
          "description": "single constructor declaration in GADT data type declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "partial": "Gadt Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:GadtDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA guarded case alternative \u003ccode\u003e|\u003c/code\u003e \u003cem\u003estmts\u003c/em\u003e \u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedAlt",
          "type": "data"
        },
        "index": {
          "description": "guarded case alternative stmts exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlt",
          "package": "haskell-src-exts",
          "partial": "Guarded Alt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:GuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe right-hand sides of a \u003ccode\u003ecase\u003c/code\u003e alternative,\n   which may be a single right-hand side or a\n   set of guarded ones.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlts",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedAlts",
          "type": "data"
        },
        "index": {
          "description": "The right-hand sides of case alternative which may be single right-hand side or set of guarded ones",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlts",
          "package": "haskell-src-exts",
          "partial": "Guarded Alts",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:GuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA guarded right hand side \u003ccode\u003e|\u003c/code\u003e \u003cem\u003estmts\u003c/em\u003e \u003ccode\u003e=\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e.\n   The guard is a series of statements when using pattern guards,\n   otherwise it will be a single qualifier expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedRhs",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedRhs",
          "type": "data"
        },
        "index": {
          "description": "guarded right hand side stmts exp The guard is series of statements when using pattern guards otherwise it will be single qualifier expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedRhs",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:GuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binding of an implicit parameter.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#IPBind",
          "type": "data"
        },
        "index": {
          "description": "binding of an implicit parameter",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "partial": "IPBind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:IPBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn implicit parameter name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#IPName",
          "type": "data"
        },
        "index": {
          "description": "An implicit parameter name",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPName",
          "package": "haskell-src-exts",
          "partial": "IPName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:IPName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn import declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "data"
        },
        "index": {
          "description": "An import declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "partial": "Import Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn import specification, representing a single explicit item imported\n   (or hidden) from a module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ImportSpec",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportSpec",
          "type": "data"
        },
        "index": {
          "description": "An import specification representing single explicit item imported or hidden from module",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ImportSpec",
          "package": "haskell-src-exts",
          "partial": "Import Spec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ImportSpec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDeclarations inside an instance declaration.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InstDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#InstDecl",
          "type": "data"
        },
        "index": {
          "description": "Declarations inside an instance declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InstDecl",
          "package": "haskell-src-exts",
          "partial": "Inst Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:InstDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn explicit kind annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Kind",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Kind",
          "type": "data"
        },
        "index": {
          "description": "An explicit kind annotation",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Kind",
          "package": "haskell-src-exts",
          "partial": "Kind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Kind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003eliteral\u003c/em\u003e\n Values of this type hold the abstract value of the literal, not the\n precise string representation used.  For example, \u003ccode\u003e10\u003c/code\u003e, \u003ccode\u003e0o12\u003c/code\u003e and \u003ccode\u003e0xa\u003c/code\u003e\n have the same representation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Literal",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "data"
        },
        "index": {
          "description": "literal Values of this type hold the abstract value of the literal not the precise string representation used For example o12 and xa have the same representation",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Literal",
          "package": "haskell-src-exts",
          "partial": "Literal",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Literal"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eClauses of a function binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Match",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Match",
          "type": "data"
        },
        "index": {
          "description": "Clauses of function binding",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Match",
          "package": "haskell-src-exts",
          "partial": "Match",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA complete Haskell source module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Module",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Module",
          "type": "data"
        },
        "index": {
          "description": "complete Haskell source module",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Module",
          "package": "haskell-src-exts",
          "partial": "Module",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of a Haskell module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ModuleName",
          "type": "newtype"
        },
        "index": {
          "description": "The name of Haskell module",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "partial": "Module Name",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA top level options pragma, preceding the module header.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModulePragma",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#ModulePragma",
          "type": "data"
        },
        "index": {
          "description": "top level options pragma preceding the module header",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModulePragma",
          "package": "haskell-src-exts",
          "partial": "Module Pragma",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:ModulePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used to represent variables, and also constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Name",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Name",
          "type": "data"
        },
        "index": {
          "description": "This type is used to represent variables and also constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Name",
          "package": "haskell-src-exts",
          "partial": "Name",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOperators appearing in \u003ccode\u003einfix\u003c/code\u003e declarations are never qualified.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Op",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Op",
          "type": "data"
        },
        "index": {
          "description": "Operators appearing in infix declarations are never qualified",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Op",
          "package": "haskell-src-exts",
          "partial": "Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Op"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn XML attribute in a pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#PXAttr",
          "type": "data"
        },
        "index": {
          "description": "An XML attribute in pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "partial": "PXAttr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:PXAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern, to be matched against a value.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Pat",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "data"
        },
        "index": {
          "description": "pattern to be matched against value",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Pat",
          "package": "haskell-src-exts",
          "partial": "Pat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Pat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn \u003cem\u003efpat\u003c/em\u003e in a labeled record pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatField",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#PatField",
          "type": "data"
        },
        "index": {
          "description": "An fpat in labeled record pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatField",
          "package": "haskell-src-exts",
          "partial": "Pat Field",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:PatField"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis type is used to represent qualified variables, and also\n   qualified constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#QName",
          "type": "data"
        },
        "index": {
          "description": "This type is used to represent qualified variables and also qualified constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QName",
          "package": "haskell-src-exts",
          "partial": "QName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:QName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePossibly qualified infix operators (\u003cem\u003eqop\u003c/em\u003e), appearing in expressions.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QOp",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#QOp",
          "type": "data"
        },
        "index": {
          "description": "Possibly qualified infix operators qop appearing in expressions",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QOp",
          "package": "haskell-src-exts",
          "partial": "QOp",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:QOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single constructor declaration within a data type declaration,\n   which may have an existential quantification binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualConDecl",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualConDecl",
          "type": "data"
        },
        "index": {
          "description": "single constructor declaration within data type declaration which may have an existential quantification binding",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualConDecl",
          "package": "haskell-src-exts",
          "partial": "Qual Con Decl",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:QualConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA general \u003cem\u003etransqual\u003c/em\u003e in a list comprehension,\n   which could potentially be a transform of the kind\n   enabled by TransformListComp.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "data"
        },
        "index": {
          "description": "general transqual in list comprehension which could potentially be transform of the kind enabled by TransformListComp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "partial": "Qual Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:QualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn entity in a regular pattern.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPat",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "data"
        },
        "index": {
          "description": "An entity in regular pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPat",
          "package": "haskell-src-exts",
          "partial": "RPat",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:RPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA regular pattern operator.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPatOp",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "data"
        },
        "index": {
          "description": "regular pattern operator",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPatOp",
          "package": "haskell-src-exts",
          "partial": "RPat Op",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:RPatOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe right hand side of a function or pattern binding.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Rhs",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Rhs",
          "type": "data"
        },
        "index": {
          "description": "The right hand side of function or pattern binding",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Rhs",
          "package": "haskell-src-exts",
          "partial": "Rhs",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Rhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe body of a RULES pragma.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Rule",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Rule",
          "type": "data"
        },
        "index": {
          "description": "The body of RULES pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Rule",
          "package": "haskell-src-exts",
          "partial": "Rule",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVariables used in a RULES pragma, optionally annotated with types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#RuleVar",
          "type": "data"
        },
        "index": {
          "description": "Variables used in RULES pragma optionally annotated with types",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "partial": "Rule Var",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:RuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe safety of a foreign function call.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Safety",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Safety",
          "type": "data"
        },
        "index": {
          "description": "The safety of foreign function call",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Safety",
          "package": "haskell-src-exts",
          "partial": "Safety",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Safety"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConstructors with special syntax.\n These names are never qualified, and always refer to builtin type or\n data constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpecialCon",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "data"
        },
        "index": {
          "description": "Constructors with special syntax These names are never qualified and always refer to builtin type or data constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpecialCon",
          "package": "haskell-src-exts",
          "partial": "Special Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:SpecialCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA template haskell splice expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Splice",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Splice",
          "type": "data"
        },
        "index": {
          "description": "template haskell splice expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Splice",
          "package": "haskell-src-exts",
          "partial": "Splice",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Splice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA single position in the source.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-SrcLoc.html#SrcLoc",
          "type": "data"
        },
        "index": {
          "description": "single position in the source",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SrcLoc",
          "package": "haskell-src-exts",
          "partial": "Src Loc",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:SrcLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA statement, representing both a \u003cem\u003estmt\u003c/em\u003e in a \u003ccode\u003edo\u003c/code\u003e-expression,\n   an ordinary \u003cem\u003equal\u003c/em\u003e in a list comprehension, as well as a \u003cem\u003estmt\u003c/em\u003e\n   in a pattern guard.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Stmt",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Stmt",
          "type": "data"
        },
        "index": {
          "description": "statement representing both stmt in do expression an ordinary qual in list comprehension as well as stmt in pattern guard",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Stmt",
          "package": "haskell-src-exts",
          "partial": "Stmt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Stmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRecognised tools for OPTIONS pragmas.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Tool",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Annotated-Syntax.html#Tool",
          "type": "data"
        },
        "index": {
          "description": "Recognised tools for OPTIONS pragmas",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Tool",
          "package": "haskell-src-exts",
          "partial": "Tool",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Tool"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type variable declaration, optionally with an explicit kind annotation.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyVarBind",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#TyVarBind",
          "type": "data"
        },
        "index": {
          "description": "type variable declaration optionally with an explicit kind annotation",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyVarBind",
          "package": "haskell-src-exts",
          "partial": "Ty Var Bind",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:TyVarBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type qualified with a context.\n   An unqualified type has an empty context.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Type",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "data"
        },
        "index": {
          "description": "type qualified with context An unqualified type has an empty context",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Type",
          "package": "haskell-src-exts",
          "partial": "Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:Type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWarning text to optionally use in the module header of e.g.\n   a deprecated module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "WarningText",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#WarningText",
          "type": "data"
        },
        "index": {
          "description": "Warning text to optionally use in the module header of e.g deprecated module",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "WarningText",
          "package": "haskell-src-exts",
          "partial": "Warning Text",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:WarningText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn xml attribute, which is a name-expression pair.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#XAttr",
          "type": "data"
        },
        "index": {
          "description": "An xml attribute which is name-expression pair",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "partial": "XAttr",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:XAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe name of an xml element or attribute,\n   possibly qualified with a namespace.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts-Syntax.html#XName",
          "type": "data"
        },
        "index": {
          "description": "The name of an xml element or attribute possibly qualified with namespace",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "partial": "XName",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#t:XName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ActiveFrom",
          "package": "haskell-src-exts",
          "signature": "ActiveFrom Int",
          "source": "src/Language-Haskell-Exts-Syntax.html#Activation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ActiveFrom",
          "package": "haskell-src-exts",
          "partial": "Active From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ActiveFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ActiveUntil",
          "package": "haskell-src-exts",
          "signature": "ActiveUntil Int",
          "source": "src/Language-Haskell-Exts-Syntax.html#Activation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ActiveUntil",
          "package": "haskell-src-exts",
          "partial": "Active Until",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ActiveUntil"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "signature": "Alt SrcLoc Pat GuardedAlts Binds",
          "source": "src/Language-Haskell-Exts-Syntax.html#Alt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Alt",
          "package": "haskell-src-exts",
          "partial": "Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Alt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AlwaysActive",
          "package": "haskell-src-exts",
          "signature": "AlwaysActive",
          "source": "src/Language-Haskell-Exts-Syntax.html#Activation",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AlwaysActive",
          "package": "haskell-src-exts",
          "partial": "Always Active",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:AlwaysActive"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation for a declared name.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Ann",
          "package": "haskell-src-exts",
          "signature": "Ann Name Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Annotation",
          "type": "function"
        },
        "index": {
          "description": "An annotation for declared name",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Ann",
          "package": "haskell-src-exts",
          "partial": "Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Ann"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eANN pragma with module scope\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AnnModulePragma",
          "package": "haskell-src-exts",
          "signature": "AnnModulePragma SrcLoc Annotation",
          "source": "src/Language-Haskell-Exts-Syntax.html#ModulePragma",
          "type": "function"
        },
        "index": {
          "description": "ANN pragma with module scope",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AnnModulePragma",
          "package": "haskell-src-exts",
          "partial": "Ann Module Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:AnnModulePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn ANN pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AnnPragma",
          "package": "haskell-src-exts",
          "signature": "AnnPragma SrcLoc Annotation",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An ANN pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AnnPragma",
          "package": "haskell-src-exts",
          "partial": "Ann Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:AnnPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary application\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "App",
          "package": "haskell-src-exts",
          "signature": "App Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "ordinary application",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "App",
          "package": "haskell-src-exts",
          "partial": "App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:App"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft-associative operator (declared with \u003ccode\u003einfixl\u003c/code\u003e).\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AssocLeft",
          "package": "haskell-src-exts",
          "signature": "AssocLeft",
          "source": "src/Language-Haskell-Exts-Syntax.html#Assoc",
          "type": "function"
        },
        "index": {
          "description": "left-associative operator declared with infixl",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AssocLeft",
          "package": "haskell-src-exts",
          "partial": "Assoc Left",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:AssocLeft"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-associative operator (declared with \u003ccode\u003einfix\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AssocNone",
          "package": "haskell-src-exts",
          "signature": "AssocNone",
          "source": "src/Language-Haskell-Exts-Syntax.html#Assoc",
          "type": "function"
        },
        "index": {
          "description": "non-associative operator declared with infix",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AssocNone",
          "package": "haskell-src-exts",
          "partial": "Assoc None",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:AssocNone"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eright-associative operator (declared with \u003ccode\u003einfixr\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AssocRight",
          "package": "haskell-src-exts",
          "signature": "AssocRight",
          "source": "src/Language-Haskell-Exts-Syntax.html#Assoc",
          "type": "function"
        },
        "index": {
          "description": "right-associative operator declared with infixr",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "AssocRight",
          "package": "haskell-src-exts",
          "partial": "Assoc Right",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:AssocRight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn ordinary binding group\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BDecls",
          "package": "haskell-src-exts",
          "signature": "BDecls [Decl]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Binds",
          "type": "function"
        },
        "index": {
          "description": "An ordinary binding group",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BDecls",
          "normalized": "BDecls[Decl]",
          "package": "haskell-src-exts",
          "partial": "BDecls",
          "signature": "BDecls[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:BDecls"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estrict component, marked with \"\u003ccode\u003e!\u003c/code\u003e\"\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BangedTy",
          "package": "haskell-src-exts",
          "signature": "BangedTy Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#BangType",
          "type": "function"
        },
        "index": {
          "description": "strict component marked with",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BangedTy",
          "package": "haskell-src-exts",
          "partial": "Banged Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:BangedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etemplate haskell bracket expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BracketExp",
          "package": "haskell-src-exts",
          "signature": "BracketExp Bracket",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "template haskell bracket expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "BracketExp",
          "package": "haskell-src-exts",
          "partial": "Bracket Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:BracketExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CApi",
          "package": "haskell-src-exts",
          "signature": "CApi",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CApi",
          "package": "haskell-src-exts",
          "partial": "CApi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:CApi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CCall",
          "package": "haskell-src-exts",
          "signature": "CCall",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CCall",
          "package": "haskell-src-exts",
          "partial": "CCall",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:CCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CPlusPlus",
          "package": "haskell-src-exts",
          "signature": "CPlusPlus",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CPlusPlus",
          "package": "haskell-src-exts",
          "partial": "CPlus Plus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:CPlusPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ecase\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eof\u003c/code\u003e \u003cem\u003ealts\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Case",
          "package": "haskell-src-exts",
          "signature": "Case Exp [Alt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "case exp of alts",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Case",
          "normalized": "Case Exp[Alt]",
          "package": "haskell-src-exts",
          "partial": "Case",
          "signature": "Case Exp[Alt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Case"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echaracter literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Char",
          "package": "haskell-src-exts",
          "signature": "Char Char",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "character literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Char",
          "package": "haskell-src-exts",
          "partial": "Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Char"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary class assertion\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClassA",
          "package": "haskell-src-exts",
          "signature": "ClassA QName [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "ordinary class assertion",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClassA",
          "normalized": "ClassA QName[Type]",
          "package": "haskell-src-exts",
          "partial": "Class",
          "signature": "ClassA QName[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ClassA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA declaration of a type class\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClassDecl",
          "package": "haskell-src-exts",
          "signature": "ClassDecl SrcLoc Context Name [TyVarBind] [FunDep] [ClassDecl]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "declaration of type class",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClassDecl",
          "normalized": "ClassDecl SrcLoc Context Name[TyVarBind][FunDep][ClassDecl]",
          "package": "haskell-src-exts",
          "partial": "Class Decl",
          "signature": "ClassDecl SrcLoc Context Name[TyVarBind][FunDep][ClassDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ClassDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeclaration of an associated data type\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsDataFam",
          "package": "haskell-src-exts",
          "signature": "ClsDataFam SrcLoc Context Name [TyVarBind] (Maybe Kind)",
          "source": "src/Language-Haskell-Exts-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "declaration of an associated data type",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsDataFam",
          "normalized": "ClsDataFam SrcLoc Context Name[TyVarBind](Maybe Kind)",
          "package": "haskell-src-exts",
          "partial": "Cls Data Fam",
          "signature": "ClsDataFam SrcLoc Context Name[TyVarBind](Maybe Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ClsDataFam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsDecl",
          "package": "haskell-src-exts",
          "signature": "ClsDecl Decl",
          "source": "src/Language-Haskell-Exts-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsDecl",
          "package": "haskell-src-exts",
          "partial": "Cls Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ClsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edefault choice for an associated type synonym\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsTyDef",
          "package": "haskell-src-exts",
          "signature": "ClsTyDef SrcLoc Type Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "default choice for an associated type synonym",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsTyDef",
          "package": "haskell-src-exts",
          "partial": "Cls Ty Def",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ClsTyDef"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeclaration of an associated type synonym\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsTyFam",
          "package": "haskell-src-exts",
          "signature": "ClsTyFam SrcLoc Name [TyVarBind] (Maybe Kind)",
          "source": "src/Language-Haskell-Exts-Syntax.html#ClassDecl",
          "type": "function"
        },
        "index": {
          "description": "declaration of an associated type synonym",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ClsTyFam",
          "normalized": "ClsTyFam SrcLoc Name[TyVarBind](Maybe Kind)",
          "package": "haskell-src-exts",
          "partial": "Cls Ty Fam",
          "signature": "ClsTyFam SrcLoc Name[TyVarBind](Maybe Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ClsTyFam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Con",
          "package": "haskell-src-exts",
          "signature": "Con QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Con",
          "package": "haskell-src-exts",
          "partial": "Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConDecl",
          "package": "haskell-src-exts",
          "signature": "ConDecl Name [BangType]",
          "source": "src/Language-Haskell-Exts-Syntax.html#ConDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConDecl",
          "normalized": "ConDecl Name[BangType]",
          "package": "haskell-src-exts",
          "partial": "Con Decl",
          "signature": "ConDecl Name[BangType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of a data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConName",
          "package": "haskell-src-exts",
          "signature": "ConName Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#CName",
          "type": "function"
        },
        "index": {
          "description": "name of data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConName",
          "package": "haskell-src-exts",
          "partial": "Con Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ConName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor operator (\u003cem\u003econop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConOp",
          "package": "haskell-src-exts",
          "signature": "ConOp Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#Op",
          "type": "function"
        },
        "index": {
          "description": "constructor operator conop",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ConOp",
          "package": "haskell-src-exts",
          "partial": "Con Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ConOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist data constructor \u003ccode\u003e(:)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Cons",
          "package": "haskell-src-exts",
          "signature": "Cons",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "list data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Cons",
          "package": "haskell-src-exts",
          "partial": "Cons",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Cons"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCORE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CorePragma",
          "package": "haskell-src-exts",
          "signature": "CorePragma String Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "CORE pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "CorePragma",
          "package": "haskell-src-exts",
          "partial": "Core Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:CorePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data OR newtype declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataDecl",
          "package": "haskell-src-exts",
          "signature": "DataDecl SrcLoc DataOrNew Context Name [TyVarBind] [QualConDecl] [Deriving]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data OR newtype declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataDecl",
          "normalized": "DataDecl SrcLoc DataOrNew Context Name[TyVarBind][QualConDecl][Deriving]",
          "package": "haskell-src-exts",
          "partial": "Data Decl",
          "signature": "DataDecl SrcLoc DataOrNew Context Name[TyVarBind][QualConDecl][Deriving]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data family declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataFamDecl",
          "package": "haskell-src-exts",
          "signature": "DataFamDecl SrcLoc Context Name [TyVarBind] (Maybe Kind)",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data family declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataFamDecl",
          "normalized": "DataFamDecl SrcLoc Context Name[TyVarBind](Maybe Kind)",
          "package": "haskell-src-exts",
          "partial": "Data Fam Decl",
          "signature": "DataFamDecl SrcLoc Context Name[TyVarBind](Maybe Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DataFamDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data family instance declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataInsDecl",
          "package": "haskell-src-exts",
          "signature": "DataInsDecl SrcLoc DataOrNew Type [QualConDecl] [Deriving]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data family instance declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataInsDecl",
          "normalized": "DataInsDecl SrcLoc DataOrNew Type[QualConDecl][Deriving]",
          "package": "haskell-src-exts",
          "partial": "Data Ins Decl",
          "signature": "DataInsDecl SrcLoc DataOrNew Type[QualConDecl][Deriving]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DataInsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataType",
          "package": "haskell-src-exts",
          "signature": "DataType",
          "source": "src/Language-Haskell-Exts-Syntax.html#DataOrNew",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DataType",
          "package": "haskell-src-exts",
          "partial": "Data Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DataType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edeclaration bracket: \u003ccode\u003e[d| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DeclBracket",
          "package": "haskell-src-exts",
          "signature": "DeclBracket [Decl]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "declaration bracket",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DeclBracket",
          "normalized": "DeclBracket[Decl]",
          "package": "haskell-src-exts",
          "partial": "Decl Bracket",
          "signature": "DeclBracket[Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DeclBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA declaration of default types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DefaultDecl",
          "package": "haskell-src-exts",
          "signature": "DefaultDecl SrcLoc [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "declaration of default types",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DefaultDecl",
          "normalized": "DefaultDecl SrcLoc[Type]",
          "package": "haskell-src-exts",
          "partial": "Default Decl",
          "signature": "DefaultDecl SrcLoc[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DefaultDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA DEPRECATED pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DeprPragmaDecl",
          "package": "haskell-src-exts",
          "signature": "DeprPragmaDecl SrcLoc [([Name], String)]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "DEPRECATED pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DeprPragmaDecl",
          "normalized": "DeprPragmaDecl SrcLoc[([Name],String)]",
          "package": "haskell-src-exts",
          "partial": "Depr Pragma Decl",
          "signature": "DeprPragmaDecl SrcLoc[([Name],String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DeprPragmaDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DeprText",
          "package": "haskell-src-exts",
          "signature": "DeprText String",
          "source": "src/Language-Haskell-Exts-Syntax.html#WarningText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DeprText",
          "package": "haskell-src-exts",
          "partial": "Depr Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DeprText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA standalone deriving declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DerivDecl",
          "package": "haskell-src-exts",
          "signature": "DerivDecl SrcLoc Context QName [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "standalone deriving declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DerivDecl",
          "normalized": "DerivDecl SrcLoc Context QName[Type]",
          "package": "haskell-src-exts",
          "partial": "Deriv Decl",
          "signature": "DerivDecl SrcLoc Context QName[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DerivDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003edo\u003c/code\u003e-expression:\n   the last statement in the list\n   should be an expression.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Do",
          "package": "haskell-src-exts",
          "signature": "Do [Stmt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "do expression the last statement in the list should be an expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Do",
          "normalized": "Do[Stmt]",
          "package": "haskell-src-exts",
          "partial": "Do",
          "signature": "Do[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Do"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DotNet",
          "package": "haskell-src-exts",
          "signature": "DotNet",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "DotNet",
          "package": "haskell-src-exts",
          "partial": "Dot Net",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:DotNet"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e:\n   a class or datatype exported abstractly,\n   or a type synonym.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EAbs",
          "package": "haskell-src-exts",
          "signature": "EAbs QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class or datatype exported abstractly or type synonym",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EAbs",
          "package": "haskell-src-exts",
          "partial": "EAbs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emodule M\u003c/code\u003e:\n   re-export a module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EModuleContents",
          "package": "haskell-src-exts",
          "signature": "EModuleContents ModuleName",
          "source": "src/Language-Haskell-Exts-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "module re-export module",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EModuleContents",
          "package": "haskell-src-exts",
          "partial": "EModule Contents",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EModuleContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(..)\u003c/code\u003e:\n   a class exported with all of its methods, or\n   a datatype exported with all of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EThingAll",
          "package": "haskell-src-exts",
          "signature": "EThingAll QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class exported with all of its methods or datatype exported with all of its constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EThingAll",
          "package": "haskell-src-exts",
          "partial": "EThing All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EThingAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(C_1,...,C_n)\u003c/code\u003e:\n   a class exported with some of its methods, or\n   a datatype exported with some of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EThingWith",
          "package": "haskell-src-exts",
          "signature": "EThingWith QName [CName]",
          "source": "src/Language-Haskell-Exts-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "class exported with some of its methods or datatype exported with some of its constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EThingWith",
          "normalized": "EThingWith QName[CName]",
          "package": "haskell-src-exts",
          "partial": "EThing With",
          "signature": "EThingWith QName[CName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EThingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EVar",
          "package": "haskell-src-exts",
          "signature": "EVar QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#ExportSpec",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EVar",
          "package": "haskell-src-exts",
          "partial": "EVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunbounded arithmetic sequence,\n   incrementing by 1: \u003ccode\u003e[from ..]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFrom",
          "package": "haskell-src-exts",
          "signature": "EnumFrom Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "unbounded arithmetic sequence incrementing by from",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFrom",
          "package": "haskell-src-exts",
          "partial": "Enum From",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EnumFrom"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunbounded arithmetic sequence,\n   with first two elements given \u003ccode\u003e[from, then ..]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFromThen",
          "package": "haskell-src-exts",
          "signature": "EnumFromThen Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "unbounded arithmetic sequence with first two elements given from then",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFromThen",
          "package": "haskell-src-exts",
          "partial": "Enum From Then",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EnumFromThen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounded arithmetic sequence,\n   with first two elements given \u003ccode\u003e[from, then .. to]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFromThenTo",
          "package": "haskell-src-exts",
          "signature": "EnumFromThenTo Exp Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "bounded arithmetic sequence with first two elements given from then to",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFromThenTo",
          "package": "haskell-src-exts",
          "partial": "Enum From Then To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EnumFromThenTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebounded arithmetic sequence,\n   incrementing by 1 \u003ccode\u003e[from .. to]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFromTo",
          "package": "haskell-src-exts",
          "signature": "EnumFromTo Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "bounded arithmetic sequence incrementing by from to",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EnumFromTo",
          "package": "haskell-src-exts",
          "partial": "Enum From To",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EnumFromTo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype equality constraint\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EqualP",
          "package": "haskell-src-exts",
          "signature": "EqualP Type Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "type equality constraint",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "EqualP",
          "package": "haskell-src-exts",
          "partial": "Equal",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:EqualP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpression bracket: \u003ccode\u003e[| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ExpBracket",
          "package": "haskell-src-exts",
          "signature": "ExpBracket Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "expression bracket",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ExpBracket",
          "package": "haskell-src-exts",
          "partial": "Exp Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ExpBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eexpression with explicit type signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ExpTypeSig",
          "package": "haskell-src-exts",
          "signature": "ExpTypeSig SrcLoc Exp Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "expression with explicit type signature",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ExpTypeSig",
          "package": "haskell-src-exts",
          "partial": "Exp Type Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ExpTypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field pun\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldPun",
          "package": "haskell-src-exts",
          "signature": "FieldPun Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#FieldUpdate",
          "type": "function"
        },
        "index": {
          "description": "record field pun",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldPun",
          "package": "haskell-src-exts",
          "partial": "Field Pun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:FieldPun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary label-expresion pair\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "signature": "FieldUpdate QName Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#FieldUpdate",
          "type": "function"
        },
        "index": {
          "description": "ordinary label-expresion pair",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldUpdate",
          "package": "haskell-src-exts",
          "partial": "Field Update",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:FieldUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field wildcard\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldWildcard",
          "package": "haskell-src-exts",
          "signature": "FieldWildcard",
          "source": "src/Language-Haskell-Exts-Syntax.html#FieldUpdate",
          "type": "function"
        },
        "index": {
          "description": "record field wildcard",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FieldWildcard",
          "package": "haskell-src-exts",
          "partial": "Field Wildcard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:FieldWildcard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA foreign export declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ForExp",
          "package": "haskell-src-exts",
          "signature": "ForExp SrcLoc CallConv String Name Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "foreign export declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ForExp",
          "package": "haskell-src-exts",
          "partial": "For Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ForExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA foreign import declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ForImp",
          "package": "haskell-src-exts",
          "signature": "ForImp SrcLoc CallConv Safety String Name Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "foreign import declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ForImp",
          "package": "haskell-src-exts",
          "partial": "For Imp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ForImp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efloating point literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Frac",
          "package": "haskell-src-exts",
          "signature": "Frac Rational",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "floating point literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Frac",
          "package": "haskell-src-exts",
          "partial": "Frac",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Frac"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA set of function binding clauses\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunBind",
          "package": "haskell-src-exts",
          "signature": "FunBind [Match]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "set of function binding clauses",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunBind",
          "normalized": "FunBind[Match]",
          "package": "haskell-src-exts",
          "partial": "Fun Bind",
          "signature": "FunBind[Match]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:FunBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction type constructor \u003ccode\u003e-\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunCon",
          "package": "haskell-src-exts",
          "signature": "FunCon",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "function type constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunCon",
          "package": "haskell-src-exts",
          "partial": "Fun Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:FunCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunDep",
          "package": "haskell-src-exts",
          "signature": "FunDep [Name] [Name]",
          "source": "src/Language-Haskell-Exts-Syntax.html#FunDep",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "FunDep",
          "normalized": "FunDep[Name][Name]",
          "package": "haskell-src-exts",
          "partial": "Fun Dep",
          "signature": "FunDep[Name][Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:FunDep"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data OR newtype declaration, GADT style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GDataDecl",
          "package": "haskell-src-exts",
          "signature": "GDataDecl SrcLoc DataOrNew Context Name [TyVarBind] (Maybe Kind) [GadtDecl] [Deriving]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data OR newtype declaration GADT style",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GDataDecl",
          "normalized": "GDataDecl SrcLoc DataOrNew Context Name[TyVarBind](Maybe Kind)[GadtDecl][Deriving]",
          "package": "haskell-src-exts",
          "partial": "GData Decl",
          "signature": "GDataDecl SrcLoc DataOrNew Context Name[TyVarBind](Maybe Kind)[GadtDecl][Deriving]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GDataDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA data family instance declaration, GADT style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GDataInsDecl",
          "package": "haskell-src-exts",
          "signature": "GDataInsDecl SrcLoc DataOrNew Type (Maybe Kind) [GadtDecl] [Deriving]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "data family instance declaration GADT style",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GDataInsDecl",
          "normalized": "GDataInsDecl SrcLoc DataOrNew Type(Maybe Kind)[GadtDecl][Deriving]",
          "package": "haskell-src-exts",
          "partial": "GData Ins Decl",
          "signature": "GDataInsDecl SrcLoc DataOrNew Type(Maybe Kind)[GadtDecl][Deriving]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GDataInsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "signature": "GadtDecl SrcLoc Name Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#GadtDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GadtDecl",
          "package": "haskell-src-exts",
          "partial": "Gadt Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GadtDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGENERATED pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GenPragma",
          "package": "haskell-src-exts",
          "signature": "GenPragma String (Int, Int) (Int, Int) Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "GENERATED pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GenPragma",
          "normalized": "GenPragma String(Int,Int)(Int,Int)Exp",
          "package": "haskell-src-exts",
          "partial": "Gen Pragma",
          "signature": "GenPragma String(Int,Int)(Int,Int)Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GenPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea generator: \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e\u003c-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Generator",
          "package": "haskell-src-exts",
          "signature": "Generator SrcLoc Pat Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "generator pat exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Generator",
          "package": "haskell-src-exts",
          "partial": "Generator",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Generator"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GroupBy",
          "package": "haskell-src-exts",
          "signature": "GroupBy Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then group by exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GroupBy",
          "package": "haskell-src-exts",
          "partial": "Group By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GroupBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eby\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eusing\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GroupByUsing",
          "package": "haskell-src-exts",
          "signature": "GroupByUsing Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then group by exp using exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GroupByUsing",
          "package": "haskell-src-exts",
          "partial": "Group By Using",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GroupByUsing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003ccode\u003egroup\u003c/code\u003e \u003ccode\u003eusing\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GroupUsing",
          "package": "haskell-src-exts",
          "signature": "GroupUsing Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then group using exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GroupUsing",
          "package": "haskell-src-exts",
          "partial": "Group Using",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GroupUsing"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlt",
          "package": "haskell-src-exts",
          "signature": "GuardedAlt SrcLoc [Stmt] Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedAlt",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlt",
          "normalized": "GuardedAlt SrcLoc[Stmt]Exp",
          "package": "haskell-src-exts",
          "partial": "Guarded Alt",
          "signature": "GuardedAlt SrcLoc[Stmt]Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003egdpat\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlts",
          "package": "haskell-src-exts",
          "signature": "GuardedAlts [GuardedAlt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedAlts",
          "type": "function"
        },
        "index": {
          "description": "gdpat",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedAlts",
          "normalized": "GuardedAlts[GuardedAlt]",
          "package": "haskell-src-exts",
          "partial": "Guarded Alts",
          "signature": "GuardedAlts[GuardedAlt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GuardedAlts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedRhs",
          "package": "haskell-src-exts",
          "signature": "GuardedRhs SrcLoc [Stmt] Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedRhs",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedRhs",
          "normalized": "GuardedRhs SrcLoc[Stmt]Exp",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhs",
          "signature": "GuardedRhs SrcLoc[Stmt]Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eguarded right hand side (\u003cem\u003egdrhs\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedRhss",
          "package": "haskell-src-exts",
          "signature": "GuardedRhss [GuardedRhs]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Rhs",
          "type": "function"
        },
        "index": {
          "description": "guarded right hand side gdrhs",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "GuardedRhss",
          "normalized": "GuardedRhss[GuardedRhs]",
          "package": "haskell-src-exts",
          "partial": "Guarded Rhss",
          "signature": "GuardedRhss[GuardedRhs]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:GuardedRhss"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT\u003c/code\u003e:\n   the name of a class, datatype or type synonym.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IAbs",
          "package": "haskell-src-exts",
          "signature": "IAbs Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "the name of class datatype or type synonym",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IAbs",
          "package": "haskell-src-exts",
          "partial": "IAbs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IAbs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "signature": "IPBind SrcLoc IPName Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#IPBind",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPBind",
          "package": "haskell-src-exts",
          "partial": "IPBind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IPBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA binding group for implicit parameters\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPBinds",
          "package": "haskell-src-exts",
          "signature": "IPBinds [IPBind]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Binds",
          "type": "function"
        },
        "index": {
          "description": "binding group for implicit parameters",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPBinds",
          "normalized": "IPBinds[IPBind]",
          "package": "haskell-src-exts",
          "partial": "IPBinds",
          "signature": "IPBinds[IPBind]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IPBinds"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e?\u003cem\u003eident\u003c/em\u003e, non-linear implicit parameter\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPDup",
          "package": "haskell-src-exts",
          "signature": "IPDup String",
          "source": "src/Language-Haskell-Exts-Syntax.html#IPName",
          "type": "function"
        },
        "index": {
          "description": "ident non-linear implicit parameter",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPDup",
          "package": "haskell-src-exts",
          "partial": "IPDup",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IPDup"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e%\u003cem\u003eident\u003c/em\u003e, linear implicit parameter\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPLin",
          "package": "haskell-src-exts",
          "signature": "IPLin String",
          "source": "src/Language-Haskell-Exts-Syntax.html#IPName",
          "type": "function"
        },
        "index": {
          "description": "ident linear implicit parameter",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPLin",
          "package": "haskell-src-exts",
          "partial": "IPLin",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IPLin"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimplicit parameter variable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPVar",
          "package": "haskell-src-exts",
          "signature": "IPVar IPName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "implicit parameter variable",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IPVar",
          "package": "haskell-src-exts",
          "partial": "IPVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IPVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimplicit parameter assertion\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IParam",
          "package": "haskell-src-exts",
          "signature": "IParam IPName Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "implicit parameter assertion",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IParam",
          "package": "haskell-src-exts",
          "partial": "IParam",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IParam"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(..)\u003c/code\u003e:\n   a class imported with all of its methods, or\n   a datatype imported with all of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IThingAll",
          "package": "haskell-src-exts",
          "signature": "IThingAll Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "class imported with all of its methods or datatype imported with all of its constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IThingAll",
          "package": "haskell-src-exts",
          "partial": "IThing All",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IThingAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eT(C_1,...,C_n)\u003c/code\u003e:\n   a class imported with some of its methods, or\n   a datatype imported with some of its constructors.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IThingWith",
          "package": "haskell-src-exts",
          "signature": "IThingWith Name [CName]",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "class imported with some of its methods or datatype imported with some of its constructors",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IThingWith",
          "normalized": "IThingWith Name[CName]",
          "package": "haskell-src-exts",
          "partial": "IThing With",
          "signature": "IThingWith Name[CName]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IThingWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IVar",
          "package": "haskell-src-exts",
          "signature": "IVar Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportSpec",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IVar",
          "package": "haskell-src-exts",
          "partial": "IVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable splice: \u003ccode\u003e$var\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IdSplice",
          "package": "haskell-src-exts",
          "signature": "IdSplice String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Splice",
          "type": "function"
        },
        "index": {
          "description": "variable splice var",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "IdSplice",
          "package": "haskell-src-exts",
          "partial": "Id Splice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:IdSplice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003evarid\u003c/em\u003e or \u003cem\u003econid\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Ident",
          "package": "haskell-src-exts",
          "signature": "Ident String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Name",
          "type": "function"
        },
        "index": {
          "description": "varid or conid",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Ident",
          "package": "haskell-src-exts",
          "partial": "Ident",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Ident"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003eif\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eelse\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "If",
          "package": "haskell-src-exts",
          "signature": "If Exp Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "if exp then exp else exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "If",
          "package": "haskell-src-exts",
          "partial": "If",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:If"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "signature": "ImportDecl",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ImportDecl",
          "package": "haskell-src-exts",
          "partial": "Import Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ImportDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eclass assertion where the class name is given infix\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixA",
          "package": "haskell-src-exts",
          "signature": "InfixA Type QName Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Asst",
          "type": "function"
        },
        "index": {
          "description": "class assertion where the class name is given infix",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixA",
          "package": "haskell-src-exts",
          "partial": "Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InfixA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix application\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixApp",
          "package": "haskell-src-exts",
          "signature": "InfixApp Exp QOp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "infix application",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixApp",
          "package": "haskell-src-exts",
          "partial": "Infix App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InfixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixConDecl",
          "package": "haskell-src-exts",
          "signature": "InfixConDecl BangType Name BangType",
          "source": "src/Language-Haskell-Exts-Syntax.html#ConDecl",
          "type": "function"
        },
        "index": {
          "description": "infix data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixConDecl",
          "package": "haskell-src-exts",
          "partial": "Infix Con Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InfixConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA declaration of operator fixity\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixDecl",
          "package": "haskell-src-exts",
          "signature": "InfixDecl SrcLoc Assoc Int [Op]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "declaration of operator fixity",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InfixDecl",
          "normalized": "InfixDecl SrcLoc Assoc Int[Op]",
          "package": "haskell-src-exts",
          "partial": "Infix Decl",
          "signature": "InfixDecl SrcLoc Assoc Int[Op]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InfixDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn INLINE CONLIKE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InlineConlikeSig",
          "package": "haskell-src-exts",
          "signature": "InlineConlikeSig SrcLoc Activation QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An INLINE CONLIKE pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InlineConlikeSig",
          "package": "haskell-src-exts",
          "partial": "Inline Conlike Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InlineConlikeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn INLINE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InlineSig",
          "package": "haskell-src-exts",
          "signature": "InlineSig SrcLoc Bool Activation QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An INLINE pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InlineSig",
          "package": "haskell-src-exts",
          "partial": "Inline Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InlineSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associated data type implementation\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsData",
          "package": "haskell-src-exts",
          "signature": "InsData SrcLoc DataOrNew Type [QualConDecl] [Deriving]",
          "source": "src/Language-Haskell-Exts-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "an associated data type implementation",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsData",
          "normalized": "InsData SrcLoc DataOrNew Type[QualConDecl][Deriving]",
          "package": "haskell-src-exts",
          "partial": "Ins Data",
          "signature": "InsData SrcLoc DataOrNew Type[QualConDecl][Deriving]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InsData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsDecl",
          "package": "haskell-src-exts",
          "signature": "InsDecl Decl",
          "source": "src/Language-Haskell-Exts-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "ordinary declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsDecl",
          "package": "haskell-src-exts",
          "partial": "Ins Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associated data type implemented using GADT style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsGData",
          "package": "haskell-src-exts",
          "signature": "InsGData SrcLoc DataOrNew Type (Maybe Kind) [GadtDecl] [Deriving]",
          "source": "src/Language-Haskell-Exts-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "an associated data type implemented using GADT style",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsGData",
          "normalized": "InsGData SrcLoc DataOrNew Type(Maybe Kind)[GadtDecl][Deriving]",
          "package": "haskell-src-exts",
          "partial": "Ins GData",
          "signature": "InsGData SrcLoc DataOrNew Type(Maybe Kind)[GadtDecl][Deriving]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InsGData"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean associated type definition\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsType",
          "package": "haskell-src-exts",
          "signature": "InsType SrcLoc Type Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#InstDecl",
          "type": "function"
        },
        "index": {
          "description": "an associated type definition",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InsType",
          "package": "haskell-src-exts",
          "partial": "Ins Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InsType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn declaration of a type class instance\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InstDecl",
          "package": "haskell-src-exts",
          "signature": "InstDecl SrcLoc Context QName [Type] [InstDecl]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "An declaration of type class instance",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InstDecl",
          "normalized": "InstDecl SrcLoc Context QName[Type][InstDecl]",
          "package": "haskell-src-exts",
          "partial": "Inst Decl",
          "signature": "InstDecl SrcLoc Context QName[Type][InstDecl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InstDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SPECIALISE instance pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InstSig",
          "package": "haskell-src-exts",
          "signature": "InstSig SrcLoc Context QName [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "SPECIALISE instance pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "InstSig",
          "normalized": "InstSig SrcLoc Context QName[Type]",
          "package": "haskell-src-exts",
          "partial": "Inst Sig",
          "signature": "InstSig SrcLoc Context QName[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:InstSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einteger literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Int",
          "package": "haskell-src-exts",
          "signature": "Int Integer",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "integer literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Int",
          "package": "haskell-src-exts",
          "partial": "Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Int"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Js",
          "package": "haskell-src-exts",
          "signature": "Js",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Js",
          "package": "haskell-src-exts",
          "partial": "Js",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Js"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Jvm",
          "package": "haskell-src-exts",
          "signature": "Jvm",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Jvm",
          "package": "haskell-src-exts",
          "partial": "Jvm",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Jvm"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e!\u003c/code\u003e, the kind of unboxed types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindBang",
          "package": "haskell-src-exts",
          "signature": "KindBang",
          "source": "src/Language-Haskell-Exts-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "the kind of unboxed types",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindBang",
          "package": "haskell-src-exts",
          "partial": "Kind Bang",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:KindBang"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e-\u003e\u003c/code\u003e, the kind of a type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindFn",
          "package": "haskell-src-exts",
          "signature": "KindFn Kind Kind",
          "source": "src/Language-Haskell-Exts-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "the kind of type constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindFn",
          "package": "haskell-src-exts",
          "partial": "Kind Fn",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:KindFn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea kind surrounded by parentheses\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindParen",
          "package": "haskell-src-exts",
          "signature": "KindParen Kind",
          "source": "src/Language-Haskell-Exts-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "kind surrounded by parentheses",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindParen",
          "package": "haskell-src-exts",
          "partial": "Kind Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:KindParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e, the kind of types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindStar",
          "package": "haskell-src-exts",
          "signature": "KindStar",
          "source": "src/Language-Haskell-Exts-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "the kind of types",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindStar",
          "package": "haskell-src-exts",
          "partial": "Kind Star",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:KindStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea kind variable (as of yet unsupported by compilers)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindVar",
          "package": "haskell-src-exts",
          "signature": "KindVar Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#Kind",
          "type": "function"
        },
        "index": {
          "description": "kind variable as of yet unsupported by compilers",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindVar",
          "package": "haskell-src-exts",
          "partial": "Kind Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:KindVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable binding with kind annotation\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindedVar",
          "package": "haskell-src-exts",
          "signature": "KindedVar Name Kind",
          "source": "src/Language-Haskell-Exts-Syntax.html#TyVarBind",
          "type": "function"
        },
        "index": {
          "description": "variable binding with kind annotation",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "KindedVar",
          "package": "haskell-src-exts",
          "partial": "Kinded Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:KindedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elambda expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Lambda",
          "package": "haskell-src-exts",
          "signature": "Lambda SrcLoc [Pat] Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "lambda expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Lambda",
          "normalized": "Lambda SrcLoc[Pat]Exp",
          "package": "haskell-src-exts",
          "partial": "Lambda",
          "signature": "Lambda SrcLoc[Pat]Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Lambda"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eLANGUAGE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LanguagePragma",
          "package": "haskell-src-exts",
          "signature": "LanguagePragma SrcLoc [Name]",
          "source": "src/Language-Haskell-Exts-Syntax.html#ModulePragma",
          "type": "function"
        },
        "index": {
          "description": "LANGUAGE pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LanguagePragma",
          "normalized": "LanguagePragma SrcLoc[Name]",
          "package": "haskell-src-exts",
          "partial": "Language Pragma",
          "signature": "LanguagePragma SrcLoc[Name]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:LanguagePragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow application (from left): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e-\u003c\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LeftArrApp",
          "package": "haskell-src-exts",
          "signature": "LeftArrApp Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "arrow application from left exp exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LeftArrApp",
          "package": "haskell-src-exts",
          "partial": "Left Arr App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:LeftArrApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehigher-order arrow application (from left): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e-\u003c\u003c\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LeftArrHighApp",
          "package": "haskell-src-exts",
          "signature": "LeftArrHighApp Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "higher-order arrow application from left exp exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LeftArrHighApp",
          "package": "haskell-src-exts",
          "partial": "Left Arr High App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:LeftArrHighApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eleft section \u003ccode\u003e(\u003c/code\u003e\u003cem\u003eexp\u003c/em\u003e \u003cem\u003eqop\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LeftSection",
          "package": "haskell-src-exts",
          "signature": "LeftSection Exp QOp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "left section exp qop",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LeftSection",
          "package": "haskell-src-exts",
          "partial": "Left Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:LeftSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal declarations with \u003ccode\u003elet\u003c/code\u003e ... \u003ccode\u003ein\u003c/code\u003e ...\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Let",
          "package": "haskell-src-exts",
          "signature": "Let Binds Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "local declarations with let in",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Let",
          "package": "haskell-src-exts",
          "partial": "Let",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Let"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elocal bindings\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LetStmt",
          "package": "haskell-src-exts",
          "signature": "LetStmt Binds",
          "source": "src/Language-Haskell-Exts-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "local bindings",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "LetStmt",
          "package": "haskell-src-exts",
          "partial": "Let Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:LetStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "List",
          "package": "haskell-src-exts",
          "signature": "List [Exp]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "list expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "List",
          "normalized": "List[Exp]",
          "package": "haskell-src-exts",
          "partial": "List",
          "signature": "List[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:List"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary list comprehension\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ListComp",
          "package": "haskell-src-exts",
          "signature": "ListComp Exp [QualStmt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "ordinary list comprehension",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ListComp",
          "normalized": "ListComp Exp[QualStmt]",
          "package": "haskell-src-exts",
          "partial": "List Comp",
          "signature": "ListComp Exp[QualStmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ListComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist type constructor \u003ccode\u003e[]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ListCon",
          "package": "haskell-src-exts",
          "signature": "ListCon",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "list type constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ListCon",
          "package": "haskell-src-exts",
          "partial": "List Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ListCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eliteral constant\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Lit",
          "package": "haskell-src-exts",
          "signature": "Lit Literal",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "literal constant",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Lit",
          "package": "haskell-src-exts",
          "partial": "Lit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Lit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003emdo\u003c/code\u003e-expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "MDo",
          "package": "haskell-src-exts",
          "signature": "MDo [Stmt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "mdo expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "MDo",
          "normalized": "MDo[Stmt]",
          "package": "haskell-src-exts",
          "partial": "MDo",
          "signature": "MDo[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:MDo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Match",
          "package": "haskell-src-exts",
          "signature": "Match SrcLoc Name [Pat] (Maybe Type) Rhs Binds",
          "source": "src/Language-Haskell-Exts-Syntax.html#Match",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Match",
          "normalized": "Match SrcLoc Name[Pat](Maybe Type)Rhs Binds",
          "package": "haskell-src-exts",
          "partial": "Match",
          "signature": "Match SrcLoc Name[Pat](Maybe Type)Rhs Binds",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Module",
          "package": "haskell-src-exts",
          "signature": "Module SrcLoc ModuleName [ModulePragma] (Maybe WarningText) (Maybe [ExportSpec]) [ImportDecl] [Decl]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Module",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Module",
          "normalized": "Module SrcLoc ModuleName[ModulePragma](Maybe WarningText)(Maybe[ExportSpec])[ImportDecl][Decl]",
          "package": "haskell-src-exts",
          "partial": "Module",
          "signature": "Module SrcLoc ModuleName[ModulePragma](Maybe WarningText)(Maybe[ExportSpec])[ImportDecl][Decl]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Module"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation for the defining module.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModuleAnn",
          "package": "haskell-src-exts",
          "signature": "ModuleAnn Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Annotation",
          "type": "function"
        },
        "index": {
          "description": "An annotation for the defining module",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModuleAnn",
          "package": "haskell-src-exts",
          "partial": "Module Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ModuleAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "signature": "ModuleName String",
          "source": "src/Language-Haskell-Exts-Syntax.html#ModuleName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ModuleName",
          "package": "haskell-src-exts",
          "partial": "Module Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ModuleName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegation expression \u003ccode\u003e-\u003cem\u003eexp\u003c/em\u003e\u003c/code\u003e (unary minus)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "NegApp",
          "package": "haskell-src-exts",
          "signature": "NegApp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "negation expression exp unary minus",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "NegApp",
          "package": "haskell-src-exts",
          "partial": "Neg App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:NegApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "NewType",
          "package": "haskell-src-exts",
          "signature": "NewType",
          "source": "src/Language-Haskell-Exts-Syntax.html#DataOrNew",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "NewType",
          "package": "haskell-src-exts",
          "partial": "New Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:NewType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOPTIONS pragma, possibly qualified with a tool, e.g. OPTIONS_GHC\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "OptionsPragma",
          "package": "haskell-src-exts",
          "signature": "OptionsPragma SrcLoc (Maybe Tool) String",
          "source": "src/Language-Haskell-Exts-Syntax.html#ModulePragma",
          "type": "function"
        },
        "index": {
          "description": "OPTIONS pragma possibly qualified with tool e.g OPTIONS GHC",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "OptionsPragma",
          "package": "haskell-src-exts",
          "partial": "Options Pragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:OptionsPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003edata constructor and argument patterns\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PApp",
          "package": "haskell-src-exts",
          "signature": "PApp QName [Pat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "data constructor and argument patterns",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PApp",
          "normalized": "PApp QName[Pat]",
          "package": "haskell-src-exts",
          "partial": "PApp",
          "signature": "PApp QName[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e@\u003c/code\u003e-pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PAsPat",
          "package": "haskell-src-exts",
          "signature": "PAsPat Name Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PAsPat",
          "package": "haskell-src-exts",
          "partial": "PAs Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PAsPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estrict (bang) pattern: \u003ccode\u003ef !x = ...\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PBangPat",
          "package": "haskell-src-exts",
          "signature": "PBangPat Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "strict bang pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PBangPat",
          "package": "haskell-src-exts",
          "partial": "PBang Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PBangPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExplicit generics style type argument e.g. \u003ccode\u003ef {| Int |} x = ...\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PExplTypeArg",
          "package": "haskell-src-exts",
          "signature": "PExplTypeArg QName Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "Explicit generics style type argument e.g Int",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PExplTypeArg",
          "package": "haskell-src-exts",
          "partial": "PExpl Type Arg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PExplTypeArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary label-pattern pair\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PFieldPat",
          "package": "haskell-src-exts",
          "signature": "PFieldPat QName Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#PatField",
          "type": "function"
        },
        "index": {
          "description": "ordinary label-pattern pair",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PFieldPat",
          "package": "haskell-src-exts",
          "partial": "PField Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PFieldPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field pun\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PFieldPun",
          "package": "haskell-src-exts",
          "signature": "PFieldPun Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#PatField",
          "type": "function"
        },
        "index": {
          "description": "record field pun",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PFieldPun",
          "package": "haskell-src-exts",
          "partial": "PField Pun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PFieldPun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord field wildcard\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PFieldWildcard",
          "package": "haskell-src-exts",
          "signature": "PFieldWildcard",
          "source": "src/Language-Haskell-Exts-Syntax.html#PatField",
          "type": "function"
        },
        "index": {
          "description": "record field wildcard",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PFieldWildcard",
          "package": "haskell-src-exts",
          "partial": "PField Wildcard",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PFieldWildcard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern with an infix data constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PInfixApp",
          "package": "haskell-src-exts",
          "signature": "PInfixApp Pat QName Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern with an infix data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PInfixApp",
          "package": "haskell-src-exts",
          "partial": "PInfix App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PInfixApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eirrefutable pattern: \u003ccode\u003e~\u003cem\u003epat\u003c/em\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PIrrPat",
          "package": "haskell-src-exts",
          "signature": "PIrrPat Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "irrefutable pattern pat",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PIrrPat",
          "package": "haskell-src-exts",
          "partial": "PIrr Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PIrrPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PList",
          "package": "haskell-src-exts",
          "signature": "PList [Pat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "list pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PList",
          "normalized": "PList[Pat]",
          "package": "haskell-src-exts",
          "partial": "PList",
          "signature": "PList[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eliteral constant\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PLit",
          "package": "haskell-src-exts",
          "signature": "PLit Literal",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "literal constant",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PLit",
          "package": "haskell-src-exts",
          "partial": "PLit",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PLit"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003en+k pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PNPlusK",
          "package": "haskell-src-exts",
          "signature": "PNPlusK Name Integer",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PNPlusK",
          "package": "haskell-src-exts",
          "partial": "PNPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PNPlusK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enegated pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PNeg",
          "package": "haskell-src-exts",
          "signature": "PNeg Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "negated pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PNeg",
          "package": "haskell-src-exts",
          "partial": "PNeg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PNeg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesized pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PParen",
          "package": "haskell-src-exts",
          "signature": "PParen Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "parenthesized pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PParen",
          "package": "haskell-src-exts",
          "partial": "PParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equasi quote patter: \u003ccode\u003e[$\u003cem\u003ename\u003c/em\u003e| \u003cem\u003estring\u003c/em\u003e |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PQuasiQuote",
          "package": "haskell-src-exts",
          "signature": "PQuasiQuote String String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "quasi quote patter name string",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PQuasiQuote",
          "package": "haskell-src-exts",
          "partial": "PQuasi Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PQuasiQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eregular list pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PRPat",
          "package": "haskell-src-exts",
          "signature": "PRPat [RPat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "regular list pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PRPat",
          "normalized": "PRPat[RPat]",
          "package": "haskell-src-exts",
          "partial": "PRPat",
          "signature": "PRPat[RPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PRPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elabelled pattern, record style\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PRec",
          "package": "haskell-src-exts",
          "signature": "PRec QName [PatField]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "labelled pattern record style",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PRec",
          "normalized": "PRec QName[PatField]",
          "package": "haskell-src-exts",
          "partial": "PRec",
          "signature": "PRec QName[PatField]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PTuple",
          "package": "haskell-src-exts",
          "signature": "PTuple Boxed [Pat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "tuple pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PTuple",
          "normalized": "PTuple Boxed[Pat]",
          "package": "haskell-src-exts",
          "partial": "PTuple",
          "signature": "PTuple Boxed[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PVar",
          "package": "haskell-src-exts",
          "signature": "PVar Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PVar",
          "package": "haskell-src-exts",
          "partial": "PVar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eview patterns of the form \u003ccode\u003e(\u003cem\u003eexp\u003c/em\u003e -\u003e \u003cem\u003epat\u003c/em\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PViewPat",
          "package": "haskell-src-exts",
          "signature": "PViewPat Exp Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "view patterns of the form exp pat",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PViewPat",
          "package": "haskell-src-exts",
          "partial": "PView Pat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PViewPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ewildcard pattern: \u003ccode\u003e_\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PWildCard",
          "package": "haskell-src-exts",
          "signature": "PWildCard",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "wildcard pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PWildCard",
          "package": "haskell-src-exts",
          "partial": "PWild Card",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PWildCard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "signature": "PXAttr XName Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#PXAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXAttr",
          "package": "haskell-src-exts",
          "partial": "PXAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PXAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML singleton element pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXETag",
          "package": "haskell-src-exts",
          "signature": "PXETag SrcLoc XName [PXAttr] (Maybe Pat)",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML singleton element pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXETag",
          "normalized": "PXETag SrcLoc XName[PXAttr](Maybe Pat)",
          "package": "haskell-src-exts",
          "partial": "PXETag",
          "signature": "PXETag SrcLoc XName[PXAttr](Maybe Pat)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PXETag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML embedded pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXPatTag",
          "package": "haskell-src-exts",
          "signature": "PXPatTag Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML embedded pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXPatTag",
          "package": "haskell-src-exts",
          "partial": "PXPat Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PXPatTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML PCDATA pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXPcdata",
          "package": "haskell-src-exts",
          "signature": "PXPcdata String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML PCDATA pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXPcdata",
          "package": "haskell-src-exts",
          "partial": "PXPcdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PXPcdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML regular list pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXRPats",
          "package": "haskell-src-exts",
          "signature": "PXRPats [RPat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML regular list pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXRPats",
          "normalized": "PXRPats[RPat]",
          "package": "haskell-src-exts",
          "partial": "PXRPats",
          "signature": "PXRPats[RPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PXRPats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eXML element pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXTag",
          "package": "haskell-src-exts",
          "signature": "PXTag SrcLoc XName [PXAttr] (Maybe Pat) [Pat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "XML element pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PXTag",
          "normalized": "PXTag SrcLoc XName[PXAttr](Maybe Pat)[Pat]",
          "package": "haskell-src-exts",
          "partial": "PXTag",
          "signature": "PXTag SrcLoc XName[PXAttr](Maybe Pat)[Pat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PXTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparallel list comprehension\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ParComp",
          "package": "haskell-src-exts",
          "signature": "ParComp Exp [[QualStmt]]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "parallel list comprehension",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ParComp",
          "normalized": "ParComp Exp[[QualStmt]]",
          "package": "haskell-src-exts",
          "partial": "Par Comp",
          "signature": "ParComp Exp[[QualStmt]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ParComp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesised expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Paren",
          "package": "haskell-src-exts",
          "signature": "Paren Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "parenthesised expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Paren",
          "package": "haskell-src-exts",
          "partial": "Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Paren"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesised expression splice: \u003ccode\u003e$(\u003cem\u003eexp\u003c/em\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ParenSplice",
          "package": "haskell-src-exts",
          "signature": "ParenSplice Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Splice",
          "type": "function"
        },
        "index": {
          "description": "parenthesised expression splice exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ParenSplice",
          "package": "haskell-src-exts",
          "partial": "Paren Splice",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ParenSplice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA pattern binding\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatBind",
          "package": "haskell-src-exts",
          "signature": "PatBind SrcLoc Pat (Maybe Type) Rhs Binds",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "pattern binding",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatBind",
          "package": "haskell-src-exts",
          "partial": "Pat Bind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PatBind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern bracket: \u003ccode\u003e[p| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatBracket",
          "package": "haskell-src-exts",
          "signature": "PatBracket Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "pattern bracket",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatBracket",
          "package": "haskell-src-exts",
          "partial": "Pat Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PatBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003epattern with type signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatTypeSig",
          "package": "haskell-src-exts",
          "signature": "PatTypeSig SrcLoc Pat Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Pat",
          "type": "function"
        },
        "index": {
          "description": "pattern with type signature",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PatTypeSig",
          "package": "haskell-src-exts",
          "partial": "Pat Type Sig",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PatTypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einterruptible\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PlayInterruptible",
          "package": "haskell-src-exts",
          "signature": "PlayInterruptible",
          "source": "src/Language-Haskell-Exts-Syntax.html#Safety",
          "type": "function"
        },
        "index": {
          "description": "interruptible",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PlayInterruptible",
          "package": "haskell-src-exts",
          "partial": "Play Interruptible",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PlayInterruptible"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunsafe\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PlayRisky",
          "package": "haskell-src-exts",
          "signature": "PlayRisky",
          "source": "src/Language-Haskell-Exts-Syntax.html#Safety",
          "type": "function"
        },
        "index": {
          "description": "unsafe",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PlayRisky",
          "package": "haskell-src-exts",
          "partial": "Play Risky",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PlayRisky"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esafe (\u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e) or threadsafe (\u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PlaySafe",
          "package": "haskell-src-exts",
          "signature": "PlaySafe Bool",
          "source": "src/Language-Haskell-Exts-Syntax.html#Safety",
          "type": "function"
        },
        "index": {
          "description": "safe False or threadsafe True",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PlaySafe",
          "package": "haskell-src-exts",
          "partial": "Play Safe",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PlaySafe"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed character literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimChar",
          "package": "haskell-src-exts",
          "signature": "PrimChar Char",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed character literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimChar",
          "package": "haskell-src-exts",
          "partial": "Prim Char",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PrimChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed double literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimDouble",
          "package": "haskell-src-exts",
          "signature": "PrimDouble Rational",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed double literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimDouble",
          "package": "haskell-src-exts",
          "partial": "Prim Double",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PrimDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed float literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimFloat",
          "package": "haskell-src-exts",
          "signature": "PrimFloat Rational",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed float literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimFloat",
          "package": "haskell-src-exts",
          "partial": "Prim Float",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PrimFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed integer literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimInt",
          "package": "haskell-src-exts",
          "signature": "PrimInt Integer",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed integer literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimInt",
          "package": "haskell-src-exts",
          "partial": "Prim Int",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PrimInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed string literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimString",
          "package": "haskell-src-exts",
          "signature": "PrimString String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed string literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimString",
          "package": "haskell-src-exts",
          "partial": "Prim String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PrimString"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed word literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimWord",
          "package": "haskell-src-exts",
          "signature": "PrimWord Integer",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "unboxed word literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "PrimWord",
          "package": "haskell-src-exts",
          "partial": "Prim Word",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:PrimWord"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrows proc: \u003ccode\u003eproc\u003c/code\u003e \u003cem\u003epat\u003c/em\u003e \u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Proc",
          "package": "haskell-src-exts",
          "signature": "Proc SrcLoc Pat Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "arrows proc proc pat exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Proc",
          "package": "haskell-src-exts",
          "partial": "Proc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Proc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003econstructor operator (\u003cem\u003eqconop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QConOp",
          "package": "haskell-src-exts",
          "signature": "QConOp QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#QOp",
          "type": "function"
        },
        "index": {
          "description": "constructor operator qconop",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QConOp",
          "package": "haskell-src-exts",
          "partial": "QCon Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:QConOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable operator (\u003cem\u003eqvarop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QVarOp",
          "package": "haskell-src-exts",
          "signature": "QVarOp QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#QOp",
          "type": "function"
        },
        "index": {
          "description": "variable operator qvarop",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QVarOp",
          "package": "haskell-src-exts",
          "partial": "QVar Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:QVarOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename qualified with a module name\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Qual",
          "package": "haskell-src-exts",
          "signature": "Qual ModuleName Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#QName",
          "type": "function"
        },
        "index": {
          "description": "name qualified with module name",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Qual",
          "package": "haskell-src-exts",
          "partial": "Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Qual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualConDecl",
          "package": "haskell-src-exts",
          "signature": "QualConDecl SrcLoc [TyVarBind] Context ConDecl",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualConDecl",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualConDecl",
          "normalized": "QualConDecl SrcLoc[TyVarBind]Context ConDecl",
          "package": "haskell-src-exts",
          "partial": "Qual Con Decl",
          "signature": "QualConDecl SrcLoc[TyVarBind]Context ConDecl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:QualConDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean ordinary statement\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "signature": "QualStmt Stmt",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "an ordinary statement",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QualStmt",
          "package": "haskell-src-exts",
          "partial": "Qual Stmt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:QualStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean \u003cem\u003eexp\u003c/em\u003e by itself: in a \u003ccode\u003edo\u003c/code\u003e-expression,\n   an action whose result is discarded;\n   in a list comprehension and pattern guard,\n   a guard expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Qualifier",
          "package": "haskell-src-exts",
          "signature": "Qualifier Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "an exp by itself in do expression an action whose result is discarded in list comprehension and pattern guard guard expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Qualifier",
          "package": "haskell-src-exts",
          "partial": "Qualifier",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Qualifier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equasi-quotaion: \u003ccode\u003e[$\u003cem\u003ename\u003c/em\u003e| \u003cem\u003estring\u003c/em\u003e |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QuasiQuote",
          "package": "haskell-src-exts",
          "signature": "QuasiQuote String String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "quasi-quotaion name string",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "QuasiQuote",
          "package": "haskell-src-exts",
          "partial": "Quasi Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:QuasiQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elinear variable binding, e.g. foo@(1 | 2)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPAs",
          "package": "haskell-src-exts",
          "signature": "RPAs Name RPat",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "linear variable binding e.g foo",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPAs",
          "package": "haskell-src-exts",
          "partial": "RPAs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-linear variable binding, e.g. (foo@:(1 | 2))*\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPCAs",
          "package": "haskell-src-exts",
          "signature": "RPCAs Name RPat",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "non-linear variable binding e.g foo",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPCAs",
          "package": "haskell-src-exts",
          "partial": "RPCAs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPCAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echoice pattern, e.g. (1 | 2)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPEither",
          "package": "haskell-src-exts",
          "signature": "RPEither RPat RPat",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "choice pattern e.g",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPEither",
          "package": "haskell-src-exts",
          "partial": "RPEither",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPEither"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eguarded pattern, e.g. (| p | p \u003c 3 |)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPGuard",
          "package": "haskell-src-exts",
          "signature": "RPGuard Pat [Stmt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "guarded pattern e.g",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPGuard",
          "normalized": "RPGuard Pat[Stmt]",
          "package": "haskell-src-exts",
          "partial": "RPGuard",
          "signature": "RPGuard Pat[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPGuard"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoperator pattern, e.g. pat*\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPOp",
          "package": "haskell-src-exts",
          "signature": "RPOp RPat RPatOp",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "operator pattern e.g pat",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPOp",
          "package": "haskell-src-exts",
          "partial": "RPOp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e?\u003c/code\u003e = 0 or 1\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPOpt",
          "package": "haskell-src-exts",
          "signature": "RPOpt",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPOpt",
          "package": "haskell-src-exts",
          "partial": "RPOpt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e?!\u003c/code\u003e = 0 or 1, greedy\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPOptG",
          "package": "haskell-src-exts",
          "signature": "RPOptG",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or greedy",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPOptG",
          "package": "haskell-src-exts",
          "partial": "RPOpt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPOptG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eparenthesised pattern, e.g. (2*)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPParen",
          "package": "haskell-src-exts",
          "signature": "RPParen RPat",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "parenthesised pattern e.g",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPParen",
          "package": "haskell-src-exts",
          "partial": "RPParen",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ean ordinary pattern\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPPat",
          "package": "haskell-src-exts",
          "signature": "RPPat Pat",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "an ordinary pattern",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPPat",
          "package": "haskell-src-exts",
          "partial": "RPPat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPPat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e+\u003c/code\u003e = 1 or more\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPPlus",
          "package": "haskell-src-exts",
          "signature": "RPPlus",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPPlus",
          "package": "haskell-src-exts",
          "partial": "RPPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPPlus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e+!\u003c/code\u003e = 1 or more, greedy\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPPlusG",
          "package": "haskell-src-exts",
          "signature": "RPPlusG",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more greedy",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPPlusG",
          "package": "haskell-src-exts",
          "partial": "RPPlus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPPlusG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003esequence pattern, e.g. (| 1, 2, 3 |)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPSeq",
          "package": "haskell-src-exts",
          "signature": "RPSeq [RPat]",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPat",
          "type": "function"
        },
        "index": {
          "description": "sequence pattern e.g",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPSeq",
          "normalized": "RPSeq[RPat]",
          "package": "haskell-src-exts",
          "partial": "RPSeq",
          "signature": "RPSeq[RPat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPSeq"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e*\u003c/code\u003e = 0 or more\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPStar",
          "package": "haskell-src-exts",
          "signature": "RPStar",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPStar",
          "package": "haskell-src-exts",
          "partial": "RPStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPStar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e*!\u003c/code\u003e = 0 or more, greedy\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPStarG",
          "package": "haskell-src-exts",
          "signature": "RPStarG",
          "source": "src/Language-Haskell-Exts-Syntax.html#RPatOp",
          "type": "function"
        },
        "index": {
          "description": "or more greedy",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RPStarG",
          "package": "haskell-src-exts",
          "partial": "RPStar",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RPStarG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord construction expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecConstr",
          "package": "haskell-src-exts",
          "signature": "RecConstr QName [FieldUpdate]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "record construction expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecConstr",
          "normalized": "RecConstr QName[FieldUpdate]",
          "package": "haskell-src-exts",
          "partial": "Rec Constr",
          "signature": "RecConstr QName[FieldUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RecConstr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecDecl",
          "package": "haskell-src-exts",
          "signature": "RecDecl Name [([Name], BangType)]",
          "source": "src/Language-Haskell-Exts-Syntax.html#ConDecl",
          "type": "function"
        },
        "index": {
          "description": "record constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecDecl",
          "normalized": "RecDecl Name[([Name],BangType)]",
          "package": "haskell-src-exts",
          "partial": "Rec Decl",
          "signature": "RecDecl Name[([Name],BangType)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RecDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ea recursive binding group for arrows\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecStmt",
          "package": "haskell-src-exts",
          "signature": "RecStmt [Stmt]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Stmt",
          "type": "function"
        },
        "index": {
          "description": "recursive binding group for arrows",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecStmt",
          "normalized": "RecStmt[Stmt]",
          "package": "haskell-src-exts",
          "partial": "Rec Stmt",
          "signature": "RecStmt[Stmt]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RecStmt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003erecord update expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecUpdate",
          "package": "haskell-src-exts",
          "signature": "RecUpdate Exp [FieldUpdate]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "record update expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RecUpdate",
          "normalized": "RecUpdate Exp[FieldUpdate]",
          "package": "haskell-src-exts",
          "partial": "Rec Update",
          "signature": "RecUpdate Exp[FieldUpdate]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RecUpdate"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003earrow application (from right): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e\u003e-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RightArrApp",
          "package": "haskell-src-exts",
          "signature": "RightArrApp Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "arrow application from right exp exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RightArrApp",
          "package": "haskell-src-exts",
          "partial": "Right Arr App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RightArrApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ehigher-order arrow application (from right): \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003e\u003e\u003e-\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RightArrHighApp",
          "package": "haskell-src-exts",
          "signature": "RightArrHighApp Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "higher-order arrow application from right exp exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RightArrHighApp",
          "package": "haskell-src-exts",
          "partial": "Right Arr High App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RightArrHighApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eright section \u003ccode\u003e(\u003c/code\u003e\u003cem\u003eqop\u003c/em\u003e \u003cem\u003eexp\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RightSection",
          "package": "haskell-src-exts",
          "signature": "RightSection QOp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "right section qop exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RightSection",
          "package": "haskell-src-exts",
          "partial": "Right Section",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RightSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Rule",
          "package": "haskell-src-exts",
          "signature": "Rule String Activation (Maybe [RuleVar]) Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Rule",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Rule",
          "normalized": "Rule String Activation(Maybe[RuleVar])Exp Exp",
          "package": "haskell-src-exts",
          "partial": "Rule",
          "signature": "Rule String Activation(Maybe[RuleVar])Exp Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Rule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA RULES pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RulePragmaDecl",
          "package": "haskell-src-exts",
          "signature": "RulePragmaDecl SrcLoc [Rule]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "RULES pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RulePragmaDecl",
          "normalized": "RulePragmaDecl SrcLoc[Rule]",
          "package": "haskell-src-exts",
          "partial": "Rule Pragma Decl",
          "signature": "RulePragmaDecl SrcLoc[Rule]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RulePragmaDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "signature": "RuleVar Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#RuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "RuleVar",
          "package": "haskell-src-exts",
          "partial": "Rule Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:RuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSCC pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SCCPragma",
          "package": "haskell-src-exts",
          "signature": "SCCPragma String Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "SCC pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SCCPragma",
          "package": "haskell-src-exts",
          "partial": "SCCPragma",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:SCCPragma"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SPECIALISE INLINE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpecInlineSig",
          "package": "haskell-src-exts",
          "signature": "SpecInlineSig SrcLoc Bool Activation QName [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "SPECIALISE INLINE pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpecInlineSig",
          "normalized": "SpecInlineSig SrcLoc Bool Activation QName[Type]",
          "package": "haskell-src-exts",
          "partial": "Spec Inline Sig",
          "signature": "SpecInlineSig SrcLoc Bool Activation QName[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:SpecInlineSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA SPECIALISE pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpecSig",
          "package": "haskell-src-exts",
          "signature": "SpecSig SrcLoc Activation QName [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "SPECIALISE pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpecSig",
          "normalized": "SpecSig SrcLoc Activation QName[Type]",
          "package": "haskell-src-exts",
          "partial": "Spec Sig",
          "signature": "SpecSig SrcLoc Activation QName[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:SpecSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebuilt-in constructor with special syntax\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Special",
          "package": "haskell-src-exts",
          "signature": "Special SpecialCon",
          "source": "src/Language-Haskell-Exts-Syntax.html#QName",
          "type": "function"
        },
        "index": {
          "description": "built-in constructor with special syntax",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Special",
          "package": "haskell-src-exts",
          "partial": "Special",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Special"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Template Haskell splicing declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpliceDecl",
          "package": "haskell-src-exts",
          "signature": "SpliceDecl SrcLoc Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "Template Haskell splicing declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpliceDecl",
          "package": "haskell-src-exts",
          "partial": "Splice Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:SpliceDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etemplate haskell splice expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpliceExp",
          "package": "haskell-src-exts",
          "signature": "SpliceExp Splice",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "template haskell splice expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "SpliceExp",
          "package": "haskell-src-exts",
          "partial": "Splice Exp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:SpliceExp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "StdCall",
          "package": "haskell-src-exts",
          "signature": "StdCall",
          "source": "src/Language-Haskell-Exts-Syntax.html#CallConv",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "StdCall",
          "package": "haskell-src-exts",
          "partial": "Std Call",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:StdCall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003estring literal\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "String",
          "package": "haskell-src-exts",
          "signature": "String String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Literal",
          "type": "function"
        },
        "index": {
          "description": "string literal",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "String",
          "package": "haskell-src-exts",
          "partial": "String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:String"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003evarsym\u003c/em\u003e or \u003cem\u003econsym\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Symbol",
          "package": "haskell-src-exts",
          "signature": "Symbol String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Name",
          "type": "function"
        },
        "index": {
          "description": "varsym or consym",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Symbol",
          "package": "haskell-src-exts",
          "partial": "Symbol",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Symbol"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e \u003ccode\u003eby\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ThenBy",
          "package": "haskell-src-exts",
          "signature": "ThenBy Exp Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then exp by exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ThenBy",
          "package": "haskell-src-exts",
          "partial": "Then By",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ThenBy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ThenTrans",
          "package": "haskell-src-exts",
          "signature": "ThenTrans Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#QualStmt",
          "type": "function"
        },
        "index": {
          "description": "then exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ThenTrans",
          "package": "haskell-src-exts",
          "partial": "Then Trans",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ThenTrans"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple expression\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Tuple",
          "package": "haskell-src-exts",
          "signature": "Tuple Boxed [Exp]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "tuple expression",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Tuple",
          "normalized": "Tuple Boxed[Exp]",
          "package": "haskell-src-exts",
          "partial": "Tuple",
          "signature": "Tuple Boxed[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Tuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003cem\u003en\u003c/em\u003e-ary tuple type and data\n   constructors \u003ccode\u003e(,)\u003c/code\u003e etc, possibly boxed \u003ccode\u003e(#,#)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TupleCon",
          "package": "haskell-src-exts",
          "signature": "TupleCon Boxed Int",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "ary tuple type and data constructors etc possibly boxed",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TupleCon",
          "package": "haskell-src-exts",
          "partial": "Tuple Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TupleCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple section expression, e.g. \u003ccode\u003e(,,3)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TupleSection",
          "package": "haskell-src-exts",
          "signature": "TupleSection Boxed [Maybe Exp]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "tuple section expression e.g",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TupleSection",
          "normalized": "TupleSection Boxed[Maybe Exp]",
          "package": "haskell-src-exts",
          "partial": "Tuple Section",
          "signature": "TupleSection Boxed[Maybe Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TupleSection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eapplication of a type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyApp",
          "package": "haskell-src-exts",
          "signature": "TyApp Type Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "application of type constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyApp",
          "package": "haskell-src-exts",
          "partial": "Ty App",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyApp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enamed type or type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyCon",
          "package": "haskell-src-exts",
          "signature": "TyCon QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "named type or type constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyCon",
          "package": "haskell-src-exts",
          "partial": "Ty Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003equalified type\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyForall",
          "package": "haskell-src-exts",
          "signature": "TyForall (Maybe [TyVarBind]) Context Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "qualified type",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyForall",
          "normalized": "TyForall(Maybe[TyVarBind])Context Type",
          "package": "haskell-src-exts",
          "partial": "Ty Forall",
          "signature": "TyForall(Maybe[TyVarBind])Context Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyForall"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003efunction type\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyFun",
          "package": "haskell-src-exts",
          "signature": "TyFun Type Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "function type",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyFun",
          "package": "haskell-src-exts",
          "partial": "Ty Fun",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyFun"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003einfix type constructor\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyInfix",
          "package": "haskell-src-exts",
          "signature": "TyInfix Type QName Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "infix type constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyInfix",
          "package": "haskell-src-exts",
          "partial": "Ty Infix",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyInfix"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype with explicit kind signature\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyKind",
          "package": "haskell-src-exts",
          "signature": "TyKind Type Kind",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "type with explicit kind signature",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyKind",
          "package": "haskell-src-exts",
          "partial": "Ty Kind",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyKind"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003elist syntax, e.g. [a], as opposed to [] a\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyList",
          "package": "haskell-src-exts",
          "signature": "TyList Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "list syntax e.g as opposed to",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyList",
          "package": "haskell-src-exts",
          "partial": "Ty List",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype surrounded by parentheses\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyParen",
          "package": "haskell-src-exts",
          "signature": "TyParen Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "type surrounded by parentheses",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyParen",
          "package": "haskell-src-exts",
          "partial": "Ty Paren",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyParen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etuple type, possibly boxed\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyTuple",
          "package": "haskell-src-exts",
          "signature": "TyTuple Boxed [Type]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "tuple type possibly boxed",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyTuple",
          "normalized": "TyTuple Boxed[Type]",
          "package": "haskell-src-exts",
          "partial": "Ty Tuple",
          "signature": "TyTuple Boxed[Type]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyTuple"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype variable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyVar",
          "package": "haskell-src-exts",
          "signature": "TyVar Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#Type",
          "type": "function"
        },
        "index": {
          "description": "type variable",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TyVar",
          "package": "haskell-src-exts",
          "partial": "Ty Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TyVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e''T\u003c/code\u003e for template haskell reifying of types\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypQuote",
          "package": "haskell-src-exts",
          "signature": "TypQuote QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "for template haskell reifying of types",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypQuote",
          "package": "haskell-src-exts",
          "partial": "Typ Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAn annotation for a declared type.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeAnn",
          "package": "haskell-src-exts",
          "signature": "TypeAnn Name Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Annotation",
          "type": "function"
        },
        "index": {
          "description": "An annotation for declared type",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeAnn",
          "package": "haskell-src-exts",
          "partial": "Type Ann",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypeAnn"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003etype bracket: \u003ccode\u003e[t| ... |]\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeBracket",
          "package": "haskell-src-exts",
          "signature": "TypeBracket Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Bracket",
          "type": "function"
        },
        "index": {
          "description": "type bracket",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeBracket",
          "package": "haskell-src-exts",
          "partial": "Type Bracket",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypeBracket"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeDecl",
          "package": "haskell-src-exts",
          "signature": "TypeDecl SrcLoc Name [TyVarBind] Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeDecl",
          "normalized": "TypeDecl SrcLoc Name[TyVarBind]Type",
          "package": "haskell-src-exts",
          "partial": "Type Decl",
          "signature": "TypeDecl SrcLoc Name[TyVarBind]Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypeDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type family declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeFamDecl",
          "package": "haskell-src-exts",
          "signature": "TypeFamDecl SrcLoc Name [TyVarBind] (Maybe Kind)",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type family declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeFamDecl",
          "normalized": "TypeFamDecl SrcLoc Name[TyVarBind](Maybe Kind)",
          "package": "haskell-src-exts",
          "partial": "Type Fam Decl",
          "signature": "TypeFamDecl SrcLoc Name[TyVarBind](Maybe Kind)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypeFamDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type family instance declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeInsDecl",
          "package": "haskell-src-exts",
          "signature": "TypeInsDecl SrcLoc Type Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type family instance declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeInsDecl",
          "package": "haskell-src-exts",
          "partial": "Type Ins Decl",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypeInsDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA type signature declaration\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeSig",
          "package": "haskell-src-exts",
          "signature": "TypeSig SrcLoc [Name] Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "type signature declaration",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypeSig",
          "normalized": "TypeSig SrcLoc[Name]Type",
          "package": "haskell-src-exts",
          "partial": "Type Sig",
          "signature": "TypeSig SrcLoc[Name]Type",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypeSig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypedRuleVar",
          "package": "haskell-src-exts",
          "signature": "TypedRuleVar Name Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#RuleVar",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "TypedRuleVar",
          "package": "haskell-src-exts",
          "partial": "Typed Rule Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:TypedRuleVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-strict component\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnBangedTy",
          "package": "haskell-src-exts",
          "signature": "UnBangedTy Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#BangType",
          "type": "function"
        },
        "index": {
          "description": "non-strict component",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnBangedTy",
          "package": "haskell-src-exts",
          "partial": "Un Banged Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnBangedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e-\u003e\u003c/code\u003e \u003cem\u003eexp\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnGuardedAlt",
          "package": "haskell-src-exts",
          "signature": "UnGuardedAlt Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#GuardedAlts",
          "type": "function"
        },
        "index": {
          "description": "exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnGuardedAlt",
          "package": "haskell-src-exts",
          "partial": "Un Guarded Alt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnGuardedAlt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunguarded right hand side (\u003cem\u003eexp\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnGuardedRhs",
          "package": "haskell-src-exts",
          "signature": "UnGuardedRhs Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Rhs",
          "type": "function"
        },
        "index": {
          "description": "unguarded right hand side exp",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnGuardedRhs",
          "package": "haskell-src-exts",
          "partial": "Un Guarded Rhs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnGuardedRhs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunqualified local name\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnQual",
          "package": "haskell-src-exts",
          "signature": "UnQual Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#QName",
          "type": "function"
        },
        "index": {
          "description": "unqualified local name",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnQual",
          "package": "haskell-src-exts",
          "partial": "Un Qual",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnQual"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed singleton tuple constructor \u003ccode\u003e(# #)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnboxedSingleCon",
          "package": "haskell-src-exts",
          "signature": "UnboxedSingleCon",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "unboxed singleton tuple constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnboxedSingleCon",
          "package": "haskell-src-exts",
          "partial": "Unboxed Single Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnboxedSingleCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunit type and data constructor \u003ccode\u003e()\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnitCon",
          "package": "haskell-src-exts",
          "signature": "UnitCon",
          "source": "src/Language-Haskell-Exts-Syntax.html#SpecialCon",
          "type": "function"
        },
        "index": {
          "description": "unit type and data constructor",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnitCon",
          "package": "haskell-src-exts",
          "partial": "Unit Con",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnitCon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eordinary variable binding\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnkindedVar",
          "package": "haskell-src-exts",
          "signature": "UnkindedVar Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#TyVarBind",
          "type": "function"
        },
        "index": {
          "description": "ordinary variable binding",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnkindedVar",
          "package": "haskell-src-exts",
          "partial": "Unkinded Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnkindedVar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eunboxed component, marked with an UNPACK pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnpackedTy",
          "package": "haskell-src-exts",
          "signature": "UnpackedTy Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#BangType",
          "type": "function"
        },
        "index": {
          "description": "unboxed component marked with an UNPACK pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "UnpackedTy",
          "package": "haskell-src-exts",
          "partial": "Unpacked Ty",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:UnpackedTy"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Var",
          "package": "haskell-src-exts",
          "signature": "Var QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "variable",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "Var",
          "package": "haskell-src-exts",
          "partial": "Var",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:Var"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of a method or field\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "VarName",
          "package": "haskell-src-exts",
          "signature": "VarName Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#CName",
          "type": "function"
        },
        "index": {
          "description": "name of method or field",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "VarName",
          "package": "haskell-src-exts",
          "partial": "Var Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:VarName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003evariable operator (\u003cem\u003evarop\u003c/em\u003e)\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "VarOp",
          "package": "haskell-src-exts",
          "signature": "VarOp Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#Op",
          "type": "function"
        },
        "index": {
          "description": "variable operator varop",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "VarOp",
          "package": "haskell-src-exts",
          "partial": "Var Op",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:VarOp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e'x\u003c/code\u003e for template haskell reifying of expressions\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "VarQuote",
          "package": "haskell-src-exts",
          "signature": "VarQuote QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "for template haskell reifying of expressions",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "VarQuote",
          "package": "haskell-src-exts",
          "partial": "Var Quote",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:VarQuote"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA WARNING pragma\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "WarnPragmaDecl",
          "package": "haskell-src-exts",
          "signature": "WarnPragmaDecl SrcLoc [([Name], String)]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Decl",
          "type": "function"
        },
        "index": {
          "description": "WARNING pragma",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "WarnPragmaDecl",
          "normalized": "WarnPragmaDecl SrcLoc[([Name],String)]",
          "package": "haskell-src-exts",
          "partial": "Warn Pragma Decl",
          "signature": "WarnPragmaDecl SrcLoc[([Name],String)]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:WarnPragmaDecl"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "WarnText",
          "package": "haskell-src-exts",
          "signature": "WarnText String",
          "source": "src/Language-Haskell-Exts-Syntax.html#WarningText",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "WarnText",
          "package": "haskell-src-exts",
          "partial": "Warn Text",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:WarnText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "signature": "XAttr XName Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#XAttr",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XAttr",
          "package": "haskell-src-exts",
          "partial": "XAttr",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XAttr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003echildren of an xml element\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XChildTag",
          "package": "haskell-src-exts",
          "signature": "XChildTag SrcLoc [Exp]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "children of an xml element",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XChildTag",
          "normalized": "XChildTag SrcLoc[Exp]",
          "package": "haskell-src-exts",
          "partial": "XChild Tag",
          "signature": "XChildTag SrcLoc[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XChildTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XDomName",
          "package": "haskell-src-exts",
          "signature": "XDomName String String",
          "source": "src/Language-Haskell-Exts-Syntax.html#XName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XDomName",
          "package": "haskell-src-exts",
          "partial": "XDom Name",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XDomName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eempty xml element, with attributes\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XETag",
          "package": "haskell-src-exts",
          "signature": "XETag SrcLoc XName [XAttr] (Maybe Exp)",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "empty xml element with attributes",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XETag",
          "normalized": "XETag SrcLoc XName[XAttr](Maybe Exp)",
          "package": "haskell-src-exts",
          "partial": "XETag",
          "signature": "XETag SrcLoc XName[XAttr](Maybe Exp)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XETag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eescaped haskell expression inside xml\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XExpTag",
          "package": "haskell-src-exts",
          "signature": "XExpTag Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "escaped haskell expression inside xml",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XExpTag",
          "package": "haskell-src-exts",
          "partial": "XExp Tag",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XExpTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "signature": "XName String",
          "source": "src/Language-Haskell-Exts-Syntax.html#XName",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XName",
          "package": "haskell-src-exts",
          "partial": "XName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePCDATA child element\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XPcdata",
          "package": "haskell-src-exts",
          "signature": "XPcdata String",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "PCDATA child element",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XPcdata",
          "package": "haskell-src-exts",
          "partial": "XPcdata",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XPcdata"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003exml element, with attributes and children\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XTag",
          "package": "haskell-src-exts",
          "signature": "XTag SrcLoc XName [XAttr] (Maybe Exp) [Exp]",
          "source": "src/Language-Haskell-Exts-Syntax.html#Exp",
          "type": "function"
        },
        "index": {
          "description": "xml element with attributes and children",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "XTag",
          "normalized": "XTag SrcLoc XName[XAttr](Maybe Exp)[Exp]",
          "package": "haskell-src-exts",
          "partial": "XTag",
          "signature": "XTag SrcLoc XName[XAttr](Maybe Exp)[Exp]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:XTag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "as_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#as_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "as_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:as_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "bang_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#bang_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "bang_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:bang_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ccall_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#ccall_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "ccall_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:ccall_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "cplusplus_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#cplusplus_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "cplusplus_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:cplusplus_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "dot_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#dot_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "dot_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:dot_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "dotnet_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#dotnet_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "dotnet_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:dotnet_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "export_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#export_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "export_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:export_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "family_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#family_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "family_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:family_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "forall_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#forall_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "forall_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:forall_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "fun_tycon",
          "package": "haskell-src-exts",
          "signature": "Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#fun_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "fun_tycon",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:fun_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "fun_tycon_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#fun_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "fun_tycon_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:fun_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "hiding_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#hiding_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "hiding_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:hiding_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional alias name in an \u003ccode\u003eas\u003c/code\u003e clause.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importAs",
          "package": "haskell-src-exts",
          "signature": "Maybe ModuleName",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "optional alias name in an as clause",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importAs",
          "package": "haskell-src-exts",
          "partial": "As",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importAs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eposition of the \u003ccode\u003eimport\u003c/code\u003e keyword.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importLoc",
          "package": "haskell-src-exts",
          "signature": "SrcLoc",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "position of the import keyword",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importLoc",
          "package": "haskell-src-exts",
          "partial": "Loc",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importLoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ename of the module imported.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importModule",
          "package": "haskell-src-exts",
          "signature": "ModuleName",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "name of the module imported",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importModule",
          "package": "haskell-src-exts",
          "partial": "Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importModule"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported with explicit package name\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importPkg",
          "package": "haskell-src-exts",
          "signature": "Maybe String",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported with explicit package name",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importPkg",
          "package": "haskell-src-exts",
          "partial": "Pkg",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importPkg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported \u003ccode\u003equalified\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importQualified",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported qualified",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importQualified",
          "package": "haskell-src-exts",
          "partial": "Qualified",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importQualified"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eoptional list of import specifications.\n The \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the names are excluded\n by \u003ccode\u003ehiding\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importSpecs",
          "package": "haskell-src-exts",
          "signature": "Maybe (Bool, [ImportSpec])",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "optional list of import specifications The Bool is True if the names are excluded by hiding",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importSpecs",
          "normalized": "Maybe(Bool,[ImportSpec])",
          "package": "haskell-src-exts",
          "partial": "Specs",
          "signature": "Maybe(Bool,[ImportSpec])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importSpecs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eimported with \u003ccode\u003e{-# SOURCE #-}\u003c/code\u003e?\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importSrc",
          "package": "haskell-src-exts",
          "signature": "Bool",
          "source": "src/Language-Haskell-Exts-Syntax.html#ImportDecl",
          "type": "function"
        },
        "index": {
          "description": "imported with SOURCE",
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "importSrc",
          "package": "haskell-src-exts",
          "partial": "Src",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:importSrc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "js_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#js_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "js_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:js_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "jvm_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#jvm_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "jvm_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:jvm_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "list_cons_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#list_cons_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "list_cons_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:list_cons_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "list_tycon",
          "package": "haskell-src-exts",
          "signature": "Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#list_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "list_tycon",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:list_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "list_tycon_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#list_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "list_tycon_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:list_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "main_mod",
          "package": "haskell-src-exts",
          "signature": "ModuleName",
          "source": "src/Language-Haskell-Exts-Syntax.html#main_mod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "main_mod",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:main_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "main_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#main_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "main_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:main_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "minus_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#minus_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "minus_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:minus_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "prelude_mod",
          "package": "haskell-src-exts",
          "signature": "ModuleName",
          "source": "src/Language-Haskell-Exts-Syntax.html#prelude_mod",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "prelude_mod",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:prelude_mod"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "qualified_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#qualified_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "qualified_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:qualified_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "safe_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#safe_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "safe_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:safe_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "star_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#star_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "star_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:star_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "stdcall_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#stdcall_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "stdcall_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:stdcall_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "threadsafe_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#threadsafe_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "threadsafe_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:threadsafe_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_con",
          "package": "haskell-src-exts",
          "signature": "Boxed -\u003e Int -\u003e Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#tuple_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_con",
          "normalized": "Boxed-\u003eInt-\u003eExp",
          "package": "haskell-src-exts",
          "signature": "Boxed-\u003eInt-\u003eExp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:tuple_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_con_name",
          "package": "haskell-src-exts",
          "signature": "Boxed -\u003e Int -\u003e QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#tuple_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_con_name",
          "normalized": "Boxed-\u003eInt-\u003eQName",
          "package": "haskell-src-exts",
          "signature": "Boxed-\u003eInt-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:tuple_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_tycon",
          "package": "haskell-src-exts",
          "signature": "Boxed -\u003e Int -\u003e Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#tuple_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_tycon",
          "normalized": "Boxed-\u003eInt-\u003eType",
          "package": "haskell-src-exts",
          "signature": "Boxed-\u003eInt-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:tuple_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_tycon_name",
          "package": "haskell-src-exts",
          "signature": "Boxed -\u003e Int -\u003e QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#tuple_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "tuple_tycon_name",
          "normalized": "Boxed-\u003eInt-\u003eQName",
          "package": "haskell-src-exts",
          "signature": "Boxed-\u003eInt-\u003eQName",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:tuple_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_con",
          "package": "haskell-src-exts",
          "signature": "Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#unboxed_singleton_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_con",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unboxed_singleton_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_con_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#unboxed_singleton_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_con_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unboxed_singleton_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_tycon",
          "package": "haskell-src-exts",
          "signature": "Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#unboxed_singleton_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_tycon",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unboxed_singleton_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_tycon_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#unboxed_singleton_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unboxed_singleton_tycon_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unboxed_singleton_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_con",
          "package": "haskell-src-exts",
          "signature": "Exp",
          "source": "src/Language-Haskell-Exts-Syntax.html#unit_con",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_con",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unit_con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_con_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#unit_con_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_con_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unit_con_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_tycon",
          "package": "haskell-src-exts",
          "signature": "Type",
          "source": "src/Language-Haskell-Exts-Syntax.html#unit_tycon",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_tycon",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unit_tycon"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_tycon_name",
          "package": "haskell-src-exts",
          "signature": "QName",
          "source": "src/Language-Haskell-Exts-Syntax.html#unit_tycon_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unit_tycon_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unit_tycon_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unsafe_name",
          "package": "haskell-src-exts",
          "signature": "Name",
          "source": "src/Language-Haskell-Exts-Syntax.html#unsafe_name",
          "type": "function"
        },
        "index": {
          "hierarchy": "Language Haskell Exts Syntax",
          "module": "Language.Haskell.Exts.Syntax",
          "name": "unsafe_name",
          "package": "haskell-src-exts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts-Syntax.html#v:unsafe_name"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eAn umbrella module for the various functionality\n of the package. Also provides some convenient\n functionality for dealing directly with source files.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Language.Haskell.Exts",
          "name": "Exts",
          "package": "haskell-src-exts",
          "source": "src/Language-Haskell-Exts.html",
          "type": "module"
        },
        "index": {
          "description": "An umbrella module for the various functionality of the package Also provides some convenient functionality for dealing directly with source files",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "Exts",
          "package": "haskell-src-exts",
          "partial": "Exts",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, using the default parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFile",
          "package": "haskell-src-exts",
          "signature": "FilePath -\u003e IO (ParseResult Module)",
          "source": "src/Language-Haskell-Exts.html#parseFile",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk using the default parse mode",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFile",
          "normalized": "FilePath-\u003eIO(ParseResult Module)",
          "package": "haskell-src-exts",
          "partial": "File",
          "signature": "FilePath-\u003eIO(ParseResult Module)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string using the default parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContents",
          "package": "haskell-src-exts",
          "signature": "String -\u003e ParseResult Module",
          "source": "src/Language-Haskell-Exts.html#parseFileContents",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string using the default parse mode",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContents",
          "normalized": "String-\u003eParseResult Module",
          "package": "haskell-src-exts",
          "partial": "File Contents",
          "signature": "String-\u003eParseResult Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileContents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string using a custom parse mode and retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContentsWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult (Module, [Comment])",
          "source": "src/Language-Haskell-Exts.html#parseFileContentsWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string using custom parse mode and retaining comments",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContentsWithComments",
          "normalized": "ParseMode-\u003eString-\u003eParseResult(Module,[Comment])",
          "package": "haskell-src-exts",
          "partial": "File Contents With Comments",
          "signature": "ParseMode-\u003eString-\u003eParseResult(Module,[Comment])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileContentsWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string, with an extra set of extensions to know about\n   on top of what the file itself declares.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContentsWithExts",
          "package": "haskell-src-exts",
          "signature": "[Extension] -\u003e String -\u003e ParseResult Module",
          "source": "src/Language-Haskell-Exts.html#parseFileContentsWithExts",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string with an extra set of extensions to know about on top of what the file itself declares",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContentsWithExts",
          "normalized": "[Extension]-\u003eString-\u003eParseResult Module",
          "package": "haskell-src-exts",
          "partial": "File Contents With Exts",
          "signature": "[Extension]-\u003eString-\u003eParseResult Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileContentsWithExts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file from a string using a custom parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContentsWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e String -\u003e ParseResult Module",
          "source": "src/Language-Haskell-Exts.html#parseFileContentsWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse source file from string using custom parse mode",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileContentsWithMode",
          "normalized": "ParseMode-\u003eString-\u003eParseResult Module",
          "package": "haskell-src-exts",
          "partial": "File Contents With Mode",
          "signature": "ParseMode-\u003eString-\u003eParseResult Module",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileContentsWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, supplying a custom parse mode, and retaining comments.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileWithComments",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e FilePath -\u003e IO (ParseResult (Module, [Comment]))",
          "source": "src/Language-Haskell-Exts.html#parseFileWithComments",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk supplying custom parse mode and retaining comments",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileWithComments",
          "normalized": "ParseMode-\u003eFilePath-\u003eIO(ParseResult(Module,[Comment]))",
          "package": "haskell-src-exts",
          "partial": "File With Comments",
          "signature": "ParseMode-\u003eFilePath-\u003eIO(ParseResult(Module,[Comment]))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileWithComments"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, with an extra set of extensions to know about\n   on top of what the file itself declares.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileWithExts",
          "package": "haskell-src-exts",
          "signature": "[Extension] -\u003e FilePath -\u003e IO (ParseResult Module)",
          "source": "src/Language-Haskell-Exts.html#parseFileWithExts",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk with an extra set of extensions to know about on top of what the file itself declares",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileWithExts",
          "normalized": "[Extension]-\u003eFilePath-\u003eIO(ParseResult Module)",
          "package": "haskell-src-exts",
          "partial": "File With Exts",
          "signature": "[Extension]-\u003eFilePath-\u003eIO(ParseResult Module)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileWithExts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eParse a source file on disk, supplying a custom parse mode.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "parseFileWithMode",
          "package": "haskell-src-exts",
          "signature": "ParseMode -\u003e FilePath -\u003e IO (ParseResult Module)",
          "source": "src/Language-Haskell-Exts.html#parseFileWithMode",
          "type": "function"
        },
        "index": {
          "description": "Parse source file on disk supplying custom parse mode",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "parseFileWithMode",
          "normalized": "ParseMode-\u003eFilePath-\u003eIO(ParseResult Module)",
          "package": "haskell-src-exts",
          "partial": "File With Mode",
          "signature": "ParseMode-\u003eFilePath-\u003eIO(ParseResult Module)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:parseFileWithMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGather the extensions declared in LANGUAGE pragmas\n   at the top of the file. Returns \u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e if the\n   parse of the pragmas fails.\n\u003c/p\u003e",
          "module": "Language.Haskell.Exts",
          "name": "readExtensions",
          "package": "haskell-src-exts",
          "signature": "String -\u003e Maybe (Maybe Language, [Extension])",
          "source": "src/Language-Haskell-Exts.html#readExtensions",
          "type": "function"
        },
        "index": {
          "description": "Gather the extensions declared in LANGUAGE pragmas at the top of the file Returns Nothing if the parse of the pragmas fails",
          "hierarchy": "Language Haskell Exts",
          "module": "Language.Haskell.Exts",
          "name": "readExtensions",
          "normalized": "String-\u003eMaybe(Maybe Language,[Extension])",
          "package": "haskell-src-exts",
          "partial": "Extensions",
          "signature": "String-\u003eMaybe(Maybe Language,[Extension])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/haskell-src-exts/docs/Language-Haskell-Exts.html#v:readExtensions"
      }
    }
  ]
]