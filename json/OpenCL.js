[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "OpenCL"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CommandQueue",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CommandQueue",
          "package": "OpenCL",
          "partial": "Command Queue",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CLCommandQueue",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandQueue",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CLCommandQueue",
          "package": "OpenCL",
          "partial": "CLCommand Queue",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#t:CLCommandQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e, Determines whether the commands \nqueued in the command-queue are executed in-order or out-of-order. If set, the \ncommands in the command-queue are executed out-of-order. Otherwise, commands are \nexecuted in-order.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_QUEUE_PROFILING_ENABLE\u003c/a\u003e\u003c/code\u003e, Enable or disable profiling of commands in the \ncommand-queue. If set, the profiling of commands is enabled. Otherwise profiling \nof commands is disabled. See \u003ccode\u003eclGetEventProfilingInfo\u003c/code\u003e for more information.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CLCommandQueueProperty",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandQueueProperty",
          "type": "data"
        },
        "index": {
          "description": "CL QUEUE OUT OF ORDER EXEC MODE ENABLE Determines whether the commands queued in the command-queue are executed in-order or out-of-order If set the commands in the command-queue are executed out-of-order Otherwise commands are executed in-order CL QUEUE PROFILING ENABLE Enable or disable profiling of commands in the command-queue If set the profiling of commands is enabled Otherwise profiling of commands is disabled See clGetEventProfilingInfo for more information",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CLCommandQueueProperty",
          "package": "OpenCL",
          "partial": "CLCommand Queue Property",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#t:CLCommandQueueProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CLMapFlag",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMapFlag",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CLMapFlag",
          "package": "OpenCL",
          "partial": "CLMap Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#t:CLMapFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_MAP_READ",
          "package": "OpenCL",
          "signature": "CL_MAP_READ",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMapFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_MAP_READ",
          "package": "OpenCL",
          "partial": "CL MAP READ",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:CL_MAP_READ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_MAP_WRITE",
          "package": "OpenCL",
          "signature": "CL_MAP_WRITE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMapFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_MAP_WRITE",
          "package": "OpenCL",
          "partial": "CL MAP WRITE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:CL_MAP_WRITE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE",
          "package": "OpenCL",
          "signature": "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandQueueProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE",
          "package": "OpenCL",
          "partial": "CL QUEUE OUT OF ORDER EXEC MODE ENABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_QUEUE_PROFILING_ENABLE",
          "package": "OpenCL",
          "signature": "CL_QUEUE_PROFILING_ENABLE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandQueueProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "CL_QUEUE_PROFILING_ENABLE",
          "package": "OpenCL",
          "partial": "CL QUEUE PROFILING ENABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:CL_QUEUE_PROFILING_ENABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate a command-queue on a specific device.\n\u003c/p\u003e\u003cp\u003eThe OpenCL functions that are submitted to a command-queue are enqueued in the \norder the calls are made but can be configured to execute in-order or \nout-of-order. The properties argument in clCreateCommandQueue can be used to \nspecify the execution order.\n\u003c/p\u003e\u003cp\u003eIf the \u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e property of a command-queue is \nnot set, the commands enqueued to a command-queue execute in order. For example, \nif an application calls \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e to execute kernel A followed by \na \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e to execute kernel B, the application can assume that \nkernel A finishes first and then kernel B is executed. If the memory objects \noutput by kernel A are inputs to kernel B then kernel B will see the correct \ndata in memory objects produced by execution of kernel A. If the \n\u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e property of a commandqueue is set, then \nthere is no guarantee that kernel A will finish before kernel B starts execution.\n\u003c/p\u003e\u003cp\u003eApplications can configure the commands enqueued to a command-queue to execute \nout-of-order by setting the \u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e property of \nthe command-queue. This can be specified when the command-queue is created or \ncan be changed dynamically using \u003ccode\u003e\u003ca\u003eclCreateCommandQueue\u003c/a\u003e\u003c/code\u003e. In out-of-order \nexecution mode there is no guarantee that the enqueued commands will finish \nexecution in the order they were queued. As there is no guarantee that kernels \nwill be executed in order, i.e. based on when the \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e calls \nare made within a command-queue, it is therefore possible that an earlier \n\u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e call to execute kernel A identified by event A may \nexecute and/or finish later than a \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e call to execute \nkernel B which was called by the application at a later point in time. To \nguarantee a specific order of execution of kernels, a wait on a particular event \n(in this case event A) can be used. The wait for event A can be specified in the \nevent_wait_list argument to \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e for kernel B.\n\u003c/p\u003e\u003cp\u003eIn addition, a wait for events or a barrier command can be enqueued to the \ncommand-queue. The wait for events command ensures that previously enqueued \ncommands identified by the list of events to wait for have finished before the \nnext batch of commands is executed. The barrier command ensures that all \npreviously enqueued commands in a command-queue have finished execution before \nthe next batch of commands is executed.\n\u003c/p\u003e\u003cp\u003eSimilarly, commands to read, write, copy or map memory objects that are enqueued \nafter \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eclEnqueueTask\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eclEnqueueNativeKernel\u003c/a\u003e\u003c/code\u003e \ncommands are not guaranteed to wait for kernels scheduled for execution to have \ncompleted (if the \u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e property is set). To \nensure correct ordering of commands, the event object returned by \n\u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eclEnqueueTask\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eclEnqueueNativeKernel\u003c/a\u003e\u003c/code\u003e can be \nused to enqueue a wait for event or a barrier command can be enqueued that must \ncomplete before reads or writes to the memory object(s) occur.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clCreateCommandQueue",
          "package": "OpenCL",
          "signature": "CLContext -\u003e CLDeviceID -\u003e [CLCommandQueueProperty] -\u003e IO CLCommandQueue",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clCreateCommandQueue",
          "type": "function"
        },
        "index": {
          "description": "Create command-queue on specific device The OpenCL functions that are submitted to command-queue are enqueued in the order the calls are made but can be configured to execute in-order or out-of-order The properties argument in clCreateCommandQueue can be used to specify the execution order If the CL QUEUE OUT OF ORDER EXEC MODE ENABLE property of command-queue is not set the commands enqueued to command-queue execute in order For example if an application calls clEnqueueNDRangeKernel to execute kernel followed by clEnqueueNDRangeKernel to execute kernel the application can assume that kernel finishes first and then kernel is executed If the memory objects output by kernel are inputs to kernel then kernel will see the correct data in memory objects produced by execution of kernel If the CL QUEUE OUT OF ORDER EXEC MODE ENABLE property of commandqueue is set then there is no guarantee that kernel will finish before kernel starts execution Applications can configure the commands enqueued to command-queue to execute out-of-order by setting the CL QUEUE OUT OF ORDER EXEC MODE ENABLE property of the command-queue This can be specified when the command-queue is created or can be changed dynamically using clCreateCommandQueue In out-of-order execution mode there is no guarantee that the enqueued commands will finish execution in the order they were queued As there is no guarantee that kernels will be executed in order i.e based on when the clEnqueueNDRangeKernel calls are made within command-queue it is therefore possible that an earlier clEnqueueNDRangeKernel call to execute kernel identified by event may execute and or finish later than clEnqueueNDRangeKernel call to execute kernel which was called by the application at later point in time To guarantee specific order of execution of kernels wait on particular event in this case event can be used The wait for event can be specified in the event wait list argument to clEnqueueNDRangeKernel for kernel In addition wait for events or barrier command can be enqueued to the command-queue The wait for events command ensures that previously enqueued commands identified by the list of events to wait for have finished before the next batch of commands is executed The barrier command ensures that all previously enqueued commands in command-queue have finished execution before the next batch of commands is executed Similarly commands to read write copy or map memory objects that are enqueued after clEnqueueNDRangeKernel clEnqueueTask or clEnqueueNativeKernel commands are not guaranteed to wait for kernels scheduled for execution to have completed if the CL QUEUE OUT OF ORDER EXEC MODE ENABLE property is set To ensure correct ordering of commands the event object returned by clEnqueueNDRangeKernel clEnqueueTask or clEnqueueNativeKernel can be used to enqueue wait for event or barrier command can be enqueued that must complete before reads or writes to the memory object occur",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clCreateCommandQueue",
          "normalized": "CLContext-\u003eCLDeviceID-\u003e[CLCommandQueueProperty]-\u003eIO CLCommandQueue",
          "package": "OpenCL",
          "partial": "Create Command Queue",
          "signature": "CLContext-\u003eCLDeviceID-\u003e[CLCommandQueueProperty]-\u003eIO CLCommandQueue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clCreateCommandQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAcquire OpenCL memory objects that have been created from OpenGL\nobjects. These objects need to be acquired before they can be used by\nany OpenCL commands queued to a command-queue. The OpenGL objects are\nacquired by the OpenCL context associated with command_queue and can\ntherefore be used by all command-queues associated with the OpenCL\ncontext.\n\u003c/p\u003e\u003cp\u003eReturns CL_SUCCESS if the function is executed successfully. If\nnum_objects is 0 and mem_objects is NULL the function does nothing and\nreturns CL_SUCCESS. Otherwise, it returns one of the following errors:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e CL_INVALID_VALUE if num_objects is zero and mem_objects is not a\nNULL value or if num_objects \u003e 0 and mem_objects is NULL.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_MEM_OBJECT if memory objects in mem_objects are not valid\nOpenCL memory objects.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_COMMAND_QUEUE if command_queue is not a valid\ncommand-queue.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_CONTEXT if context associated with command_queue was not\ncreated from an OpenGL context.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_GL_OBJECT if memory objects in mem_objects have not been\ncreated from a GL object(s).\n\u003c/li\u003e\u003cli\u003e CL_INVALID_EVENT_WAIT_LIST if event_wait_list is NULL and\nnum_events_in_wait_list \u003e 0, or event_wait_list is not NULL and\nnum_events_in_wait_list is 0, or if event objects in event_wait_list\nare not valid events.\n\u003c/li\u003e\u003cli\u003e CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources\nrequired by the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueAcquireGLObjects",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e [CLMem] -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueAcquireGLObjects",
          "type": "function"
        },
        "index": {
          "description": "Acquire OpenCL memory objects that have been created from OpenGL objects These objects need to be acquired before they can be used by any OpenCL commands queued to command-queue The OpenGL objects are acquired by the OpenCL context associated with command queue and can therefore be used by all command-queues associated with the OpenCL context Returns CL SUCCESS if the function is executed successfully If num objects is and mem objects is NULL the function does nothing and returns CL SUCCESS Otherwise it returns one of the following errors CL INVALID VALUE if num objects is zero and mem objects is not NULL value or if num objects and mem objects is NULL CL INVALID MEM OBJECT if memory objects in mem objects are not valid OpenCL memory objects CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if context associated with command queue was not created from an OpenGL context CL INVALID GL OBJECT if memory objects in mem objects have not been created from GL object CL INVALID EVENT WAIT LIST if event wait list is NULL and num events in wait list or event wait list is not NULL and num events in wait list is or if event objects in event wait list are not valid events CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueAcquireGLObjects",
          "normalized": "CLCommandQueue-\u003e[CLMem]-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Acquire GLObjects",
          "signature": "CLCommandQueue-\u003e[CLMem]-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueAcquireGLObjects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueBarrier\u003c/a\u003e\u003c/code\u003e is a synchronization point that ensures that all queued\n commands in command_queue have finished execution before the next batch of\n commands can begin execution. It throws \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if\n command_queue is not a valid command-queue and throws\n \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\n by the OpenCL implementation on the host.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueBarrier",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO ()",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueBarrier",
          "type": "function"
        },
        "index": {
          "description": "clEnqueueBarrier is synchronization point that ensures that all queued commands in command queue have finished execution before the next batch of commands can begin execution It throws CL INVALID COMMAND QUEUE if command queue is not valid command-queue and throws CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueBarrier",
          "normalized": "CLCommandQueue-\u003eIO()",
          "package": "OpenCL",
          "partial": "Enqueue Barrier",
          "signature": "CLCommandQueue-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueBarrier"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to copy a buffer object to an image object.\n\u003c/p\u003e\u003cp\u003eThe size in bytes of the region to be copied from src_buffer referred to as\nsrc_cb is computed as width * height * depth * bytes/image element if dst_image\nis a 3D image object and is computed as width * height * bytes/image element if\ndst_image is a 2D image object.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular copy command and can be\nused to query or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to\ncomplete. \u003ccode\u003e\u003ca\u003eclEnqueueBarrier\u003c/a\u003e\u003c/code\u003e can be used instead.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueCopyBufferToImage\u003c/a\u003e\u003c/code\u003e returns the \u003ccode\u003e\u003ca\u003eCLEvent\u003c/a\u003e\u003c/code\u003e if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue, src_buffer\nand dst_image are not the same or if the context associated with command_queue\nand events in event_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if src_buffer is not a valid buffer object and\ndst_image is not a valid image object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if the 2D or 3D rectangular region specified by dst_origin\nand dst_origin + region refers to a region outside dst_origin, or if the region\nspecified by src_offset and src_offset + src_cb refers to a region outside\nsrc_buffer.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if dst_image is a 2D image object and dst_origin.z is not\nequal to 0 or region.depth is not equal to 1.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with src_buffer or dst_image.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueCopyBufferToImage",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e CLMem-\u003e a-\u003e (a, a, a)-\u003e (a, a, a)-\u003e [CLEvent]-\u003e IO CLEvent",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to copy buffer object to an image object The size in bytes of the region to be copied from src buffer referred to as src cb is computed as width height depth bytes image element if dst image is image object and is computed as width height bytes image element if dst image is image object Returns an event object that identifies this particular copy command and can be used to query or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete clEnqueueBarrier can be used instead clEnqueueCopyBufferToImage returns the CLEvent if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue src buffer and dst image are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if src buffer is not valid buffer object and dst image is not valid image object CL INVALID VALUE if the or rectangular region specified by dst origin and dst origin region refers to region outside dst origin or if the region specified by src offset and src offset src cb refers to region outside src buffer CL INVALID VALUE if dst image is image object and dst origin.z is not equal to or region.depth is not equal to CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with src buffer or dst image CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueCopyBufferToImage",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eCLMem-\u003ea-\u003e(a,a,a)-\u003e(a,a,a)-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Copy Buffer To Image",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eCLMem-\u003ea-\u003e(a,a,a)-\u003e(a,a,a)-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueCopyBufferToImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to copy image objects.\n\u003c/p\u003e\u003cp\u003eNotes \n\u003c/p\u003e\u003cp\u003eIt is currently a requirement that the src_image and dst_image image memory\nobjects for \u003ccode\u003e\u003ca\u003eclEnqueueCopyImage\u003c/a\u003e\u003c/code\u003e must have the exact same image format (i.e. the\n\u003ccode\u003eCLImageFormat\u003c/code\u003e descriptor specified when src_image and dst_image are created\nmust match).\n\u003c/p\u003e\u003cp\u003esrc_image and dst_image can be 2D or 3D image objects allowing us to perform the\nfollowing actions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Copy a 2D image object to a 2D image object.\n\u003c/li\u003e\u003cli\u003e Copy a 2D image object to a 2D slice of a 3D image object.\n\u003c/li\u003e\u003cli\u003e Copy a 2D slice of a 3D image object to a 2D image object.\n\u003c/li\u003e\u003cli\u003e Copy a 3D image object to a 3D image object.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueCopyImage\u003c/a\u003e\u003c/code\u003e returns the \u003ccode\u003e\u003ca\u003eCLEvent\u003c/a\u003e\u003c/code\u003e if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e 'CL_INVALID_COMMAND_QUEUE if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_CONTEXT if the context associated with command_queue, src_image\nand dst_image are not the same or if the context associated with command_queue\nand events in event_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_MEM_OBJECT if src_image and dst_image are not valid image\nobjects.\n\u003c/li\u003e\u003cli\u003e 'CL_IMAGE_FORMAT_MISMATCH if src_image and dst_image do not use the same\nimage format.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_VALUE if the 2D or 3D rectangular region specified by src_origin\nand src_origin + region refers to a region outside src_image, or if the 2D or 3D\nrectangular region specified by dst_origin and dst_origin + region refers to a\nregion outside dst_image.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_VALUE if src_image is a 2D image object and src_origin.z is not\nequal to 0 or region.depth is not equal to 1.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_VALUE if dst_image is a 2D image object and dst_origen.z is not\nequal to 0 or region.depth is not equal to 1.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_EVENT_WAIT_LIST if event objects in event_wait_list are not valid\nevents.\n\u003c/li\u003e\u003cli\u003e 'CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate memory\nfor data store associated with src_image or dst_image.\n\u003c/li\u003e\u003cli\u003e 'CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003cli\u003e 'CL_MEM_COPY_OVERLAP if src_image and dst_image are the same image object and\nthe source and destination regions overlap.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueCopyImage",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e CLMem-\u003e (a, a, a)-\u003e (a, a, a)-\u003e (a, a, a)-\u003e [CLEvent]-\u003e IO CLEvent",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to copy image objects Notes It is currently requirement that the src image and dst image image memory objects for clEnqueueCopyImage must have the exact same image format i.e the CLImageFormat descriptor specified when src image and dst image are created must match src image and dst image can be or image objects allowing us to perform the following actions Copy image object to image object Copy image object to slice of image object Copy slice of image object to image object Copy image object to image object clEnqueueCopyImage returns the CLEvent if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue src image and dst image are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if src image and dst image are not valid image objects CL IMAGE FORMAT MISMATCH if src image and dst image do not use the same image format CL INVALID VALUE if the or rectangular region specified by src origin and src origin region refers to region outside src image or if the or rectangular region specified by dst origin and dst origin region refers to region outside dst image CL INVALID VALUE if src image is image object and src origin.z is not equal to or region.depth is not equal to CL INVALID VALUE if dst image is image object and dst origen.z is not equal to or region.depth is not equal to CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with src image or dst image CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host CL MEM COPY OVERLAP if src image and dst image are the same image object and the source and destination regions overlap",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueCopyImage",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eCLMem-\u003e(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Copy Image",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eCLMem-\u003e(a,a,a)-\u003e(a,a,a)-\u003e(a,a,a)-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueCopyImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to copy an image object to a buffer object.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular copy command and can be\nused to query or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to\ncomplete. \u003ccode\u003e\u003ca\u003eclEnqueueBarrier\u003c/a\u003e\u003c/code\u003e can be used instead.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueCopyImageToBuffer\u003c/a\u003e\u003c/code\u003e returns the \u003ccode\u003e\u003ca\u003eCLEvent\u003c/a\u003e\u003c/code\u003e if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e CL_INVALID_COMMAND_QUEUE if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_CONTEXT if the context associated with command_queue, src_image\nand dst_buffer are not the same or if the context associated with command_queue\nand events in event_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_MEM_OBJECT if src_image is not a valid image object and dst_buffer\nis not a valid buffer object.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_VALUE if the 2D or 3D rectangular region specified by src_origin\nand src_origin + region refers to a region outside src_image, or if the region\nspecified by dst_offset and dst_offset + dst_cb refers to a region outside\ndst_buffer.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_VALUE if src_image is a 2D image object and src_origin.z is not\nequal to 0 or region.depth is not equal to 1.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_EVENT_WAIT_LIST if event objects in event_wait_list are not valid\nevents.\n\u003c/li\u003e\u003cli\u003e CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate memory for\ndata store associated with src_image or dst_buffer.\n\u003c/li\u003e\u003cli\u003e CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by\nthe OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueCopyImageToBuffer",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e CLMem-\u003e (a, a, a)-\u003e (a, a, a)-\u003e a-\u003e [CLEvent]-\u003e IO CLEvent",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to copy an image object to buffer object Returns an event object that identifies this particular copy command and can be used to query or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete clEnqueueBarrier can be used instead clEnqueueCopyImageToBuffer returns the CLEvent if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue src image and dst buffer are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if src image is not valid image object and dst buffer is not valid buffer object CL INVALID VALUE if the or rectangular region specified by src origin and src origin region refers to region outside src image or if the region specified by dst offset and dst offset dst cb refers to region outside dst buffer CL INVALID VALUE if src image is image object and src origin.z is not equal to or region.depth is not equal to CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with src image or dst buffer CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueCopyImageToBuffer",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eCLMem-\u003e(a,a,a)-\u003e(a,a,a)-\u003ea-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Copy Image To Buffer",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eCLMem-\u003e(a,a,a)-\u003e(a,a,a)-\u003ea-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueCopyImageToBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to map a region of the buffer object given by buffer into\nthe host address space and returns a pointer to this mapped region.\n\u003c/p\u003e\u003cp\u003eIf blocking_map is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e does not return until the\nspecified region in buffer can be mapped.\n\u003c/p\u003e\u003cp\u003eIf blocking_map is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e i.e. map operation is non-blocking, the pointer to\nthe mapped region returned by \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e cannot be used until the map\ncommand has completed. The event argument returns an event object which can be\nused to query the execution status of the map command. When the map command is\ncompleted, the application can access the contents of the mapped region using\nthe pointer returned by \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular copy command and can be\nused toquery or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to complete.\n\u003c/p\u003e\u003cp\u003eThe contents of the regions of a memory object mapped for writing\n(i.e. \u003ccode\u003e\u003ca\u003eCL_MAP_WRITE\u003c/a\u003e\u003c/code\u003e is set in map_flags argument to \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e) are considered to be undefined until this region is\nunmapped. Reads and writes by a kernel executing on a device to a memory\nregion(s) mapped for writing are undefined.\n\u003c/p\u003e\u003cp\u003eMultiple command-queues can map a region or overlapping regions of a memory\nobject for reading (i.e. map_flags = \u003ccode\u003e\u003ca\u003eCL_MAP_READ\u003c/a\u003e\u003c/code\u003e). The contents of the regions\nof a memory object mapped for reading can also be read by kernels executing on a\ndevice(s). The behavior of writes by a kernel executing on a device to a mapped\nregion of a memory object is undefined. Mapping (and unmapping) overlapped\nregions of a buffer or image memory object for writing is undefined.\n\u003c/p\u003e\u003cp\u003eThe behavior of OpenCL function calls that enqueue commands that write or copy\nto regions of a memory object that are mapped is undefined.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e will return a pointer to the mapped region if the function\nis executed successfully. A nullPtr pointer is returned otherwise with one of\nthe following exception:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue, src_image\nand dst_buffer are not the same or if the context associated with command_queue\nand events in event_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if buffer is not a valid buffer object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if region being mapped given by (offset, cb) is out of\nbounds or if values specified in map_flags are not valid\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MAP_FAILURE\u003c/code\u003e if there is a failure to map the requested region into the\nhost address space. This error cannot occur for buffer objects created with\n\u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e or \u003ccode\u003eCL_MEM_ALLOC_HOST_PTR\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with buffer.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe pointer returned maps a region starting at offset and is atleast cb bytes in\nsize. The result of a memory access outside this region is undefined.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueMapBuffer",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e Bool-\u003e [CLMapFlag]-\u003e a-\u003e a-\u003e [CLEvent]-\u003e IO (CLEvent, Ptr ())",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to map region of the buffer object given by buffer into the host address space and returns pointer to this mapped region If blocking map is True clEnqueueMapBuffer does not return until the specified region in buffer can be mapped If blocking map is False i.e map operation is non-blocking the pointer to the mapped region returned by clEnqueueMapBuffer cannot be used until the map command has completed The event argument returns an event object which can be used to query the execution status of the map command When the map command is completed the application can access the contents of the mapped region using the pointer returned by clEnqueueMapBuffer Returns an event object that identifies this particular copy command and can be used toquery or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete The contents of the regions of memory object mapped for writing i.e CL MAP WRITE is set in map flags argument to clEnqueueMapBuffer or clEnqueueMapImage are considered to be undefined until this region is unmapped Reads and writes by kernel executing on device to memory region mapped for writing are undefined Multiple command-queues can map region or overlapping regions of memory object for reading i.e map flags CL MAP READ The contents of the regions of memory object mapped for reading can also be read by kernels executing on device The behavior of writes by kernel executing on device to mapped region of memory object is undefined Mapping and unmapping overlapped regions of buffer or image memory object for writing is undefined The behavior of OpenCL function calls that enqueue commands that write or copy to regions of memory object that are mapped is undefined clEnqueueMapBuffer will return pointer to the mapped region if the function is executed successfully nullPtr pointer is returned otherwise with one of the following exception CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue src image and dst buffer are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if buffer is not valid buffer object CL INVALID VALUE if region being mapped given by offset cb is out of bounds or if values specified in map flags are not valid CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MAP FAILURE if there is failure to map the requested region into the host address space This error cannot occur for buffer objects created with CL MEM USE HOST PTR or CL MEM ALLOC HOST PTR CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with buffer CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host The pointer returned maps region starting at offset and is atleast cb bytes in size The result of memory access outside this region is undefined",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueMapBuffer",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e[CLMapFlag]-\u003ea-\u003ea-\u003e[CLEvent]-\u003eIO(CLEvent,Ptr())",
          "package": "OpenCL",
          "partial": "Enqueue Map Buffer",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e[CLMapFlag]-\u003ea-\u003ea-\u003e[CLEvent]-\u003eIO(CLEvent,Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueMapBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to map a region of an image object into the host address\nspace and returns a pointer to this mapped region.\n\u003c/p\u003e\u003cp\u003eIf blocking_map is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e i.e. map operation is non-blocking, the pointer to\nthe mapped region returned by \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e cannot be used until the map\ncommand has completed. The event argument returns an event object which can be\nused to query the execution status of the map command. When the map command is\ncompleted, the application can access the contents of the mapped region using\nthe pointer returned by \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular copy command and can be\nused to query or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to complete.\n\u003c/p\u003e\u003cp\u003eIf the buffer or image object is created with \u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e set in\nmem_flags, the following will be true:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The host_ptr specified in \u003ccode\u003eclCreateBuffer\u003c/code\u003e, \u003ccode\u003eclCreateImage2D\u003c/code\u003e, or\n\u003ccode\u003eclCreateImage3D\u003c/code\u003e is guaranteed to contain the latest bits in the region being\nmapped when the \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e command has\ncompleted.\n\u003c/li\u003e\u003cli\u003e The pointer value returned by \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e\nwill be derived from the host_ptr specified when the buffer or image object is\ncreated.  \n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe contents of the regions of a memory object mapped for writing\n(i.e. \u003ccode\u003e\u003ca\u003eCL_MAP_WRITE\u003c/a\u003e\u003c/code\u003e is set in map_flags argument to \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e) are considered to be undefined until this region is\nunmapped. Reads and writes by a kernel executing on a device to a memory\nregion(s) mapped for writing are undefined.\n\u003c/p\u003e\u003cp\u003eMultiple command-queues can map a region or overlapping regions of a memory\nobject for reading (i.e. map_flags = \u003ccode\u003e\u003ca\u003eCL_MAP_READ\u003c/a\u003e\u003c/code\u003e). The contents of the regions\nof a memory object mapped for reading can also be read by kernels executing on a\ndevice(s). The behavior of writes by a kernel executing on a device to a mapped\nregion of a memory object is undefined. Mapping (and unmapping) overlapped\nregions of a buffer or image memory object for writing is undefined.\n\u003c/p\u003e\u003cp\u003eThe behavior of OpenCL function calls that enqueue commands that write or copy\nto regions of a memory object that are mapped is undefined.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e will return a pointer to the mapped region if the\nfunction is executed successfully also the scan-line (row) pitch in bytes for\nthe mapped region and the size in bytes of each 2D slice for the mapped\nregion. For a 2D image, zero is returned as slice pitch. A nullPtr pointer is\nreturned otherwise with one of the following exception:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue and image\nare not the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if image is not a valid image object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if region being mapped given by (origin, origin+region) is\nout of bounds or if values specified in map_flags are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if image is a 2D image object and z is not equal to 0 or\ndepth is not equal to 1.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MAP_FAILURE\u003c/code\u003e if there is a failure to map the requested region into the\nhost address space. This error cannot occur for image objects created with\n\u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e or \u003ccode\u003eCL_MEM_ALLOC_HOST_PTR\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with image.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe pointer returned maps a 2D or 3D region starting at origin and is atleast\n(image_row_pitch * y + x) pixels in size for a 2D image, and is atleast\n(image_slice_pitch * z] + image_row_pitch * y + x) pixels in size for a 3D\nimage. The result of a memory access outside this region is undefined.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueMapImage",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e Bool-\u003e [CLMapFlag]-\u003e (a, a, a)-\u003e (a, a, a)-\u003e [CLEvent]-\u003e IO (CLEvent, (Ptr (), CSize, CSize))",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to map region of an image object into the host address space and returns pointer to this mapped region If blocking map is False i.e map operation is non-blocking the pointer to the mapped region returned by clEnqueueMapImage cannot be used until the map command has completed The event argument returns an event object which can be used to query the execution status of the map command When the map command is completed the application can access the contents of the mapped region using the pointer returned by clEnqueueMapImage Returns an event object that identifies this particular copy command and can be used to query or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete If the buffer or image object is created with CL MEM USE HOST PTR set in mem flags the following will be true The host ptr specified in clCreateBuffer clCreateImage2D or clCreateImage3D is guaranteed to contain the latest bits in the region being mapped when the clEnqueueMapBuffer or clEnqueueMapImage command has completed The pointer value returned by clEnqueueMapBuffer or clEnqueueMapImage will be derived from the host ptr specified when the buffer or image object is created The contents of the regions of memory object mapped for writing i.e CL MAP WRITE is set in map flags argument to clEnqueueMapBuffer or clEnqueueMapImage are considered to be undefined until this region is unmapped Reads and writes by kernel executing on device to memory region mapped for writing are undefined Multiple command-queues can map region or overlapping regions of memory object for reading i.e map flags CL MAP READ The contents of the regions of memory object mapped for reading can also be read by kernels executing on device The behavior of writes by kernel executing on device to mapped region of memory object is undefined Mapping and unmapping overlapped regions of buffer or image memory object for writing is undefined The behavior of OpenCL function calls that enqueue commands that write or copy to regions of memory object that are mapped is undefined clEnqueueMapImage will return pointer to the mapped region if the function is executed successfully also the scan-line row pitch in bytes for the mapped region and the size in bytes of each slice for the mapped region For image zero is returned as slice pitch nullPtr pointer is returned otherwise with one of the following exception CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue and image are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if image is not valid image object CL INVALID VALUE if region being mapped given by origin origin region is out of bounds or if values specified in map flags are not valid CL INVALID VALUE if image is image object and is not equal to or depth is not equal to CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MAP FAILURE if there is failure to map the requested region into the host address space This error cannot occur for image objects created with CL MEM USE HOST PTR or CL MEM ALLOC HOST PTR CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with image CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host The pointer returned maps or region starting at origin and is atleast image row pitch pixels in size for image and is atleast image slice pitch image row pitch pixels in size for image The result of memory access outside this region is undefined",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueMapImage",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e[CLMapFlag]-\u003e(a,a,a)-\u003e(a,a,a)-\u003e[CLEvent]-\u003eIO(CLEvent,(Ptr(),CSize,CSize))",
          "package": "OpenCL",
          "partial": "Enqueue Map Image",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e[CLMapFlag]-\u003e(a,a,a)-\u003e(a,a,a)-\u003e[CLEvent]-\u003eIO(CLEvent,(Ptr(),CSize,CSize))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueMapImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a marker command to command_queue. The marker command returns an\n event which can be used to queue a wait on this marker event i.e. wait for\n all commands queued before the marker command to complete. Returns the event\n if the function is successfully executed. It throw the \u003ccode\u003eCLError\u003c/code\u003e exception\n \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue and\n throw \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources\n required by the OpenCL implementation on the host.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueMarker",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueMarker",
          "type": "function"
        },
        "index": {
          "description": "Enqueues marker command to command queue The marker command returns an event which can be used to queue wait on this marker event i.e wait for all commands queued before the marker command to complete Returns the event if the function is successfully executed It throw the CLError exception CL INVALID COMMAND QUEUE if command queue is not valid command-queue and throw CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueMarker",
          "normalized": "CLCommandQueue-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Marker",
          "signature": "CLCommandQueue-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueMarker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to execute a kernel on a device. Each work-item is\nuniquely identified by a global identifier. The global ID, which can be read\ninside the kernel, is computed using the value given by global_work_size and\nglobal_work_offset. In OpenCL 1.0, the starting global ID is always (0, 0,\n... 0). In addition, a work-item is also identified within a work-group by a\nunique local ID. The local ID, which can also be read by the kernel, is computed\nusing the value given by local_work_size. The starting local ID is always (0, 0,\n... 0).\n\u003c/p\u003e\u003cp\u003eReturns the event if the kernel execution was successfully queued. It can throw\nthe following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_PROGRAM_EXECUTABLE\u003c/code\u003e if there is no successfully built program\nexecutable available for device associated with command_queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL\u003c/code\u003e if kernel is not a valid kernel object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context associated with command_queue and kernel is\nnot the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL_ARGS\u003c/code\u003e if the kernel argument values have not been\nspecified.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_WORK_DIMENSION\u003c/code\u003e if work_dim is not a valid value (i.e. a value\nbetween 1 and 3).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_WORK_GROUP_SIZE\u003c/code\u003e if local_work_size is specified and number of\nwork-items specified by global_work_size is not evenly divisable by size of\nwork-group given by local_work_size or does not match the work-group size\nspecified for kernel using the __attribute__((reqd_work_group_size(X, Y, Z)))\nqualifier in program source.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_WORK_GROUP_SIZE\u003c/code\u003e if local_work_size is specified and the total\nnumber of work-items in the work-group computed as local_work_size[0]\n*... local_work_size[work_dim - 1] is greater than the value specified by\n\u003ccode\u003eCL_DEVICE_MAX_WORK_GROUP_SIZE\u003c/code\u003e in the table of OpenCL Device Queries for\nclGetDeviceInfo.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_WORK_GROUP_SIZE\u003c/code\u003e if local_work_size is NULL and the\n__attribute__((reqd_work_group_size(X, Y, Z))) qualifier is used to declare the\nwork-group size for kernel in the program source.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_WORK_ITEM_SIZE\u003c/code\u003e if the number of work-items specified in any of\nlocal_work_size[0], ... local_work_size[work_dim - 1] is greater than the\ncorresponding values specified by \u003ccode\u003eCL_DEVICE_MAX_WORK_ITEM_SIZES\u003c/code\u003e[0],\n.... \u003ccode\u003eCL_DEVICE_MAX_WORK_ITEM_SIZES\u003c/code\u003e[work_dim - 1].\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_RESOURCES\u003c/code\u003e if there is a failure to queue the execution instance\nof kernel on the command-queue because of insufficient resources needed to\nexecute the kernel. For example, the explicitly specified local_work_size causes\na failure to execute the kernel because of insufficient resources such as\nregisters or local memory. Another example would be the number of read-only\nimage args used in kernel exceed the \u003ccode\u003eCL_DEVICE_MAX_READ_IMAGE_ARGS\u003c/code\u003e value for\ndevice or the number of write-only image args used in kernel exceed the\n\u003ccode\u003eCL_DEVICE_MAX_WRITE_IMAGE_ARGS\u003c/code\u003e value for device or the number of samplers used\nin kernel exceed \u003ccode\u003eCL_DEVICE_MAX_SAMPLERS\u003c/code\u003e for device.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory for data store associated with image or buffer objects specified as arguments to kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required by\nthe OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueNDRangeKernel",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e CLKernel -\u003e [a] -\u003e [a] -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueNDRangeKernel",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to execute kernel on device Each work-item is uniquely identified by global identifier The global ID which can be read inside the kernel is computed using the value given by global work size and global work offset In OpenCL the starting global ID is always In addition work-item is also identified within work-group by unique local ID The local ID which can also be read by the kernel is computed using the value given by local work size The starting local ID is always Returns the event if the kernel execution was successfully queued It can throw the following CLError exceptions CL INVALID PROGRAM EXECUTABLE if there is no successfully built program executable available for device associated with command queue CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID KERNEL if kernel is not valid kernel object CL INVALID CONTEXT if context associated with command queue and kernel is not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID KERNEL ARGS if the kernel argument values have not been specified CL INVALID WORK DIMENSION if work dim is not valid value i.e value between and CL INVALID WORK GROUP SIZE if local work size is specified and number of work-items specified by global work size is not evenly divisable by size of work-group given by local work size or does not match the work-group size specified for kernel using the attribute reqd work group size qualifier in program source CL INVALID WORK GROUP SIZE if local work size is specified and the total number of work-items in the work-group computed as local work size local work size work dim is greater than the value specified by CL DEVICE MAX WORK GROUP SIZE in the table of OpenCL Device Queries for clGetDeviceInfo CL INVALID WORK GROUP SIZE if local work size is NULL and the attribute reqd work group size qualifier is used to declare the work-group size for kernel in the program source CL INVALID WORK ITEM SIZE if the number of work-items specified in any of local work size local work size work dim is greater than the corresponding values specified by CL DEVICE MAX WORK ITEM SIZES CL DEVICE MAX WORK ITEM SIZES work dim CL OUT OF RESOURCES if there is failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel For example the explicitly specified local work size causes failure to execute the kernel because of insufficient resources such as registers or local memory Another example would be the number of read-only image args used in kernel exceed the CL DEVICE MAX READ IMAGE ARGS value for device or the number of write-only image args used in kernel exceed the CL DEVICE MAX WRITE IMAGE ARGS value for device or the number of samplers used in kernel exceed CL DEVICE MAX SAMPLERS for device CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with image or buffer objects specified as arguments to kernel CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueNDRangeKernel",
          "normalized": "CLCommandQueue-\u003eCLKernel-\u003e[a]-\u003e[a]-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue NDRange Kernel",
          "signature": "CLCommandQueue-\u003eCLKernel-\u003e[a]-\u003e[a]-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueNDRangeKernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to execute a native C/C++ function not compiled using the\nOpenCL compiler. A native user function can only be executed on a command-queue\ncreated on a device that has \u003ccode\u003eCL_EXEC_NATIVE_KERNEL\u003c/code\u003e capability set in\n\u003ccode\u003eclGetDeviceExecutionCapabilities\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThe data pointed to by args and cb_args bytes in size will be copied and a\npointer to this copied region will be passed to user_func. The copy needs to be\ndone because the memory objects (\u003ccode\u003e\u003ca\u003eCLMem\u003c/a\u003e\u003c/code\u003e values) that args may contain need to\nbe modified and replaced by appropriate pointers to global memory. When\n\u003ccode\u003e\u003ca\u003eclEnqueueNativeKernel\u003c/a\u003e\u003c/code\u003e returns, the memory region pointed to by args can be\nreused by the application.\n\u003c/p\u003e\u003cp\u003eReturns the evens if the kernel execution was successfully queued. It can throw\nthe following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context associated with command_queue and events in\nevent-wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if args is a NULL value and cb_args is greater than 0, or\nif args is a NULL value and num_mem_objects is greater than 0.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if args is not NULL and cb_args is 0.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if device cannot execute the native kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if one or more memory objects specified in mem_list\nare not valid or are not buffer objects.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_RESOURCES\u003c/code\u003e if there is a failure to queue the execution instance\nof kernel on the command-queue because of insufficient resources needed to\nexecute the kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with buffer objects specified as arguments to kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueNativeKernel",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e (Ptr () -\u003e IO ()) -\u003e Ptr () -\u003e CSize -\u003e [CLMem] -\u003e [Ptr ()] -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueNativeKernel",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to execute native function not compiled using the OpenCL compiler native user function can only be executed on command-queue created on device that has CL EXEC NATIVE KERNEL capability set in clGetDeviceExecutionCapabilities The data pointed to by args and cb args bytes in size will be copied and pointer to this copied region will be passed to user func The copy needs to be done because the memory objects CLMem values that args may contain need to be modified and replaced by appropriate pointers to global memory When clEnqueueNativeKernel returns the memory region pointed to by args can be reused by the application Returns the evens if the kernel execution was successfully queued It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if context associated with command queue and events in event-wait list are not the same CL INVALID VALUE if args is NULL value and cb args is greater than or if args is NULL value and num mem objects is greater than CL INVALID VALUE if args is not NULL and cb args is CL INVALID OPERATION if device cannot execute the native kernel CL INVALID MEM OBJECT if one or more memory objects specified in mem list are not valid or are not buffer objects CL OUT OF RESOURCES if there is failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with buffer objects specified as arguments to kernel CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueNativeKernel",
          "normalized": "CLCommandQueue-\u003e(Ptr()-\u003eIO())-\u003ePtr()-\u003eCSize-\u003e[CLMem]-\u003e[Ptr()]-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Native Kernel",
          "signature": "CLCommandQueue-\u003e(Ptr()-\u003eIO())-\u003ePtr()-\u003eCSize-\u003e[CLMem]-\u003e[Ptr()]-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueNativeKernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueue commands to read from a buffer object to host memory. Calling\nclEnqueueReadBuffer to read a region of the buffer object with the ptr argument\nvalue set to host_ptr + offset, where host_ptr is a pointer to the memory region\nspecified when the buffer object being read is created with\n\u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e, must meet the following requirements in order to avoid\nundefined behavior:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e All commands that use this buffer object have finished execution before the\nread command begins execution\n\u003c/li\u003e\u003cli\u003e The buffer object is not mapped\n\u003c/li\u003e\u003cli\u003e The buffer object is not used by any command-queue until the read command has\nfinished execution Errors\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueReadBuffer\u003c/a\u003e\u003c/code\u003e returns the event if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue and buffer\nare not the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if buffer is not a valid buffer object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if the region being read specified by (offset, cb) is out\nof bounds or if ptr is a NULL value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event_wait_list is NULL and\nnum_events_in_wait_list greater than 0, or event_wait_list is not NULL and\nnum_events_in_wait_list is 0, or if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with buffer.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueReadBuffer",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e CLMem -\u003e Bool -\u003e a -\u003e a -\u003e Ptr () -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueReadBuffer",
          "type": "function"
        },
        "index": {
          "description": "Enqueue commands to read from buffer object to host memory Calling clEnqueueReadBuffer to read region of the buffer object with the ptr argument value set to host ptr offset where host ptr is pointer to the memory region specified when the buffer object being read is created with CL MEM USE HOST PTR must meet the following requirements in order to avoid undefined behavior All commands that use this buffer object have finished execution before the read command begins execution The buffer object is not mapped The buffer object is not used by any command-queue until the read command has finished execution Errors clEnqueueReadBuffer returns the event if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue and buffer are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if buffer is not valid buffer object CL INVALID VALUE if the region being read specified by offset cb is out of bounds or if ptr is NULL value CL INVALID EVENT WAIT LIST if event wait list is NULL and num events in wait list greater than or event wait list is not NULL and num events in wait list is or if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with buffer CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueReadBuffer",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Read Buffer",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueReadBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to read from a 2D or 3D image object to host memory.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular read command and can be\nused to query or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to complete.\n\u003c/p\u003e\u003cp\u003eNotes\n\u003c/p\u003e\u003cp\u003eIf blocking is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e i.e. the read command is blocking, \u003ccode\u003e\u003ca\u003eclEnqueueReadImage\u003c/a\u003e\u003c/code\u003e\ndoes not return until the buffer data has been read and copied into memory\npointed to by ptr.\n\u003c/p\u003e\u003cp\u003eIf blocking_read is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e i.e. map operation is non-blocking,\n\u003ccode\u003e\u003ca\u003eclEnqueueReadImage\u003c/a\u003e\u003c/code\u003e queues a non-blocking read command and returns. The\ncontents of the buffer that ptr points to cannot be used until the read command\nhas completed. The event argument returns an event object which can be used to\nquery the execution status of the read command. When the read command has\ncompleted, the contents of the buffer that ptr points to can be used by the\napplication.\n\u003c/p\u003e\u003cp\u003eCalling \u003ccode\u003e\u003ca\u003eclEnqueueReadImage\u003c/a\u003e\u003c/code\u003e to read a region of the image object with the ptr\nargument value set to host_ptr + (origin.z * image slice pitch + origin.y *\nimage row pitch + origin.x * bytes per pixel), where host_ptr is a pointer to\nthe memory region specified when the image object being read is created with\n\u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e, must meet the following requirements in order to avoid\nundefined behavior:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e All commands that use this image object have finished execution before the\nread command begins execution.\n\u003c/li\u003e\u003cli\u003e The row_pitch and slice_pitch argument values in clEnqueueReadImage must be\nset to the image row pitch and slice pitch.\n\u003c/li\u003e\u003cli\u003e The image object is not mapped.\n\u003c/li\u003e\u003cli\u003e The image object is not used by any command-queue until the read command has\nfinished execution.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueReadImage\u003c/a\u003e\u003c/code\u003e returns the \u003ccode\u003e\u003ca\u003eCLEvent\u003c/a\u003e\u003c/code\u003e if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue and image\nare not the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if image is not a valid image object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if the region being read specified by origin and region is\nout of bounds or if ptr is a nullPtr value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if image is a 2D image object and z is not equal to 0 or\ndepth is not equal to 1 or slice_pitch is not equal to 0.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with image.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueReadImage",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e Bool-\u003e (a, a, a)-\u003e (a, a, a)-\u003e a-\u003e a-\u003e Ptr ()-\u003e [CLEvent]-\u003e IO CLEvent",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to read from or image object to host memory Returns an event object that identifies this particular read command and can be used to query or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete Notes If blocking is True i.e the read command is blocking clEnqueueReadImage does not return until the buffer data has been read and copied into memory pointed to by ptr If blocking read is False i.e map operation is non-blocking clEnqueueReadImage queues non-blocking read command and returns The contents of the buffer that ptr points to cannot be used until the read command has completed The event argument returns an event object which can be used to query the execution status of the read command When the read command has completed the contents of the buffer that ptr points to can be used by the application Calling clEnqueueReadImage to read region of the image object with the ptr argument value set to host ptr origin.z image slice pitch origin.y image row pitch origin.x bytes per pixel where host ptr is pointer to the memory region specified when the image object being read is created with CL MEM USE HOST PTR must meet the following requirements in order to avoid undefined behavior All commands that use this image object have finished execution before the read command begins execution The row pitch and slice pitch argument values in clEnqueueReadImage must be set to the image row pitch and slice pitch The image object is not mapped The image object is not used by any command-queue until the read command has finished execution clEnqueueReadImage returns the CLEvent if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue and image are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if image is not valid image object CL INVALID VALUE if the region being read specified by origin and region is out of bounds or if ptr is nullPtr value CL INVALID VALUE if image is image object and is not equal to or depth is not equal to or slice pitch is not equal to CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with image CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueReadImage",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e(a,a,a)-\u003e(a,a,a)-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Read Image",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e(a,a,a)-\u003e(a,a,a)-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueReadImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRelease OpenCL memory objects that have been created from OpenGL\nobjects. These objects need to be released before they can be used by\nOpenGL. The OpenGL objects are released by the OpenCL context\nassociated with command_queue.\n\u003c/p\u003e\u003cp\u003eclEnqueueReleaseGLObjects returns CL_SUCCESS if the function is\nexecuted successfully. If num_objects is 0 and mem_objects is NULL the\nfunction does nothing and returns CL_SUCCESS. Otherwise, it returns\none of the following errors:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e CL_INVALID_VALUE if num_objects is zero and mem_objects is not a\nNULL value or if num_objects \u003e 0 and mem_objects is NULL.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_MEM_OBJECT if memory objects in mem_objects are not valid\nOpenCL memory objects.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_COMMAND_QUEUE if command_queue is not a valid\ncommand-queue.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_CONTEXT if context associated with command_queue was not\ncreated from an OpenGL context\n\u003c/li\u003e\u003cli\u003e CL_INVALID_GL_OBJECT if memory objects in mem_objects have not been\ncreated from a GL object(s).\n\u003c/li\u003e\u003cli\u003e CL_INVALID_EVENT_WAIT_LIST if event_wait_list is NULL and\nnum_events_in_wait_list \u003e 0, or event_wait_list is not NULL and\nnum_events_in_wait_list is 0, or if event objects in event_wait_list\nare not valid events.\n\u003c/li\u003e\u003cli\u003e CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources\nrequired by the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueReleaseGLObjects",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e [CLMem] -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueReleaseGLObjects",
          "type": "function"
        },
        "index": {
          "description": "Release OpenCL memory objects that have been created from OpenGL objects These objects need to be released before they can be used by OpenGL The OpenGL objects are released by the OpenCL context associated with command queue clEnqueueReleaseGLObjects returns CL SUCCESS if the function is executed successfully If num objects is and mem objects is NULL the function does nothing and returns CL SUCCESS Otherwise it returns one of the following errors CL INVALID VALUE if num objects is zero and mem objects is not NULL value or if num objects and mem objects is NULL CL INVALID MEM OBJECT if memory objects in mem objects are not valid OpenCL memory objects CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if context associated with command queue was not created from an OpenGL context CL INVALID GL OBJECT if memory objects in mem objects have not been created from GL object CL INVALID EVENT WAIT LIST if event wait list is NULL and num events in wait list or event wait list is not NULL and num events in wait list is or if event objects in event wait list are not valid events CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueReleaseGLObjects",
          "normalized": "CLCommandQueue-\u003e[CLMem]-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Release GLObjects",
          "signature": "CLCommandQueue-\u003e[CLMem]-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueReleaseGLObjects"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to execute a kernel on a device. The kernel is executed\nusing a single work-item.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueTask\u003c/a\u003e\u003c/code\u003e is equivalent to calling \u003ccode\u003e\u003ca\u003eclEnqueueNDRangeKernel\u003c/a\u003e\u003c/code\u003e with work_dim\n= 1, global_work_offset = [], global_work_size[0] set to 1, and\nlocal_work_size[0] set to 1.\n\u003c/p\u003e\u003cp\u003eReturns the evens if the kernel execution was successfully queued. It can throw\nthe following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_PROGRAM_EXECUTABLE\u003c/code\u003e if there is no successfully built program\nexecutable available for device associated with command_queue.\n\u003c/li\u003e\u003cli\u003e 'CL_INVALID_COMMAND_QUEUE if' command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL\u003c/code\u003e if kernel is not a valid kernel object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context associated with command_queue and kernel is\nnot the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL_ARGS\u003c/code\u003e if the kernel argument values have not been specified.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_WORK_GROUP_SIZE\u003c/code\u003e if a work-group size is specified for kernel\nusing the __attribute__((reqd_work_group_size(X, Y, Z))) qualifier in program\nsource and is not (1, 1, 1).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_RESOURCES\u003c/code\u003e if there is a failure to queue the execution instance\nof kernel on the command-queue because of insufficient resources needed to\nexecute the kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with image or buffer objects specified as arguments to\nkernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueTask",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e CLKernel -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueTask",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to execute kernel on device The kernel is executed using single work-item clEnqueueTask is equivalent to calling clEnqueueNDRangeKernel with work dim global work offset global work size set to and local work size set to Returns the evens if the kernel execution was successfully queued It can throw the following CLError exceptions CL INVALID PROGRAM EXECUTABLE if there is no successfully built program executable available for device associated with command queue CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID KERNEL if kernel is not valid kernel object CL INVALID CONTEXT if context associated with command queue and kernel is not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID KERNEL ARGS if the kernel argument values have not been specified CL INVALID WORK GROUP SIZE if work-group size is specified for kernel using the attribute reqd work group size qualifier in program source and is not CL OUT OF RESOURCES if there is failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with image or buffer objects specified as arguments to kernel CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueTask",
          "normalized": "CLCommandQueue-\u003eCLKernel-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Task",
          "signature": "CLCommandQueue-\u003eCLKernel-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueTask"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to unmap a previously mapped region of a memory object.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular copy command and can be\nused to query or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to\ncomplete. \u003ccode\u003e\u003ca\u003eclEnqueueBarrier\u003c/a\u003e\u003c/code\u003e can be used instead.\n\u003c/p\u003e\u003cp\u003eReads or writes from the host using the pointer returned by \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e\nor \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e are considered to be complete.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e increments the mapped count of the\nmemory object. The initial mapped count value of a memory object is\nzero. Multiple calls to \u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e on the same\nmemory object will increment this mapped count by appropriate number of\ncalls. \u003ccode\u003e\u003ca\u003eclEnqueueUnmapMemObject\u003c/a\u003e\u003c/code\u003e decrements the mapped count of the memory\nobject.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e act as synchronization points for a\nregion of the memory object being mapped.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueUnmapMemObject\u003c/a\u003e\u003c/code\u003e returns the \u003ccode\u003e\u003ca\u003eCLEvent\u003c/a\u003e\u003c/code\u003e if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e CL_INVALID_COMMAND_QUEUE if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_MEM_OBJECT if memobj is not a valid memory object.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_VALUE if mapped_ptr is not a valid pointer returned by\n\u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e for memobj.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_EVENT_WAIT_LIST if event objects in event_wait_list are not valid\nevents.\n\u003c/li\u003e\u003cli\u003e CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by\nthe OpenCL implementation on the host.\n\u003c/li\u003e\u003cli\u003e CL_INVALID_CONTEXT if the context associated with command_queue and memobj\nare not the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueUnmapMemObject",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e Ptr ()-\u003e [CLEvent]-\u003e IO CLEvent",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to unmap previously mapped region of memory object Returns an event object that identifies this particular copy command and can be used to query or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete clEnqueueBarrier can be used instead Reads or writes from the host using the pointer returned by clEnqueueMapBuffer or clEnqueueMapImage are considered to be complete clEnqueueMapBuffer and clEnqueueMapImage increments the mapped count of the memory object The initial mapped count value of memory object is zero Multiple calls to clEnqueueMapBuffer or clEnqueueMapImage on the same memory object will increment this mapped count by appropriate number of calls clEnqueueUnmapMemObject decrements the mapped count of the memory object clEnqueueMapBuffer and clEnqueueMapImage act as synchronization points for region of the memory object being mapped clEnqueueUnmapMemObject returns the CLEvent if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID MEM OBJECT if memobj is not valid memory object CL INVALID VALUE if mapped ptr is not valid pointer returned by clEnqueueMapBuffer or clEnqueueMapImage for memobj CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host CL INVALID CONTEXT if the context associated with command queue and memobj are not the same or if the context associated with command queue and events in event wait list are not the same",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueUnmapMemObject",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Unmap Mem Object",
          "signature": "CLCommandQueue-\u003eCLMem-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueUnmapMemObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a wait for a specific event or a list of events to complete before\nany future commands queued in the command-queue are executed. The context\nassociated with events in event_list and command_queue must be the same.\n\u003c/p\u003e\u003cp\u003eIt can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue and events\nin event_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if num_events is zero.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT\u003c/code\u003e if event objects specified in event_list are not valid\nevents.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueWaitForEvents",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e [CLEvent] -\u003e IO ()",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueWaitForEvents",
          "type": "function"
        },
        "index": {
          "description": "Enqueues wait for specific event or list of events to complete before any future commands queued in the command-queue are executed The context associated with events in event list and command queue must be the same It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue and events in event list are not the same CL INVALID VALUE if num events is zero CL INVALID EVENT if event objects specified in event list are not valid events CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueWaitForEvents",
          "normalized": "CLCommandQueue-\u003e[CLEvent]-\u003eIO()",
          "package": "OpenCL",
          "partial": "Enqueue Wait For Events",
          "signature": "CLCommandQueue-\u003e[CLEvent]-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueWaitForEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueue commands to write to a buffer object from host memory.Calling\nclEnqueueWriteBuffer to update the latest bits in a region of the buffer object\nwith the ptr argument value set to host_ptr + offset, where host_ptr is a\npointer to the memory region specified when the buffer object being written is\ncreated with \u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e, must meet the following requirements in\norder to avoid undefined behavior:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The host memory region given by (host_ptr + offset, cb) contains the latest\nbits when the enqueued write command begins execution.\n\u003c/li\u003e\u003cli\u003e The buffer object is not mapped.\n\u003c/li\u003e\u003cli\u003e The buffer object is not used by any command-queue until the write command\nhas finished execution.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueWriteBuffer\u003c/a\u003e\u003c/code\u003e returns the Event if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue and buffer\nare not the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if buffer is not a valid buffer object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if the region being written specified by (offset, cb) is\nout of bounds or if ptr is a NULL value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event_wait_list is NULL and\nnum_events_in_wait_list greater than 0, or event_wait_list is not NULL and\nnum_events_in_wait_list is 0, or if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with buffer.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueWriteBuffer",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e CLMem -\u003e Bool -\u003e a -\u003e a -\u003e Ptr () -\u003e [CLEvent] -\u003e IO CLEvent",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clEnqueueWriteBuffer",
          "type": "function"
        },
        "index": {
          "description": "Enqueue commands to write to buffer object from host memory.Calling clEnqueueWriteBuffer to update the latest bits in region of the buffer object with the ptr argument value set to host ptr offset where host ptr is pointer to the memory region specified when the buffer object being written is created with CL MEM USE HOST PTR must meet the following requirements in order to avoid undefined behavior The host memory region given by host ptr offset cb contains the latest bits when the enqueued write command begins execution The buffer object is not mapped The buffer object is not used by any command-queue until the write command has finished execution clEnqueueWriteBuffer returns the Event if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue and buffer are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if buffer is not valid buffer object CL INVALID VALUE if the region being written specified by offset cb is out of bounds or if ptr is NULL value CL INVALID EVENT WAIT LIST if event wait list is NULL and num events in wait list greater than or event wait list is not NULL and num events in wait list is or if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with buffer CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueWriteBuffer",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Write Buffer",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueWriteBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnqueues a command to write from a 2D or 3D image object to host memory.\n\u003c/p\u003e\u003cp\u003eReturns an event object that identifies this particular write command and can be\nused to query or queue a wait for this particular command to complete. event can\nbe NULL in which case it will not be possible for the application to query the\nstatus of this command or queue a wait for this command to complete.\n\u003c/p\u003e\u003cp\u003eNotes\n\u003c/p\u003e\u003cp\u003eIf blocking_write is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e the OpenCL implementation copies the data referred\nto by ptr and enqueues the write command in the command-queue. The memory\npointed to by ptr can be reused by the application after the\n\u003ccode\u003e\u003ca\u003eclEnqueueWriteImage\u003c/a\u003e\u003c/code\u003e call returns.\n\u003c/p\u003e\u003cp\u003eIf blocking_write is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e the OpenCL implementation will use ptr to perform a\nnonblocking write. As the write is non-blocking the implementation can return\nimmediately. The memory pointed to by ptr cannot be reused by the application\nafter the call returns. The event argument returns an event object which can be\nused to query the execution status of the write command. When the write command\nhas completed, the memory pointed to by ptr can then be reused by the\napplication.\n\u003c/p\u003e\u003cp\u003eCalling \u003ccode\u003e\u003ca\u003eclEnqueueWriteImage\u003c/a\u003e\u003c/code\u003e to update the latest bits in a region of the image\nobject with the ptr argument value set to host_ptr + (origin.z * image slice\npitch + origin.y * image row pitch + origin.x * bytes per pixel), where host_ptr\nis a pointer to the memory region specified when the image object being written\nis created with \u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e, must meet the following requirements in\norder to avoid undefined behavior:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The host memory region being written contains the latest bits when the\nenqueued write command begins execution.\n\u003c/li\u003e\u003cli\u003e The input_row_pitch and input_slice_pitch argument values in\nclEnqueueWriteImage must be set to the image row pitch and slice pitch.\n\u003c/li\u003e\u003cli\u003e The image object is not mapped.\n\u003c/li\u003e\u003cli\u003e The image object is not used by any command-queue until the write command has\nfinished execution.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclEnqueueWriteImage\u003c/a\u003e\u003c/code\u003e returns the \u003ccode\u003e\u003ca\u003eCLEvent\u003c/a\u003e\u003c/code\u003e if the function is executed\nsuccessfully. It can throw the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_COMMAND_QUEUE\u003c/code\u003e if command_queue is not a valid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if the context associated with command_queue and image\nare not the same or if the context associated with command_queue and events in\nevent_wait_list are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e if image is not a valid image object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if the region being write or written specified by origin\nand region is out of bounds or if ptr is a NULL value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if image is a 2D image object and z is not equal to 0 or\ndepth is not equal to 1 or slice_pitch is not equal to 0.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/code\u003e if event objects in event_wait_list are not\nvalid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor data store associated with image.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueWriteImage",
          "package": "OpenCL",
          "signature": "CLCommandQueue-\u003e CLMem-\u003e Bool-\u003e (a, a, a)-\u003e (a, a, a)-\u003e a-\u003e a-\u003e Ptr ()-\u003e [CLEvent]-\u003e IO CLEvent",
          "type": "function"
        },
        "index": {
          "description": "Enqueues command to write from or image object to host memory Returns an event object that identifies this particular write command and can be used to query or queue wait for this particular command to complete event can be NULL in which case it will not be possible for the application to query the status of this command or queue wait for this command to complete Notes If blocking write is True the OpenCL implementation copies the data referred to by ptr and enqueues the write command in the command-queue The memory pointed to by ptr can be reused by the application after the clEnqueueWriteImage call returns If blocking write is False the OpenCL implementation will use ptr to perform nonblocking write As the write is non-blocking the implementation can return immediately The memory pointed to by ptr cannot be reused by the application after the call returns The event argument returns an event object which can be used to query the execution status of the write command When the write command has completed the memory pointed to by ptr can then be reused by the application Calling clEnqueueWriteImage to update the latest bits in region of the image object with the ptr argument value set to host ptr origin.z image slice pitch origin.y image row pitch origin.x bytes per pixel where host ptr is pointer to the memory region specified when the image object being written is created with CL MEM USE HOST PTR must meet the following requirements in order to avoid undefined behavior The host memory region being written contains the latest bits when the enqueued write command begins execution The input row pitch and input slice pitch argument values in clEnqueueWriteImage must be set to the image row pitch and slice pitch The image object is not mapped The image object is not used by any command-queue until the write command has finished execution clEnqueueWriteImage returns the CLEvent if the function is executed successfully It can throw the following CLError exceptions CL INVALID COMMAND QUEUE if command queue is not valid command-queue CL INVALID CONTEXT if the context associated with command queue and image are not the same or if the context associated with command queue and events in event wait list are not the same CL INVALID MEM OBJECT if image is not valid image object CL INVALID VALUE if the region being write or written specified by origin and region is out of bounds or if ptr is NULL value CL INVALID VALUE if image is image object and is not equal to or depth is not equal to or slice pitch is not equal to CL INVALID EVENT WAIT LIST if event objects in event wait list are not valid events CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for data store associated with image CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clEnqueueWriteImage",
          "normalized": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e(a,a,a)-\u003e(a,a,a)-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "package": "OpenCL",
          "partial": "Enqueue Write Image",
          "signature": "CLCommandQueue-\u003eCLMem-\u003eBool-\u003e(a,a,a)-\u003e(a,a,a)-\u003ea-\u003ea-\u003ePtr()-\u003e[CLEvent]-\u003eIO CLEvent",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clEnqueueWriteImage"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBlocks until all previously queued OpenCL commands in a command-queue are \n issued to the associated device and have completed.\n \u003ccode\u003e\u003ca\u003eclFinish\u003c/a\u003e\u003c/code\u003e does not return until all queued commands in command_queue have \n been processed and completed. \u003ccode\u003e\u003ca\u003eclFinish\u003c/a\u003e\u003c/code\u003e is also a synchronization point.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclFinish\u003c/a\u003e\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function call was executed successfully. It \n returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if command_queue is not a valid command-queue or if there is \n a failure to allocate resources required by the OpenCL implementation on the \n host.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clFinish",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clFinish",
          "type": "function"
        },
        "index": {
          "description": "Blocks until all previously queued OpenCL commands in command-queue are issued to the associated device and have completed clFinish does not return until all queued commands in command queue have been processed and completed clFinish is also synchronization point clFinish returns True if the function call was executed successfully It returns False if command queue is not valid command-queue or if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clFinish",
          "normalized": "CLCommandQueue-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Finish",
          "signature": "CLCommandQueue-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clFinish"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIssues all previously queued OpenCL commands in a command-queue to the\ndevice associated with the command-queue.  \u003ccode\u003e\u003ca\u003eclFlush\u003c/a\u003e\u003c/code\u003e only guarantees that all\nqueued commands to command_queue get issued to the appropriate device. There is\nno guarantee that they will be complete after \u003ccode\u003e\u003ca\u003eclFlush\u003c/a\u003e\u003c/code\u003e returns.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclFlush\u003c/a\u003e\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function call was executed successfully. It\nreturns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if command_queue is not a valid command-queue or if there is a\nfailure to allocate resources required by the OpenCL implementation on the host.\n\u003c/p\u003e\u003cp\u003eAny blocking commands queued in a command-queue such as \u003ccode\u003e\u003ca\u003eclEnqueueReadImage\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eclEnqueueReadBuffer\u003c/a\u003e\u003c/code\u003e with blocking_read set to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eclEnqueueWriteImage\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eclEnqueueWriteBuffer\u003c/a\u003e\u003c/code\u003e with blocking_write set to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eclEnqueueMapImage\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eclEnqueueMapBuffer\u003c/a\u003e\u003c/code\u003e with blocking_map set to \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003eclWaitForEvents\u003c/code\u003e\nperform an implicit flush of the command-queue.\n\u003c/p\u003e\u003cp\u003eTo use event objects that refer to commands enqueued in a command-queue as\nevent objects to wait on by commands enqueued in a different command-queue, the\napplication must call a \u003ccode\u003e\u003ca\u003eclFlush\u003c/a\u003e\u003c/code\u003e or any blocking commands that perform an\nimplicit flush of the command-queue where the commands that refer to these event\nobjects are enqueued.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clFlush",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clFlush",
          "type": "function"
        },
        "index": {
          "description": "Issues all previously queued OpenCL commands in command-queue to the device associated with the command-queue clFlush only guarantees that all queued commands to command queue get issued to the appropriate device There is no guarantee that they will be complete after clFlush returns clFlush returns True if the function call was executed successfully It returns False if command queue is not valid command-queue or if there is failure to allocate resources required by the OpenCL implementation on the host Any blocking commands queued in command-queue such as clEnqueueReadImage or clEnqueueReadBuffer with blocking read set to True clEnqueueWriteImage or clEnqueueWriteBuffer with blocking write set to True clEnqueueMapImage or clEnqueueMapBuffer with blocking map set to True or clWaitForEvents perform an implicit flush of the command-queue To use event objects that refer to commands enqueued in command-queue as event objects to wait on by commands enqueued in different command-queue the application must call clFlush or any blocking commands that perform an implicit flush of the command-queue where the commands that refer to these event objects are enqueued",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clFlush",
          "normalized": "CLCommandQueue-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Flush",
          "signature": "CLCommandQueue-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clFlush"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the context specified when the command-queue is created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetCommandQueueInfo with \u003ccode\u003eCL_QUEUE_CONTEXT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueContext",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clGetCommandQueueContext",
          "type": "function"
        },
        "index": {
          "description": "Return the context specified when the command-queue is created This function execute OpenCL clGetCommandQueueInfo with CL QUEUE CONTEXT",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueContext",
          "normalized": "CLCommandQueue-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Get Command Queue Context",
          "signature": "CLCommandQueue-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clGetCommandQueueContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the device specified when the command-queue is created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetCommandQueueInfo with \u003ccode\u003eCL_QUEUE_DEVICE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueDevice",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO CLDeviceID",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clGetCommandQueueDevice",
          "type": "function"
        },
        "index": {
          "description": "Return the device specified when the command-queue is created This function execute OpenCL clGetCommandQueueInfo with CL QUEUE DEVICE",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueDevice",
          "normalized": "CLCommandQueue-\u003eIO CLDeviceID",
          "package": "OpenCL",
          "partial": "Get Command Queue Device",
          "signature": "CLCommandQueue-\u003eIO CLDeviceID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clGetCommandQueueDevice"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the currently specified properties for the command-queue. These \n properties are specified by the properties argument in \u003ccode\u003e\u003ca\u003eclCreateCommandQueue\u003c/a\u003e\u003c/code\u003e\n , and can be changed by \u003ccode\u003e\u003ca\u003eclSetCommandQueueProperty\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetCommandQueueInfo with\n \u003ccode\u003eCL_QUEUE_PROPERTIES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueProperties",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO [CLCommandQueueProperty]",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clGetCommandQueueProperties",
          "type": "function"
        },
        "index": {
          "description": "Return the currently specified properties for the command-queue These properties are specified by the properties argument in clCreateCommandQueue and can be changed by clSetCommandQueueProperty This function execute OpenCL clGetCommandQueueInfo with CL QUEUE PROPERTIES",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueProperties",
          "normalized": "CLCommandQueue-\u003eIO[CLCommandQueueProperty]",
          "package": "OpenCL",
          "partial": "Get Command Queue Properties",
          "signature": "CLCommandQueue-\u003eIO[CLCommandQueueProperty]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clGetCommandQueueProperties"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the command-queue reference count.\n The reference count returned should be considered immediately stale. It is \n unsuitable for general use in applications. This feature is provided for \n identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetCommandQueueInfo with\n \u003ccode\u003eCL_QUEUE_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueReferenceCount",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clGetCommandQueueReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return the command-queue reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetCommandQueueInfo with CL QUEUE REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clGetCommandQueueReferenceCount",
          "normalized": "CLCommandQueue-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Command Queue Reference Count",
          "signature": "CLCommandQueue-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clGetCommandQueueReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrements the command_queue reference count.\n After the command_queue reference count becomes zero and all commands queued \n to command_queue have finished (e.g., kernel executions, memory object \n updates, etc.), the command-queue is deleted.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n if command_queue is not a valid command-queue.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clReleaseCommandQueue",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clReleaseCommandQueue",
          "type": "function"
        },
        "index": {
          "description": "Decrements the command queue reference count After the command queue reference count becomes zero and all commands queued to command queue have finished e.g kernel executions memory object updates etc the command-queue is deleted Returns True if the function is executed successfully It returns False if command queue is not valid command-queue",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clReleaseCommandQueue",
          "normalized": "CLCommandQueue-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Command Queue",
          "signature": "CLCommandQueue-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clReleaseCommandQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrements the command_queue reference count. \u003ccode\u003e\u003ca\u003eclCreateCommandQueue\u003c/a\u003e\u003c/code\u003e\nperforms an implicit retain. This is very helpful for 3rd party libraries, which\ntypically get a command-queue passed to them by the application. However, it is\npossible that the application may delete the command-queue without informing the\nlibrary. Allowing functions to attach to (i.e. retain) and release a\ncommand-queue solves the problem of a command-queue being used by a library no\nlonger being valid.  Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. It\nreturns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if command_queue is not a valid command-queue.  \n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clRetainCommandQueue",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clRetainCommandQueue",
          "type": "function"
        },
        "index": {
          "description": "Increments the command queue reference count clCreateCommandQueue performs an implicit retain This is very helpful for rd party libraries which typically get command-queue passed to them by the application However it is possible that the application may delete the command-queue without informing the library Allowing functions to attach to i.e retain and release command-queue solves the problem of command-queue being used by library no longer being valid Returns True if the function is executed successfully It returns False if command queue is not valid command-queue",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clRetainCommandQueue",
          "normalized": "CLCommandQueue-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Command Queue",
          "signature": "CLCommandQueue-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clRetainCommandQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eEnable or disable the properties of a command-queue.  Returns the\ncommand-queue properties before they were changed by\n\u003ccode\u003e\u003ca\u003eclSetCommandQueueProperty\u003c/a\u003e\u003c/code\u003e.  As specified for \u003ccode\u003e\u003ca\u003eclCreateCommandQueue\u003c/a\u003e\u003c/code\u003e, the\n\u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e command-queue property determines\nwhether the commands in a command-queue are executed in-order or\nout-of-order. Changing this command-queue property will cause the OpenCL\nimplementation to block until all previously queued commands in command_queue\nhave completed. This can be an expensive operation and therefore changes to the\n\u003ccode\u003e\u003ca\u003eCL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\u003c/a\u003e\u003c/code\u003e property should be only done when\nabsolutely necessary.\n\u003c/p\u003e\u003cp\u003eIt is possible that a device(s) becomes unavailable after a context and\ncommand-queues that use this device(s) have been created and commands have been\nqueued to command-queues. In this case the behavior of OpenCL API calls that use\nthis context (and command-queues) are considered to be\nimplementation-defined. The user callback function, if specified when the\ncontext is created, can be used to record appropriate information when the\ndevice becomes unavailable.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clSetCommandQueueProperty",
          "package": "OpenCL",
          "signature": "CLCommandQueue -\u003e [CLCommandQueueProperty] -\u003e Bool -\u003e IO [CLCommandQueueProperty]",
          "source": "src/Control-Parallel-OpenCL-CommandQueue.html#clSetCommandQueueProperty",
          "type": "function"
        },
        "index": {
          "description": "Enable or disable the properties of command-queue Returns the command-queue properties before they were changed by clSetCommandQueueProperty As specified for clCreateCommandQueue the CL QUEUE OUT OF ORDER EXEC MODE ENABLE command-queue property determines whether the commands in command-queue are executed in-order or out-of-order Changing this command-queue property will cause the OpenCL implementation to block until all previously queued commands in command queue have completed This can be an expensive operation and therefore changes to the CL QUEUE OUT OF ORDER EXEC MODE ENABLE property should be only done when absolutely necessary It is possible that device becomes unavailable after context and command-queues that use this device have been created and commands have been queued to command-queues In this case the behavior of OpenCL API calls that use this context and command-queues are considered to be implementation-defined The user callback function if specified when the context is created can be used to record appropriate information when the device becomes unavailable",
          "hierarchy": "Control Parallel OpenCL CommandQueue",
          "module": "Control.Parallel.OpenCL.CommandQueue",
          "name": "clSetCommandQueueProperty",
          "normalized": "CLCommandQueue-\u003e[CLCommandQueueProperty]-\u003eBool-\u003eIO[CLCommandQueueProperty]",
          "package": "OpenCL",
          "partial": "Set Command Queue Property",
          "signature": "CLCommandQueue-\u003e[CLCommandQueueProperty]-\u003eBool-\u003eIO[CLCommandQueueProperty]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-CommandQueue.html#v:clSetCommandQueueProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "Context",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Context.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "Context",
          "package": "OpenCL",
          "partial": "Context",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CLContext",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLContext",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CLContext",
          "package": "OpenCL",
          "partial": "CLContext",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#t:CLContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies a context property name and its corresponding value.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CLContextProperty",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "data"
        },
        "index": {
          "description": "Specifies context property name and its corresponding value",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CLContextProperty",
          "package": "OpenCL",
          "partial": "CLContext Property",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#t:CLContextProperty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the CGL share group to use.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_CGL_SHAREGROUP_KHR",
          "package": "OpenCL",
          "signature": "CL_CGL_SHAREGROUP_KHR (Ptr ())",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "function"
        },
        "index": {
          "description": "Specifies the CGL share group to use",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_CGL_SHAREGROUP_KHR",
          "normalized": "CL_CGL_SHAREGROUP_KHR(Ptr())",
          "package": "OpenCL",
          "partial": "CL CGL SHAREGROUP KHR",
          "signature": "CL_CGL_SHAREGROUP_KHR(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:CL_CGL_SHAREGROUP_KHR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the platform to use.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_CONTEXT_PLATFORM",
          "package": "OpenCL",
          "signature": "CL_CONTEXT_PLATFORM CLPlatformID",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "function"
        },
        "index": {
          "description": "Specifies the platform to use",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_CONTEXT_PLATFORM",
          "package": "OpenCL",
          "partial": "CL CONTEXT PLATFORM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:CL_CONTEXT_PLATFORM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_EGL_DISPLAY_KHR",
          "package": "OpenCL",
          "signature": "CL_EGL_DISPLAY_KHR (Ptr ())",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_EGL_DISPLAY_KHR",
          "normalized": "CL_EGL_DISPLAY_KHR(Ptr())",
          "package": "OpenCL",
          "partial": "CL EGL DISPLAY KHR",
          "signature": "CL_EGL_DISPLAY_KHR(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:CL_EGL_DISPLAY_KHR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_GLX_DISPLAY_KHR",
          "package": "OpenCL",
          "signature": "CL_GLX_DISPLAY_KHR (Ptr ())",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_GLX_DISPLAY_KHR",
          "normalized": "CL_GLX_DISPLAY_KHR(Ptr())",
          "package": "OpenCL",
          "partial": "CL GLX DISPLAY KHR",
          "signature": "CL_GLX_DISPLAY_KHR(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:CL_GLX_DISPLAY_KHR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_GL_CONTEXT_KHR",
          "package": "OpenCL",
          "signature": "CL_GL_CONTEXT_KHR (Ptr ())",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_GL_CONTEXT_KHR",
          "normalized": "CL_GL_CONTEXT_KHR(Ptr())",
          "package": "OpenCL",
          "partial": "CL GL CONTEXT KHR",
          "signature": "CL_GL_CONTEXT_KHR(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:CL_GL_CONTEXT_KHR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_WGL_HDC_KHR",
          "package": "OpenCL",
          "signature": "CL_WGL_HDC_KHR (Ptr ())",
          "source": "src/Control-Parallel-OpenCL-Context.html#CLContextProperty",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "CL_WGL_HDC_KHR",
          "normalized": "CL_WGL_HDC_KHR(Ptr())",
          "package": "OpenCL",
          "partial": "CL WGL HDC KHR",
          "signature": "CL_WGL_HDC_KHR(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:CL_WGL_HDC_KHR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates an OpenCL context.\n An OpenCL context is created with one or more devices. Contexts are used by\n the OpenCL runtime for managing objects such as command-queues, memory,\n program and kernel objects and for executing kernels on one or more devices\n specified in the context.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clCreateContext",
          "package": "OpenCL",
          "signature": "[CLContextProperty] -\u003e [CLDeviceID] -\u003e (String -\u003e IO ()) -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-Context.html#clCreateContext",
          "type": "function"
        },
        "index": {
          "description": "Creates an OpenCL context An OpenCL context is created with one or more devices Contexts are used by the OpenCL runtime for managing objects such as command-queues memory program and kernel objects and for executing kernels on one or more devices specified in the context",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clCreateContext",
          "normalized": "[CLContextProperty]-\u003e[CLDeviceID]-\u003e(String-\u003eIO())-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Create Context",
          "signature": "[CLContextProperty]-\u003e[CLDeviceID]-\u003e(String-\u003eIO())-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clCreateContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreate an OpenCL context from a device type that identifies the specific\n device(s) to use.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clCreateContextFromType",
          "package": "OpenCL",
          "signature": "[CLContextProperty] -\u003e [CLDeviceType] -\u003e (String -\u003e IO ()) -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-Context.html#clCreateContextFromType",
          "type": "function"
        },
        "index": {
          "description": "Create an OpenCL context from device type that identifies the specific device to use",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clCreateContextFromType",
          "normalized": "[CLContextProperty]-\u003e[CLDeviceType]-\u003e(String-\u003eIO())-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Create Context From Type",
          "signature": "[CLContextProperty]-\u003e[CLDeviceType]-\u003e(String-\u003eIO())-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clCreateContextFromType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the list of devices in context.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetContextInfo with \u003ccode\u003eCL_CONTEXT_DEVICES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clGetContextDevices",
          "package": "OpenCL",
          "signature": "CLContext -\u003e IO [CLDeviceID]",
          "source": "src/Control-Parallel-OpenCL-Context.html#clGetContextDevices",
          "type": "function"
        },
        "index": {
          "description": "Return the list of devices in context This function execute OpenCL clGetContextInfo with CL CONTEXT DEVICES",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clGetContextDevices",
          "normalized": "CLContext-\u003eIO[CLDeviceID]",
          "package": "OpenCL",
          "partial": "Get Context Devices",
          "signature": "CLContext-\u003eIO[CLDeviceID]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clGetContextDevices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clGetContextProperties",
          "package": "OpenCL",
          "signature": "CLContext -\u003e IO [CLContextProperty]",
          "source": "src/Control-Parallel-OpenCL-Context.html#clGetContextProperties",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clGetContextProperties",
          "normalized": "CLContext-\u003eIO[CLContextProperty]",
          "package": "OpenCL",
          "partial": "Get Context Properties",
          "signature": "CLContext-\u003eIO[CLContextProperty]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clGetContextProperties"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the context reference count. The reference count returned should be\n considered immediately stale. It is unsuitable for general use in\n applications. This feature is provided for identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetContextInfo with \u003ccode\u003eCL_CONTEXT_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clGetContextReferenceCount",
          "package": "OpenCL",
          "signature": "CLContext -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Context.html#clGetContextReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return the context reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetContextInfo with CL CONTEXT REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clGetContextReferenceCount",
          "normalized": "CLContext-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Context Reference Count",
          "signature": "CLContext-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clGetContextReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrement the context reference count.\n After the context reference count becomes zero and all the objects attached\n to context (such as memory objects, command-queues) are released, the\n context is deleted.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully, or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if\n context is not a valid OpenCL context.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clReleaseContext",
          "package": "OpenCL",
          "signature": "CLContext -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Context.html#clReleaseContext",
          "type": "function"
        },
        "index": {
          "description": "Decrement the context reference count After the context reference count becomes zero and all the objects attached to context such as memory objects command-queues are released the context is deleted Returns True if the function is executed successfully or False if context is not valid OpenCL context",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clReleaseContext",
          "normalized": "CLContext-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Context",
          "signature": "CLContext-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clReleaseContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrement the context reference count.\n \u003ccode\u003e\u003ca\u003eclCreateContext\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eclCreateContextFromType\u003c/a\u003e\u003c/code\u003e perform an implicit retain.\n This is very helpful for 3rd party libraries, which typically get a context\n passed to them by the application. However, it is possible that the\n application may delete the context without informing the library. Allowing\n functions to attach to (i.e. retain) and release a context solves the\n problem of a context being used by a library no longer being valid.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully, or \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if\n context is not a valid OpenCL context.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clRetainContext",
          "package": "OpenCL",
          "signature": "CLContext -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Context.html#clRetainContext",
          "type": "function"
        },
        "index": {
          "description": "Increment the context reference count clCreateContext and clCreateContextFromType perform an implicit retain This is very helpful for rd party libraries which typically get context passed to them by the application However it is possible that the application may delete the context without informing the library Allowing functions to attach to i.e retain and release context solves the problem of context being used by library no longer being valid Returns True if the function is executed successfully or False if context is not valid OpenCL context",
          "hierarchy": "Control Parallel OpenCL Context",
          "module": "Control.Parallel.OpenCL.Context",
          "name": "clRetainContext",
          "normalized": "CLContext-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Context",
          "signature": "CLContext-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Context.html#v:clRetainContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "Event",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Event.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "Event",
          "package": "OpenCL",
          "partial": "Event",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_QUEUED\u003c/a\u003e\u003c/code\u003e, command has been enqueued in the command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SUBMITTED\u003c/a\u003e\u003c/code\u003e, enqueued command has been submitted by the host to the \ndevice associated with the command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_RUNNING\u003c/a\u003e\u003c/code\u003e, device is currently executing this command.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_COMPLETE\u003c/a\u003e\u003c/code\u003e, the command has completed.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_EXEC_ERROR\u003c/a\u003e\u003c/code\u003e, command was abnormally terminated.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLCommandExecutionStatus",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandExecutionStatus",
          "type": "data"
        },
        "index": {
          "description": "CL QUEUED command has been enqueued in the command-queue CL SUBMITTED enqueued command has been submitted by the host to the device associated with the command-queue CL RUNNING device is currently executing this command CL COMPLETE the command has completed CL EXEC ERROR command was abnormally terminated",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLCommandExecutionStatus",
          "package": "OpenCL",
          "partial": "CLCommand Execution Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#t:CLCommandExecutionStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCommand associated with an event.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLCommandType",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "data"
        },
        "index": {
          "description": "Command associated with an event",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLCommandType",
          "package": "OpenCL",
          "partial": "CLCommand Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#t:CLCommandType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLEvent",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLEvent",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLEvent",
          "package": "OpenCL",
          "partial": "CLEvent",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#t:CLEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the profiling data.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PROFILING_COMMAND_QUEUED\u003c/a\u003e\u003c/code\u003e, A 64-bit value that describes the current \ndevice time counter in nanoseconds when the command identified by event is \nenqueued in a command-queue by the host.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PROFILING_COMMAND_SUBMIT\u003c/a\u003e\u003c/code\u003e, A 64-bit value that describes the current \ndevice time counter in nanoseconds when the command identified by event that has \nbeen enqueued is submitted by the host to the device associated with the \ncommandqueue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PROFILING_COMMAND_START\u003c/a\u003e\u003c/code\u003e, A 64-bit value that describes the current \ndevice time counter in nanoseconds when the command identified by event starts \nexecution on the device.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PROFILING_COMMAND_END\u003c/a\u003e\u003c/code\u003e, A 64-bit value that describes the current device \ntime counter in nanoseconds when the command identified by event has finished \nexecution on the device.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLProfilingInfo",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLProfilingInfo",
          "type": "data"
        },
        "index": {
          "description": "Specifies the profiling data CL PROFILING COMMAND QUEUED bit value that describes the current device time counter in nanoseconds when the command identified by event is enqueued in command-queue by the host CL PROFILING COMMAND SUBMIT bit value that describes the current device time counter in nanoseconds when the command identified by event that has been enqueued is submitted by the host to the device associated with the commandqueue CL PROFILING COMMAND START bit value that describes the current device time counter in nanoseconds when the command identified by event starts execution on the device CL PROFILING COMMAND END bit value that describes the current device time counter in nanoseconds when the command identified by event has finished execution on the device",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CLProfilingInfo",
          "package": "OpenCL",
          "partial": "CLProfiling Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#t:CLProfilingInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_ACQUIRE_GL_OBJECTS",
          "package": "OpenCL",
          "signature": "CL_COMMAND_ACQUIRE_GL_OBJECTS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_ACQUIRE_GL_OBJECTS",
          "package": "OpenCL",
          "partial": "CL COMMAND ACQUIRE GL OBJECTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_ACQUIRE_GL_OBJECTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_BUFFER",
          "package": "OpenCL",
          "signature": "CL_COMMAND_COPY_BUFFER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_BUFFER",
          "package": "OpenCL",
          "partial": "CL COMMAND COPY BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_COPY_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_BUFFER_TO_IMAGE",
          "package": "OpenCL",
          "signature": "CL_COMMAND_COPY_BUFFER_TO_IMAGE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_BUFFER_TO_IMAGE",
          "package": "OpenCL",
          "partial": "CL COMMAND COPY BUFFER TO IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_COPY_BUFFER_TO_IMAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_IMAGE",
          "package": "OpenCL",
          "signature": "CL_COMMAND_COPY_IMAGE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_IMAGE",
          "package": "OpenCL",
          "partial": "CL COMMAND COPY IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_COPY_IMAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_IMAGE_TO_BUFFER",
          "package": "OpenCL",
          "signature": "CL_COMMAND_COPY_IMAGE_TO_BUFFER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_COPY_IMAGE_TO_BUFFER",
          "package": "OpenCL",
          "partial": "CL COMMAND COPY IMAGE TO BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_COPY_IMAGE_TO_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_MAP_BUFFER",
          "package": "OpenCL",
          "signature": "CL_COMMAND_MAP_BUFFER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_MAP_BUFFER",
          "package": "OpenCL",
          "partial": "CL COMMAND MAP BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_MAP_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_MAP_IMAGE",
          "package": "OpenCL",
          "signature": "CL_COMMAND_MAP_IMAGE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_MAP_IMAGE",
          "package": "OpenCL",
          "partial": "CL COMMAND MAP IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_MAP_IMAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_MARKER",
          "package": "OpenCL",
          "signature": "CL_COMMAND_MARKER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_MARKER",
          "package": "OpenCL",
          "partial": "CL COMMAND MARKER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_MARKER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_NATIVE_KERNEL",
          "package": "OpenCL",
          "signature": "CL_COMMAND_NATIVE_KERNEL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_NATIVE_KERNEL",
          "package": "OpenCL",
          "partial": "CL COMMAND NATIVE KERNEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_NATIVE_KERNEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_NDRANGE_KERNEL",
          "package": "OpenCL",
          "signature": "CL_COMMAND_NDRANGE_KERNEL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_NDRANGE_KERNEL",
          "package": "OpenCL",
          "partial": "CL COMMAND NDRANGE KERNEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_NDRANGE_KERNEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_READ_BUFFER",
          "package": "OpenCL",
          "signature": "CL_COMMAND_READ_BUFFER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_READ_BUFFER",
          "package": "OpenCL",
          "partial": "CL COMMAND READ BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_READ_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_READ_IMAGE",
          "package": "OpenCL",
          "signature": "CL_COMMAND_READ_IMAGE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_READ_IMAGE",
          "package": "OpenCL",
          "partial": "CL COMMAND READ IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_READ_IMAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_RELEASE_GL_OBJECTS",
          "package": "OpenCL",
          "signature": "CL_COMMAND_RELEASE_GL_OBJECTS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_RELEASE_GL_OBJECTS",
          "package": "OpenCL",
          "partial": "CL COMMAND RELEASE GL OBJECTS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_RELEASE_GL_OBJECTS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_TASK",
          "package": "OpenCL",
          "signature": "CL_COMMAND_TASK",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_TASK",
          "package": "OpenCL",
          "partial": "CL COMMAND TASK",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_TASK"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_UNMAP_MEM_OBJECT",
          "package": "OpenCL",
          "signature": "CL_COMMAND_UNMAP_MEM_OBJECT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_UNMAP_MEM_OBJECT",
          "package": "OpenCL",
          "partial": "CL COMMAND UNMAP MEM OBJECT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_UNMAP_MEM_OBJECT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_WRITE_BUFFER",
          "package": "OpenCL",
          "signature": "CL_COMMAND_WRITE_BUFFER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_WRITE_BUFFER",
          "package": "OpenCL",
          "partial": "CL COMMAND WRITE BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_WRITE_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_WRITE_IMAGE",
          "package": "OpenCL",
          "signature": "CL_COMMAND_WRITE_IMAGE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMMAND_WRITE_IMAGE",
          "package": "OpenCL",
          "partial": "CL COMMAND WRITE IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMMAND_WRITE_IMAGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMPLETE",
          "package": "OpenCL",
          "signature": "CL_COMPLETE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandExecutionStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_COMPLETE",
          "package": "OpenCL",
          "partial": "CL COMPLETE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_COMPLETE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_EXEC_ERROR",
          "package": "OpenCL",
          "signature": "CL_EXEC_ERROR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandExecutionStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_EXEC_ERROR",
          "package": "OpenCL",
          "partial": "CL EXEC ERROR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_EXEC_ERROR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_END",
          "package": "OpenCL",
          "signature": "CL_PROFILING_COMMAND_END",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLProfilingInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_END",
          "package": "OpenCL",
          "partial": "CL PROFILING COMMAND END",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_PROFILING_COMMAND_END"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_QUEUED",
          "package": "OpenCL",
          "signature": "CL_PROFILING_COMMAND_QUEUED",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLProfilingInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_QUEUED",
          "package": "OpenCL",
          "partial": "CL PROFILING COMMAND QUEUED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_PROFILING_COMMAND_QUEUED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_START",
          "package": "OpenCL",
          "signature": "CL_PROFILING_COMMAND_START",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLProfilingInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_START",
          "package": "OpenCL",
          "partial": "CL PROFILING COMMAND START",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_PROFILING_COMMAND_START"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_SUBMIT",
          "package": "OpenCL",
          "signature": "CL_PROFILING_COMMAND_SUBMIT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLProfilingInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_PROFILING_COMMAND_SUBMIT",
          "package": "OpenCL",
          "partial": "CL PROFILING COMMAND SUBMIT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_PROFILING_COMMAND_SUBMIT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_QUEUED",
          "package": "OpenCL",
          "signature": "CL_QUEUED",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandExecutionStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_QUEUED",
          "package": "OpenCL",
          "partial": "CL QUEUED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_QUEUED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_RUNNING",
          "package": "OpenCL",
          "signature": "CL_RUNNING",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandExecutionStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_RUNNING",
          "package": "OpenCL",
          "partial": "CL RUNNING",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_RUNNING"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_SUBMITTED",
          "package": "OpenCL",
          "signature": "CL_SUBMITTED",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLCommandExecutionStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "CL_SUBMITTED",
          "package": "OpenCL",
          "partial": "CL SUBMITTED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:CL_SUBMITTED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the execution status of the command identified by event.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetEventInfo with\n \u003ccode\u003eCL_EVENT_COMMAND_EXECUTION_STATUS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventCommandExecutionStatus",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e IO CLCommandExecutionStatus",
          "source": "src/Control-Parallel-OpenCL-Event.html#clGetEventCommandExecutionStatus",
          "type": "function"
        },
        "index": {
          "description": "Return the execution status of the command identified by event This function execute OpenCL clGetEventInfo with CL EVENT COMMAND EXECUTION STATUS",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventCommandExecutionStatus",
          "normalized": "CLEvent-\u003eIO CLCommandExecutionStatus",
          "package": "OpenCL",
          "partial": "Get Event Command Execution Status",
          "signature": "CLEvent-\u003eIO CLCommandExecutionStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clGetEventCommandExecutionStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the command-queue associated with event.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetEventInfo with \u003ccode\u003eCL_EVENT_COMMAND_QUEUE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventCommandQueue",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e IO CLCommandQueue",
          "source": "src/Control-Parallel-OpenCL-Event.html#clGetEventCommandQueue",
          "type": "function"
        },
        "index": {
          "description": "Return the command-queue associated with event This function execute OpenCL clGetEventInfo with CL EVENT COMMAND QUEUE",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventCommandQueue",
          "normalized": "CLEvent-\u003eIO CLCommandQueue",
          "package": "OpenCL",
          "partial": "Get Event Command Queue",
          "signature": "CLEvent-\u003eIO CLCommandQueue",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clGetEventCommandQueue"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the command associated with event.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetEventInfo with \u003ccode\u003eCL_EVENT_COMMAND_TYPE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventCommandType",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e IO CLCommandType",
          "source": "src/Control-Parallel-OpenCL-Event.html#clGetEventCommandType",
          "type": "function"
        },
        "index": {
          "description": "Return the command associated with event This function execute OpenCL clGetEventInfo with CL EVENT COMMAND TYPE",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventCommandType",
          "normalized": "CLEvent-\u003eIO CLCommandType",
          "package": "OpenCL",
          "partial": "Get Event Command Type",
          "signature": "CLEvent-\u003eIO CLCommandType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clGetEventCommandType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns profiling information for the command associated with event if \nprofiling is enabled. The unsigned 64-bit values returned can be used to measure \nthe time in nano-seconds consumed by OpenCL commands.\n\u003c/p\u003e\u003cp\u003eOpenCL devices are required to correctly track time across changes in device \nfrequency and power states. The \u003ccode\u003eCL_DEVICE_PROFILING_TIMER_RESOLUTION\u003c/code\u003e specifies \nthe resolution of the timer i.e. the number of nanoseconds elapsed before the \ntimer is incremented.\n\u003c/p\u003e\u003cp\u003eEvent objects can be used to capture profiling information that measure \nexecution time of a command. Profiling of OpenCL commands can be enabled either \nby using a command-queue created with \u003ccode\u003eCL_QUEUE_PROFILING_ENABLE\u003c/code\u003e flag set in \nproperties argument to clCreateCommandQueue or by setting the \n\u003ccode\u003eCL_QUEUE_PROFILING_ENABLE\u003c/code\u003e flag in properties argument to \n\u003ccode\u003eclSetCommandQueueProperty\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclGetEventProfilingInfo\u003c/a\u003e\u003c/code\u003e returns the valueif the function is executed \nsuccessfully and the profiling information has been recorded, and returns \n\u003ccode\u003e\u003ca\u003eNothing\u003c/a\u003e\u003c/code\u003e  if the \u003ccode\u003eCL_QUEUE_PROFILING_ENABLE\u003c/code\u003e flag is not set for the \ncommand-queue and if the profiling information is currently not available \n(because the command identified by event has not completed), or if event is a \nnot a valid event object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventProfilingInfo",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e CLProfilingInfo -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Event.html#clGetEventProfilingInfo",
          "type": "function"
        },
        "index": {
          "description": "Returns profiling information for the command associated with event if profiling is enabled The unsigned bit values returned can be used to measure the time in nano-seconds consumed by OpenCL commands OpenCL devices are required to correctly track time across changes in device frequency and power states The CL DEVICE PROFILING TIMER RESOLUTION specifies the resolution of the timer i.e the number of nanoseconds elapsed before the timer is incremented Event objects can be used to capture profiling information that measure execution time of command Profiling of OpenCL commands can be enabled either by using command-queue created with CL QUEUE PROFILING ENABLE flag set in properties argument to clCreateCommandQueue or by setting the CL QUEUE PROFILING ENABLE flag in properties argument to clSetCommandQueueProperty clGetEventProfilingInfo returns the valueif the function is executed successfully and the profiling information has been recorded and returns Nothing if the CL QUEUE PROFILING ENABLE flag is not set for the command-queue and if the profiling information is currently not available because the command identified by event has not completed or if event is not valid event object",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventProfilingInfo",
          "normalized": "CLEvent-\u003eCLProfilingInfo-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Event Profiling Info",
          "signature": "CLEvent-\u003eCLProfilingInfo-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clGetEventProfilingInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the event reference count. The reference count returned should be \n considered immediately stale. It is unsuitable for general use in applications. \n This feature is provided for identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetEventInfo with \u003ccode\u003eCL_EVENT_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventReferenceCount",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e IO CLint",
          "source": "src/Control-Parallel-OpenCL-Event.html#clGetEventReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return the event reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetEventInfo with CL EVENT REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clGetEventReferenceCount",
          "normalized": "CLEvent-\u003eIO CLint",
          "package": "OpenCL",
          "partial": "Get Event Reference Count",
          "signature": "CLEvent-\u003eIO CLint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clGetEventReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrements the event reference count.\n Decrements the event reference count. The event object is deleted once the \n reference count becomes zero, the specific command identified by this event \n has completed (or terminated) and there are no commands in the command-queues \n of a context that require a wait for this event to complete.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e \n if event is not a valid event object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clReleaseEvent",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Event.html#clReleaseEvent",
          "type": "function"
        },
        "index": {
          "description": "Decrements the event reference count Decrements the event reference count The event object is deleted once the reference count becomes zero the specific command identified by this event has completed or terminated and there are no commands in the command-queues of context that require wait for this event to complete Returns True if the function is executed successfully It returns False if event is not valid event object",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clReleaseEvent",
          "normalized": "CLEvent-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Event",
          "signature": "CLEvent-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clReleaseEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrements the event reference count.\n The OpenCL commands that return an event perform an implicit retain.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e \n if event is not a valid event object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clRetainEvent",
          "package": "OpenCL",
          "signature": "CLEvent -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Event.html#clRetainEvent",
          "type": "function"
        },
        "index": {
          "description": "Increments the event reference count The OpenCL commands that return an event perform an implicit retain Returns True if the function is executed successfully It returns False if event is not valid event object",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clRetainEvent",
          "normalized": "CLEvent-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Event",
          "signature": "CLEvent-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clRetainEvent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWaits on the host thread for commands identified by event objects in \n event_list to complete. A command is considered complete if its execution \n status is \u003ccode\u003e\u003ca\u003eCL_COMPLETE\u003c/a\u003e\u003c/code\u003e or a negative value.\n Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function was executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e\n if the list of events is empty, or if events specified in event_list do not \n belong to the same context, or if event objects specified in event_list are \n not valid event objects.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clWaitForEvents",
          "package": "OpenCL",
          "signature": "[CLEvent] -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Event.html#clWaitForEvents",
          "type": "function"
        },
        "index": {
          "description": "Waits on the host thread for commands identified by event objects in event list to complete command is considered complete if its execution status is CL COMPLETE or negative value Returns True if the function was executed successfully It returns False if the list of events is empty or if events specified in event list do not belong to the same context or if event objects specified in event list are not valid event objects",
          "hierarchy": "Control Parallel OpenCL Event",
          "module": "Control.Parallel.OpenCL.Event",
          "name": "clWaitForEvents",
          "normalized": "[CLEvent]-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Wait For Events",
          "signature": "[CLEvent]-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Event.html#v:clWaitForEvents"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "Memory",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Memory.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "Memory",
          "package": "OpenCL",
          "partial": "Memory",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLAddressingMode",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLAddressingMode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLAddressingMode",
          "package": "OpenCL",
          "partial": "CLAddressing Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecifies the number of channels and the channel layout i.e. the memory\nlayout in which channels are stored in the image. Valid values are described in\nthe table below.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_R\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_A\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INTENSITY\u003c/a\u003e\u003c/code\u003e, This format can only be used if channel data type =\n\u003ccode\u003e\u003ca\u003eCL_UNORM_INT8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_UNORM_INT16\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_SNORM_INT8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_SNORM_INT16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eCL_HALF_FLOAT\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eCL_FLOAT\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_LUMINANCE\u003c/a\u003e\u003c/code\u003e, This format can only be used if channel data type =\n\u003ccode\u003e\u003ca\u003eCL_UNORM_INT8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_UNORM_INT16\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_SNORM_INT8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_SNORM_INT16\u003c/a\u003e\u003c/code\u003e,\n\u003ccode\u003e\u003ca\u003eCL_HALF_FLOAT\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eCL_FLOAT\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_RG\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_RA\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_RGB\u003c/a\u003e\u003c/code\u003e, This format can only be used if channel data type =\n\u003ccode\u003e\u003ca\u003eCL_UNORM_SHORT_565\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_UNORM_SHORT_555\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003eCL_UNORM_INT101010\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_RGBA\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_ARGB\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_BGRA\u003c/a\u003e\u003c/code\u003e. This format can only be used if channel data type =\n\u003ccode\u003e\u003ca\u003eCL_UNORM_INT8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_SNORM_INT8\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_SIGNED_INT8\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eCL_UNSIGNED_INT8\u003c/a\u003e\u003c/code\u003e.  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLChannelOrder",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "data"
        },
        "index": {
          "description": "Specifies the number of channels and the channel layout i.e the memory layout in which channels are stored in the image Valid values are described in the table below CL CL CL INTENSITY This format can only be used if channel data type CL UNORM INT8 CL UNORM INT16 CL SNORM INT8 CL SNORM INT16 CL HALF FLOAT or CL FLOAT CL LUMINANCE This format can only be used if channel data type CL UNORM INT8 CL UNORM INT16 CL SNORM INT8 CL SNORM INT16 CL HALF FLOAT or CL FLOAT CL RG CL RA CL RGB This format can only be used if channel data type CL UNORM SHORT CL UNORM SHORT or CL UNORM INT101010 CL RGBA CL ARGB CL BGRA This format can only be used if channel data type CL UNORM INT8 CL SNORM INT8 CL SIGNED INT8 or CL UNSIGNED INT8",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLChannelOrder",
          "package": "OpenCL",
          "partial": "CLChannel Order",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLChannelOrder"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the size of the channel data type. The number of bits per element\ndetermined by the image_channel_data_type and image_channel_order must be a\npower of two. The list of supported values is described in the table below.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SNORM_INT8\u003c/a\u003e\u003c/code\u003e, Each channel component is a normalized signed 8-bit integer\nvalue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SNORM_INT16\u003c/a\u003e\u003c/code\u003e, Each channel component is a normalized signed 16-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNORM_INT8\u003c/a\u003e\u003c/code\u003e, Each channel component is a normalized unsigned 8-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNORM_INT16\u003c/a\u003e\u003c/code\u003e, Each channel component is a normalized unsigned 16-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNORM_SHORT_565\u003c/a\u003e\u003c/code\u003e, Represents a normalized 5-6-5 3-channel RGB image. The\nchannel order must be \u003ccode\u003e\u003ca\u003eCL_RGB\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNORM_SHORT_555\u003c/a\u003e\u003c/code\u003e, Represents a normalized x-5-5-5 4-channel xRGB\nimage. The channel order must be \u003ccode\u003e\u003ca\u003eCL_RGB\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNORM_INT_101010\u003c/a\u003e\u003c/code\u003e, Represents a normalized x-10-10-10 4-channel xRGB\nimage. The channel order must be \u003ccode\u003e\u003ca\u003eCL_RGB\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SIGNED_INT8\u003c/a\u003e\u003c/code\u003e, Each channel component is an unnormalized signed 8-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SIGNED_INT16\u003c/a\u003e\u003c/code\u003e, Each channel component is an unnormalized signed 16-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SIGNED_INT32\u003c/a\u003e\u003c/code\u003e, Each channel component is an unnormalized signed 32-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNSIGNED_INT8\u003c/a\u003e\u003c/code\u003e, Each channel component is an unnormalized unsigned 8-bit\ninteger value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNSIGNED_INT16\u003c/a\u003e\u003c/code\u003e, Each channel component is an unnormalized unsigned\n16-bit integer value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_UNSIGNED_INT32\u003c/a\u003e\u003c/code\u003e, Each channel component is an unnormalized unsigned\n32-bit integer value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_HALF_FLOAT\u003c/a\u003e\u003c/code\u003e, Each channel component is a 16-bit half-float value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FLOAT\u003c/a\u003e\u003c/code\u003e, Each channel component is a single precision floating-point\nvalue.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLChannelType",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "data"
        },
        "index": {
          "description": "Describes the size of the channel data type The number of bits per element determined by the image channel data type and image channel order must be power of two The list of supported values is described in the table below CL SNORM INT8 Each channel component is normalized signed bit integer value CL SNORM INT16 Each channel component is normalized signed bit integer value CL UNORM INT8 Each channel component is normalized unsigned bit integer value CL UNORM INT16 Each channel component is normalized unsigned bit integer value CL UNORM SHORT Represents normalized channel RGB image The channel order must be CL RGB CL UNORM SHORT Represents normalized x-5-5-5 channel xRGB image The channel order must be CL RGB CL UNORM INT Represents normalized x-10-10-10 channel xRGB image The channel order must be CL RGB CL SIGNED INT8 Each channel component is an unnormalized signed bit integer value CL SIGNED INT16 Each channel component is an unnormalized signed bit integer value CL SIGNED INT32 Each channel component is an unnormalized signed bit integer value CL UNSIGNED INT8 Each channel component is an unnormalized unsigned bit integer value CL UNSIGNED INT16 Each channel component is an unnormalized unsigned bit integer value CL UNSIGNED INT32 Each channel component is an unnormalized unsigned bit integer value CL HALF FLOAT Each channel component is bit half-float value CL FLOAT Each channel component is single precision floating-point value",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLChannelType",
          "package": "OpenCL",
          "partial": "CLChannel Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLChannelType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLFilterMode",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLFilterMode",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLFilterMode",
          "package": "OpenCL",
          "partial": "CLFilter Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLFilterMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLImageFormat",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLImageFormat",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLImageFormat",
          "package": "OpenCL",
          "partial": "CLImage Format",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLImageFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLMem",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMem",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLMem",
          "package": "OpenCL",
          "partial": "CLMem",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLMem"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_READ_WRITE\u003c/a\u003e\u003c/code\u003e, This flag specifies that the memory object will be\nread and written by a kernel. This is the default.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_WRITE_ONLY\u003c/a\u003e\u003c/code\u003e, This flags specifies that the memory object will be\nwritten but not read by a kernel. Reading from a buffer or image object created\nwith \u003ccode\u003eCLMEM_WRITE_ONLY\u003c/code\u003e inside a kernel is undefined.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_READ_ONLY\u003c/a\u003e\u003c/code\u003e, This flag specifies that the memory object is a read-only\nmemory object when used inside a kernel. Writing to a buffer or image object\ncreated with \u003ccode\u003eCLMEM_READ_ONLY\u003c/code\u003e inside a kernel is undefined.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e, This flag is valid only if host_ptr is not NULL. If\nspecified, it indicates that the application wants the OpenCL implementation to\nuse memory referenced by host_ptr as the storage bits for the memory\nobject. OpenCL implementations are allowed to cache the buffer contents pointed\nto by host_ptr in device memory. This cached copy can be used when kernels are\nexecuted on a device. The result of OpenCL commands that operate on multiple\nbuffer objects created with the same host_ptr or overlapping host regions is\nconsidered to be undefined.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_ALLOC_HOST_PTR\u003c/a\u003e\u003c/code\u003e, This flag specifies that the application wants the\nOpenCL implementation to allocate memory from host accessible\nmemory. \u003ccode\u003e\u003ca\u003eCL_MEM_ALLOC_HOST_PTR\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e are mutually exclusive.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e, This flag is valid only if host_ptr is not NULL. If\nspecified, it indicates that the application wants the OpenCL implementation to\nallocate memory for the memory object and copy the data from memory referenced\nby host_ptr. \u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e are mutually\nexclusive. \u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e can be used with \u003ccode\u003e\u003ca\u003eCL_MEM_ALLOC_HOST_PTR\u003c/a\u003e\u003c/code\u003e to\ninitialize the contents of the cl_mem object allocated using host-accessible\n(e.g. PCIe) memory.  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLMemFlag",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "data"
        },
        "index": {
          "description": "CL MEM READ WRITE This flag specifies that the memory object will be read and written by kernel This is the default CL MEM WRITE ONLY This flags specifies that the memory object will be written but not read by kernel Reading from buffer or image object created with CLMEM WRITE ONLY inside kernel is undefined CL MEM READ ONLY This flag specifies that the memory object is read-only memory object when used inside kernel Writing to buffer or image object created with CLMEM READ ONLY inside kernel is undefined CL MEM USE HOST PTR This flag is valid only if host ptr is not NULL If specified it indicates that the application wants the OpenCL implementation to use memory referenced by host ptr as the storage bits for the memory object OpenCL implementations are allowed to cache the buffer contents pointed to by host ptr in device memory This cached copy can be used when kernels are executed on device The result of OpenCL commands that operate on multiple buffer objects created with the same host ptr or overlapping host regions is considered to be undefined CL MEM ALLOC HOST PTR This flag specifies that the application wants the OpenCL implementation to allocate memory from host accessible memory CL MEM ALLOC HOST PTR and CL MEM USE HOST PTR are mutually exclusive CL MEM COPY HOST PTR This flag is valid only if host ptr is not NULL If specified it indicates that the application wants the OpenCL implementation to allocate memory for the memory object and copy the data from memory referenced by host ptr CL MEM COPY HOST PTR and CL MEM USE HOST PTR are mutually exclusive CL MEM COPY HOST PTR can be used with CL MEM ALLOC HOST PTR to initialize the contents of the cl mem object allocated using host-accessible e.g PCIe memory",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLMemFlag",
          "package": "OpenCL",
          "partial": "CLMem Flag",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLMemFlag"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_OBJECT_BUFFER\u003c/a\u003e\u003c/code\u003e if memobj is created with \u003ccode\u003eclCreateBuffer\u003c/code\u003e. \n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_OBJECT_IMAGE2D\u003c/a\u003e\u003c/code\u003e if memobj is created with \u003ccode\u003eclCreateImage2D\u003c/code\u003e \n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_OBJECT_IMAGE3D\u003c/a\u003e\u003c/code\u003e if memobj is created with \u003ccode\u003eclCreateImage3D\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLMemObjectType",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemObjectType",
          "type": "data"
        },
        "index": {
          "description": "CL MEM OBJECT BUFFER if memobj is created with clCreateBuffer CL MEM OBJECT IMAGE2D if memobj is created with clCreateImage2D CL MEM OBJECT IMAGE3D if memobj is created with clCreateImage3D",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLMemObjectType",
          "package": "OpenCL",
          "partial": "CLMem Object Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLMemObjectType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLSampler",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLSampler",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLSampler",
          "package": "OpenCL",
          "partial": "CLSampler",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#t:CLSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLImageFormat",
          "package": "OpenCL",
          "signature": "CLImageFormat",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLImageFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CLImageFormat",
          "package": "OpenCL",
          "partial": "CLImage Format",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CLImageFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_A",
          "package": "OpenCL",
          "signature": "CL_A",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_A",
          "package": "OpenCL",
          "partial": "CL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_A"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_CLAMP",
          "package": "OpenCL",
          "signature": "CL_ADDRESS_CLAMP",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_CLAMP",
          "package": "OpenCL",
          "partial": "CL ADDRESS CLAMP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_ADDRESS_CLAMP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_CLAMP_TO_EDGE",
          "package": "OpenCL",
          "signature": "CL_ADDRESS_CLAMP_TO_EDGE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_CLAMP_TO_EDGE",
          "package": "OpenCL",
          "partial": "CL ADDRESS CLAMP TO EDGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_ADDRESS_CLAMP_TO_EDGE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_NONE",
          "package": "OpenCL",
          "signature": "CL_ADDRESS_NONE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_NONE",
          "package": "OpenCL",
          "partial": "CL ADDRESS NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_ADDRESS_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_REPEAT",
          "package": "OpenCL",
          "signature": "CL_ADDRESS_REPEAT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLAddressingMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ADDRESS_REPEAT",
          "package": "OpenCL",
          "partial": "CL ADDRESS REPEAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_ADDRESS_REPEAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ARGB",
          "package": "OpenCL",
          "signature": "CL_ARGB",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_ARGB",
          "package": "OpenCL",
          "partial": "CL ARGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_ARGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_BGRA",
          "package": "OpenCL",
          "signature": "CL_BGRA",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_BGRA",
          "package": "OpenCL",
          "partial": "CL BGRA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_BGRA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_FILTER_LINEAR",
          "package": "OpenCL",
          "signature": "CL_FILTER_LINEAR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLFilterMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_FILTER_LINEAR",
          "package": "OpenCL",
          "partial": "CL FILTER LINEAR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_FILTER_LINEAR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_FILTER_NEAREST",
          "package": "OpenCL",
          "signature": "CL_FILTER_NEAREST",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLFilterMode",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_FILTER_NEAREST",
          "package": "OpenCL",
          "partial": "CL FILTER NEAREST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_FILTER_NEAREST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_FLOAT",
          "package": "OpenCL",
          "signature": "CL_FLOAT",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_FLOAT",
          "package": "OpenCL",
          "partial": "CL FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_FLOAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_HALF_FLOAT",
          "package": "OpenCL",
          "signature": "CL_HALF_FLOAT",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_HALF_FLOAT",
          "package": "OpenCL",
          "partial": "CL HALF FLOAT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_HALF_FLOAT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_INTENSITY",
          "package": "OpenCL",
          "signature": "CL_INTENSITY",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_INTENSITY",
          "package": "OpenCL",
          "partial": "CL INTENSITY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_INTENSITY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_LUMINANCE",
          "package": "OpenCL",
          "signature": "CL_LUMINANCE",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_LUMINANCE",
          "package": "OpenCL",
          "partial": "CL LUMINANCE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_LUMINANCE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_ALLOC_HOST_PTR",
          "package": "OpenCL",
          "signature": "CL_MEM_ALLOC_HOST_PTR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_ALLOC_HOST_PTR",
          "package": "OpenCL",
          "partial": "CL MEM ALLOC HOST PTR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_ALLOC_HOST_PTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_COPY_HOST_PTR",
          "package": "OpenCL",
          "signature": "CL_MEM_COPY_HOST_PTR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_COPY_HOST_PTR",
          "package": "OpenCL",
          "partial": "CL MEM COPY HOST PTR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_COPY_HOST_PTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_OBJECT_BUFFER",
          "package": "OpenCL",
          "signature": "CL_MEM_OBJECT_BUFFER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemObjectType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_OBJECT_BUFFER",
          "package": "OpenCL",
          "partial": "CL MEM OBJECT BUFFER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_OBJECT_BUFFER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_OBJECT_IMAGE2D",
          "package": "OpenCL",
          "signature": "CL_MEM_OBJECT_IMAGE2D",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemObjectType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_OBJECT_IMAGE2D",
          "package": "OpenCL",
          "partial": "CL MEM OBJECT IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_OBJECT_IMAGE2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_OBJECT_IMAGE3D",
          "package": "OpenCL",
          "signature": "CL_MEM_OBJECT_IMAGE3D",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemObjectType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_OBJECT_IMAGE3D",
          "package": "OpenCL",
          "partial": "CL MEM OBJECT IMAGE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_OBJECT_IMAGE3D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_READ_ONLY",
          "package": "OpenCL",
          "signature": "CL_MEM_READ_ONLY",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_READ_ONLY",
          "package": "OpenCL",
          "partial": "CL MEM READ ONLY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_READ_ONLY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_READ_WRITE",
          "package": "OpenCL",
          "signature": "CL_MEM_READ_WRITE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_READ_WRITE",
          "package": "OpenCL",
          "partial": "CL MEM READ WRITE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_READ_WRITE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_USE_HOST_PTR",
          "package": "OpenCL",
          "signature": "CL_MEM_USE_HOST_PTR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_USE_HOST_PTR",
          "package": "OpenCL",
          "partial": "CL MEM USE HOST PTR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_USE_HOST_PTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_WRITE_ONLY",
          "package": "OpenCL",
          "signature": "CL_MEM_WRITE_ONLY",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLMemFlag",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_MEM_WRITE_ONLY",
          "package": "OpenCL",
          "partial": "CL MEM WRITE ONLY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_MEM_WRITE_ONLY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_R",
          "package": "OpenCL",
          "signature": "CL_R",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_R",
          "package": "OpenCL",
          "partial": "CL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_R"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RA",
          "package": "OpenCL",
          "signature": "CL_RA",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RA",
          "package": "OpenCL",
          "partial": "CL RA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_RA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RG",
          "package": "OpenCL",
          "signature": "CL_RG",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RG",
          "package": "OpenCL",
          "partial": "CL RG",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_RG"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RGB",
          "package": "OpenCL",
          "signature": "CL_RGB",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RGB",
          "package": "OpenCL",
          "partial": "CL RGB",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_RGB"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RGBA",
          "package": "OpenCL",
          "signature": "CL_RGBA",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelOrder",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_RGBA",
          "package": "OpenCL",
          "partial": "CL RGBA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_RGBA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SIGNED_INT16",
          "package": "OpenCL",
          "signature": "CL_SIGNED_INT16",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SIGNED_INT16",
          "package": "OpenCL",
          "partial": "CL SIGNED INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_SIGNED_INT16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SIGNED_INT32",
          "package": "OpenCL",
          "signature": "CL_SIGNED_INT32",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SIGNED_INT32",
          "package": "OpenCL",
          "partial": "CL SIGNED INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_SIGNED_INT32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SIGNED_INT8",
          "package": "OpenCL",
          "signature": "CL_SIGNED_INT8",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SIGNED_INT8",
          "package": "OpenCL",
          "partial": "CL SIGNED INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_SIGNED_INT8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SNORM_INT16",
          "package": "OpenCL",
          "signature": "CL_SNORM_INT16",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SNORM_INT16",
          "package": "OpenCL",
          "partial": "CL SNORM INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_SNORM_INT16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SNORM_INT8",
          "package": "OpenCL",
          "signature": "CL_SNORM_INT8",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_SNORM_INT8",
          "package": "OpenCL",
          "partial": "CL SNORM INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_SNORM_INT8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_INT16",
          "package": "OpenCL",
          "signature": "CL_UNORM_INT16",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_INT16",
          "package": "OpenCL",
          "partial": "CL UNORM INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNORM_INT16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_INT8",
          "package": "OpenCL",
          "signature": "CL_UNORM_INT8",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_INT8",
          "package": "OpenCL",
          "partial": "CL UNORM INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNORM_INT8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_INT_101010",
          "package": "OpenCL",
          "signature": "CL_UNORM_INT_101010",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_INT_101010",
          "package": "OpenCL",
          "partial": "CL UNORM INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNORM_INT_101010"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_SHORT_555",
          "package": "OpenCL",
          "signature": "CL_UNORM_SHORT_555",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_SHORT_555",
          "package": "OpenCL",
          "partial": "CL UNORM SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNORM_SHORT_555"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_SHORT_565",
          "package": "OpenCL",
          "signature": "CL_UNORM_SHORT_565",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNORM_SHORT_565",
          "package": "OpenCL",
          "partial": "CL UNORM SHORT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNORM_SHORT_565"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNSIGNED_INT16",
          "package": "OpenCL",
          "signature": "CL_UNSIGNED_INT16",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNSIGNED_INT16",
          "package": "OpenCL",
          "partial": "CL UNSIGNED INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNSIGNED_INT16"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNSIGNED_INT32",
          "package": "OpenCL",
          "signature": "CL_UNSIGNED_INT32",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNSIGNED_INT32",
          "package": "OpenCL",
          "partial": "CL UNSIGNED INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNSIGNED_INT32"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNSIGNED_INT8",
          "package": "OpenCL",
          "signature": "CL_UNSIGNED_INT8",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLChannelType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "CL_UNSIGNED_INT8",
          "package": "OpenCL",
          "partial": "CL UNSIGNED INT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:CL_UNSIGNED_INT8"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a buffer object. Returns a valid non-zero buffer object if the\nbuffer object is created successfully. Otherwise, it throws the \u003ccode\u003eCLError\u003c/code\u003e: \n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if values specified in flags are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_BUFFER_SIZE\u003c/code\u003e if size is 0 or is greater than\n\u003ccode\u003eclDeviceMaxMemAllocSize\u003c/code\u003e value for all devices in context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_HOST_PTR\u003c/code\u003e if host_ptr is NULL and \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e are set in flags or if host_ptr is not NULL but\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e are not set in flags.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor buffer object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateBuffer",
          "package": "OpenCL",
          "signature": "CLContext -\u003e [CLMemFlag] -\u003e (a, Ptr ()) -\u003e IO CLMem",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clCreateBuffer",
          "type": "function"
        },
        "index": {
          "description": "Creates buffer object Returns valid non-zero buffer object if the buffer object is created successfully Otherwise it throws the CLError CL INVALID CONTEXT if context is not valid context CL INVALID VALUE if values specified in flags are not valid CL INVALID BUFFER SIZE if size is or is greater than clDeviceMaxMemAllocSize value for all devices in context CL INVALID HOST PTR if host ptr is NULL and CL MEM USE HOST PTR or CL MEM COPY HOST PTR are set in flags or if host ptr is not NULL but CL MEM COPY HOST PTR or CL MEM USE HOST PTR are not set in flags CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for buffer object CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateBuffer",
          "normalized": "CLContext-\u003e[CLMemFlag]-\u003e(a,Ptr())-\u003eIO CLMem",
          "package": "OpenCL",
          "partial": "Create Buffer",
          "signature": "CLContext-\u003e[CLMemFlag]-\u003e(a,Ptr())-\u003eIO CLMem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clCreateBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates an OpenCL buffer object from an OpenGL buffer object. Returns a valid non-zero OpenCL buffer object if the buffer object is created successfully. Otherwise it throws the \u003ccode\u003eCLError\u003c/code\u003e:\n * \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context or was not created from a GL context.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if values specified in flags are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_GL_OBJECT\u003c/code\u003e if bufobj is not a GL buffer object or is a GL buffer object but does not have an existing data store.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_RESOURCES\u003c/code\u003e if there is a failure to allocate resources required by the OpenCL implementation on the device.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required by the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateFromGLBuffer",
          "package": "OpenCL",
          "signature": "CLContext -\u003e [CLMemFlag] -\u003e a -\u003e IO CLMem",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clCreateFromGLBuffer",
          "type": "function"
        },
        "index": {
          "description": "Creates an OpenCL buffer object from an OpenGL buffer object Returns valid non-zero OpenCL buffer object if the buffer object is created successfully Otherwise it throws the CLError CL INVALID CONTEXT if context is not valid context or was not created from GL context CL INVALID VALUE if values specified in flags are not valid CL INVALID GL OBJECT if bufobj is not GL buffer object or is GL buffer object but does not have an existing data store CL OUT OF RESOURCES if there is failure to allocate resources required by the OpenCL implementation on the device CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateFromGLBuffer",
          "normalized": "CLContext-\u003e[CLMemFlag]-\u003ea-\u003eIO CLMem",
          "package": "OpenCL",
          "partial": "Create From GLBuffer",
          "signature": "CLContext-\u003e[CLMemFlag]-\u003ea-\u003eIO CLMem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clCreateFromGLBuffer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a 2D OpenCL image object from an existing OpenGL texture.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclCreateFromGLTexture2D\u003c/a\u003e\u003c/code\u003e returns a non-zero image object if the image\nobject is created successfully. Otherwise, it throws one of the\nfollowing \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context or was not\ncreated from a GL context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if values specified in flags are not valid or if\nvalue specified in texture_target is not one of the values specified\nin the description of texture_target.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MIPLEVEL\u003c/code\u003e if miplevel is less than the value of\nlevelbase (for OpenGL implementations) or zero (for OpenGL ES\nimplementations); or greater than the value of q (for both OpenGL and\nOpenGL ES). levelbase and q are defined for the texture in section\n3.8.10 (Texture Completeness) of the OpenGL 2.1 specification and\nsection 3.7.10 of the OpenGL ES 2.0 specification.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MIPLEVEL\u003c/code\u003e if miplevel is greater than zero and the\nOpenGL implementation does not support creating from non-zero mipmap\nlevels.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_GL_OBJECT\u003c/code\u003e if texture is not a GL texture object whose\ntype matches texture_target, if the specified miplevel of texture is\nnot defined, or if the width or height of the specified miplevel is\nzero.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_IMAGE_FORMAT_DESCRIPTOR\u003c/code\u003e if the OpenGL texture internal\nformat does not map to a supported OpenCL image format.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources\nrequired by the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateFromGLTexture2D",
          "package": "OpenCL",
          "signature": "CLContext-\u003e [CLMemFlag]-\u003e a-\u003e b-\u003e c-\u003e IO CLMem",
          "type": "function"
        },
        "index": {
          "description": "Creates OpenCL image object from an existing OpenGL texture clCreateFromGLTexture2D returns non-zero image object if the image object is created successfully Otherwise it throws one of the following CLError exceptions CL INVALID CONTEXT if context is not valid context or was not created from GL context CL INVALID VALUE if values specified in flags are not valid or if value specified in texture target is not one of the values specified in the description of texture target CL INVALID MIPLEVEL if miplevel is less than the value of levelbase for OpenGL implementations or zero for OpenGL ES implementations or greater than the value of for both OpenGL and OpenGL ES levelbase and are defined for the texture in section Texture Completeness of the OpenGL specification and section of the OpenGL ES specification CL INVALID MIPLEVEL if miplevel is greater than zero and the OpenGL implementation does not support creating from non-zero mipmap levels CL INVALID GL OBJECT if texture is not GL texture object whose type matches texture target if the specified miplevel of texture is not defined or if the width or height of the specified miplevel is zero CL INVALID IMAGE FORMAT DESCRIPTOR if the OpenGL texture internal format does not map to supported OpenCL image format CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateFromGLTexture2D",
          "normalized": "CLContext-\u003e[CLMemFlag]-\u003ea-\u003eb-\u003ec-\u003eIO CLMem",
          "package": "OpenCL",
          "partial": "Create From GLTexture",
          "signature": "CLContext-\u003e[CLMemFlag]-\u003ea-\u003eb-\u003ec-\u003eIO CLMem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clCreateFromGLTexture2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a 2D image object.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclCreateImage2D\u003c/a\u003e\u003c/code\u003e returns a valid non-zero image object created if the image\nobject is created successfully. Otherwise, it throws one of the following\n\u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if values specified in flags are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_IMAGE_FORMAT_DESCRIPTOR\u003c/code\u003e if values specified in image_format are\nnot valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_IMAGE_SIZE\u003c/code\u003e if image_width or image_height are 0 or if they\nexceed values specified in \u003ccode\u003eCL_DEVICE_IMAGE2D_MAX_WIDTH\u003c/code\u003e or\n\u003ccode\u003eCL_DEVICE_IMAGE2D_MAX_HEIGHT\u003c/code\u003e respectively for all devices in context or if\nvalues specified by image_row_pitch do not follow rules described in the\nargument description above.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_HOST_PTR\u003c/code\u003e if host_ptr is \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e are set in flags or if host_ptr is not \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e but\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e are not set in flags.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_IMAGE_FORMAT_NOT_SUPPORTED\u003c/code\u003e if the image_format is not supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor image object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if there are no devices in context that support images\n(i.e. \u003ccode\u003eCL_DEVICE_IMAGE_SUPPORT\u003c/code\u003e (specified in the table of OpenCL Device Queries\nfor \u003ccode\u003eclGetDeviceInfo\u003c/code\u003e) is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateImage2D",
          "package": "OpenCL",
          "signature": "CLContext-\u003e [CLMemFlag]-\u003e CLImageFormat-\u003e a-\u003e a-\u003e a-\u003e Ptr ()-\u003e IO CLMem",
          "type": "function"
        },
        "index": {
          "description": "Creates image object clCreateImage2D returns valid non-zero image object created if the image object is created successfully Otherwise it throws one of the following CLError exceptions CL INVALID CONTEXT if context is not valid context CL INVALID VALUE if values specified in flags are not valid CL INVALID IMAGE FORMAT DESCRIPTOR if values specified in image format are not valid CL INVALID IMAGE SIZE if image width or image height are or if they exceed values specified in CL DEVICE IMAGE2D MAX WIDTH or CL DEVICE IMAGE2D MAX HEIGHT respectively for all devices in context or if values specified by image row pitch do not follow rules described in the argument description above CL INVALID HOST PTR if host ptr is nullPtr and CL MEM USE HOST PTR or CL MEM COPY HOST PTR are set in flags or if host ptr is not nullPtr but CL MEM COPY HOST PTR or CL MEM USE HOST PTR are not set in flags CL IMAGE FORMAT NOT SUPPORTED if the image format is not supported CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for image object CL INVALID OPERATION if there are no devices in context that support images i.e CL DEVICE IMAGE SUPPORT specified in the table of OpenCL Device Queries for clGetDeviceInfo is False CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateImage2D",
          "normalized": "CLContext-\u003e[CLMemFlag]-\u003eCLImageFormat-\u003ea-\u003ea-\u003ea-\u003ePtr()-\u003eIO CLMem",
          "package": "OpenCL",
          "partial": "Create Image",
          "signature": "CLContext-\u003e[CLMemFlag]-\u003eCLImageFormat-\u003ea-\u003ea-\u003ea-\u003ePtr()-\u003eIO CLMem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clCreateImage2D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a 3D image object.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclCreateImage3D\u003c/a\u003e\u003c/code\u003e returns a valid non-zero image object created if the image\nobject is created successfully. Otherwise, it throws one of the following\n\u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if values specified in flags are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_IMAGE_FORMAT_DESCRIPTOR\u003c/code\u003e if values specified in image_format are\nnot valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_IMAGE_SIZE\u003c/code\u003e if image_width, image_height are 0 or if image_depth\nless than or equal to 1 or if they exceed values specified in\n\u003ccode\u003eCL_DEVICE_IMAGE3D_MAX_WIDTH\u003c/code\u003e, CL_DEVICE_IMAGE3D_MAX_HEIGHT' or\n\u003ccode\u003eCL_DEVICE_IMAGE3D_MAX_DEPTH\u003c/code\u003e respectively for all devices in context or if\nvalues specified by image_row_pitch and image_slice_pitch do not follow rules\ndescribed in the argument description above.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_HOST_PTR\u003c/code\u003e if host_ptr is \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e or\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e are set in flags or if host_ptr is not \u003ccode\u003e\u003ca\u003enullPtr\u003c/a\u003e\u003c/code\u003e but\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e are not set in flags.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_IMAGE_FORMAT_NOT_SUPPORTED\u003c/code\u003e if the image_format is not supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/code\u003e if there is a failure to allocate memory\nfor image object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if there are no devices in context that support images\n(i.e. \u003ccode\u003eCL_DEVICE_IMAGE_SUPPORT\u003c/code\u003e (specified in the table of OpenCL Device Queries\nfor clGetDeviceInfo) is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateImage3D",
          "package": "OpenCL",
          "signature": "CLContext-\u003e [CLMemFlag]-\u003e CLImageFormat-\u003e a-\u003e a-\u003e a-\u003e a-\u003e a-\u003e Ptr ()-\u003e IO CLMem",
          "type": "function"
        },
        "index": {
          "description": "Creates image object clCreateImage3D returns valid non-zero image object created if the image object is created successfully Otherwise it throws one of the following CLError exceptions CL INVALID CONTEXT if context is not valid context CL INVALID VALUE if values specified in flags are not valid CL INVALID IMAGE FORMAT DESCRIPTOR if values specified in image format are not valid CL INVALID IMAGE SIZE if image width image height are or if image depth less than or equal to or if they exceed values specified in CL DEVICE IMAGE3D MAX WIDTH CL DEVICE IMAGE3D MAX HEIGHT or CL DEVICE IMAGE3D MAX DEPTH respectively for all devices in context or if values specified by image row pitch and image slice pitch do not follow rules described in the argument description above CL INVALID HOST PTR if host ptr is nullPtr and CL MEM USE HOST PTR or CL MEM COPY HOST PTR are set in flags or if host ptr is not nullPtr but CL MEM COPY HOST PTR or CL MEM USE HOST PTR are not set in flags CL IMAGE FORMAT NOT SUPPORTED if the image format is not supported CL MEM OBJECT ALLOCATION FAILURE if there is failure to allocate memory for image object CL INVALID OPERATION if there are no devices in context that support images i.e CL DEVICE IMAGE SUPPORT specified in the table of OpenCL Device Queries for clGetDeviceInfo is False CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateImage3D",
          "normalized": "CLContext-\u003e[CLMemFlag]-\u003eCLImageFormat-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ePtr()-\u003eIO CLMem",
          "package": "OpenCL",
          "partial": "Create Image",
          "signature": "CLContext-\u003e[CLMemFlag]-\u003eCLImageFormat-\u003ea-\u003ea-\u003ea-\u003ea-\u003ea-\u003ePtr()-\u003eIO CLMem",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clCreateImage3D"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a sampler object. A sampler object describes how to sample an image\nwhen the image is read in the kernel. The built-in functions to read from an\nimage in a kernel take a sampler as an argument. The sampler arguments to the\nimage read function can be sampler objects created using OpenCL functions and\npassed as argument values to the kernel or can be samplers declared inside a\nkernel. In this section we discuss how sampler objects are created using OpenCL\nfunctions.\n\u003c/p\u003e\u003cp\u003eReturns a valid non-zero sampler object if the sampler object is created\nsuccessfully. Otherwise, it throws one of the following \u003ccode\u003eCLError\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if addressing_mode, filter_mode, or normalized_coords or a\ncombination of these argument values are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if images are not supported by any device associated\nwith context (i.e. \u003ccode\u003eCL_DEVICE_IMAGE_SUPPORT\u003c/code\u003e specified in the table of OpenCL\nDevice Queries for clGetDeviceInfo is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateSampler",
          "package": "OpenCL",
          "signature": "CLContext -\u003e Bool -\u003e CLAddressingMode -\u003e CLFilterMode -\u003e IO CLSampler",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clCreateSampler",
          "type": "function"
        },
        "index": {
          "description": "Creates sampler object sampler object describes how to sample an image when the image is read in the kernel The built-in functions to read from an image in kernel take sampler as an argument The sampler arguments to the image read function can be sampler objects created using OpenCL functions and passed as argument values to the kernel or can be samplers declared inside kernel In this section we discuss how sampler objects are created using OpenCL functions Returns valid non-zero sampler object if the sampler object is created successfully Otherwise it throws one of the following CLError exceptions CL INVALID CONTEXT if context is not valid context CL INVALID VALUE if addressing mode filter mode or normalized coords or combination of these argument values are not valid CL INVALID OPERATION if images are not supported by any device associated with context i.e CL DEVICE IMAGE SUPPORT specified in the table of OpenCL Device Queries for clGetDeviceInfo is False CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clCreateSampler",
          "normalized": "CLContext-\u003eBool-\u003eCLAddressingMode-\u003eCLFilterMode-\u003eIO CLSampler",
          "package": "OpenCL",
          "partial": "Create Sampler",
          "signature": "CLContext-\u003eBool-\u003eCLAddressingMode-\u003eCLFilterMode-\u003eIO CLSampler",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clCreateSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn depth of the image in pixels. For a 2D image, depth equals 0.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_DEPTH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageDepth",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageDepth",
          "type": "function"
        },
        "index": {
          "description": "Return depth of the image in pixels For image depth equals This function execute OpenCL clGetImageInfo with CL IMAGE DEPTH",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageDepth",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Image Depth",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn size of each element of the image memory object given by image. An\n element is made up of n channels. The value of n is given in \u003ccode\u003e\u003ca\u003eCLImageFormat\u003c/a\u003e\u003c/code\u003e\n descriptor.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_ELEMENT_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageElementSize",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageElementSize",
          "type": "function"
        },
        "index": {
          "description": "Return size of each element of the image memory object given by image An element is made up of channels The value of is given in CLImageFormat descriptor This function execute OpenCL clGetImageInfo with CL IMAGE ELEMENT SIZE",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageElementSize",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Image Element Size",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageElementSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn image format descriptor specified when image is created with\n clCreateImage2D or clCreateImage3D.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_FORMAT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageFormat",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CLImageFormat",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageFormat",
          "type": "function"
        },
        "index": {
          "description": "Return image format descriptor specified when image is created with clCreateImage2D or clCreateImage3D This function execute OpenCL clGetImageInfo with CL IMAGE FORMAT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageFormat",
          "normalized": "CLMem-\u003eIO CLImageFormat",
          "package": "OpenCL",
          "partial": "Get Image Format",
          "signature": "CLMem-\u003eIO CLImageFormat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageFormat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn height of image in pixels.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_HEIGHT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageHeight",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageHeight",
          "type": "function"
        },
        "index": {
          "description": "Return height of image in pixels This function execute OpenCL clGetImageInfo with CL IMAGE HEIGHT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageHeight",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Image Height",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn size in bytes of a row of elements of the image object given by\n image.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_ROW_PITCH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageRowPitch",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageRowPitch",
          "type": "function"
        },
        "index": {
          "description": "Return size in bytes of row of elements of the image object given by image This function execute OpenCL clGetImageInfo with CL IMAGE ROW PITCH",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageRowPitch",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Image Row Pitch",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageRowPitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn size in bytes of a 2D slice for the 3D image object given by\n image. For a 2D image object this value will be 0.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_SLICE_PITCH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageSlicePitch",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageSlicePitch",
          "type": "function"
        },
        "index": {
          "description": "Return size in bytes of slice for the image object given by image For image object this value will be This function execute OpenCL clGetImageInfo with CL IMAGE SLICE PITCH",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageSlicePitch",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Image Slice Pitch",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageSlicePitch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn width of image in pixels.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetImageInfo with \u003ccode\u003eCL_IMAGE_WIDTH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageWidth",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetImageWidth",
          "type": "function"
        },
        "index": {
          "description": "Return width of image in pixels This function execute OpenCL clGetImageInfo with CL IMAGE WIDTH",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetImageWidth",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Image Width",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetImageWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn context specified when memory object is created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_CONTEXT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemContext",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemContext",
          "type": "function"
        },
        "index": {
          "description": "Return context specified when memory object is created This function execute OpenCL clGetMemObjectInfo with CL MEM CONTEXT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemContext",
          "normalized": "CLMem-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Get Mem Context",
          "signature": "CLMem-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the flags argument value specified when memobj was created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_FLAGS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemFlags",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO [CLMemFlag]",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemFlags",
          "type": "function"
        },
        "index": {
          "description": "Return the flags argument value specified when memobj was created This function execute OpenCL clGetMemObjectInfo with CL MEM FLAGS",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemFlags",
          "normalized": "CLMem-\u003eIO[CLMemFlag]",
          "package": "OpenCL",
          "partial": "Get Mem Flags",
          "signature": "CLMem-\u003eIO[CLMemFlag]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemFlags"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the host_ptr argument value specified when memobj is created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_HOST_PTR\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemHostPtr",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO (Ptr ())",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemHostPtr",
          "type": "function"
        },
        "index": {
          "description": "Return the host ptr argument value specified when memobj is created This function execute OpenCL clGetMemObjectInfo with CL MEM HOST PTR",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemHostPtr",
          "normalized": "CLMem-\u003eIO(Ptr())",
          "package": "OpenCL",
          "partial": "Get Mem Host Ptr",
          "signature": "CLMem-\u003eIO(Ptr())",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemHostPtr"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMap count. The map count returned should be considered immediately\n stale. It is unsuitable for general use in applications. This feature is\n provided for debugging.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_MAP_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemMapCount",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemMapCount",
          "type": "function"
        },
        "index": {
          "description": "Map count The map count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for debugging This function execute OpenCL clGetMemObjectInfo with CL MEM MAP COUNT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemMapCount",
          "normalized": "CLMem-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Mem Map Count",
          "signature": "CLMem-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemMapCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn memobj reference count. The reference count returned should be\n considered immediately stale. It is unsuitable for general use in\n applications. This feature is provided for identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemReferenceCount",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return memobj reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetMemObjectInfo with CL MEM REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemReferenceCount",
          "normalized": "CLMem-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Mem Reference Count",
          "signature": "CLMem-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn actual size of memobj in bytes.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemSize",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemSize",
          "type": "function"
        },
        "index": {
          "description": "Return actual size of memobj in bytes This function execute OpenCL clGetMemObjectInfo with CL MEM SIZE",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemSize",
          "normalized": "CLMem-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Mem Size",
          "signature": "CLMem-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the mem object type.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetMemObjectInfo with \u003ccode\u003eCL_MEM_TYPE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemType",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO CLMemObjectType",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetMemType",
          "type": "function"
        },
        "index": {
          "description": "Returns the mem object type This function execute OpenCL clGetMemObjectInfo with CL MEM TYPE",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetMemType",
          "normalized": "CLMem-\u003eIO CLMemObjectType",
          "package": "OpenCL",
          "partial": "Get Mem Type",
          "signature": "CLMem-\u003eIO CLMemObjectType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetMemType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value specified by addressing_mode argument to clCreateSampler.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetSamplerInfo with\n \u003ccode\u003eCL_SAMPLER_ADDRESSING_MODE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerAddressingMode",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO CLAddressingMode",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetSamplerAddressingMode",
          "type": "function"
        },
        "index": {
          "description": "Return the value specified by addressing mode argument to clCreateSampler This function execute OpenCL clGetSamplerInfo with CL SAMPLER ADDRESSING MODE",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerAddressingMode",
          "normalized": "CLSampler-\u003eIO CLAddressingMode",
          "package": "OpenCL",
          "partial": "Get Sampler Addressing Mode",
          "signature": "CLSampler-\u003eIO CLAddressingMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetSamplerAddressingMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the context specified when the sampler is created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetSamplerInfo with \u003ccode\u003eCL_SAMPLER_CONTEXT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerContext",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetSamplerContext",
          "type": "function"
        },
        "index": {
          "description": "Return the context specified when the sampler is created This function execute OpenCL clGetSamplerInfo with CL SAMPLER CONTEXT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerContext",
          "normalized": "CLSampler-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Get Sampler Context",
          "signature": "CLSampler-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetSamplerContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value specified by filter_mode argument to clCreateSampler.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetSamplerInfo with \u003ccode\u003eCL_SAMPLER_FILTER_MODE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerFilterMode",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO CLFilterMode",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetSamplerFilterMode",
          "type": "function"
        },
        "index": {
          "description": "Return the value specified by filter mode argument to clCreateSampler This function execute OpenCL clGetSamplerInfo with CL SAMPLER FILTER MODE",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerFilterMode",
          "normalized": "CLSampler-\u003eIO CLFilterMode",
          "package": "OpenCL",
          "partial": "Get Sampler Filter Mode",
          "signature": "CLSampler-\u003eIO CLFilterMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetSamplerFilterMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the value specified by normalized_coords argument to\n clCreateSampler.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetSamplerInfo with\n \u003ccode\u003eCL_SAMPLER_NORMALIZED_COORDS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerNormalizedCoords",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetSamplerNormalizedCoords",
          "type": "function"
        },
        "index": {
          "description": "Return the value specified by normalized coords argument to clCreateSampler This function execute OpenCL clGetSamplerInfo with CL SAMPLER NORMALIZED COORDS",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerNormalizedCoords",
          "normalized": "CLSampler-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Get Sampler Normalized Coords",
          "signature": "CLSampler-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetSamplerNormalizedCoords"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the sampler reference count. The reference count returned should be\n considered immediately stale. It is unsuitable for general use in\n applications. This feature is provided for identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetSamplerInfo with\n \u003ccode\u003eCL_SAMPLER_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerReferenceCount",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clGetSamplerReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return the sampler reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetSamplerInfo with CL SAMPLER REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSamplerReferenceCount",
          "normalized": "CLSampler-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Sampler Reference Count",
          "signature": "CLSampler-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetSamplerReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet the list of image formats supported by an OpenCL\nimplementation. \u003ccode\u003e\u003ca\u003eclGetSupportedImageFormats\u003c/a\u003e\u003c/code\u003e can be used to get the list of\nimage formats supported by an OpenCL implementation when the following\ninformation about an image memory object is specified:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Context\n * Image type - 2D or 3D image\n * Image object allocation information\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThrows \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context, throws\n\u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if flags or image_type are not valid.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSupportedImageFormats",
          "package": "OpenCL",
          "signature": "CLContext-\u003e [CLMemFlag]-\u003e CLMemObjectType-\u003e IO [CLImageFormat]",
          "type": "function"
        },
        "index": {
          "description": "Get the list of image formats supported by an OpenCL implementation clGetSupportedImageFormats can be used to get the list of image formats supported by an OpenCL implementation when the following information about an image memory object is specified Context Image type or image Image object allocation information Throws CL INVALID CONTEXT if context is not valid context throws CL INVALID VALUE if flags or image type are not valid",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clGetSupportedImageFormats",
          "normalized": "CLContext-\u003e[CLMemFlag]-\u003eCLMemObjectType-\u003eIO[CLImageFormat]",
          "package": "OpenCL",
          "partial": "Get Supported Image Formats",
          "signature": "CLContext-\u003e[CLMemFlag]-\u003eCLMemObjectType-\u003eIO[CLImageFormat]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clGetSupportedImageFormats"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrements the memory object reference count. After the memobj reference\n count becomes zero and commands queued for execution on a command-queue(s)\n that use memobj have finished, the memory object is deleted. Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e\n if the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if memobj is not\n a valid memory object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clReleaseMemObject",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clReleaseMemObject",
          "type": "function"
        },
        "index": {
          "description": "Decrements the memory object reference count After the memobj reference count becomes zero and commands queued for execution on command-queue that use memobj have finished the memory object is deleted Returns True if the function is executed successfully It returns False if memobj is not valid memory object",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clReleaseMemObject",
          "normalized": "CLMem-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Mem Object",
          "signature": "CLMem-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clReleaseMemObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrements the sampler reference count. The sampler object is deleted after\n the reference count becomes zero and commands queued for execution on a\n command-queue(s) that use sampler have finished. \u003ccode\u003e\u003ca\u003eclReleaseSampler\u003c/a\u003e\u003c/code\u003e returns\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if\n sampler is not a valid sampler object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clReleaseSampler",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clReleaseSampler",
          "type": "function"
        },
        "index": {
          "description": "Decrements the sampler reference count The sampler object is deleted after the reference count becomes zero and commands queued for execution on command-queue that use sampler have finished clReleaseSampler returns True if the function is executed successfully It returns False if sampler is not valid sampler object",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clReleaseSampler",
          "normalized": "CLSampler-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Sampler",
          "signature": "CLSampler-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clReleaseSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrements the memory object reference count. returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the\n function is executed successfully. After the memobj reference count becomes\n zero and commands queued for execution on a command-queue(s) that use memobj\n have finished, the memory object is deleted. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if memobj is\n not a valid memory object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clRetainMemObject",
          "package": "OpenCL",
          "signature": "CLMem -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clRetainMemObject",
          "type": "function"
        },
        "index": {
          "description": "Increments the memory object reference count returns True if the function is executed successfully After the memobj reference count becomes zero and commands queued for execution on command-queue that use memobj have finished the memory object is deleted It returns False if memobj is not valid memory object",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clRetainMemObject",
          "normalized": "CLMem-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Mem Object",
          "signature": "CLMem-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clRetainMemObject"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrements the sampler reference count. \u003ccode\u003e\u003ca\u003eclCreateSampler\u003c/a\u003e\u003c/code\u003e does an implicit\n retain. Returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. It returns\n \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if sampler is not a valid sampler object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clRetainSampler",
          "package": "OpenCL",
          "signature": "CLSampler -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Memory.html#clRetainSampler",
          "type": "function"
        },
        "index": {
          "description": "Increments the sampler reference count clCreateSampler does an implicit retain Returns True if the function is executed successfully It returns False if sampler is not valid sampler object",
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "clRetainSampler",
          "normalized": "CLSampler-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Sampler",
          "signature": "CLSampler-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:clRetainSampler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "image_channel_data_type",
          "package": "OpenCL",
          "signature": "CLChannelType",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLImageFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "image_channel_data_type",
          "package": "OpenCL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:image_channel_data_type"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "image_channel_order",
          "package": "OpenCL",
          "signature": "CLChannelOrder",
          "source": "src/Control-Parallel-OpenCL-Memory.html#CLImageFormat",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Memory",
          "module": "Control.Parallel.OpenCL.Memory",
          "name": "image_channel_order",
          "package": "OpenCL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Memory.html#v:image_channel_order"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "Program",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Program.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "Program",
          "package": "OpenCL",
          "partial": "Program",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_BUILD_NONE\u003c/a\u003e\u003c/code\u003e. The build status returned if no build has been performed\non the specified program object for device.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_BUILD_ERROR\u003c/a\u003e\u003c/code\u003e. The build status returned if the last call to\n\u003ccode\u003eclBuildProgram\u003c/code\u003e on the specified program object for device generated an error.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_BUILD_SUCCESS\u003c/a\u003e\u003c/code\u003e. The build status retrned if the last call to\n\u003ccode\u003eclBuildProgram\u003c/code\u003e on the specified program object for device was successful.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_BUILD_IN_PROGRESS\u003c/a\u003e\u003c/code\u003e. The build status returned if the last call to \n\u003ccode\u003eclBuildProgram\u003c/code\u003e on the specified program object for device has not finished.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CLBuildStatus",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLBuildStatus",
          "type": "data"
        },
        "index": {
          "description": "CL BUILD NONE The build status returned if no build has been performed on the specified program object for device CL BUILD ERROR The build status returned if the last call to clBuildProgram on the specified program object for device generated an error CL BUILD SUCCESS The build status retrned if the last call to clBuildProgram on the specified program object for device was successful CL BUILD IN PROGRESS The build status returned if the last call to clBuildProgram on the specified program object for device has not finished",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CLBuildStatus",
          "package": "OpenCL",
          "partial": "CLBuild Status",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#t:CLBuildStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CLKernel",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLKernel",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CLKernel",
          "package": "OpenCL",
          "partial": "CLKernel",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#t:CLKernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CLProgram",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLProgram",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CLProgram",
          "package": "OpenCL",
          "partial": "CLProgram",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#t:CLProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_ERROR",
          "package": "OpenCL",
          "signature": "CL_BUILD_ERROR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLBuildStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_ERROR",
          "package": "OpenCL",
          "partial": "CL BUILD ERROR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:CL_BUILD_ERROR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_IN_PROGRESS",
          "package": "OpenCL",
          "signature": "CL_BUILD_IN_PROGRESS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLBuildStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_IN_PROGRESS",
          "package": "OpenCL",
          "partial": "CL BUILD IN PROGRESS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:CL_BUILD_IN_PROGRESS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_NONE",
          "package": "OpenCL",
          "signature": "CL_BUILD_NONE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLBuildStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_NONE",
          "package": "OpenCL",
          "partial": "CL BUILD NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:CL_BUILD_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_SUCCESS",
          "package": "OpenCL",
          "signature": "CL_BUILD_SUCCESS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLBuildStatus",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "CL_BUILD_SUCCESS",
          "package": "OpenCL",
          "partial": "CL BUILD SUCCESS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:CL_BUILD_SUCCESS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eBuilds (compiles and links) a program executable from the program source or\nbinary. OpenCL allows program executables to be built using the source or the\nbinary. The build options are categorized as pre-processor options, options for\nmath intrinsics, options that control optimization and miscellaneous\noptions. This specification defines a standard set of options that must be\nsupported by an OpenCL compiler when building program executables online or\noffline. These may be extended by a set of vendor- or platform-specific options.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Preprocessor Options\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThese options control the OpenCL preprocessor which is run on each program\nsource before actual compilation. -D options are processed in the order they are\ngiven in the options argument to clBuildProgram.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e-D name\u003c/dt\u003e\u003cdd\u003e Predefine name as a macro, with definition 1.\n\u003c/dd\u003e\u003cdt\u003e-D name=definition\u003c/dt\u003e\u003cdd\u003e The contents of definition are tokenized and processed as\nif they appeared during translation phase three in a `#define' directive. In\nparticular, the definition will be truncated by embedded newline characters.\n\u003c/dd\u003e\u003cdt\u003e-I dir\u003c/dt\u003e\u003cdd\u003e Add the directory dir to the list of directories to be searched for\nheader files.\n\u003c/dd\u003e\u003c/dl\u003e\u003cul\u003e\u003cli\u003e Math Intrinsics Options\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThese options control compiler behavior regarding floating-point\narithmetic. These options trade off between speed and correctness.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e-cl-single-precision-constant\u003c/dt\u003e\u003cdd\u003e Treat double precision floating-point constant\nas single precision constant.\n\u003c/dd\u003e\u003cdt\u003e-cl-denorms-are-zero\u003c/dt\u003e\u003cdd\u003e This option controls how single precision and double\nprecision denormalized numbers are handled. If specified as a build option, the\nsingle precision denormalized numbers may be flushed to zero and if the optional\nextension for double precision is supported, double precision denormalized\nnumbers may also be flushed to zero. This is intended to be a performance hint\nand the OpenCL compiler can choose not to flush denorms to zero if the device\nsupports single precision (or double precision) denormalized numbers.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThis option is ignored for single precision numbers if the device does not\nsupport single precision denormalized numbers i.e. \u003ccode\u003eCL_FP_DENORM\u003c/code\u003e bit is not set\nin \u003ccode\u003eclGetDeviceSingleFPConfig\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis option is ignored for double precision numbers if the device does not\nsupport double precision or if it does support double precison but\n\u003ccode\u003eCL_FP_DENORM\u003c/code\u003e bit is not set in \u003ccode\u003eclGetDeviceDoubleFPConfig\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis flag only applies for scalar and vector single precision floating-point\nvariables and computations on these floating-point variables inside a\nprogram. It does not apply to reading from or writing to image objects.\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e Optimization Options\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThese options control various sorts of optimizations. Turning on optimization\nflags makes the compiler attempt to improve the performance and/or code size at\nthe expense of compilation time and possibly the ability to debug the program.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e-cl-opt-disable\u003c/dt\u003e\u003cdd\u003e This option disables all optimizations. The default is\noptimizations are enabled.\n\u003c/dd\u003e\u003cdt\u003e-cl-strict-aliasing\u003c/dt\u003e\u003cdd\u003e This option allows the compiler to assume the strictest\naliasing rules.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eThe following options control compiler behavior regarding floating-point\narithmetic. These options trade off between performance and correctness and must\nbe specifically enabled. These options are not turned on by default since it can\nresult in incorrect output for programs which depend on an exact implementation\nof IEEE 754 rules/specifications for math functions.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e-cl-mad-enable\u003c/dt\u003e\u003cdd\u003e Allow a * b + c to be replaced by a mad. The mad computes a *\nb + c with reduced accuracy. For example, some OpenCL devices implement mad as\ntruncate the result of a * b before adding it to c.\n\u003c/dd\u003e\u003cdt\u003e-cl-no-signed-zeros\u003c/dt\u003e\u003cdd\u003e Allow optimizations for floating-point arithmetic that\nignore the signedness of zero. IEEE 754 arithmetic specifies the behavior of\ndistinct +0.0 and -0.0 values, which then prohibits simplification of\nexpressions such as x+0.0 or 0.0*x (even with -clfinite-math only). This option\nimplies that the sign of a zero result isn't significant.\n\u003c/dd\u003e\u003cdt\u003e-cl-unsafe-math-optimizations\u003c/dt\u003e\u003cdd\u003e Allow optimizations for floating-point\narithmetic that (a) assume that arguments and results are valid, (b) may violate\nIEEE 754 standard and (c) may violate the OpenCL numerical compliance\nrequirements as defined in section 7.4 for single-precision floating-point,\nsection 9.3.9 for double-precision floating-point, and edge case behavior in\nsection 7.5. This option includes the -cl-no-signed-zeros and -cl-mad-enable\noptions.\n\u003c/dd\u003e\u003cdt\u003e-cl-finite-math-only\u003c/dt\u003e\u003cdd\u003e Allow optimizations for floating-point arithmetic that\nassume that arguments and results are not NaNs or &#177;&#8734;. This option may violatethe OpenCL numerical compliance requirements defined in in section 7.4 for\nsingle-precision floating-point, section 9.3.9 for double-precision\nfloating-point, and edge case behavior in section 7.5.\n\u003c/dd\u003e\u003cdt\u003e-cl-fast-relaxed-math\u003c/dt\u003e\u003cdd\u003e Sets the optimization options -cl-finite-math-only and\n-cl-unsafe-math-optimizations. This allows optimizations for floating-point\narithmetic that may violate the IEEE 754 standard and the OpenCL numerical\ncompliance requirements defined in the specification in section 7.4 for\nsingle-precision floating-point, section 9.3.9 for double-precision\nfloating-point, and edge case behavior in section 7.5. This option causes the\npreprocessor macro __FAST_RELAXED_MATH__ to be defined in the OpenCL program.\n\u003c/dd\u003e\u003c/dl\u003e\u003cul\u003e\u003cli\u003e Options to Request or Suppress Warnings\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eWarnings are diagnostic messages that report constructions which are not\ninherently erroneous but which are risky or suggest there may have been an\nerror. The following languageindependent options do not enable specific warnings\nbut control the kinds of diagnostics produced by the OpenCL compiler.\n\u003c/p\u003e\u003cdl\u003e\u003cdt\u003e-w\u003c/dt\u003e\u003cdd\u003e Inhibit all warning messages.\n\u003c/dd\u003e\u003cdt\u003e-Werror\u003c/dt\u003e\u003cdd\u003e Make all warnings into errors.\n\u003c/dd\u003e\u003c/dl\u003e\u003cp\u003eclBuildProgram can throw the following \u003ccode\u003e\u003ca\u003eCLError\u003c/a\u003e\u003c/code\u003e exceptions when fails:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_PROGRAM\u003c/code\u003e if program is not a valid program object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_DEVICE\u003c/code\u003e if OpenCL devices listed in device_list are not in the\nlist of devices associated with program.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_BINARY\u003c/code\u003e if program is created with\n\u003ccode\u003eclCreateWithProgramWithBinary\u003c/code\u003e and devices listed in device_list do not have a\nvalid program binary loaded.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_BUILD_OPTIONS\u003c/code\u003e if the build options specified by options are\ninvalid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if the build of a program executable for any of the\ndevices listed in device_list by a previous call to \u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e for program\nhas not completed.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_COMPILER_NOT_AVAILABLE\u003c/code\u003e if program is created with\n\u003ccode\u003e\u003ca\u003eclCreateProgramWithSource\u003c/a\u003e\u003c/code\u003e and a compiler is not available\ni.e. \u003ccode\u003eclGetDeviceCompilerAvailable\u003c/code\u003e is set to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_BUILD_PROGRAM_FAILURE\u003c/code\u003e if there is a failure to build the program\nexecutable. This error will be returned if \u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e does not return\nuntil the build has completed.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if there are kernel objects attached to program.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clBuildProgram",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e [CLDeviceID] -\u003e String -\u003e IO ()",
          "source": "src/Control-Parallel-OpenCL-Program.html#clBuildProgram",
          "type": "function"
        },
        "index": {
          "description": "Builds compiles and links program executable from the program source or binary OpenCL allows program executables to be built using the source or the binary The build options are categorized as pre-processor options options for math intrinsics options that control optimization and miscellaneous options This specification defines standard set of options that must be supported by an OpenCL compiler when building program executables online or offline These may be extended by set of vendor or platform-specific options Preprocessor Options These options control the OpenCL preprocessor which is run on each program source before actual compilation options are processed in the order they are given in the options argument to clBuildProgram name Predefine name as macro with definition name definition The contents of definition are tokenized and processed as if they appeared during translation phase three in define directive In particular the definition will be truncated by embedded newline characters dir Add the directory dir to the list of directories to be searched for header files Math Intrinsics Options These options control compiler behavior regarding floating-point arithmetic These options trade off between speed and correctness cl-single-precision-constant Treat double precision floating-point constant as single precision constant cl-denorms-are-zero This option controls how single precision and double precision denormalized numbers are handled If specified as build option the single precision denormalized numbers may be flushed to zero and if the optional extension for double precision is supported double precision denormalized numbers may also be flushed to zero This is intended to be performance hint and the OpenCL compiler can choose not to flush denorms to zero if the device supports single precision or double precision denormalized numbers This option is ignored for single precision numbers if the device does not support single precision denormalized numbers i.e CL FP DENORM bit is not set in clGetDeviceSingleFPConfig This option is ignored for double precision numbers if the device does not support double precision or if it does support double precison but CL FP DENORM bit is not set in clGetDeviceDoubleFPConfig This flag only applies for scalar and vector single precision floating-point variables and computations on these floating-point variables inside program It does not apply to reading from or writing to image objects Optimization Options These options control various sorts of optimizations Turning on optimization flags makes the compiler attempt to improve the performance and or code size at the expense of compilation time and possibly the ability to debug the program cl-opt-disable This option disables all optimizations The default is optimizations are enabled cl-strict-aliasing This option allows the compiler to assume the strictest aliasing rules The following options control compiler behavior regarding floating-point arithmetic These options trade off between performance and correctness and must be specifically enabled These options are not turned on by default since it can result in incorrect output for programs which depend on an exact implementation of IEEE rules specifications for math functions cl-mad-enable Allow to be replaced by mad The mad computes with reduced accuracy For example some OpenCL devices implement mad as truncate the result of before adding it to cl-no-signed-zeros Allow optimizations for floating-point arithmetic that ignore the signedness of zero IEEE arithmetic specifies the behavior of distinct and values which then prohibits simplification of expressions such as or even with clfinite-math only This option implies that the sign of zero result isn significant cl-unsafe-math-optimizations Allow optimizations for floating-point arithmetic that assume that arguments and results are valid may violate IEEE standard and may violate the OpenCL numerical compliance requirements as defined in section for single-precision floating-point section for double-precision floating-point and edge case behavior in section This option includes the cl-no-signed-zeros and cl-mad-enable options cl-finite-math-only Allow optimizations for floating-point arithmetic that assume that arguments and results are not NaNs or This option may violatethe OpenCL numerical compliance requirements defined in in section for single-precision floating-point section for double-precision floating-point and edge case behavior in section cl-fast-relaxed-math Sets the optimization options cl-finite-math-only and cl-unsafe-math-optimizations This allows optimizations for floating-point arithmetic that may violate the IEEE standard and the OpenCL numerical compliance requirements defined in the specification in section for single-precision floating-point section for double-precision floating-point and edge case behavior in section This option causes the preprocessor macro FAST RELAXED MATH to be defined in the OpenCL program Options to Request or Suppress Warnings Warnings are diagnostic messages that report constructions which are not inherently erroneous but which are risky or suggest there may have been an error The following languageindependent options do not enable specific warnings but control the kinds of diagnostics produced by the OpenCL compiler Inhibit all warning messages Werror Make all warnings into errors clBuildProgram can throw the following CLError exceptions when fails CL INVALID PROGRAM if program is not valid program object CL INVALID DEVICE if OpenCL devices listed in device list are not in the list of devices associated with program CL INVALID BINARY if program is created with clCreateWithProgramWithBinary and devices listed in device list do not have valid program binary loaded CL INVALID BUILD OPTIONS if the build options specified by options are invalid CL INVALID OPERATION if the build of program executable for any of the devices listed in device list by previous call to clBuildProgram for program has not completed CL COMPILER NOT AVAILABLE if program is created with clCreateProgramWithSource and compiler is not available i.e clGetDeviceCompilerAvailable is set to False CL BUILD PROGRAM FAILURE if there is failure to build the program executable This error will be returned if clBuildProgram does not return until the build has completed CL INVALID OPERATION if there are kernel objects attached to program CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clBuildProgram",
          "normalized": "CLProgram-\u003e[CLDeviceID]-\u003eString-\u003eIO()",
          "package": "OpenCL",
          "partial": "Build Program",
          "signature": "CLProgram-\u003e[CLDeviceID]-\u003eString-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clBuildProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a kernal object. A kernel is a function declared in a program. A\nkernel is identified by the __kernel qualifier applied to any function in a\nprogram. A kernel object encapsulates the specific __kernel function declared in\na program and the argument values to be used when executing this __kernel\nfunction.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclCreateKernel\u003c/a\u003e\u003c/code\u003e returns a valid non-zero kernel object if the kernel object is\ncreated successfully. Otherwise, it throws one of the following \u003ccode\u003e\u003ca\u003eCLError\u003c/a\u003e\u003c/code\u003e\nexceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_PROGRAM\u003c/code\u003e if program is not a valid program object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_PROGRAM_EXECUTABLE\u003c/code\u003e if there is no successfully built executable\n for program.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL_NAME\u003c/code\u003e if kernel_name is not found in program.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL_DEFINITION\u003c/code\u003e if the function definition for __kernel\nfunction given by kernel_name such as the number of arguments, the argument\ntypes are not the same for all devices for which the program executable has been\nbuilt.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateKernel",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e String -\u003e IO CLKernel",
          "source": "src/Control-Parallel-OpenCL-Program.html#clCreateKernel",
          "type": "function"
        },
        "index": {
          "description": "Creates kernal object kernel is function declared in program kernel is identified by the kernel qualifier applied to any function in program kernel object encapsulates the specific kernel function declared in program and the argument values to be used when executing this kernel function clCreateKernel returns valid non-zero kernel object if the kernel object is created successfully Otherwise it throws one of the following CLError exceptions CL INVALID PROGRAM if program is not valid program object CL INVALID PROGRAM EXECUTABLE if there is no successfully built executable for program CL INVALID KERNEL NAME if kernel name is not found in program CL INVALID KERNEL DEFINITION if the function definition for kernel function given by kernel name such as the number of arguments the argument types are not the same for all devices for which the program executable has been built CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateKernel",
          "normalized": "CLProgram-\u003eString-\u003eIO CLKernel",
          "package": "OpenCL",
          "partial": "Create Kernel",
          "signature": "CLProgram-\u003eString-\u003eIO CLKernel",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clCreateKernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates kernel objects for all kernel functions in a program object. Kernel\nobjects are not created for any __kernel functions in program that do not have\nthe same function definition across all devices for which a program executable\nhas been successfully built.\n\u003c/p\u003e\u003cp\u003eKernel objects can only be created once you have a program object with a valid\nprogram source or binary loaded into the program object and the program\nexecutable has been successfully built for one or more devices associated with\nprogram. No changes to the program executable are allowed while there are kernel\nobjects associated with a program object. This means that calls to\n\u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e return \u003ccode\u003eCL_INVALID_OPERATION\u003c/code\u003e if there are kernel objects\nattached to a program object. The OpenCL context associated with program will be\nthe context associated with kernel. The list of devices associated with program\nare the devices associated with kernel. Devices associated with a program object\nfor which a valid program executable has been built can be used to execute\nkernels declared in the program object.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclCreateKernelsInProgram\u003c/a\u003e\u003c/code\u003e will return the kernel objects if the kernel objects\nwere successfully allocated, throws \u003ccode\u003eCL_INVALID_PROGRAM\u003c/code\u003e if program is not a\nvalid program object, throws \u003ccode\u003eCL_INVALID_PROGRAM_EXECUTABLE\u003c/code\u003e if there is no\nsuccessfully built executable for any device in program and throws\n\u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required by\nthe OpenCL implementation on the host.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateKernelsInProgram",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO [CLKernel]",
          "source": "src/Control-Parallel-OpenCL-Program.html#clCreateKernelsInProgram",
          "type": "function"
        },
        "index": {
          "description": "Creates kernel objects for all kernel functions in program object Kernel objects are not created for any kernel functions in program that do not have the same function definition across all devices for which program executable has been successfully built Kernel objects can only be created once you have program object with valid program source or binary loaded into the program object and the program executable has been successfully built for one or more devices associated with program No changes to the program executable are allowed while there are kernel objects associated with program object This means that calls to clBuildProgram return CL INVALID OPERATION if there are kernel objects attached to program object The OpenCL context associated with program will be the context associated with kernel The list of devices associated with program are the devices associated with kernel Devices associated with program object for which valid program executable has been built can be used to execute kernels declared in the program object clCreateKernelsInProgram will return the kernel objects if the kernel objects were successfully allocated throws CL INVALID PROGRAM if program is not valid program object throws CL INVALID PROGRAM EXECUTABLE if there is no successfully built executable for any device in program and throws CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateKernelsInProgram",
          "normalized": "CLProgram-\u003eIO[CLKernel]",
          "package": "OpenCL",
          "partial": "Create Kernels In Program",
          "signature": "CLProgram-\u003eIO[CLKernel]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clCreateKernelsInProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a program object for a context, and loads specified binary data into\nthe program object.\n\u003c/p\u003e\u003cp\u003eThe program binaries specified by binaries contain the bits that describe the\nprogram executable that will be run on the device(s) associated with\ncontext. The program binary can consist of either or both of device-specific\nexecutable(s), and/or implementation-specific intermediate representation (IR)\nwhich will be converted to the device-specific executable.\n\u003c/p\u003e\u003cp\u003eOpenCL allows applications to create a program object using the program\nsource or binary and build appropriate program executables. This allows\napplications to determine whether they want to use the pre-built offline binary\nor load and compile the program source and use the executable compiled/linked\nonline as the program executable. This can be very useful as it allows\napplications to load and build program executables online on its first instance\nfor appropriate OpenCL devices in the system. These executables can now be\nqueried and cached by the application. Future instances of the application\nlaunching will no longer need to compile and build the program executables. The\ncached executables can be read and loaded by the application, which can help\nsignificantly reduce the application initialization time.\n\u003c/p\u003e\u003cp\u003eReturns a valid non-zero program object and a list of \u003ccode\u003e\u003ca\u003eCLError\u003c/a\u003e\u003c/code\u003e values whether\nthe program binary for each device specified in device_list was loaded\nsuccessfully or not. It is list of the same length the list of devices with\n\u003ccode\u003eCL_SUCCESS\u003c/code\u003e if binary was successfully loaded for device specified by same\nposition; otherwise returns \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if length of binary is zero or\n\u003ccode\u003eCL_INVALID_BINARY\u003c/code\u003e if program binary is not a valid binary\nfor the specified device.\n\u003c/p\u003e\u003cp\u003eThe function can throw on of the following \u003ccode\u003e\u003ca\u003eCLError\u003c/a\u003e\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context.  \n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_VALUE\u003c/code\u003e if the device list is empty; or if lengths or binaries are\nempty.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_DEVICE\u003c/code\u003e if OpenCL devices listed in the device list are not in\nthe list of devices associated with context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_BINARY\u003c/code\u003e if an invalid program binary was encountered for any\ndevice.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateProgramWithBinary",
          "package": "OpenCL",
          "signature": "CLContext -\u003e [CLDeviceID] -\u003e [[Word8]] -\u003e IO (CLProgram, [CLError])",
          "source": "src/Control-Parallel-OpenCL-Program.html#clCreateProgramWithBinary",
          "type": "function"
        },
        "index": {
          "description": "Creates program object for context and loads specified binary data into the program object The program binaries specified by binaries contain the bits that describe the program executable that will be run on the device associated with context The program binary can consist of either or both of device-specific executable and or implementation-specific intermediate representation IR which will be converted to the device-specific executable OpenCL allows applications to create program object using the program source or binary and build appropriate program executables This allows applications to determine whether they want to use the pre-built offline binary or load and compile the program source and use the executable compiled linked online as the program executable This can be very useful as it allows applications to load and build program executables online on its first instance for appropriate OpenCL devices in the system These executables can now be queried and cached by the application Future instances of the application launching will no longer need to compile and build the program executables The cached executables can be read and loaded by the application which can help significantly reduce the application initialization time Returns valid non-zero program object and list of CLError values whether the program binary for each device specified in device list was loaded successfully or not It is list of the same length the list of devices with CL SUCCESS if binary was successfully loaded for device specified by same position otherwise returns CL INVALID VALUE if length of binary is zero or CL INVALID BINARY if program binary is not valid binary for the specified device The function can throw on of the following CLError exceptions CL INVALID CONTEXT if context is not valid context CL INVALID VALUE if the device list is empty or if lengths or binaries are empty CL INVALID DEVICE if OpenCL devices listed in the device list are not in the list of devices associated with context CL INVALID BINARY if an invalid program binary was encountered for any device CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateProgramWithBinary",
          "normalized": "CLContext-\u003e[CLDeviceID]-\u003e[[Word]]-\u003eIO(CLProgram,[CLError])",
          "package": "OpenCL",
          "partial": "Create Program With Binary",
          "signature": "CLContext-\u003e[CLDeviceID]-\u003e[[Word]]-\u003eIO(CLProgram,[CLError])",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clCreateProgramWithBinary"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a program object for a context, and loads the source code specified\nby the text strings in the strings array into the program object. The devices\nassociated with the program object are the devices associated with context.\n\u003c/p\u003e\u003cp\u003eOpenCL allows applications to create a program object using the program source\nor binary and build appropriate program executables. This allows applications to\ndetermine whether they want to use the pre-built offline binary or load and\ncompile the program source and use the executable compiled/linked online as the\nprogram executable. This can be very useful as it allows applications to load\nand build program executables online on its first instance for appropriate\nOpenCL devices in the system. These executables can now be queried and cached by\nthe application. Future instances of the application launching will no longer\nneed to compile and build the program executables. The cached executables can be\nread and loaded by the application, which can help significantly reduce the\napplication initialization time.\n\u003c/p\u003e\u003cp\u003eAn OpenCL program consists of a set of kernels that are identified as functions\ndeclared with the __kernel qualifier in the program source. OpenCL programs may\nalso contain auxiliary functions and constant data that can be used by __kernel\nfunctions. The program executable can be generated online or offline by the\nOpenCL compiler for the appropriate target device(s).\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclCreateProgramWithSource\u003c/a\u003e\u003c/code\u003e returns a valid non-zero program object if the\nprogram object is created successfully. Otherwise, it throws one of the\nfollowing \u003ccode\u003e\u003ca\u003eCLError\u003c/a\u003e\u003c/code\u003e exceptions:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_CONTEXT\u003c/code\u003e if context is not a valid context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_OUT_OF_HOST_MEMORY\u003c/code\u003e if there is a failure to allocate resources required\nby the OpenCL implementation on the host.  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateProgramWithSource",
          "package": "OpenCL",
          "signature": "CLContext -\u003e String -\u003e IO CLProgram",
          "source": "src/Control-Parallel-OpenCL-Program.html#clCreateProgramWithSource",
          "type": "function"
        },
        "index": {
          "description": "Creates program object for context and loads the source code specified by the text strings in the strings array into the program object The devices associated with the program object are the devices associated with context OpenCL allows applications to create program object using the program source or binary and build appropriate program executables This allows applications to determine whether they want to use the pre-built offline binary or load and compile the program source and use the executable compiled linked online as the program executable This can be very useful as it allows applications to load and build program executables online on its first instance for appropriate OpenCL devices in the system These executables can now be queried and cached by the application Future instances of the application launching will no longer need to compile and build the program executables The cached executables can be read and loaded by the application which can help significantly reduce the application initialization time An OpenCL program consists of set of kernels that are identified as functions declared with the kernel qualifier in the program source OpenCL programs may also contain auxiliary functions and constant data that can be used by kernel functions The program executable can be generated online or offline by the OpenCL compiler for the appropriate target device clCreateProgramWithSource returns valid non-zero program object if the program object is created successfully Otherwise it throws one of the following CLError exceptions CL INVALID CONTEXT if context is not valid context CL OUT OF HOST MEMORY if there is failure to allocate resources required by the OpenCL implementation on the host",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clCreateProgramWithSource",
          "normalized": "CLContext-\u003eString-\u003eIO CLProgram",
          "package": "OpenCL",
          "partial": "Create Program With Source",
          "signature": "CLContext-\u003eString-\u003eIO CLProgram",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clCreateProgramWithSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the work-group size specified by the __attribute__((reqd_work_gr\n oup_size(X, Y, Z))) qualifier. See Function Qualifiers. If the work-group\n size is not specified using the above attribute qualifier (0, 0, 0) is\n returned.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelWorkGroupInfo with\n \u003ccode\u003eCL_KERNEL_COMPILE_WORK_GROUP_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelCompileWorkGroupSize",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e CLDeviceID -\u003e IO [CSize]",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelCompileWorkGroupSize",
          "type": "function"
        },
        "index": {
          "description": "Returns the work-group size specified by the attribute reqd work gr oup size qualifier See Function Qualifiers If the work-group size is not specified using the above attribute qualifier is returned This function execute OpenCL clGetKernelWorkGroupInfo with CL KERNEL COMPILE WORK GROUP SIZE",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelCompileWorkGroupSize",
          "normalized": "CLKernel-\u003eCLDeviceID-\u003eIO[CSize]",
          "package": "OpenCL",
          "partial": "Get Kernel Compile Work Group Size",
          "signature": "CLKernel-\u003eCLDeviceID-\u003eIO[CSize]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelCompileWorkGroupSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the context associated with kernel.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelInfo with \u003ccode\u003eCL_KERNEL_CONTEXT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelContext",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelContext",
          "type": "function"
        },
        "index": {
          "description": "Return the context associated with kernel This function execute OpenCL clGetKernelInfo with CL KERNEL CONTEXT",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelContext",
          "normalized": "CLKernel-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Get Kernel Context",
          "signature": "CLKernel-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the kernel function name.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelInfo with \u003ccode\u003eCL_KERNEL_FUNCTION_NAME\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelFunctionName",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelFunctionName",
          "type": "function"
        },
        "index": {
          "description": "Return the kernel function name This function execute OpenCL clGetKernelInfo with CL KERNEL FUNCTION NAME",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelFunctionName",
          "normalized": "CLKernel-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Kernel Function Name",
          "signature": "CLKernel-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelFunctionName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the amount of local memory in bytes being used by a kernel. This\n includes local memory that may be needed by an implementation to execute the\n kernel, variables declared inside the kernel with the __local address\n qualifier and local memory to be allocated for arguments to the kernel\n declared as pointers with the __local address qualifier and whose size is\n specified with \u003ccode\u003e\u003ca\u003eclSetKernelArg\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf the local memory size, for any pointer argument to the kernel declared\n with the __local address qualifier, is not specified, its size is assumed to\n be 0.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelWorkGroupInfo with\n \u003ccode\u003eCL_KERNEL_LOCAL_MEM_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelLocalMemSize",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e CLDeviceID -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelLocalMemSize",
          "type": "function"
        },
        "index": {
          "description": "Returns the amount of local memory in bytes being used by kernel This includes local memory that may be needed by an implementation to execute the kernel variables declared inside the kernel with the local address qualifier and local memory to be allocated for arguments to the kernel declared as pointers with the local address qualifier and whose size is specified with clSetKernelArg If the local memory size for any pointer argument to the kernel declared with the local address qualifier is not specified its size is assumed to be This function execute OpenCL clGetKernelWorkGroupInfo with CL KERNEL LOCAL MEM SIZE",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelLocalMemSize",
          "normalized": "CLKernel-\u003eCLDeviceID-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Kernel Local Mem Size",
          "signature": "CLKernel-\u003eCLDeviceID-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelLocalMemSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of arguments to kernel.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelInfo with \u003ccode\u003eCL_KERNEL_NUM_ARGS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelNumArgs",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelNumArgs",
          "type": "function"
        },
        "index": {
          "description": "Return the number of arguments to kernel This function execute OpenCL clGetKernelInfo with CL KERNEL NUM ARGS",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelNumArgs",
          "normalized": "CLKernel-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Kernel Num Args",
          "signature": "CLKernel-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelNumArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the program object associated with kernel.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelInfo with \u003ccode\u003eCL_KERNEL_PROGRAM\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelProgram",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO CLProgram",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelProgram",
          "type": "function"
        },
        "index": {
          "description": "Return the program object associated with kernel This function execute OpenCL clGetKernelInfo with CL KERNEL PROGRAM",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelProgram",
          "normalized": "CLKernel-\u003eIO CLProgram",
          "package": "OpenCL",
          "partial": "Get Kernel Program",
          "signature": "CLKernel-\u003eIO CLProgram",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the kernel reference count. The reference count returned should be\n considered immediately stale. It is unsuitable for general use in\n applications. This feature is provided for identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelInfo with\n \u003ccode\u003eCL_KERNEL_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelReferenceCount",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return the kernel reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetKernelInfo with CL KERNEL REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelReferenceCount",
          "normalized": "CLKernel-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Kernel Reference Count",
          "signature": "CLKernel-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis provides a mechanism for the application to query the work-group size\n that can be used to execute a kernel on a specific device given by\n device. The OpenCL implementation uses the resource requirements of the\n kernel (register usage etc.) to determine what this work-group size should\n be.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetKernelWorkGroupInfo with\n \u003ccode\u003eCL_KERNEL_WORK_GROUP_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelWorkGroupSize",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetKernelWorkGroupSize",
          "type": "function"
        },
        "index": {
          "description": "This provides mechanism for the application to query the work-group size that can be used to execute kernel on specific device given by device The OpenCL implementation uses the resource requirements of the kernel register usage etc to determine what this work-group size should be This function execute OpenCL clGetKernelWorkGroupInfo with CL KERNEL WORK GROUP SIZE",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetKernelWorkGroupSize",
          "normalized": "CLKernel-\u003eCLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Kernel Work Group Size",
          "signature": "CLKernel-\u003eCLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetKernelWorkGroupSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the program binaries for all devices associated with program. For\neach device in program, the binary returned can be the binary specified for the\ndevice when program is created with \u003ccode\u003e\u003ca\u003eclCreateProgramWithBinary\u003c/a\u003e\u003c/code\u003e or it can be the\nexecutable binary generated by \u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e. If program is created with\n\u003ccode\u003e\u003ca\u003eclCreateProgramWithSource\u003c/a\u003e\u003c/code\u003e, the binary returned is the binary generated by\n\u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e. The bits returned can be an implementation-specific\nintermediate representation (a.k.a. IR) or device specific executable bits or\nboth. The decision on which information is returned in the binary is up to the\nOpenCL implementation.\n\u003c/p\u003e\u003cp\u003eTo find out which device the program binary in the array refers to, use the\n\u003ccode\u003e\u003ca\u003eclGetProgramDevices\u003c/a\u003e\u003c/code\u003e query to get the list of devices. There is a one-to-one\ncorrespondence between the array of data returned by \u003ccode\u003e\u003ca\u003eclGetProgramBinaries\u003c/a\u003e\u003c/code\u003e and\narray of devices returned by \u003ccode\u003e\u003ca\u003eclGetProgramDevices\u003c/a\u003e\u003c/code\u003e.  \n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with \u003ccode\u003eCL_PROGRAM_BINARIES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBinaries",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO [[Word8]]",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramBinaries",
          "type": "function"
        },
        "index": {
          "description": "Return the program binaries for all devices associated with program For each device in program the binary returned can be the binary specified for the device when program is created with clCreateProgramWithBinary or it can be the executable binary generated by clBuildProgram If program is created with clCreateProgramWithSource the binary returned is the binary generated by clBuildProgram The bits returned can be an implementation-specific intermediate representation a.k.a IR or device specific executable bits or both The decision on which information is returned in the binary is up to the OpenCL implementation To find out which device the program binary in the array refers to use the clGetProgramDevices query to get the list of devices There is one-to-one correspondence between the array of data returned by clGetProgramBinaries and array of devices returned by clGetProgramDevices This function execute OpenCL clGetProgramInfo with CL PROGRAM BINARIES",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBinaries",
          "normalized": "CLProgram-\u003eIO[[Word]]",
          "package": "OpenCL",
          "partial": "Get Program Binaries",
          "signature": "CLProgram-\u003eIO[[Word]]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramBinaries"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns an array that contains the size in bytes of the program binary for\n each device associated with program. The size of the array is the number of\n devices associated with program. If a binary is not available for a\n device(s), a size of zero is returned.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with \u003ccode\u003eCL_PROGRAM_BINARY_SIZES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBinarySizes",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO [CSize]",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramBinarySizes",
          "type": "function"
        },
        "index": {
          "description": "Returns an array that contains the size in bytes of the program binary for each device associated with program The size of the array is the number of devices associated with program If binary is not available for device size of zero is returned This function execute OpenCL clGetProgramInfo with CL PROGRAM BINARY SIZES",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBinarySizes",
          "normalized": "CLProgram-\u003eIO[CSize]",
          "package": "OpenCL",
          "partial": "Get Program Binary Sizes",
          "signature": "CLProgram-\u003eIO[CSize]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramBinarySizes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the build log when \u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e was called for device. If build\n status of program for device is \u003ccode\u003e\u003ca\u003eCL_BUILD_NONE\u003c/a\u003e\u003c/code\u003e, an empty string is returned.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramBuildInfo with\n \u003ccode\u003eCL_PROGRAM_BUILD_LOG\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBuildLog",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramBuildLog",
          "type": "function"
        },
        "index": {
          "description": "Return the build log when clBuildProgram was called for device If build status of program for device is CL BUILD NONE an empty string is returned This function execute OpenCL clGetProgramBuildInfo with CL PROGRAM BUILD LOG",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBuildLog",
          "normalized": "CLProgram-\u003eCLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Program Build Log",
          "signature": "CLProgram-\u003eCLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramBuildLog"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the build options specified by the options argument in\n clBuildProgram for device. If build status of program for device is\n \u003ccode\u003e\u003ca\u003eCL_BUILD_NONE\u003c/a\u003e\u003c/code\u003e, an empty string is returned.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramBuildInfo with\n \u003ccode\u003eCL_PROGRAM_BUILD_OPTIONS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBuildOptions",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramBuildOptions",
          "type": "function"
        },
        "index": {
          "description": "Return the build options specified by the options argument in clBuildProgram for device If build status of program for device is CL BUILD NONE an empty string is returned This function execute OpenCL clGetProgramBuildInfo with CL PROGRAM BUILD OPTIONS",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBuildOptions",
          "normalized": "CLProgram-\u003eCLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Program Build Options",
          "signature": "CLProgram-\u003eCLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramBuildOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the build status of program for a specific device as given by\n device.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramBuildInfo with\n \u003ccode\u003eCL_PROGRAM_BUILD_STATUS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBuildStatus",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e CLDeviceID -\u003e IO CLBuildStatus",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramBuildStatus",
          "type": "function"
        },
        "index": {
          "description": "Returns the build status of program for specific device as given by device This function execute OpenCL clGetProgramBuildInfo with CL PROGRAM BUILD STATUS",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramBuildStatus",
          "normalized": "CLProgram-\u003eCLDeviceID-\u003eIO CLBuildStatus",
          "package": "OpenCL",
          "partial": "Get Program Build Status",
          "signature": "CLProgram-\u003eCLDeviceID-\u003eIO CLBuildStatus",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramBuildStatus"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the context specified when the program object is created.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with \u003ccode\u003eCL_PROGRAM_CONTEXT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramContext",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO CLContext",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramContext",
          "type": "function"
        },
        "index": {
          "description": "Return the context specified when the program object is created This function execute OpenCL clGetProgramInfo with CL PROGRAM CONTEXT",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramContext",
          "normalized": "CLProgram-\u003eIO CLContext",
          "package": "OpenCL",
          "partial": "Get Program Context",
          "signature": "CLProgram-\u003eIO CLContext",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the list of devices associated with the program object. This can be\n the devices associated with context on which the program object has been\n created or can be a subset of devices that are specified when a progam object\n is created using \u003ccode\u003e\u003ca\u003eclCreateProgramWithBinary\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with \u003ccode\u003eCL_PROGRAM_DEVICES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramDevices",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO [CLDeviceID]",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramDevices",
          "type": "function"
        },
        "index": {
          "description": "Return the list of devices associated with the program object This can be the devices associated with context on which the program object has been created or can be subset of devices that are specified when progam object is created using clCreateProgramWithBinary This function execute OpenCL clGetProgramInfo with CL PROGRAM DEVICES",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramDevices",
          "normalized": "CLProgram-\u003eIO[CLDeviceID]",
          "package": "OpenCL",
          "partial": "Get Program Devices",
          "signature": "CLProgram-\u003eIO[CLDeviceID]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramDevices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the number of devices associated with program.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with \u003ccode\u003eCL_PROGRAM_NUM_DEVICES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramNumDevices",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramNumDevices",
          "type": "function"
        },
        "index": {
          "description": "Return the number of devices associated with program This function execute OpenCL clGetProgramInfo with CL PROGRAM NUM DEVICES",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramNumDevices",
          "normalized": "CLProgram-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Program Num Devices",
          "signature": "CLProgram-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramNumDevices"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the program reference count. The reference count returned should be\n considered immediately stale. It is unsuitable for general use in\n applications. This feature is provided for identifying memory leaks.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with\n \u003ccode\u003eCL_PROGRAM_REFERENCE_COUNT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramReferenceCount",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramReferenceCount",
          "type": "function"
        },
        "index": {
          "description": "Return the program reference count The reference count returned should be considered immediately stale It is unsuitable for general use in applications This feature is provided for identifying memory leaks This function execute OpenCL clGetProgramInfo with CL PROGRAM REFERENCE COUNT",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramReferenceCount",
          "normalized": "CLProgram-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Program Reference Count",
          "signature": "CLProgram-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramReferenceCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturn the program source code specified by\n \u003ccode\u003e\u003ca\u003eclCreateProgramWithSource\u003c/a\u003e\u003c/code\u003e. The source string returned is a concatenation of\n all source strings specified to \u003ccode\u003e\u003ca\u003eclCreateProgramWithSource\u003c/a\u003e\u003c/code\u003e with a null\n terminator. The concatenation strips any nulls in the original source\n strings. The actual number of characters that represents the program source\n code including the null terminator is returned in param_value_size_ret.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetProgramInfo with \u003ccode\u003eCL_PROGRAM_SOURCE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramSource",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Program.html#clGetProgramSource",
          "type": "function"
        },
        "index": {
          "description": "Return the program source code specified by clCreateProgramWithSource The source string returned is concatenation of all source strings specified to clCreateProgramWithSource with null terminator The concatenation strips any nulls in the original source strings The actual number of characters that represents the program source code including the null terminator is returned in param value size ret This function execute OpenCL clGetProgramInfo with CL PROGRAM SOURCE",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clGetProgramSource",
          "normalized": "CLProgram-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Program Source",
          "signature": "CLProgram-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clGetProgramSource"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrements the kernel reference count. The kernel object is deleted once\n the number of instances that are retained to kernel become zero and the\n kernel object is no longer needed by any enqueued commands that use\n kernel. \u003ccode\u003e\u003ca\u003eclReleaseKernel\u003c/a\u003e\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed\n successfully.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clReleaseKernel",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Program.html#clReleaseKernel",
          "type": "function"
        },
        "index": {
          "description": "Decrements the kernel reference count The kernel object is deleted once the number of instances that are retained to kernel become zero and the kernel object is no longer needed by any enqueued commands that use kernel clReleaseKernel returns True if the function is executed successfully",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clReleaseKernel",
          "normalized": "CLKernel-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Kernel",
          "signature": "CLKernel-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clReleaseKernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDecrements the program reference count. The program object is deleted after \n all kernel objects associated with program have been deleted and the program \n reference count becomes zero. \u003ccode\u003eclReleseProgram\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if \n the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if program is not a \n valid program object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clReleaseProgram",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Program.html#clReleaseProgram",
          "type": "function"
        },
        "index": {
          "description": "Decrements the program reference count The program object is deleted after all kernel objects associated with program have been deleted and the program reference count becomes zero clReleseProgram returns True if the function is executed successfully It returns False if program is not valid program object",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clReleaseProgram",
          "normalized": "CLProgram-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Release Program",
          "signature": "CLProgram-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clReleaseProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrements the program program reference count. \u003ccode\u003e\u003ca\u003eclRetainKernel\u003c/a\u003e\u003c/code\u003e returns\n \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the function is executed successfully. \u003ccode\u003e\u003ca\u003eclCreateKernel\u003c/a\u003e\u003c/code\u003e or\n \u003ccode\u003e\u003ca\u003eclCreateKernelsInProgram\u003c/a\u003e\u003c/code\u003e do an implicit retain.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clRetainKernel",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Program.html#clRetainKernel",
          "type": "function"
        },
        "index": {
          "description": "Increments the program program reference count clRetainKernel returns True if the function is executed successfully clCreateKernel or clCreateKernelsInProgram do an implicit retain",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clRetainKernel",
          "normalized": "CLKernel-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Kernel",
          "signature": "CLKernel-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clRetainKernel"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIncrements the program reference count. \u003ccode\u003e\u003ca\u003eclRetainProgram\u003c/a\u003e\u003c/code\u003e returns \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if \n the function is executed successfully. It returns \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if program is not a \n valid program object.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clRetainProgram",
          "package": "OpenCL",
          "signature": "CLProgram -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Program.html#clRetainProgram",
          "type": "function"
        },
        "index": {
          "description": "Increments the program reference count clRetainProgram returns True if the function is executed successfully It returns False if program is not valid program object",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clRetainProgram",
          "normalized": "CLProgram-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Retain Program",
          "signature": "CLProgram-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clRetainProgram"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed to set the argument value for a specific argument of a kernel.\n\u003c/p\u003e\u003cp\u003eA kernel object does not update the reference count for objects such as memory,\nsampler objects specified as argument values by \u003ccode\u003e\u003ca\u003eclSetKernelArg\u003c/a\u003e\u003c/code\u003e, Users may not\nrely on a kernel object to retain objects specified as argument values to the\nkernel.\n\u003c/p\u003e\u003cp\u003eImplementations shall not allow \u003ccode\u003e\u003ca\u003eCLKernel\u003c/a\u003e\u003c/code\u003e objects to hold reference counts to\n\u003ccode\u003e\u003ca\u003eCLKernel\u003c/a\u003e\u003c/code\u003e arguments, because no mechanism is provided for the user to tell the\nkernel to release that ownership right. If the kernel holds ownership rights on\nkernel args, that would make it impossible for the user to tell with certainty\nwhen he may safely release user allocated resources associated with OpenCL\nobjects such as the CLMem backing store used with \u003ccode\u003eCL_MEM_USE_HOST_PTR\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003eclSetKernelArg\u003c/a\u003e\u003c/code\u003e throws one of the following \u003ccode\u003e\u003ca\u003eCLError\u003c/a\u003e\u003c/code\u003e exceptions when fails:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_KERNEL\u003c/code\u003e if kernel is not a valid kernel object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_ARG_INDEX\u003c/code\u003e if arg_index is not a valid argument index.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_ARG_VALUE\u003c/code\u003e if arg_value specified is NULL for an argument that is\nnot declared with the __local qualifier or vice-versa.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_MEM_OBJECT\u003c/code\u003e for an argument declared to be a memory object when\nthe specified arg_value is not a valid memory object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_SAMPLER\u003c/code\u003e for an argument declared to be of type sampler_t when\nthe specified arg_value is not a valid sampler object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_INVALID_ARG_SIZE\u003c/code\u003e if arg_size does not match the size of the data type\nfor an argument that is not a memory object or if the argument is a memory\nobject and arg_size != sizeof(cl_mem) or if arg_size is zero and the argument is\ndeclared with the __local qualifier or if the argument is a sampler and arg_size\n!= sizeof(cl_sampler).  \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clSetKernelArg",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e CLuint -\u003e a -\u003e Ptr b -\u003e IO ()",
          "source": "src/Control-Parallel-OpenCL-Program.html#clSetKernelArg",
          "type": "function"
        },
        "index": {
          "description": "Used to set the argument value for specific argument of kernel kernel object does not update the reference count for objects such as memory sampler objects specified as argument values by clSetKernelArg Users may not rely on kernel object to retain objects specified as argument values to the kernel Implementations shall not allow CLKernel objects to hold reference counts to CLKernel arguments because no mechanism is provided for the user to tell the kernel to release that ownership right If the kernel holds ownership rights on kernel args that would make it impossible for the user to tell with certainty when he may safely release user allocated resources associated with OpenCL objects such as the CLMem backing store used with CL MEM USE HOST PTR clSetKernelArg throws one of the following CLError exceptions when fails CL INVALID KERNEL if kernel is not valid kernel object CL INVALID ARG INDEX if arg index is not valid argument index CL INVALID ARG VALUE if arg value specified is NULL for an argument that is not declared with the local qualifier or vice-versa CL INVALID MEM OBJECT for an argument declared to be memory object when the specified arg value is not valid memory object CL INVALID SAMPLER for an argument declared to be of type sampler when the specified arg value is not valid sampler object CL INVALID ARG SIZE if arg size does not match the size of the data type for an argument that is not memory object or if the argument is memory object and arg size sizeof cl mem or if arg size is zero and the argument is declared with the local qualifier or if the argument is sampler and arg size sizeof cl sampler",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clSetKernelArg",
          "normalized": "CLKernel-\u003eCLuint-\u003ea-\u003ePtr b-\u003eIO()",
          "package": "OpenCL",
          "partial": "Set Kernel Arg",
          "signature": "CLKernel-\u003eCLuint-\u003ea-\u003ePtr b-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clSetKernelArg"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWrap function of \u003ccode\u003e\u003ca\u003eclSetKernelArg\u003c/a\u003e\u003c/code\u003e with Storable data.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clSetKernelArgSto",
          "package": "OpenCL",
          "signature": "CLKernel -\u003e CLuint -\u003e a -\u003e IO ()",
          "source": "src/Control-Parallel-OpenCL-Program.html#clSetKernelArgSto",
          "type": "function"
        },
        "index": {
          "description": "Wrap function of clSetKernelArg with Storable data",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clSetKernelArgSto",
          "normalized": "CLKernel-\u003eCLuint-\u003ea-\u003eIO()",
          "package": "OpenCL",
          "partial": "Set Kernel Arg Sto",
          "signature": "CLKernel-\u003eCLuint-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clSetKernelArgSto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAllows the implementation to release the resources allocated by the OpenCL\n compiler. This is a hint from the application and does not guarantee that the\n compiler will not be used in the future or that the compiler will actually be\n unloaded by the implementation. Calls to \u003ccode\u003e\u003ca\u003eclBuildProgram\u003c/a\u003e\u003c/code\u003e after\n \u003ccode\u003e\u003ca\u003eclUnloadCompiler\u003c/a\u003e\u003c/code\u003e will reload the compiler, if necessary, to build the\n appropriate program executable.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clUnloadCompiler",
          "package": "OpenCL",
          "signature": "IO ()",
          "source": "src/Control-Parallel-OpenCL-Program.html#clUnloadCompiler",
          "type": "function"
        },
        "index": {
          "description": "Allows the implementation to release the resources allocated by the OpenCL compiler This is hint from the application and does not guarantee that the compiler will not be used in the future or that the compiler will actually be unloaded by the implementation Calls to clBuildProgram after clUnloadCompiler will reload the compiler if necessary to build the appropriate program executable",
          "hierarchy": "Control Parallel OpenCL Program",
          "module": "Control.Parallel.OpenCL.Program",
          "name": "clUnloadCompiler",
          "normalized": "IO()",
          "package": "OpenCL",
          "partial": "Unload Compiler",
          "signature": "IO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Program.html#v:clUnloadCompiler"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "Query",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Query.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "Query",
          "package": "OpenCL",
          "partial": "Query",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_EXEC_KERNEL\u003c/a\u003e\u003c/code\u003e, The OpenCL device can execute OpenCL kernels.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_EXEC_NATIVE_KERNEL\u003c/a\u003e\u003c/code\u003e, The OpenCL device can execute native kernels.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceExecCapability",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceExecCapability",
          "type": "data"
        },
        "index": {
          "description": "CL EXEC KERNEL The OpenCL device can execute OpenCL kernels CL EXEC NATIVE KERNEL The OpenCL device can execute native kernels",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceExecCapability",
          "package": "OpenCL",
          "partial": "CLDevice Exec Capability",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLDeviceExecCapability"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FP_DENORM\u003c/a\u003e\u003c/code\u003e, denorms are supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FP_INF_NAN\u003c/a\u003e\u003c/code\u003e, INF and NaNs are supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_NEAREST\u003c/a\u003e\u003c/code\u003e, round to nearest even rounding mode supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_ZERO\u003c/a\u003e\u003c/code\u003e, round to zero rounding mode supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_INF\u003c/a\u003e\u003c/code\u003e, round to +ve and -ve infinity rounding modes supported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_FP_FMA\u003c/a\u003e\u003c/code\u003e, IEEE754-2008 fused multiply-add is supported.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceFPConfig",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "data"
        },
        "index": {
          "description": "CL FP DENORM denorms are supported CL FP INF NAN INF and NaNs are supported CL FP ROUND TO NEAREST round to nearest even rounding mode supported CL FP ROUND TO ZERO round to zero rounding mode supported CL FP ROUND TO INF round to ve and ve infinity rounding modes supported CL FP FMA IEEE754-2008 fused multiply-add is supported",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceFPConfig",
          "package": "OpenCL",
          "partial": "CLDevice FPConfig",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLDeviceFPConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceID",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceID",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceID",
          "package": "OpenCL",
          "partial": "CLDevice ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLDeviceID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceLocalMemType",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceLocalMemType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceLocalMemType",
          "package": "OpenCL",
          "partial": "CLDevice Local Mem Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLDeviceLocalMemType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceMemCacheType",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceMemCacheType",
          "type": "data"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceMemCacheType",
          "package": "OpenCL",
          "partial": "CLDevice Mem Cache Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLDeviceMemCacheType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_CPU\u003c/a\u003e\u003c/code\u003e, An OpenCL device that is the host processor. The host \nprocessor runs the OpenCL implementations and is a single or multi-core CPU.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_GPU\u003c/a\u003e\u003c/code\u003e, An OpenCL device that is a GPU. By this we mean that the \ndevice can also be used to accelerate a 3D API such as OpenGL or DirectX.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_ACCELERATOR\u003c/a\u003e\u003c/code\u003e, Dedicated OpenCL accelerators (for example the \nIBM CELL Blade). These devices communicate with the host processor using a \nperipheral interconnect such as PCIe.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_DEFAULT\u003c/a\u003e\u003c/code\u003e, The default OpenCL device in the system.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_ALL\u003c/a\u003e\u003c/code\u003e, All OpenCL devices available in the system.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceType",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceType",
          "type": "data"
        },
        "index": {
          "description": "CL DEVICE TYPE CPU An OpenCL device that is the host processor The host processor runs the OpenCL implementations and is single or multi-core CPU CL DEVICE TYPE GPU An OpenCL device that is GPU By this we mean that the device can also be used to accelerate API such as OpenGL or DirectX CL DEVICE TYPE ACCELERATOR Dedicated OpenCL accelerators for example the IBM CELL Blade These devices communicate with the host processor using peripheral interconnect such as PCIe CL DEVICE TYPE DEFAULT The default OpenCL device in the system CL DEVICE TYPE ALL All OpenCL devices available in the system",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLDeviceType",
          "package": "OpenCL",
          "partial": "CLDevice Type",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLDeviceType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLPlatformID",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformID",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLPlatformID",
          "package": "OpenCL",
          "partial": "CLPlatform ID",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLPlatformID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PLATFORM_PROFILE\u003c/a\u003e\u003c/code\u003e, OpenCL profile string. Returns the profile name \nsupported by the implementation. The profile name returned can be one of the \nfollowing strings:\n\u003c/li\u003e\u003c/ul\u003e\u003cdl\u003e\u003cdt\u003e\u003ccode\u003eFULL_PROFILE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If the implementation supports the OpenCL specification\n(functionality defined as part of the core specification and does not require\nany extensions to be supported).\n\u003c/dd\u003e\u003cdt\u003e\u003ccode\u003eEMBEDDED_PROFILE\u003c/code\u003e\u003c/dt\u003e\u003cdd\u003e If the implementation supports the OpenCL embedded \nprofile. The embedded profile is  defined to be a subset for each version of \nOpenCL.\n\u003c/dd\u003e\u003c/dl\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PLATFORM_VERSION\u003c/a\u003e\u003c/code\u003e, OpenCL version string. Returns the OpenCL version \nsupported by the implementation. This version string has the following format: \n\u003cem\u003eOpenCL major_version.minor_version platform-specific information\u003c/em\u003e The \n\u003cem\u003emajor_version.minor_version\u003c/em\u003e value returned will be 1.0.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PLATFORM_NAME\u003c/a\u003e\u003c/code\u003e, Platform name string.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PLATFORM_VENDOR\u003c/a\u003e\u003c/code\u003e, Platform vendor string.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PLATFORM_EXTENSIONS\u003c/a\u003e\u003c/code\u003e, Returns a space-separated list of extension names \n(the extension names themselves do not contain any spaces) supported by the \nplatform. Extensions defined here must be supported by all devices associated \nwith this platform.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLPlatformInfo",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformInfo",
          "type": "data"
        },
        "index": {
          "description": "CL PLATFORM PROFILE OpenCL profile string Returns the profile name supported by the implementation The profile name returned can be one of the following strings FULL PROFILE If the implementation supports the OpenCL specification functionality defined as part of the core specification and does not require any extensions to be supported EMBEDDED PROFILE If the implementation supports the OpenCL embedded profile The embedded profile is defined to be subset for each version of OpenCL CL PLATFORM VERSION OpenCL version string Returns the OpenCL version supported by the implementation This version string has the following format OpenCL major version.minor version platform-specific information The major version.minor version value returned will be CL PLATFORM NAME Platform name string CL PLATFORM VENDOR Platform vendor string CL PLATFORM EXTENSIONS Returns space-separated list of extension names the extension names themselves do not contain any spaces supported by the platform Extensions defined here must be supported by all devices associated with this platform",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CLPlatformInfo",
          "package": "OpenCL",
          "partial": "CLPlatform Info",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#t:CLPlatformInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_ACCELERATOR",
          "package": "OpenCL",
          "signature": "CL_DEVICE_TYPE_ACCELERATOR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_ACCELERATOR",
          "package": "OpenCL",
          "partial": "CL DEVICE TYPE ACCELERATOR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_DEVICE_TYPE_ACCELERATOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_ALL",
          "package": "OpenCL",
          "signature": "CL_DEVICE_TYPE_ALL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_ALL",
          "package": "OpenCL",
          "partial": "CL DEVICE TYPE ALL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_DEVICE_TYPE_ALL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_CPU",
          "package": "OpenCL",
          "signature": "CL_DEVICE_TYPE_CPU",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_CPU",
          "package": "OpenCL",
          "partial": "CL DEVICE TYPE CPU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_DEVICE_TYPE_CPU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_DEFAULT",
          "package": "OpenCL",
          "signature": "CL_DEVICE_TYPE_DEFAULT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_DEFAULT",
          "package": "OpenCL",
          "partial": "CL DEVICE TYPE DEFAULT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_DEVICE_TYPE_DEFAULT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_GPU",
          "package": "OpenCL",
          "signature": "CL_DEVICE_TYPE_GPU",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_DEVICE_TYPE_GPU",
          "package": "OpenCL",
          "partial": "CL DEVICE TYPE GPU",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_DEVICE_TYPE_GPU"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_EXEC_KERNEL",
          "package": "OpenCL",
          "signature": "CL_EXEC_KERNEL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceExecCapability",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_EXEC_KERNEL",
          "package": "OpenCL",
          "partial": "CL EXEC KERNEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_EXEC_KERNEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_EXEC_NATIVE_KERNEL",
          "package": "OpenCL",
          "signature": "CL_EXEC_NATIVE_KERNEL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceExecCapability",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_EXEC_NATIVE_KERNEL",
          "package": "OpenCL",
          "partial": "CL EXEC NATIVE KERNEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_EXEC_NATIVE_KERNEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_DENORM",
          "package": "OpenCL",
          "signature": "CL_FP_DENORM",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_DENORM",
          "package": "OpenCL",
          "partial": "CL FP DENORM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_FP_DENORM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_FMA",
          "package": "OpenCL",
          "signature": "CL_FP_FMA",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_FMA",
          "package": "OpenCL",
          "partial": "CL FP FMA",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_FP_FMA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_INF_NAN",
          "package": "OpenCL",
          "signature": "CL_FP_INF_NAN",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_INF_NAN",
          "package": "OpenCL",
          "partial": "CL FP INF NAN",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_FP_INF_NAN"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_ROUND_TO_INF",
          "package": "OpenCL",
          "signature": "CL_FP_ROUND_TO_INF",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_ROUND_TO_INF",
          "package": "OpenCL",
          "partial": "CL FP ROUND TO INF",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_FP_ROUND_TO_INF"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_ROUND_TO_NEAREST",
          "package": "OpenCL",
          "signature": "CL_FP_ROUND_TO_NEAREST",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_ROUND_TO_NEAREST",
          "package": "OpenCL",
          "partial": "CL FP ROUND TO NEAREST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_FP_ROUND_TO_NEAREST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_ROUND_TO_ZERO",
          "package": "OpenCL",
          "signature": "CL_FP_ROUND_TO_ZERO",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceFPConfig",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_FP_ROUND_TO_ZERO",
          "package": "OpenCL",
          "partial": "CL FP ROUND TO ZERO",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_FP_ROUND_TO_ZERO"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_GLOBAL",
          "package": "OpenCL",
          "signature": "CL_GLOBAL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceLocalMemType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_GLOBAL",
          "package": "OpenCL",
          "partial": "CL GLOBAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_GLOBAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_LOCAL",
          "package": "OpenCL",
          "signature": "CL_LOCAL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceLocalMemType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_LOCAL",
          "package": "OpenCL",
          "partial": "CL LOCAL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_LOCAL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_NONE",
          "package": "OpenCL",
          "signature": "CL_NONE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceMemCacheType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_NONE",
          "package": "OpenCL",
          "partial": "CL NONE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_NONE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_EXTENSIONS",
          "package": "OpenCL",
          "signature": "CL_PLATFORM_EXTENSIONS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_EXTENSIONS",
          "package": "OpenCL",
          "partial": "CL PLATFORM EXTENSIONS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_PLATFORM_EXTENSIONS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_NAME",
          "package": "OpenCL",
          "signature": "CL_PLATFORM_NAME",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_NAME",
          "package": "OpenCL",
          "partial": "CL PLATFORM NAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_PLATFORM_NAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_PROFILE",
          "package": "OpenCL",
          "signature": "CL_PLATFORM_PROFILE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_PROFILE",
          "package": "OpenCL",
          "partial": "CL PLATFORM PROFILE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_PLATFORM_PROFILE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_VENDOR",
          "package": "OpenCL",
          "signature": "CL_PLATFORM_VENDOR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_VENDOR",
          "package": "OpenCL",
          "partial": "CL PLATFORM VENDOR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_PLATFORM_VENDOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_VERSION",
          "package": "OpenCL",
          "signature": "CL_PLATFORM_VERSION",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLPlatformInfo",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_PLATFORM_VERSION",
          "package": "OpenCL",
          "partial": "CL PLATFORM VERSION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_PLATFORM_VERSION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_READ_ONLY_CACHE",
          "package": "OpenCL",
          "signature": "CL_READ_ONLY_CACHE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceMemCacheType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_READ_ONLY_CACHE",
          "package": "OpenCL",
          "partial": "CL READ ONLY CACHE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_READ_ONLY_CACHE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_READ_WRITE_CACHE",
          "package": "OpenCL",
          "signature": "CL_READ_WRITE_CACHE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLDeviceMemCacheType",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "CL_READ_WRITE_CACHE",
          "package": "OpenCL",
          "partial": "CL READ WRITE CACHE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:CL_READ_WRITE_CACHE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe default compute device address space size specified as an unsigned \n integer value in bits. Currently supported values are 32 or 64 bits.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_ADDRESS_BITS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceAddressBits",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceAddressBits",
          "type": "function"
        },
        "index": {
          "description": "The default compute device address space size specified as an unsigned integer value in bits Currently supported values are or bits This function execute OpenCL clGetDeviceInfo with CL DEVICE ADDRESS BITS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceAddressBits",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Address Bits",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceAddressBits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the device is available and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the device is not \n available.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_AVAILABLE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceAvailable",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceAvailable",
          "type": "function"
        },
        "index": {
          "description": "Is True if the device is available and False if the device is not available This function execute OpenCL clGetDeviceInfo with CL DEVICE AVAILABLE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceAvailable",
          "normalized": "CLDeviceID-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Get Device Available",
          "signature": "CLDeviceID-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceAvailable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the implementation does not have a compiler available to \n compile the program source. Is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the compiler is available. This can \n be \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e for the embededed platform profile only.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_COMPILER_AVAILABLE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceCompilerAvailable",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceCompilerAvailable",
          "type": "function"
        },
        "index": {
          "description": "Is False if the implementation does not have compiler available to compile the program source Is True if the compiler is available This can be False for the embededed platform profile only This function execute OpenCL clGetDeviceInfo with CL DEVICE COMPILER AVAILABLE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceCompilerAvailable",
          "normalized": "CLDeviceID-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Get Device Compiler Available",
          "signature": "CLDeviceID-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceCompilerAvailable"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the OPTIONAL double precision floating-point capability of the \n OpenCL device. This is a bit-field that describes one or more of the \n \u003ccode\u003e\u003ca\u003eCLDeviceFPConfig\u003c/a\u003e\u003c/code\u003e values.\n The mandated minimum double precision floating-point capability is \n \u003ccode\u003e\u003ca\u003eCL_FP_FMA\u003c/a\u003e\u003c/code\u003e | \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_NEAREST\u003c/a\u003e\u003c/code\u003e | \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_ZERO\u003c/a\u003e\u003c/code\u003e | \n \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_INF\u003c/a\u003e\u003c/code\u003e | \u003ccode\u003e\u003ca\u003eCL_FP_INF_NAN\u003c/a\u003e\u003c/code\u003e | \u003ccode\u003e\u003ca\u003eCL_FP_DENORM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_DOUBLE_FP_CONFIG\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceDoubleFPConfig",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CLDeviceFPConfig]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceDoubleFPConfig",
          "type": "function"
        },
        "index": {
          "description": "Describes the OPTIONAL double precision floating-point capability of the OpenCL device This is bit-field that describes one or more of the CLDeviceFPConfig values The mandated minimum double precision floating-point capability is CL FP FMA CL FP ROUND TO NEAREST CL FP ROUND TO ZERO CL FP ROUND TO INF CL FP INF NAN CL FP DENORM This function execute OpenCL clGetDeviceInfo with CL DEVICE DOUBLE FP CONFIG",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceDoubleFPConfig",
          "normalized": "CLDeviceID-\u003eIO[CLDeviceFPConfig]",
          "package": "OpenCL",
          "partial": "Get Device Double FPConfig",
          "signature": "CLDeviceID-\u003eIO[CLDeviceFPConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceDoubleFPConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpenCL software driver version string in the form major_number.minor_number.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DRIVER_VERSION\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceDriverVersion",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceDriverVersion",
          "type": "function"
        },
        "index": {
          "description": "OpenCL software driver version string in the form major number.minor number This function execute OpenCL clGetDeviceInfo with CL DRIVER VERSION",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceDriverVersion",
          "normalized": "CLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Device Driver Version",
          "signature": "CLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceDriverVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the OpenCL device is a little endian device and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e \n otherwise.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_ENDIAN_LITTLE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceEndianLittle",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceEndianLittle",
          "type": "function"
        },
        "index": {
          "description": "Is True if the OpenCL device is little endian device and False otherwise This function execute OpenCL clGetDeviceInfo with CL DEVICE ENDIAN LITTLE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceEndianLittle",
          "normalized": "CLDeviceID-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Get Device Endian Little",
          "signature": "CLDeviceID-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceEndianLittle"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if the device implements error correction for the memories, \n caches, registers etc. in the device. Is \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e if the device does not \n implement error correction. This can be a requirement for certain clients of \n OpenCL.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_ERROR_CORRECTION_SUPPORT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceErrorCorrectionSupport",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceErrorCorrectionSupport",
          "type": "function"
        },
        "index": {
          "description": "Is True if the device implements error correction for the memories caches registers etc in the device Is False if the device does not implement error correction This can be requirement for certain clients of OpenCL This function execute OpenCL clGetDeviceInfo with CL DEVICE ERROR CORRECTION SUPPORT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceErrorCorrectionSupport",
          "normalized": "CLDeviceID-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Get Device Error Correction Support",
          "signature": "CLDeviceID-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceErrorCorrectionSupport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the execution capabilities of the device. This is a list that \n describes one or more of the \u003ccode\u003e\u003ca\u003eCLDeviceExecCapability\u003c/a\u003e\u003c/code\u003e values.\n The mandated minimum capability is \u003ccode\u003e\u003ca\u003eCL_EXEC_KERNEL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_EXECUTION_CAPABILITIES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceExecutionCapabilities",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CLDeviceExecCapability]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceExecutionCapabilities",
          "type": "function"
        },
        "index": {
          "description": "Describes the execution capabilities of the device This is list that describes one or more of the CLDeviceExecCapability values The mandated minimum capability is CL EXEC KERNEL This function execute OpenCL clGetDeviceInfo with CL DEVICE EXECUTION CAPABILITIES",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceExecutionCapabilities",
          "normalized": "CLDeviceID-\u003eIO[CLDeviceExecCapability]",
          "package": "OpenCL",
          "partial": "Get Device Execution Capabilities",
          "signature": "CLDeviceID-\u003eIO[CLDeviceExecCapability]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceExecutionCapabilities"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns a space separated list of extension names (the extension names \n themselves do not contain any spaces). The list of extension names returned \n currently can include one or more of the following approved extension names:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e cl_khr_fp64\n\u003c/li\u003e\u003cli\u003e cl_khr_select_fprounding_mode\n\u003c/li\u003e\u003cli\u003e cl_khr_global_int32_base_atomics\n\u003c/li\u003e\u003cli\u003e cl_khr_global_int32_extended_atomics\n\u003c/li\u003e\u003cli\u003e cl_khr_local_int32_base_atomics\n\u003c/li\u003e\u003cli\u003e cl_khr_local_int32_extended_atomics\n\u003c/li\u003e\u003cli\u003e cl_khr_int64_base_atomics\n\u003c/li\u003e\u003cli\u003e cl_khr_int64_extended_atomics\n\u003c/li\u003e\u003cli\u003e cl_khr_3d_image_writes\n\u003c/li\u003e\u003cli\u003e cl_khr_byte_addressable_store\n\u003c/li\u003e\u003cli\u003e cl_khr_fp16\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_EXTENSIONS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceExtensions",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceExtensions",
          "type": "function"
        },
        "index": {
          "description": "Returns space separated list of extension names the extension names themselves do not contain any spaces The list of extension names returned currently can include one or more of the following approved extension names cl khr fp64 cl khr select fprounding mode cl khr global int32 base atomics cl khr global int32 extended atomics cl khr local int32 base atomics cl khr local int32 extended atomics cl khr int64 base atomics cl khr int64 extended atomics cl khr image writes cl khr byte addressable store cl khr fp16 This function execute OpenCL clGetDeviceInfo with CL DEVICE EXTENSIONS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceExtensions",
          "normalized": "CLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Device Extensions",
          "signature": "CLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceExtensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of global memory cache in bytes.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_GLOBAL_MEM_CACHE_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemCacheSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceGlobalMemCacheSize",
          "type": "function"
        },
        "index": {
          "description": "Size of global memory cache in bytes This function execute OpenCL clGetDeviceInfo with CL DEVICE GLOBAL MEM CACHE SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemCacheSize",
          "normalized": "CLDeviceID-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Device Global Mem Cache Size",
          "signature": "CLDeviceID-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceGlobalMemCacheSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of global memory cache supported. Valid values are: \u003ccode\u003e\u003ca\u003eCL_NONE\u003c/a\u003e\u003c/code\u003e, \n \u003ccode\u003e\u003ca\u003eCL_READ_ONLY_CACHE\u003c/a\u003e\u003c/code\u003e, and \u003ccode\u003e\u003ca\u003eCL_READ_WRITE_CACHE\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_GLOBAL_MEM_CACHE_TYPE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemCacheType",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLDeviceMemCacheType",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceGlobalMemCacheType",
          "type": "function"
        },
        "index": {
          "description": "Type of global memory cache supported Valid values are CL NONE CL READ ONLY CACHE and CL READ WRITE CACHE This function execute OpenCL clGetDeviceInfo with CL DEVICE GLOBAL MEM CACHE TYPE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemCacheType",
          "normalized": "CLDeviceID-\u003eIO CLDeviceMemCacheType",
          "package": "OpenCL",
          "partial": "Get Device Global Mem Cache Type",
          "signature": "CLDeviceID-\u003eIO CLDeviceMemCacheType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceGlobalMemCacheType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of global memory cache line in bytes.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemCachelineSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceGlobalMemCachelineSize",
          "type": "function"
        },
        "index": {
          "description": "Size of global memory cache line in bytes This function execute OpenCL clGetDeviceInfo with CL DEVICE GLOBAL MEM CACHELINE SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemCachelineSize",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Global Mem Cacheline Size",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceGlobalMemCachelineSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of global device memory in bytes.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_GLOBAL_MEM_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceGlobalMemSize",
          "type": "function"
        },
        "index": {
          "description": "Size of global device memory in bytes This function execute OpenCL clGetDeviceInfo with CL DEVICE GLOBAL MEM SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceGlobalMemSize",
          "normalized": "CLDeviceID-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Device Global Mem Size",
          "signature": "CLDeviceID-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceGlobalMemSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the OPTIONAL half precision floating-point capability of the \n OpenCL device. This is a bit-field that describes one or more of the \n \u003ccode\u003e\u003ca\u003eCLDeviceFPConfig\u003c/a\u003e\u003c/code\u003e values.\n The required minimum half precision floating-point capability as implemented \n by this extension is \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_ZERO\u003c/a\u003e\u003c/code\u003e | \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_INF\u003c/a\u003e\u003c/code\u003e | \n \u003ccode\u003e\u003ca\u003eCL_FP_INF_NAN\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_HALF_FP_CONFIG\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceHalfFPConfig",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CLDeviceFPConfig]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceHalfFPConfig",
          "type": "function"
        },
        "index": {
          "description": "Describes the OPTIONAL half precision floating-point capability of the OpenCL device This is bit-field that describes one or more of the CLDeviceFPConfig values The required minimum half precision floating-point capability as implemented by this extension is CL FP ROUND TO ZERO CL FP ROUND TO INF CL FP INF NAN This function execute OpenCL clGetDeviceInfo with CL DEVICE HALF FP CONFIG",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceHalfFPConfig",
          "normalized": "CLDeviceID-\u003eIO[CLDeviceFPConfig]",
          "package": "OpenCL",
          "partial": "Get Device Half FPConfig",
          "signature": "CLDeviceID-\u003eIO[CLDeviceFPConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceHalfFPConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the list of devices available on a platform. Returns the list if \n the function is executed successfully. Otherwise it returns the empty list \n if platform is not a valid platform or no OpenCL devices that matched \n device_type were found.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceIDs",
          "package": "OpenCL",
          "signature": "CLPlatformID -\u003e CLDeviceType -\u003e IO [CLDeviceID]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceIDs",
          "type": "function"
        },
        "index": {
          "description": "Obtain the list of devices available on platform Returns the list if the function is executed successfully Otherwise it returns the empty list if platform is not valid platform or no OpenCL devices that matched device type were found",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceIDs",
          "normalized": "CLPlatformID-\u003eCLDeviceType-\u003eIO[CLDeviceID]",
          "package": "OpenCL",
          "partial": "Get Device IDs",
          "signature": "CLPlatformID-\u003eCLDeviceType-\u003eIO[CLDeviceID]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceIDs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax height of 2D image in pixels. The minimum value is 8192 if\n \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_IMAGE2D_MAX_HEIGHT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage2DMaxHeight",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceImage2DMaxHeight",
          "type": "function"
        },
        "index": {
          "description": "Max height of image in pixels The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE IMAGE2D MAX HEIGHT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage2DMaxHeight",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Image DMax Height",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceImage2DMaxHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax width of 2D image in pixels. The minimum value is 8192 if\n \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_IMAGE2D_MAX_WIDTH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage2DMaxWidth",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceImage2DMaxWidth",
          "type": "function"
        },
        "index": {
          "description": "Max width of image in pixels The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE IMAGE2D MAX WIDTH",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage2DMaxWidth",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Image DMax Width",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceImage2DMaxWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax depth of 3D image in pixels. The minimum value is 2048 if \n \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_IMAGE3D_MAX_DEPTH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage3DMaxDepth",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceImage3DMaxDepth",
          "type": "function"
        },
        "index": {
          "description": "Max depth of image in pixels The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE IMAGE3D MAX DEPTH",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage3DMaxDepth",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Image DMax Depth",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceImage3DMaxDepth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax height of 3D image in pixels. The minimum value is 2048 if \n \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_IMAGE3D_MAX_HEIGHT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage3DMaxHeight",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceImage3DMaxHeight",
          "type": "function"
        },
        "index": {
          "description": "Max height of image in pixels The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE IMAGE3D MAX HEIGHT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage3DMaxHeight",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Image DMax Height",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceImage3DMaxHeight"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax width of 3D image in pixels. The minimum value is 2048 if \n \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_IMAGE3D_MAX_WIDTH\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage3DMaxWidth",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceImage3DMaxWidth",
          "type": "function"
        },
        "index": {
          "description": "Max width of image in pixels The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE IMAGE3D MAX WIDTH",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImage3DMaxWidth",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Image DMax Width",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceImage3DMaxWidth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIs \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e if images are supported by the OpenCL device and \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e otherwise.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_IMAGE_SUPPORT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImageSupport",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO Bool",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceImageSupport",
          "type": "function"
        },
        "index": {
          "description": "Is True if images are supported by the OpenCL device and False otherwise This function execute OpenCL clGetDeviceInfo with CL DEVICE IMAGE SUPPORT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceImageSupport",
          "normalized": "CLDeviceID-\u003eIO Bool",
          "package": "OpenCL",
          "partial": "Get Device Image Support",
          "signature": "CLDeviceID-\u003eIO Bool",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceImageSupport"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSize of local memory arena in bytes. The minimum value is 16 KB.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_LOCAL_MEM_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceLocalMemSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceLocalMemSize",
          "type": "function"
        },
        "index": {
          "description": "Size of local memory arena in bytes The minimum value is KB This function execute OpenCL clGetDeviceInfo with CL DEVICE LOCAL MEM SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceLocalMemSize",
          "normalized": "CLDeviceID-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Device Local Mem Size",
          "signature": "CLDeviceID-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceLocalMemSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eType of local memory supported. This can be set to \u003ccode\u003e\u003ca\u003eCL_LOCAL\u003c/a\u003e\u003c/code\u003e implying \n dedicated local memory storage such as SRAM, or \u003ccode\u003e\u003ca\u003eCL_GLOBAL\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_LOCAL_MEM_TYPE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceLocalMemType",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLDeviceLocalMemType",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceLocalMemType",
          "type": "function"
        },
        "index": {
          "description": "Type of local memory supported This can be set to CL LOCAL implying dedicated local memory storage such as SRAM or CL GLOBAL This function execute OpenCL clGetDeviceInfo with CL DEVICE LOCAL MEM TYPE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceLocalMemType",
          "normalized": "CLDeviceID-\u003eIO CLDeviceLocalMemType",
          "package": "OpenCL",
          "partial": "Get Device Local Mem Type",
          "signature": "CLDeviceID-\u003eIO CLDeviceLocalMemType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceLocalMemType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum configured clock frequency of the device in MHz.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_CLOCK_FREQUENCY\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxClockFrequency",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxClockFrequency",
          "type": "function"
        },
        "index": {
          "description": "Maximum configured clock frequency of the device in MHz This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX CLOCK FREQUENCY",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxClockFrequency",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Clock Frequency",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxClockFrequency"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe number of parallel compute cores on the OpenCL device. The minimum \n value is 1.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_COMPUTE_UNITS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxComputeUnits",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxComputeUnits",
          "type": "function"
        },
        "index": {
          "description": "The number of parallel compute cores on the OpenCL device The minimum value is This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX COMPUTE UNITS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxComputeUnits",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Compute Units",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxComputeUnits"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax number of arguments declared with the __constant qualifier in a kernel. \n The minimum value is 8.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_CONSTANT_ARGS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxConstantArgs",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxConstantArgs",
          "type": "function"
        },
        "index": {
          "description": "Max number of arguments declared with the constant qualifier in kernel The minimum value is This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX CONSTANT ARGS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxConstantArgs",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Constant Args",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxConstantArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax size in bytes of a constant buffer allocation. The minimum value is \n 64 KB.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_CONSTANT_BUFFER_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxConstantBufferSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxConstantBufferSize",
          "type": "function"
        },
        "index": {
          "description": "Max size in bytes of constant buffer allocation The minimum value is KB This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX CONSTANT BUFFER SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxConstantBufferSize",
          "normalized": "CLDeviceID-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Device Max Constant Buffer Size",
          "signature": "CLDeviceID-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxConstantBufferSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax size of memory object allocation in bytes. The minimum value is max \n (1/4th of \u003ccode\u003e\u003ca\u003eclGetDeviceGlobalMemSize\u003c/a\u003e\u003c/code\u003e, 128*1024*1024)\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_MAX_MEM_ALLOC_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxMemAllocSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLulong",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxMemAllocSize",
          "type": "function"
        },
        "index": {
          "description": "Max size of memory object allocation in bytes The minimum value is max th of clGetDeviceGlobalMemSize This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX MEM ALLOC SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxMemAllocSize",
          "normalized": "CLDeviceID-\u003eIO CLulong",
          "package": "OpenCL",
          "partial": "Get Device Max Mem Alloc Size",
          "signature": "CLDeviceID-\u003eIO CLulong",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxMemAllocSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax size in bytes of the arguments that can be passed to a kernel. The \n minimum value is 256.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_PARAMETER_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxParameterSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxParameterSize",
          "type": "function"
        },
        "index": {
          "description": "Max size in bytes of the arguments that can be passed to kernel The minimum value is This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX PARAMETER SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxParameterSize",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Max Parameter Size",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxParameterSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax number of simultaneous image objects that can be read by a kernel. The \n minimum value is 128 if \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_READ_IMAGE_ARGS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxReadImageArgs",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxReadImageArgs",
          "type": "function"
        },
        "index": {
          "description": "Max number of simultaneous image objects that can be read by kernel The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX READ IMAGE ARGS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxReadImageArgs",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Read Image Args",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxReadImageArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum number of samplers that can be used in a kernel. The minimum value \n is 16 if \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e. (Also see sampler type.)\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_MAX_SAMPLERS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxSamplers",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxSamplers",
          "type": "function"
        },
        "index": {
          "description": "Maximum number of samplers that can be used in kernel The minimum value is if clGetDeviceImageSupport is True Also see sampler type This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX SAMPLERS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxSamplers",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Samplers",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxSamplers"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum number of work-items in a work-group executing a kernel using the \n data parallel execution model. (Refer to \u003ccode\u003eclEnqueueNDRangeKernel\u003c/code\u003e). The \n minimum value is 1.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_WORK_GROUP_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWorkGroupSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxWorkGroupSize",
          "type": "function"
        },
        "index": {
          "description": "Maximum number of work-items in work-group executing kernel using the data parallel execution model Refer to clEnqueueNDRangeKernel The minimum value is This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX WORK GROUP SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWorkGroupSize",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Max Work Group Size",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxWorkGroupSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum dimensions that specify the global and local work-item IDs used by \n the data parallel execution model. (Refer to \u003ccode\u003eclEnqueueNDRangeKernel\u003c/code\u003e). \n The minimum value is 3.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_WORK_ITEM_DIMENSIONS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWorkItemDimensions",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxWorkItemDimensions",
          "type": "function"
        },
        "index": {
          "description": "Maximum dimensions that specify the global and local work-item IDs used by the data parallel execution model Refer to clEnqueueNDRangeKernel The minimum value is This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX WORK ITEM DIMENSIONS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWorkItemDimensions",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Work Item Dimensions",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxWorkItemDimensions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMaximum number of work-items that can be specified in each dimension of the \n work-group to \u003ccode\u003eclEnqueueNDRangeKernel\u003c/code\u003e.\n Returns n entries, where n is the value returned by the query for \n clDeviceMaxWorkItemDimensions. The minimum value is (1, 1, 1).\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_WORK_ITEM_SIZES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWorkItemSizes",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CSize]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxWorkItemSizes",
          "type": "function"
        },
        "index": {
          "description": "Maximum number of work-items that can be specified in each dimension of the work-group to clEnqueueNDRangeKernel Returns entries where is the value returned by the query for clDeviceMaxWorkItemDimensions The minimum value is This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX WORK ITEM SIZES",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWorkItemSizes",
          "normalized": "CLDeviceID-\u003eIO[CSize]",
          "package": "OpenCL",
          "partial": "Get Device Max Work Item Sizes",
          "signature": "CLDeviceID-\u003eIO[CSize]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxWorkItemSizes"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eMax number of simultaneous image objects that can be written to by a \n kernel. The minimum value is 8 if \u003ccode\u003e\u003ca\u003eclGetDeviceImageSupport\u003c/a\u003e\u003c/code\u003e is \u003ccode\u003e\u003ca\u003eTrue\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MAX_WRITE_IMAGE_ARGS\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWriteImageArgs",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMaxWriteImageArgs",
          "type": "function"
        },
        "index": {
          "description": "Max number of simultaneous image objects that can be written to by kernel The minimum value is if clGetDeviceImageSupport is True This function execute OpenCL clGetDeviceInfo with CL DEVICE MAX WRITE IMAGE ARGS",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMaxWriteImageArgs",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Max Write Image Args",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMaxWriteImageArgs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the alignment in bits of the base address of any allocated \n memory object.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MEM_BASE_ADDR_ALIGN\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMemBaseAddrAlign",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMemBaseAddrAlign",
          "type": "function"
        },
        "index": {
          "description": "Describes the alignment in bits of the base address of any allocated memory object This function execute OpenCL clGetDeviceInfo with CL DEVICE MEM BASE ADDR ALIGN",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMemBaseAddrAlign",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Mem Base Addr Align",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMemBaseAddrAlign"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe smallest alignment in bytes which can be used for any data type.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMinDataTypeAlignSize",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceMinDataTypeAlignSize",
          "type": "function"
        },
        "index": {
          "description": "The smallest alignment in bytes which can be used for any data type This function execute OpenCL clGetDeviceInfo with CL DEVICE MIN DATA TYPE ALIGN SIZE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceMinDataTypeAlignSize",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Min Data Type Align Size",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceMinDataTypeAlignSize"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDevice name string.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_NAME\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceName",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceName",
          "type": "function"
        },
        "index": {
          "description": "Device name string This function execute OpenCL clGetDeviceInfo with CL DEVICE NAME",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceName",
          "normalized": "CLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Device Name",
          "signature": "CLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceName"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe platform associated with this device.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_PLATFORM\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePlatform",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLPlatformID",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePlatform",
          "type": "function"
        },
        "index": {
          "description": "The platform associated with this device This function execute OpenCL clGetDeviceInfo with CL DEVICE PLATFORM",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePlatform",
          "normalized": "CLDeviceID-\u003eIO CLPlatformID",
          "package": "OpenCL",
          "partial": "Get Device Platform",
          "signature": "CLDeviceID-\u003eIO CLPlatformID",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePlatform"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePreferred native vector width size for built-in char types that can be put \n into vectors. The vector width is defined as the number of scalar elements \n that can be stored in the vector.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthChar",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePreferredVectorWidthChar",
          "type": "function"
        },
        "index": {
          "description": "Preferred native vector width size for built-in char types that can be put into vectors The vector width is defined as the number of scalar elements that can be stored in the vector This function execute OpenCL clGetDeviceInfo with CL DEVICE PREFERRED VECTOR WIDTH CHAR",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthChar",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Preferred Vector Width Char",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePreferredVectorWidthChar"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePreferred native vector width size for built-in double types that can be put \n into vectors. The vector width is defined as the number of scalar elements \n that can be stored in the vector.\n | If the cl_khr_fp64 extension is not supported, \n \u003ccode\u003e\u003ca\u003eclGetDevicePreferredVectorWidthDouble\u003c/a\u003e\u003c/code\u003e must return 0.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthDouble",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePreferredVectorWidthDouble",
          "type": "function"
        },
        "index": {
          "description": "Preferred native vector width size for built-in double types that can be put into vectors The vector width is defined as the number of scalar elements that can be stored in the vector If the cl khr fp64 extension is not supported clGetDevicePreferredVectorWidthDouble must return This function execute OpenCL clGetDeviceInfo with CL DEVICE PREFERRED VECTOR WIDTH DOUBLE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthDouble",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Preferred Vector Width Double",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePreferredVectorWidthDouble"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePreferred native vector width size for built-in float types that can be put \n into vectors. The vector width is defined as the number of scalar elements \n that can be stored in the vector.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthFloat",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePreferredVectorWidthFloat",
          "type": "function"
        },
        "index": {
          "description": "Preferred native vector width size for built-in float types that can be put into vectors The vector width is defined as the number of scalar elements that can be stored in the vector This function execute OpenCL clGetDeviceInfo with CL DEVICE PREFERRED VECTOR WIDTH FLOAT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthFloat",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Preferred Vector Width Float",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePreferredVectorWidthFloat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePreferred native vector width size for built-in int types that can be put \n into vectors. The vector width is defined as the number of scalar elements \n that can be stored in the vector.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PREFERRED_VECTOR_WIDTH_INT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthInt",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePreferredVectorWidthInt",
          "type": "function"
        },
        "index": {
          "description": "Preferred native vector width size for built-in int types that can be put into vectors The vector width is defined as the number of scalar elements that can be stored in the vector This function execute OpenCL clGetDeviceInfo with CL DEVICE PREFERRED VECTOR WIDTH INT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthInt",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Preferred Vector Width Int",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePreferredVectorWidthInt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePreferred native vector width size for built-in long types that can be put \n into vectors. The vector width is defined as the number of scalar elements \n that can be stored in the vector.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthLong",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePreferredVectorWidthLong",
          "type": "function"
        },
        "index": {
          "description": "Preferred native vector width size for built-in long types that can be put into vectors The vector width is defined as the number of scalar elements that can be stored in the vector This function execute OpenCL clGetDeviceInfo with CL DEVICE PREFERRED VECTOR WIDTH LONG",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthLong",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Preferred Vector Width Long",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePreferredVectorWidthLong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ePreferred native vector width size for built-in short types that can be put \n into vectors. The vector width is defined as the number of scalar elements \n that can be stored in the vector.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthShort",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDevicePreferredVectorWidthShort",
          "type": "function"
        },
        "index": {
          "description": "Preferred native vector width size for built-in short types that can be put into vectors The vector width is defined as the number of scalar elements that can be stored in the vector This function execute OpenCL clGetDeviceInfo with CL DEVICE PREFERRED VECTOR WIDTH SHORT",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDevicePreferredVectorWidthShort",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Preferred Vector Width Short",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDevicePreferredVectorWidthShort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpenCL profile string. Returns the profile name supported by the device \n (see note). The profile name returned can be one of the following strings:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e FULL_PROFILE - if the device supports the OpenCL specification \n (functionality defined as part of the core specification and does not require \n any extensions to be supported).\n\u003c/li\u003e\u003cli\u003e EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_PROFILE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceProfile",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceProfile",
          "type": "function"
        },
        "index": {
          "description": "OpenCL profile string Returns the profile name supported by the device see note The profile name returned can be one of the following strings FULL PROFILE if the device supports the OpenCL specification functionality defined as part of the core specification and does not require any extensions to be supported EMBEDDED PROFILE if the device supports the OpenCL embedded profile This function execute OpenCL clGetDeviceInfo with CL DEVICE PROFILE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceProfile",
          "normalized": "CLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Device Profile",
          "signature": "CLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceProfile"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the resolution of device timer. This is measured in nanoseconds.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_PROFILING_TIMER_RESOLUTION\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceProfilingTimerResolution",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CSize",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceProfilingTimerResolution",
          "type": "function"
        },
        "index": {
          "description": "Describes the resolution of device timer This is measured in nanoseconds This function execute OpenCL clGetDeviceInfo with CL DEVICE PROFILING TIMER RESOLUTION",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceProfilingTimerResolution",
          "normalized": "CLDeviceID-\u003eIO CSize",
          "package": "OpenCL",
          "partial": "Get Device Profiling Timer Resolution",
          "signature": "CLDeviceID-\u003eIO CSize",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceProfilingTimerResolution"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes the command-queue properties supported by the device. This is a \n list that describes one or more of the CLCommandQueueProperty values.\n These properties are described in the table for \u003ccode\u003eclCreateCommandQueue\u003c/code\u003e. \n The mandated minimum capability is \u003ccode\u003eCL_QUEUE_PROFILING_ENABLE\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_QUEUE_PROPERTIES\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceQueueProperties",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CLCommandQueueProperty]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceQueueProperties",
          "type": "function"
        },
        "index": {
          "description": "Describes the command-queue properties supported by the device This is list that describes one or more of the CLCommandQueueProperty values These properties are described in the table for clCreateCommandQueue The mandated minimum capability is CL QUEUE PROFILING ENABLE This function execute OpenCL clGetDeviceInfo with CL DEVICE QUEUE PROPERTIES",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceQueueProperties",
          "normalized": "CLDeviceID-\u003eIO[CLCommandQueueProperty]",
          "package": "OpenCL",
          "partial": "Get Device Queue Properties",
          "signature": "CLDeviceID-\u003eIO[CLCommandQueueProperty]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceQueueProperties"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDescribes single precision floating-point capability of the device. This is \n a bit-field that describes one or more of the \u003ccode\u003e\u003ca\u003eCLDeviceFPConfig\u003c/a\u003e\u003c/code\u003e values.\n The mandated minimum floating-point capability is \u003ccode\u003e\u003ca\u003eCL_FP_ROUND_TO_NEAREST\u003c/a\u003e\u003c/code\u003e | \n \u003ccode\u003e\u003ca\u003eCL_FP_INF_NAN\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with\n \u003ccode\u003eCL_DEVICE_SINGLE_FP_CONFIG\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceSingleFPConfig",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CLDeviceFPConfig]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceSingleFPConfig",
          "type": "function"
        },
        "index": {
          "description": "Describes single precision floating-point capability of the device This is bit-field that describes one or more of the CLDeviceFPConfig values The mandated minimum floating-point capability is CL FP ROUND TO NEAREST CL FP INF NAN This function execute OpenCL clGetDeviceInfo with CL DEVICE SINGLE FP CONFIG",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceSingleFPConfig",
          "normalized": "CLDeviceID-\u003eIO[CLDeviceFPConfig]",
          "package": "OpenCL",
          "partial": "Get Device Single FPConfig",
          "signature": "CLDeviceID-\u003eIO[CLDeviceFPConfig]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceSingleFPConfig"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe OpenCL device type. Currently supported values are one of or a \n combination of: \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_CPU\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_GPU\u003c/a\u003e\u003c/code\u003e, \n \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_ACCELERATOR\u003c/a\u003e\u003c/code\u003e, or \u003ccode\u003e\u003ca\u003eCL_DEVICE_TYPE_DEFAULT\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_TYPE\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceType",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO [CLDeviceType]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceType",
          "type": "function"
        },
        "index": {
          "description": "The OpenCL device type Currently supported values are one of or combination of CL DEVICE TYPE CPU CL DEVICE TYPE GPU CL DEVICE TYPE ACCELERATOR or CL DEVICE TYPE DEFAULT This function execute OpenCL clGetDeviceInfo with CL DEVICE TYPE",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceType",
          "normalized": "CLDeviceID-\u003eIO[CLDeviceType]",
          "package": "OpenCL",
          "partial": "Get Device Type",
          "signature": "CLDeviceID-\u003eIO[CLDeviceType]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eVendor name string.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_VENDOR\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceVendor",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceVendor",
          "type": "function"
        },
        "index": {
          "description": "Vendor name string This function execute OpenCL clGetDeviceInfo with CL DEVICE VENDOR",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceVendor",
          "normalized": "CLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Device Vendor",
          "signature": "CLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceVendor"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA unique device vendor identifier. An example of a unique device identifier \n could be the PCIe ID.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_VENDOR_ID\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceVendorID",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO CLuint",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceVendorID",
          "type": "function"
        },
        "index": {
          "description": "unique device vendor identifier An example of unique device identifier could be the PCIe ID This function execute OpenCL clGetDeviceInfo with CL DEVICE VENDOR ID",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceVendorID",
          "normalized": "CLDeviceID-\u003eIO CLuint",
          "package": "OpenCL",
          "partial": "Get Device Vendor ID",
          "signature": "CLDeviceID-\u003eIO CLuint",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceVendorID"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpenCL version string. Returns the OpenCL version supported by the device. \n This version string has the following format:\n \u003cem\u003eOpenCL major_version.minor_version vendor-specific information\u003c/em\u003e\n The major_version.minor_version value returned will be 1.0.\n\u003c/p\u003e\u003cp\u003eThis function execute OpenCL clGetDeviceInfo with \u003ccode\u003eCL_DEVICE_VERSION\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceVersion",
          "package": "OpenCL",
          "signature": "CLDeviceID -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetDeviceVersion",
          "type": "function"
        },
        "index": {
          "description": "OpenCL version string Returns the OpenCL version supported by the device This version string has the following format OpenCL major version.minor version vendor-specific information The major version.minor version value returned will be This function execute OpenCL clGetDeviceInfo with CL DEVICE VERSION",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetDeviceVersion",
          "normalized": "CLDeviceID-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Device Version",
          "signature": "CLDeviceID-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetDeviceVersion"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eObtain the list of platforms available. Returns the list if the function \n is executed successfully. Otherwise it returns the empty list.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetPlatformIDs",
          "package": "OpenCL",
          "signature": "IO [CLPlatformID]",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetPlatformIDs",
          "type": "function"
        },
        "index": {
          "description": "Obtain the list of platforms available Returns the list if the function is executed successfully Otherwise it returns the empty list",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetPlatformIDs",
          "normalized": "IO[CLPlatformID]",
          "package": "OpenCL",
          "partial": "Get Platform IDs",
          "signature": "IO[CLPlatformID]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetPlatformIDs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eGet specific information about the OpenCL platform. It returns Nothing if\n platform is not a valid platform.\n\u003c/p\u003e",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetPlatformInfo",
          "package": "OpenCL",
          "signature": "CLPlatformID -\u003e CLPlatformInfo -\u003e IO String",
          "source": "src/Control-Parallel-OpenCL-Query.html#clGetPlatformInfo",
          "type": "function"
        },
        "index": {
          "description": "Get specific information about the OpenCL platform It returns Nothing if platform is not valid platform",
          "hierarchy": "Control Parallel OpenCL Query",
          "module": "Control.Parallel.OpenCL.Query",
          "name": "clGetPlatformInfo",
          "normalized": "CLPlatformID-\u003eCLPlatformInfo-\u003eIO String",
          "package": "OpenCL",
          "partial": "Get Platform Info",
          "signature": "CLPlatformID-\u003eCLPlatformInfo-\u003eIO String",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL-Query.html#v:clGetPlatformInfo"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "OpenCL",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL.html",
          "type": "module"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "OpenCL",
          "package": "OpenCL",
          "partial": "Open CL",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_BUILD_PROGRAM_FAILURE\u003c/a\u003e\u003c/code\u003e, Returned if there is a failure to build the\nprogram executable.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_COMPILER_NOT_AVAILABLE\u003c/a\u003e\u003c/code\u003e, Returned if the parameter program is created with\n\u003ccode\u003eclCreateProgramWithSource\u003c/code\u003e and a compiler is not available. For example\n\u003ccode\u003eclDeviceCompilerAvalaible\u003c/code\u003e is set to \u003ccode\u003e\u003ca\u003eFalse\u003c/a\u003e\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_NOT_AVAILABLE\u003c/a\u003e\u003c/code\u003e, Returned if the specified device is not currently\navailable.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_DEVICE_NOT_FOUND\u003c/a\u003e\u003c/code\u003e, Returned if no OpenCL devices that match the specified\ndevices were found.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eCL_PLATFORM_NOT_FOUND_khr\u003c/code\u003e, Returned when no .icd (platform drivers)\n can be properly loaded.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_IMAGE_FORMAT_MISMATCH\u003c/a\u003e\u003c/code\u003e, Returned if the specified source and destination\nimages are not valid image objects.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_IMAGE_FORMAT_NOT_SUPPORTED\u003c/a\u003e\u003c/code\u003e, Returned if the specified image format is not\nsupported.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_ARG_INDEX\u003c/a\u003e\u003c/code\u003e, Returned if an invalid argument index is specified.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_ARG_SIZE\u003c/a\u003e\u003c/code\u003e, Returned if argument size specified (arg_size) does not\nmatch the size of the data type for an argument that is not a memory object, or\nif the argument is a memory object and arg_size != sizeof(cl_mem) or if arg_size\nis zero and the argument is declared with the __local qualifier or if the\nargument is a sampler and arg_size != sizeof(cl_sampler).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_ARG_VALUE\u003c/a\u003e\u003c/code\u003e, Returned if the argument value specified is NULL for\nan argument that is not declared with the __local qualifier or vice-versa.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_BINARY\u003c/a\u003e\u003c/code\u003e, Returned if the program binary is not a valid binary for\nthe specified device.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_BUFFER_SIZE\u003c/a\u003e\u003c/code\u003e, Returned if the value of the parameter size is 0 or\nis greater than \u003ccode\u003eclDeviceMaxMemAllocSize\u003c/code\u003e for all devices specified in the\nparameter context.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_BUILD_OPTIONS\u003c/a\u003e\u003c/code\u003e, Returned if the specified build options are\ninvalid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_COMMAND_QUEUE\u003c/a\u003e\u003c/code\u003e, Returned if the specified command-queue is not a\nvalid command-queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_CONTEXT\u003c/a\u003e\u003c/code\u003e, Returned if the specified context is not a valid OpenCL\ncontext, or the context associated with certain parameters are not the same.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_DEVICE\u003c/a\u003e\u003c/code\u003e, Returned if the device or devices specified are not\nvalid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_DEVICE_TYPE\u003c/a\u003e\u003c/code\u003e, Returned if device type specified is not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_EVENT\u003c/a\u003e\u003c/code\u003e, Returned if the event objects specified are not valid.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_EVENT_WAIT_LIST\u003c/a\u003e\u003c/code\u003e, Returned if event_wait_list is NULL and\nnum_events_in_wait_list \u003e 0, or event_wait_list_list is not NULL and\nnum_events_in_wait_list is 0, or specified event objects are not valid events.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_GL_OBJECT\u003c/a\u003e\u003c/code\u003e, Returned if obj is not a vaild GL object or is a GL\nobject but does not have an existing data store.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_GLOBAL_OFFSET\u003c/a\u003e\u003c/code\u003e, Returned if global_work_offset is not NULL.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_HOST_PTR\u003c/a\u003e\u003c/code\u003e, Returned if host_ptr is NULL and \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e\nor \u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e are set in flags or if host_ptr is not NULL but\n\u003ccode\u003e\u003ca\u003eCL_MEM_COPY_HOST_PTR\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eCL_MEM_USE_HOST_PTR\u003c/a\u003e\u003c/code\u003e are not set in flags.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_IMAGE_FORMAT_DESCRIPTOR\u003c/a\u003e\u003c/code\u003e, Returned if the image format specified\nis not valid or is NULL or does not map to a supported OpenCL image format.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_IMAGE_SIZE\u003c/a\u003e\u003c/code\u003e, Returned if the specified image width or height are\ninvalid or if the image row pitch and image slice pitch do not follow the rules.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_KERNEL_NAME\u003c/a\u003e\u003c/code\u003e, Returned if the specified kernel name is not found\nin program.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_KERNEL\u003c/a\u003e\u003c/code\u003e, Returned if the specified kernel is not a valid kernel\nobject.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_KERNEL_ARGS\u003c/a\u003e\u003c/code\u003e, Returned if the kernel argument values have not been\nspecified.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_KERNEL_DEFINITION\u003c/a\u003e\u003c/code\u003e, Returned if the function definition for\n__kernel function given by kernel_name such as the number of arguments, the\nargument types are not the same for all devices for which the program executable\nhas been built.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_MEM_OBJECT\u003c/a\u003e\u003c/code\u003e, Returned if a parameter is not a valid memory, image,\nor buffer object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_OPERATION\u003c/a\u003e\u003c/code\u003e, Returned if there are no devices in context that\nsupport images. Returned if the build of a program executable for any of the\ndevices specified by a previous call to \u003ccode\u003eclBuildProgram\u003c/code\u003e for program has not\ncompleted, or if there are kernel objects attached to program. Returned by\n\u003ccode\u003eclEnqueueNativeKernel\u003c/code\u003e if the specified device cannot execute the native\nkernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_PLATFORM\u003c/a\u003e\u003c/code\u003e, Returned if the specified platform is not a valid\nplatform, or no platform could be selected, or if platform value specified in\nproperties is not a valid platform.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_PROGRAM\u003c/a\u003e\u003c/code\u003e, Returned if the specified program is not a valid program\nobject.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_PROGRAM_EXECUTABLE\u003c/a\u003e\u003c/code\u003e, Returned if there is no successfully built\nexecutable for program, or if there is no device in program. Returned if there\nis no successfully built program executable available for device associated with\ncommand_queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_QUEUE_PROPERTIES\u003c/a\u003e\u003c/code\u003e, Returned if specified properties are valid but\nare not supported by the device.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_SAMPLER\u003c/a\u003e\u003c/code\u003e, Returned if the specified sampler is not a valid sampler\nobject, or for an argument declared to be of type sampler_t when the specified\narg_value is not a valid sampler object.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_VALUE\u003c/a\u003e\u003c/code\u003e, Returned if a parameter is not an expected value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_WORK_DIMENSION\u003c/a\u003e\u003c/code\u003e, Returned if work_dim is not a valid value.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_WORK_GROUP_SIZE\u003c/a\u003e\u003c/code\u003e, Returned if local_work_size is specified and\nnumber of workitems specified by global_work_size is not evenly divisible by\nsize of work-group given by local_work_size or does not match the work-group\nsize specified for kernel using the __attribute__((reqd_work_group_size(X, Y,\nZ))) qualifier in program source.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_INVALID_WORK_ITEM_SIZE\u003c/a\u003e\u003c/code\u003e, Returned if the number of work-items specified in\nany of local_work_size... [0]... local_work_size[work_dim - 1] is greater than\nthe corresponding values specified by \u003ccode\u003eclDeviceMaxWorkItemSizes\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MAP_FAILURE\u003c/a\u003e\u003c/code\u003e, Returned by if there is a failure to map the requested\nregion into the host address space. This error cannot occur for buffer objects\ncreated with \u003ccode\u003eCLMEM_USE_HOST_PTR\u003c/code\u003e or \u003ccode\u003eCLMEM_ALLOC_HOST_PTR\u003c/code\u003e.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_OBJECT_ALLOCATION_FAILURE\u003c/a\u003e\u003c/code\u003e, Returned if there is a failure to allocate\nmemory for data store associated with image or buffer objects specified as\narguments to kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_MEM_COPY_OVERLAP\u003c/a\u003e\u003c/code\u003e, Returned if the source and destination images are the\nsame image (or the source and destination buffers are the same buffer), and the\nsource and destination regions overlap.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_OUT_OF_HOST_MEMORY\u003c/a\u003e\u003c/code\u003e, Returned in the event of a failure to allocate\nresources required by the OpenCL implementation on the host.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_OUT_OF_RESOURCES\u003c/a\u003e\u003c/code\u003e, Returned in the event of a failure to queue the\nexecution instance of kernel on the command-queue because of insufficient\nresources needed to execute the kernel.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_PROFILING_INFO_NOT_AVAILABLE\u003c/a\u003e\u003c/code\u003e, Returned if the \u003ccode\u003e\u003ca\u003eCL_QUEUE_PROFILING_ENABLE\u003c/a\u003e\u003c/code\u003e\nflag is not set for the command-queue and the profiling information is currently\nnot available (because the command identified by event has not completed).\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCL_SUCCESS\u003c/a\u003e\u003c/code\u003e, Indicates that the function executed successfully.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Control.Parallel.OpenCL",
          "name": "CLError",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "data"
        },
        "index": {
          "description": "CL BUILD PROGRAM FAILURE Returned if there is failure to build the program executable CL COMPILER NOT AVAILABLE Returned if the parameter program is created with clCreateProgramWithSource and compiler is not available For example clDeviceCompilerAvalaible is set to False CL DEVICE NOT AVAILABLE Returned if the specified device is not currently available CL DEVICE NOT FOUND Returned if no OpenCL devices that match the specified devices were found CL PLATFORM NOT FOUND khr Returned when no icd platform drivers can be properly loaded CL IMAGE FORMAT MISMATCH Returned if the specified source and destination images are not valid image objects CL IMAGE FORMAT NOT SUPPORTED Returned if the specified image format is not supported CL INVALID ARG INDEX Returned if an invalid argument index is specified CL INVALID ARG SIZE Returned if argument size specified arg size does not match the size of the data type for an argument that is not memory object or if the argument is memory object and arg size sizeof cl mem or if arg size is zero and the argument is declared with the local qualifier or if the argument is sampler and arg size sizeof cl sampler CL INVALID ARG VALUE Returned if the argument value specified is NULL for an argument that is not declared with the local qualifier or vice-versa CL INVALID BINARY Returned if the program binary is not valid binary for the specified device CL INVALID BUFFER SIZE Returned if the value of the parameter size is or is greater than clDeviceMaxMemAllocSize for all devices specified in the parameter context CL INVALID BUILD OPTIONS Returned if the specified build options are invalid CL INVALID COMMAND QUEUE Returned if the specified command-queue is not valid command-queue CL INVALID CONTEXT Returned if the specified context is not valid OpenCL context or the context associated with certain parameters are not the same CL INVALID DEVICE Returned if the device or devices specified are not valid CL INVALID DEVICE TYPE Returned if device type specified is not valid CL INVALID EVENT Returned if the event objects specified are not valid CL INVALID EVENT WAIT LIST Returned if event wait list is NULL and num events in wait list or event wait list list is not NULL and num events in wait list is or specified event objects are not valid events CL INVALID GL OBJECT Returned if obj is not vaild GL object or is GL object but does not have an existing data store CL INVALID GLOBAL OFFSET Returned if global work offset is not NULL CL INVALID HOST PTR Returned if host ptr is NULL and CL MEM USE HOST PTR or CL MEM COPY HOST PTR are set in flags or if host ptr is not NULL but CL MEM COPY HOST PTR or CL MEM USE HOST PTR are not set in flags CL INVALID IMAGE FORMAT DESCRIPTOR Returned if the image format specified is not valid or is NULL or does not map to supported OpenCL image format CL INVALID IMAGE SIZE Returned if the specified image width or height are invalid or if the image row pitch and image slice pitch do not follow the rules CL INVALID KERNEL NAME Returned if the specified kernel name is not found in program CL INVALID KERNEL Returned if the specified kernel is not valid kernel object CL INVALID KERNEL ARGS Returned if the kernel argument values have not been specified CL INVALID KERNEL DEFINITION Returned if the function definition for kernel function given by kernel name such as the number of arguments the argument types are not the same for all devices for which the program executable has been built CL INVALID MEM OBJECT Returned if parameter is not valid memory image or buffer object CL INVALID OPERATION Returned if there are no devices in context that support images Returned if the build of program executable for any of the devices specified by previous call to clBuildProgram for program has not completed or if there are kernel objects attached to program Returned by clEnqueueNativeKernel if the specified device cannot execute the native kernel CL INVALID PLATFORM Returned if the specified platform is not valid platform or no platform could be selected or if platform value specified in properties is not valid platform CL INVALID PROGRAM Returned if the specified program is not valid program object CL INVALID PROGRAM EXECUTABLE Returned if there is no successfully built executable for program or if there is no device in program Returned if there is no successfully built program executable available for device associated with command queue CL INVALID QUEUE PROPERTIES Returned if specified properties are valid but are not supported by the device CL INVALID SAMPLER Returned if the specified sampler is not valid sampler object or for an argument declared to be of type sampler when the specified arg value is not valid sampler object CL INVALID VALUE Returned if parameter is not an expected value CL INVALID WORK DIMENSION Returned if work dim is not valid value CL INVALID WORK GROUP SIZE Returned if local work size is specified and number of workitems specified by global work size is not evenly divisible by size of work-group given by local work size or does not match the work-group size specified for kernel using the attribute reqd work group size qualifier in program source CL INVALID WORK ITEM SIZE Returned if the number of work-items specified in any of local work size local work size work dim is greater than the corresponding values specified by clDeviceMaxWorkItemSizes CL MAP FAILURE Returned by if there is failure to map the requested region into the host address space This error cannot occur for buffer objects created with CLMEM USE HOST PTR or CLMEM ALLOC HOST PTR CL MEM OBJECT ALLOCATION FAILURE Returned if there is failure to allocate memory for data store associated with image or buffer objects specified as arguments to kernel CL MEM COPY OVERLAP Returned if the source and destination images are the same image or the source and destination buffers are the same buffer and the source and destination regions overlap CL OUT OF HOST MEMORY Returned in the event of failure to allocate resources required by the OpenCL implementation on the host CL OUT OF RESOURCES Returned in the event of failure to queue the execution instance of kernel on the command-queue because of insufficient resources needed to execute the kernel CL PROFILING INFO NOT AVAILABLE Returned if the CL QUEUE PROFILING ENABLE flag is not set for the command-queue and the profiling information is currently not available because the command identified by event has not completed CL SUCCESS Indicates that the function executed successfully",
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CLError",
          "package": "OpenCL",
          "partial": "CLError",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#t:CLError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CLint",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLint",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CLint",
          "package": "OpenCL",
          "partial": "CLint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#t:CLint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CLuint",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLuint",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CLuint",
          "package": "OpenCL",
          "partial": "CLuint",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#t:CLuint"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CLulong",
          "package": "OpenCL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLulong",
          "type": "type"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CLulong",
          "package": "OpenCL",
          "partial": "CLulong",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#t:CLulong"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_BUILD_PROGRAM_FAILURE",
          "package": "OpenCL",
          "signature": "CL_BUILD_PROGRAM_FAILURE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_BUILD_PROGRAM_FAILURE",
          "package": "OpenCL",
          "partial": "CL BUILD PROGRAM FAILURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_BUILD_PROGRAM_FAILURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_COMPILER_NOT_AVAILABLE",
          "package": "OpenCL",
          "signature": "CL_COMPILER_NOT_AVAILABLE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_COMPILER_NOT_AVAILABLE",
          "package": "OpenCL",
          "partial": "CL COMPILER NOT AVAILABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_COMPILER_NOT_AVAILABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_DEVICE_NOT_AVAILABLE",
          "package": "OpenCL",
          "signature": "CL_DEVICE_NOT_AVAILABLE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_DEVICE_NOT_AVAILABLE",
          "package": "OpenCL",
          "partial": "CL DEVICE NOT AVAILABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_DEVICE_NOT_AVAILABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_DEVICE_NOT_FOUND",
          "package": "OpenCL",
          "signature": "CL_DEVICE_NOT_FOUND",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_DEVICE_NOT_FOUND",
          "package": "OpenCL",
          "partial": "CL DEVICE NOT FOUND",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_DEVICE_NOT_FOUND"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_IMAGE_FORMAT_MISMATCH",
          "package": "OpenCL",
          "signature": "CL_IMAGE_FORMAT_MISMATCH",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_IMAGE_FORMAT_MISMATCH",
          "package": "OpenCL",
          "partial": "CL IMAGE FORMAT MISMATCH",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_IMAGE_FORMAT_MISMATCH"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_IMAGE_FORMAT_NOT_SUPPORTED",
          "package": "OpenCL",
          "signature": "CL_IMAGE_FORMAT_NOT_SUPPORTED",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_IMAGE_FORMAT_NOT_SUPPORTED",
          "package": "OpenCL",
          "partial": "CL IMAGE FORMAT NOT SUPPORTED",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_IMAGE_FORMAT_NOT_SUPPORTED"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_ARG_INDEX",
          "package": "OpenCL",
          "signature": "CL_INVALID_ARG_INDEX",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_ARG_INDEX",
          "package": "OpenCL",
          "partial": "CL INVALID ARG INDEX",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_ARG_INDEX"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_ARG_SIZE",
          "package": "OpenCL",
          "signature": "CL_INVALID_ARG_SIZE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_ARG_SIZE",
          "package": "OpenCL",
          "partial": "CL INVALID ARG SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_ARG_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_ARG_VALUE",
          "package": "OpenCL",
          "signature": "CL_INVALID_ARG_VALUE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_ARG_VALUE",
          "package": "OpenCL",
          "partial": "CL INVALID ARG VALUE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_ARG_VALUE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_BINARY",
          "package": "OpenCL",
          "signature": "CL_INVALID_BINARY",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_BINARY",
          "package": "OpenCL",
          "partial": "CL INVALID BINARY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_BINARY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_BUFFER_SIZE",
          "package": "OpenCL",
          "signature": "CL_INVALID_BUFFER_SIZE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_BUFFER_SIZE",
          "package": "OpenCL",
          "partial": "CL INVALID BUFFER SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_BUFFER_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_BUILD_OPTIONS",
          "package": "OpenCL",
          "signature": "CL_INVALID_BUILD_OPTIONS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_BUILD_OPTIONS",
          "package": "OpenCL",
          "partial": "CL INVALID BUILD OPTIONS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_BUILD_OPTIONS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_COMMAND_QUEUE",
          "package": "OpenCL",
          "signature": "CL_INVALID_COMMAND_QUEUE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_COMMAND_QUEUE",
          "package": "OpenCL",
          "partial": "CL INVALID COMMAND QUEUE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_COMMAND_QUEUE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_CONTEXT",
          "package": "OpenCL",
          "signature": "CL_INVALID_CONTEXT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_CONTEXT",
          "package": "OpenCL",
          "partial": "CL INVALID CONTEXT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_CONTEXT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_DEVICE",
          "package": "OpenCL",
          "signature": "CL_INVALID_DEVICE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_DEVICE",
          "package": "OpenCL",
          "partial": "CL INVALID DEVICE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_DEVICE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_DEVICE_TYPE",
          "package": "OpenCL",
          "signature": "CL_INVALID_DEVICE_TYPE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_DEVICE_TYPE",
          "package": "OpenCL",
          "partial": "CL INVALID DEVICE TYPE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_DEVICE_TYPE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_EVENT",
          "package": "OpenCL",
          "signature": "CL_INVALID_EVENT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_EVENT",
          "package": "OpenCL",
          "partial": "CL INVALID EVENT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_EVENT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_EVENT_WAIT_LIST",
          "package": "OpenCL",
          "signature": "CL_INVALID_EVENT_WAIT_LIST",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_EVENT_WAIT_LIST",
          "package": "OpenCL",
          "partial": "CL INVALID EVENT WAIT LIST",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_EVENT_WAIT_LIST"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_GLOBAL_OFFSET",
          "package": "OpenCL",
          "signature": "CL_INVALID_GLOBAL_OFFSET",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_GLOBAL_OFFSET",
          "package": "OpenCL",
          "partial": "CL INVALID GLOBAL OFFSET",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_GLOBAL_OFFSET"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_GL_OBJECT",
          "package": "OpenCL",
          "signature": "CL_INVALID_GL_OBJECT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_GL_OBJECT",
          "package": "OpenCL",
          "partial": "CL INVALID GL OBJECT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_GL_OBJECT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_HOST_PTR",
          "package": "OpenCL",
          "signature": "CL_INVALID_HOST_PTR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_HOST_PTR",
          "package": "OpenCL",
          "partial": "CL INVALID HOST PTR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_HOST_PTR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR",
          "package": "OpenCL",
          "signature": "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_IMAGE_FORMAT_DESCRIPTOR",
          "package": "OpenCL",
          "partial": "CL INVALID IMAGE FORMAT DESCRIPTOR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_IMAGE_FORMAT_DESCRIPTOR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_IMAGE_SIZE",
          "package": "OpenCL",
          "signature": "CL_INVALID_IMAGE_SIZE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_IMAGE_SIZE",
          "package": "OpenCL",
          "partial": "CL INVALID IMAGE SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_IMAGE_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL",
          "package": "OpenCL",
          "signature": "CL_INVALID_KERNEL",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL",
          "package": "OpenCL",
          "partial": "CL INVALID KERNEL",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_KERNEL"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL_ARGS",
          "package": "OpenCL",
          "signature": "CL_INVALID_KERNEL_ARGS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL_ARGS",
          "package": "OpenCL",
          "partial": "CL INVALID KERNEL ARGS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_KERNEL_ARGS"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL_DEFINITION",
          "package": "OpenCL",
          "signature": "CL_INVALID_KERNEL_DEFINITION",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL_DEFINITION",
          "package": "OpenCL",
          "partial": "CL INVALID KERNEL DEFINITION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_KERNEL_DEFINITION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL_NAME",
          "package": "OpenCL",
          "signature": "CL_INVALID_KERNEL_NAME",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_KERNEL_NAME",
          "package": "OpenCL",
          "partial": "CL INVALID KERNEL NAME",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_KERNEL_NAME"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_MEM_OBJECT",
          "package": "OpenCL",
          "signature": "CL_INVALID_MEM_OBJECT",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_MEM_OBJECT",
          "package": "OpenCL",
          "partial": "CL INVALID MEM OBJECT",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_MEM_OBJECT"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_OPERATION",
          "package": "OpenCL",
          "signature": "CL_INVALID_OPERATION",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_OPERATION",
          "package": "OpenCL",
          "partial": "CL INVALID OPERATION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_OPERATION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_PLATFORM",
          "package": "OpenCL",
          "signature": "CL_INVALID_PLATFORM",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_PLATFORM",
          "package": "OpenCL",
          "partial": "CL INVALID PLATFORM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_PLATFORM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_PROGRAM",
          "package": "OpenCL",
          "signature": "CL_INVALID_PROGRAM",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_PROGRAM",
          "package": "OpenCL",
          "partial": "CL INVALID PROGRAM",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_PROGRAM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_PROGRAM_EXECUTABLE",
          "package": "OpenCL",
          "signature": "CL_INVALID_PROGRAM_EXECUTABLE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_PROGRAM_EXECUTABLE",
          "package": "OpenCL",
          "partial": "CL INVALID PROGRAM EXECUTABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_PROGRAM_EXECUTABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_QUEUE_PROPERTIES",
          "package": "OpenCL",
          "signature": "CL_INVALID_QUEUE_PROPERTIES",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_QUEUE_PROPERTIES",
          "package": "OpenCL",
          "partial": "CL INVALID QUEUE PROPERTIES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_QUEUE_PROPERTIES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_SAMPLER",
          "package": "OpenCL",
          "signature": "CL_INVALID_SAMPLER",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_SAMPLER",
          "package": "OpenCL",
          "partial": "CL INVALID SAMPLER",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_SAMPLER"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_VALUE",
          "package": "OpenCL",
          "signature": "CL_INVALID_VALUE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_VALUE",
          "package": "OpenCL",
          "partial": "CL INVALID VALUE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_VALUE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_WORK_DIMENSION",
          "package": "OpenCL",
          "signature": "CL_INVALID_WORK_DIMENSION",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_WORK_DIMENSION",
          "package": "OpenCL",
          "partial": "CL INVALID WORK DIMENSION",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_WORK_DIMENSION"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_WORK_GROUP_SIZE",
          "package": "OpenCL",
          "signature": "CL_INVALID_WORK_GROUP_SIZE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_WORK_GROUP_SIZE",
          "package": "OpenCL",
          "partial": "CL INVALID WORK GROUP SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_WORK_GROUP_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_WORK_ITEM_SIZE",
          "package": "OpenCL",
          "signature": "CL_INVALID_WORK_ITEM_SIZE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_INVALID_WORK_ITEM_SIZE",
          "package": "OpenCL",
          "partial": "CL INVALID WORK ITEM SIZE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_INVALID_WORK_ITEM_SIZE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_MAP_FAILURE",
          "package": "OpenCL",
          "signature": "CL_MAP_FAILURE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_MAP_FAILURE",
          "package": "OpenCL",
          "partial": "CL MAP FAILURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_MAP_FAILURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_MEM_COPY_OVERLAP",
          "package": "OpenCL",
          "signature": "CL_MEM_COPY_OVERLAP",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_MEM_COPY_OVERLAP",
          "package": "OpenCL",
          "partial": "CL MEM COPY OVERLAP",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_MEM_COPY_OVERLAP"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_MEM_OBJECT_ALLOCATION_FAILURE",
          "package": "OpenCL",
          "signature": "CL_MEM_OBJECT_ALLOCATION_FAILURE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_MEM_OBJECT_ALLOCATION_FAILURE",
          "package": "OpenCL",
          "partial": "CL MEM OBJECT ALLOCATION FAILURE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_MEM_OBJECT_ALLOCATION_FAILURE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_OUT_OF_HOST_MEMORY",
          "package": "OpenCL",
          "signature": "CL_OUT_OF_HOST_MEMORY",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_OUT_OF_HOST_MEMORY",
          "package": "OpenCL",
          "partial": "CL OUT OF HOST MEMORY",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_OUT_OF_HOST_MEMORY"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_OUT_OF_RESOURCES",
          "package": "OpenCL",
          "signature": "CL_OUT_OF_RESOURCES",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_OUT_OF_RESOURCES",
          "package": "OpenCL",
          "partial": "CL OUT OF RESOURCES",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_OUT_OF_RESOURCES"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_PLATFORM_NOT_FOUND_KHR",
          "package": "OpenCL",
          "signature": "CL_PLATFORM_NOT_FOUND_KHR",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_PLATFORM_NOT_FOUND_KHR",
          "package": "OpenCL",
          "partial": "CL PLATFORM NOT FOUND KHR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_PLATFORM_NOT_FOUND_KHR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_PROFILING_INFO_NOT_AVAILABLE",
          "package": "OpenCL",
          "signature": "CL_PROFILING_INFO_NOT_AVAILABLE",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_PROFILING_INFO_NOT_AVAILABLE",
          "package": "OpenCL",
          "partial": "CL PROFILING INFO NOT AVAILABLE",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_PROFILING_INFO_NOT_AVAILABLE"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Control.Parallel.OpenCL",
          "name": "CL_SUCCESS",
          "package": "OpenCL",
          "signature": "CL_SUCCESS",
          "source": "src/Control-Parallel-OpenCL-Types.html#CLError",
          "type": "function"
        },
        "index": {
          "hierarchy": "Control Parallel OpenCL",
          "module": "Control.Parallel.OpenCL",
          "name": "CL_SUCCESS",
          "package": "OpenCL",
          "partial": "CL SUCCESS",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/OpenCL/docs/Control-Parallel-OpenCL.html#v:CL_SUCCESS"
      }
    }
  ]
]