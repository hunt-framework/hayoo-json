[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "stomp-queue"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eExceptions for the Stompl Client\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "Exception",
          "package": "stomp-queue",
          "type": "module"
        },
        "index": {
          "description": "Exceptions for the Stompl Client",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "Exception",
          "package": "stomp-queue",
          "partial": "Exception",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Stompl Client uses exceptions to communicate errors\n   to the user application.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "StomplException",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "The Stompl Client uses exceptions to communicate errors to the user application",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "StomplException",
          "package": "stomp-queue",
          "partial": "Stompl Exception",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#t:StomplException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown by \u003cem\u003eabort\u003c/em\u003e\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "AppException",
          "package": "stomp-queue",
          "signature": "AppException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown by abort",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "AppException",
          "package": "stomp-queue",
          "partial": "App Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:AppException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when an error frame is received\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "BrokerException",
          "package": "stomp-queue",
          "signature": "BrokerException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown when an error frame is received",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "BrokerException",
          "package": "stomp-queue",
          "partial": "Broker Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:BrokerException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown on connection errors, \u003cem\u003ee.g.\u003c/em\u003e\n   connection was disconnected\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "ConnectException",
          "package": "stomp-queue",
          "signature": "ConnectException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown on connection errors e.g connection was disconnected",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "ConnectException",
          "package": "stomp-queue",
          "partial": "Connect Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:ConnectException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eShould be thrown \n   by user-defined converters\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "ConvertException",
          "package": "stomp-queue",
          "signature": "ConvertException String",
          "type": "function"
        },
        "index": {
          "description": "Should be thrown by user-defined converters",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "ConvertException",
          "package": "stomp-queue",
          "partial": "Convert Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:ConvertException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eYou hit a bug!\n   This exception is only thrown\n   when something really strange happened\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "OuchException",
          "package": "stomp-queue",
          "signature": "OuchException String",
          "type": "function"
        },
        "index": {
          "description": "You hit bug This exception is only thrown when something really strange happened",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "OuchException",
          "package": "stomp-queue",
          "partial": "Ouch Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:OuchException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown when something \n   against the protocol happens, \u003cem\u003ee.g.\u003c/em\u003e\n   an unexpected frame is received\n   or a message from a queue\n   that was not subscribed\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "ProtocolException",
          "package": "stomp-queue",
          "signature": "ProtocolException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown when something against the protocol happens e.g an unexpected frame is received or message from queue that was not subscribed",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "ProtocolException",
          "package": "stomp-queue",
          "partial": "Protocol Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:ProtocolException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown on wrong uses of queues, \u003cem\u003ee.g.\u003c/em\u003e\n   use of a queue outside its scope\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "QueueException",
          "package": "stomp-queue",
          "signature": "QueueException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown on wrong uses of queues e.g use of queue outside its scope",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "QueueException",
          "package": "stomp-queue",
          "partial": "Queue Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:QueueException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown\n   on problems with the socket, \u003cem\u003ee.g.\u003c/em\u003e\n   when a message cannot be sent\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "SocketException",
          "package": "stomp-queue",
          "signature": "SocketException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown on problems with the socket e.g when message cannot be sent",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "SocketException",
          "package": "stomp-queue",
          "partial": "Socket Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:SocketException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrown on transaction errors, \u003cem\u003ee.g.\u003c/em\u003e\n   pending acks\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "TxException",
          "package": "stomp-queue",
          "signature": "TxException String",
          "type": "function"
        },
        "index": {
          "description": "Thrown on transaction errors e.g pending acks",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "TxException",
          "package": "stomp-queue",
          "partial": "Tx Exception",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:TxException"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThrows \u003ccode\u003e\u003ca\u003eConvertException\u003c/a\u003e\u003c/code\u003e\n   to signal a conversion error.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "convertError",
          "package": "stomp-queue",
          "signature": "String -\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Throws ConvertException to signal conversion error",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "convertError",
          "normalized": "String-\u003eIO a",
          "package": "stomp-queue",
          "partial": "Error",
          "signature": "String-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:convertError"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCatches any \u003ccode\u003e\u003ca\u003eStomplException\u003c/a\u003e\u003c/code\u003e,\n   including asynchronous exceptions coming from internal threads\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "try",
          "package": "stomp-queue",
          "signature": "IO a -\u003e IO (Either StomplException a)",
          "type": "function"
        },
        "index": {
          "description": "Catches any StomplException including asynchronous exceptions coming from internal threads",
          "hierarchy": "Network Mom Stompl Client Exception",
          "module": "Network.Mom.Stompl.Client.Exception",
          "name": "try",
          "normalized": "IO a-\u003eIO(Either StomplException a)",
          "package": "stomp-queue",
          "signature": "IO a-\u003eIO(Either StomplException a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Exception.html#v:try"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cdiv class=\"warning\"\u003e\u003cp\u003eDeprecated: use Network.Mom.Stompl.Patterns.Basic instead!\u003c/p\u003e\u003c/div\u003e\u003cp\u003eThe Stomp specification defines only one queuing pattern:\n \u003cem\u003epublish and subscribe\u003c/em\u003e.\n In some situations, other patterns may be more appropriate\n such as \u003cem\u003epeer-to-peer\u003c/em\u003e or \u003cem\u003eclient server\u003c/em\u003e.\n Whereas patterns like peer-to-peer \n are easy to simulate with the means provided by Stomp,\n client/server needs some more coordination\n between the involved parties, the clients and the server.\n\u003c/p\u003e\u003cp\u003eThis module provides abstractions that implement\n a simple client/server protocol on top of Stomp.\n A server is an application that provides a \u003cem\u003eservice\u003c/em\u003e\n to others.\n The service must be explicitly requested by a client\n and only the requesting client must see the response\n produced by the server.\n\u003c/p\u003e\u003cp\u003eThe module, basically, provides two data types (\u003ccode\u003e\u003ca\u003eClientA\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eServerA\u003c/a\u003e\u003c/code\u003e)\n and two functions working on these data types, namely\n \u003ccode\u003e\u003ca\u003erequest\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereply\u003c/a\u003e\u003c/code\u003e.\n With the request function, the client requests a service\n and waits for a response.\n With the reply function, a server waits for a request,\n produces a response and sends it back through a channel\n indicated by the client.\n\u003c/p\u003e\u003cp\u003eInternally, \u003ccode\u003e\u003ca\u003erequest\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ereply\u003c/a\u003e\u003c/code\u003e use a message header\n called \"__client__\" to agree on the reply queue\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "Patterns",
          "package": "stomp-queue",
          "type": "module"
        },
        "index": {
          "description": "Deprecated use Network.Mom.Stompl.Patterns.Basic instead The Stomp specification defines only one queuing pattern publish and subscribe In some situations other patterns may be more appropriate such as peer-to-peer or client server Whereas patterns like peer-to-peer are easy to simulate with the means provided by Stomp client server needs some more coordination between the involved parties the clients and the server This module provides abstractions that implement simple client server protocol on top of Stomp server is an application that provides service to others The service must be explicitly requested by client and only the requesting client must see the response produced by the server The module basically provides two data types ClientA and ServerA and two functions working on these data types namely request and reply With the request function the client requests service and waits for response With the reply function server waits for request produces response and sends it back through channel indicated by the client Internally request and reply use message header called client to agree on the reply queue",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "Patterns",
          "package": "stomp-queue",
          "partial": "Patterns",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe client data type\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "ClientA",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "The client data type",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "ClientA",
          "package": "stomp-queue",
          "partial": "Client",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#t:ClientA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe server data type\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "ServerA",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "The server data type",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "ServerA",
          "package": "stomp-queue",
          "partial": "Server",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#t:ServerA"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis function serves as a \"delayed\" receiver for the case\n   that the timeout of a request has expired.\n   When using this function, it is assumed\n   that a request has been made, but no response has been received.\n   It can be used in time-critical applications,\n   where the client may use the time between request and reply\n   productively, instead of blocking on the reply queue.\n\u003c/p\u003e\u003cp\u003eUse this function with care! It can be easily abused\n   to break the client/server pattern, when it is called\n   without a request having been made before.\n   If, in this case, \u003cem\u003etimout\u003c/em\u003e is \u003cem\u003e-1\u003c/em\u003e,\n   the application will block for ever.\n\u003c/p\u003e\u003cp\u003eFor parameters, please refer to \u003ccode\u003e\u003ca\u003erequest\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "checkRequest",
          "package": "stomp-queue",
          "signature": "ClientA i o -\u003e Int -\u003e IO (Maybe (Message i))",
          "type": "function"
        },
        "index": {
          "description": "This function serves as delayed receiver for the case that the timeout of request has expired When using this function it is assumed that request has been made but no response has been received It can be used in time-critical applications where the client may use the time between request and reply productively instead of blocking on the reply queue Use this function with care It can be easily abused to break the client server pattern when it is called without request having been made before If in this case timout is the application will block for ever For parameters please refer to request",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "checkRequest",
          "normalized": "ClientA a b-\u003eInt-\u003eIO(Maybe(Message a))",
          "package": "stomp-queue",
          "partial": "Request",
          "signature": "ClientA i o-\u003eInt-\u003eIO(Maybe(Message i))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#v:checkRequest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWaits for a client request, \n   calls the application-defined transformer to generate a reply\n   and sends this reply through the queue\n   whose name is indicated by the value of the \"__client__\" header.\n   The time a server waits for a request may be restricted\n   by the timeout. Typically, you would call reply with \n   timeout set to \u003cem\u003e-1\u003c/em\u003e (for \u003cem\u003ewait eternally\u003c/em\u003e).\n   There may be situations, however, where it actually\n   makes sense to restrict the waiting time,\n   \u003cem\u003ei.e.\u003c/em\u003e to perform some housekeeping in between.\n\u003c/p\u003e\u003cp\u003eTypically, you call reply in a loop like\n\u003c/p\u003e\u003cpre\u003e forever $ reply srv (-1) nullType [] f\n\u003c/pre\u003e\u003cp\u003ewhere \u003cem\u003ef\u003c/em\u003e is a function of type \n\u003c/p\u003e\u003cpre\u003e 'Message' i -\u003e 'IO' o.\n\u003c/pre\u003e\u003cp\u003eParameters:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eServerA\u003c/a\u003e\u003c/code\u003e i o: The server; note that i is the request queue\n                                     and  o the reply queue.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eInt\u003c/code\u003e: The timeout in microseconds.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eType\u003c/code\u003e: The \u003cem\u003eMIME\u003c/em\u003e type of the reply.\n\u003c/li\u003e\u003cli\u003e [\u003ccode\u003eHeader\u003c/code\u003e]: Additional headers to be sent with the reply.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e i -\u003e IO o: Transforms the request into a reply -\n                          this defines the service provided by this\n                          application.\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "reply",
          "package": "stomp-queue",
          "signature": "ServerA i o -\u003e Int -\u003e Type -\u003e [Header] -\u003e (Message i -\u003e IO o) -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Waits for client request calls the application-defined transformer to generate reply and sends this reply through the queue whose name is indicated by the value of the client header The time server waits for request may be restricted by the timeout Typically you would call reply with timeout set to for wait eternally There may be situations however where it actually makes sense to restrict the waiting time i.e to perform some housekeeping in between Typically you call reply in loop like forever reply srv nullType where is function of type Message IO Parameters ServerA The server note that is the request queue and the reply queue Int The timeout in microseconds Type The MIME type of the reply Header Additional headers to be sent with the reply Message IO Transforms the request into reply this defines the service provided by this application",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "reply",
          "normalized": "ServerA a b-\u003eInt-\u003eType-\u003e[Header]-\u003e(Message a-\u003eIO b)-\u003eIO()",
          "package": "stomp-queue",
          "signature": "ServerA i o-\u003eInt-\u003eType-\u003e[Header]-\u003e(Message i-\u003eIO o)-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#v:reply"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe client will send the request of type \u003cem\u003eo\u003c/em\u003e\n   and wait for the reply until the timeout exprires.\n   The reply is of type \u003cem\u003ei\u003c/em\u003e and is returned as \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e \u003cem\u003ei\u003c/em\u003e.\n   If the timeout expires before the reply has been received,\n   the function returns \u003ccode\u003eNothing\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eParameters:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eClientA\u003c/a\u003e\u003c/code\u003e i o: The client; note that i is the type of the reply,\n                                          o is the type of the request.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eInt\u003c/code\u003e: The timeout in microseconds.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eType\u003c/code\u003e: The \u003cem\u003eMIME\u003c/em\u003e type of the request.\n\u003c/li\u003e\u003cli\u003e [\u003ccode\u003eHeader\u003c/code\u003e]: List of additional headers \n                   to be sent with the request;\n                   note that the function, internally,\n                   uses a header named \"__client__\".\n                   This header name, hence, is reserved\n                   and must not be used by the application.\n\u003c/li\u003e\u003cli\u003e \u003cem\u003eo\u003c/em\u003e: The request \n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "request",
          "package": "stomp-queue",
          "signature": "ClientA i o -\u003e Int -\u003e Type -\u003e [Header] -\u003e o -\u003e IO (Maybe (Message i))",
          "type": "function"
        },
        "index": {
          "description": "The client will send the request of type and wait for the reply until the timeout exprires The reply is of type and is returned as Message If the timeout expires before the reply has been received the function returns Nothing Parameters ClientA The client note that is the type of the reply is the type of the request Int The timeout in microseconds Type The MIME type of the request Header List of additional headers to be sent with the request note that the function internally uses header named client This header name hence is reserved and must not be used by the application The request",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "request",
          "normalized": "ClientA a b-\u003eInt-\u003eType-\u003e[Header]-\u003eb-\u003eIO(Maybe(Message a))",
          "package": "stomp-queue",
          "signature": "ClientA i o-\u003eInt-\u003eType-\u003e[Header]-\u003eo-\u003eIO(Maybe(Message i))",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#v:request"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function creates a client that lives within its scope.\n\u003c/p\u003e\u003cp\u003eParameters:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e: Connection to a Stomp broker\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eString\u003c/code\u003e: Name of the Client, used for debugging.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eReaderDesc\u003c/a\u003e\u003c/code\u003e i: Description of a reader queue;\n                     this is the queue through which the server\n                     will send its response.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eWriterDesc\u003c/a\u003e\u003c/code\u003e o: Description of a writer queue;\n                     this is the queue through which the server\n                     is expecting requests.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eClientA\u003c/a\u003e\u003c/code\u003e i o -\u003e IO r: An application-defined action\n                            whose scope defines the client's lifetime\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "withClient",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e ReaderDesc i -\u003e WriterDesc o -\u003e (ClientA i o -\u003e IO r) -\u003e IO r",
          "type": "function"
        },
        "index": {
          "description": "The function creates client that lives within its scope Parameters Con Connection to Stomp broker String Name of the Client used for debugging ReaderDesc Description of reader queue this is the queue through which the server will send its response WriterDesc Description of writer queue this is the queue through which the server is expecting requests ClientA IO An application-defined action whose scope defines the client lifetime",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "withClient",
          "normalized": "Con-\u003eString-\u003eReaderDesc a-\u003eWriterDesc b-\u003e(ClientA a b-\u003eIO c)-\u003eIO c",
          "package": "stomp-queue",
          "partial": "Client",
          "signature": "Con-\u003eString-\u003eReaderDesc i-\u003eWriterDesc o-\u003e(ClientA i o-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#v:withClient"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe function creates a server\n   that lives within its scope.\n\u003c/p\u003e\u003cp\u003eParameters:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e: Connection to a Stomp broker\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eString\u003c/code\u003e: Name of the Server, used for debugging.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eReaderDesc\u003c/a\u003e\u003c/code\u003e i: Description of a reader queue;\n                     this is the queue through which clients\n                     are expected to send requests.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eWriterDesc\u003c/a\u003e\u003c/code\u003e o: Description of a writer queue;\n                     this is the queue through which\n                     a specific client will expect the reply.\n                     Note that the server will overwrite\n                     the destination of this queue\n                     using \u003ccode\u003e\u003ca\u003ewriteAdHoc\u003c/a\u003e\u003c/code\u003e; \n                     the destination of this queue, hence,\n                     is irrelevant.\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eServerA\u003c/a\u003e\u003c/code\u003e i o -\u003e IO r: An application-defined action\n                            whose scope defines the server's lifetime\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "withServer",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e ReaderDesc i -\u003e WriterDesc o -\u003e (ServerA i o -\u003e IO r) -\u003e IO r",
          "type": "function"
        },
        "index": {
          "description": "The function creates server that lives within its scope Parameters Con Connection to Stomp broker String Name of the Server used for debugging ReaderDesc Description of reader queue this is the queue through which clients are expected to send requests WriterDesc Description of writer queue this is the queue through which specific client will expect the reply Note that the server will overwrite the destination of this queue using writeAdHoc the destination of this queue hence is irrelevant ServerA IO An application-defined action whose scope defines the server lifetime",
          "hierarchy": "Network Mom Stompl Client Patterns",
          "module": "Network.Mom.Stompl.Client.Patterns",
          "name": "withServer",
          "normalized": "Con-\u003eString-\u003eReaderDesc a-\u003eWriterDesc b-\u003e(ServerA a b-\u003eIO c)-\u003eIO c",
          "package": "stomp-queue",
          "partial": "Server",
          "signature": "Con-\u003eString-\u003eReaderDesc i-\u003eWriterDesc o-\u003e(ServerA i o-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Patterns.html#v:withServer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThe Stomp Protocol specifies message-oriented interoperability.\n Applications connect to a message broker to send (publish)\n or receive (subscribe) messages through queues. \n Interoperating applications do not know \n the location or internal structure of each other.\n They only see interfaces, \u003cem\u003ei.e.\u003c/em\u003e the messages\n published and subscribed through the broker.\n\u003c/p\u003e\u003cp\u003eThe Stompl Client library implements\n a Stomp client using abstractions like\n \u003ccode\u003eConnection\u003c/code\u003e, \u003ccode\u003eTransaction\u003c/code\u003e and\n queues in terms of \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Queue",
          "package": "stomp-queue",
          "type": "module"
        },
        "index": {
          "description": "The Stomp Protocol specifies message-oriented interoperability Applications connect to message broker to send publish or receive subscribe messages through queues Interoperating applications do not know the location or internal structure of each other They only see interfaces i.e the messages published and subscribed through the broker The Stompl Client library implements Stomp client using abstractions like Connection Transaction and queues in terms of Reader and Writer",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Queue",
          "package": "stomp-queue",
          "partial": "Queue",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "AckMode",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "AckMode",
          "package": "stomp-queue",
          "partial": "Ack Mode",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:AckMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOpaque Connection handle.\n   Only valid within the action passed to \u003cem\u003ewithConnection\u003c/em\u003e. \n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Con",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Opaque Connection handle Only valid within the action passed to withConnection",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Con",
          "package": "stomp-queue",
          "partial": "Con",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Con"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions passed to a connection\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Copt",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Options passed to connection",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Copt",
          "package": "stomp-queue",
          "partial": "Copt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Copt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Heart",
          "package": "stomp-queue",
          "type": "type"
        },
        "index": {
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Heart",
          "package": "stomp-queue",
          "partial": "Heart",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Heart"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eConverters are user-defined actions passed to \n   \u003ccode\u003e\u003ca\u003enewReader\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eInBound\u003c/a\u003e\u003c/code\u003e) and\n   \u003ccode\u003e\u003ca\u003enewWriter\u003c/a\u003e\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eOutBound\u003c/a\u003e\u003c/code\u003e)\n   that convert a \u003ccode\u003eByteString\u003c/code\u003e to a value of type \u003cem\u003ea\u003c/em\u003e (\u003ccode\u003e\u003ca\u003eInBound\u003c/a\u003e\u003c/code\u003e) or\n                a value of type \u003cem\u003ea\u003c/em\u003e to \u003ccode\u003eByteString\u003c/code\u003e (\u003ccode\u003e\u003ca\u003eOutBound\u003c/a\u003e\u003c/code\u003e). \n   Converters are, hence, similar to \u003cem\u003eput\u003c/em\u003e and \u003cem\u003eget\u003c/em\u003e in the \u003cem\u003eBinary\u003c/em\u003e\n   monad. \n\u003c/p\u003e\u003cp\u003eThe reason for using explicit, user-defined converters \n   instead of \u003cem\u003eBinary\u003c/em\u003e \u003cem\u003eencode\u003c/em\u003e and \u003cem\u003edecode\u003c/em\u003e\n   is that the conversion with queues\n   may be much more complex, involving reading configurations \n   or other \u003ccode\u003eIO\u003c/code\u003e actions.\n   Furthermore, we have to distinguish between data types and \n   there binary encoding when sent over the network.\n   This distinction is made by \u003cem\u003eMIME\u003c/em\u003e types.\n   Two applications may send the same data type,\n   but one encodes this type as \"text/plain\",\n   the other as \"text/xml\".\n   \u003ccode\u003e\u003ca\u003eInBound\u003c/a\u003e\u003c/code\u003e conversions have to consider the \u003cem\u003eMIME\u003c/em\u003e type\n   and, hence, need more input parameters than provided by \u003cem\u003edecode\u003c/em\u003e.\n   \u003cem\u003eencode\u003c/em\u003e and \u003cem\u003edecode\u003c/em\u003e, however,\n   can be used internally by user-defined converters.\n\u003c/p\u003e\u003cp\u003eThe parameters expected by an \u003ccode\u003e\u003ca\u003eInBound\u003c/a\u003e\u003c/code\u003e converter are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e the \u003cem\u003eMIME\u003c/em\u003e type of the content\n\u003c/li\u003e\u003cli\u003e the content size \n\u003c/li\u003e\u003cli\u003e the list of \u003ccode\u003eHeader\u003c/code\u003e coming with the message\n\u003c/li\u003e\u003cli\u003e the contents encoded as \u003ccode\u003eByteString\u003c/code\u003e.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe simplest possible in-bound converter for plain strings\n   may be created like this:\n\u003c/p\u003e\u003cpre\u003e let iconv _ _ _ = return . toString\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "InBound",
          "package": "stomp-queue",
          "type": "type"
        },
        "index": {
          "description": "Converters are user-defined actions passed to newReader InBound and newWriter OutBound that convert ByteString to value of type InBound or value of type to ByteString OutBound Converters are hence similar to put and get in the Binary monad The reason for using explicit user-defined converters instead of Binary encode and decode is that the conversion with queues may be much more complex involving reading configurations or other IO actions Furthermore we have to distinguish between data types and there binary encoding when sent over the network This distinction is made by MIME types Two applications may send the same data type but one encodes this type as text plain the other as text xml InBound conversions have to consider the MIME type and hence need more input parameters than provided by decode encode and decode however can be used internally by user-defined converters The parameters expected by an InBound converter are the MIME type of the content the content size the list of Header coming with the message the contents encoded as ByteString The simplest possible in-bound converter for plain strings may be created like this let iconv return toString",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "InBound",
          "package": "stomp-queue",
          "partial": "In Bound",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:InBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAny content received from a queue\n   is wrapped in a message.\n   It is, in particular, the return value of \u003cem\u003ereadQ\u003c/em\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Message",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Any content received from queue is wrapped in message It is in particular the return value of readQ",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Message",
          "package": "stomp-queue",
          "partial": "Message",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Message"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOut-bound converters are much simpler.\n   Since the application developer knows,\n   which encoding to use, the \u003cem\u003eMIME\u003c/em\u003e type is not needed.\n   The converter receives only the value of type \u003cem\u003ea\u003c/em\u003e\n   and converts it into a \u003ccode\u003eByteString\u003c/code\u003e.\n   A simple example to create an out-bound converter \n   for plain strings could be:\n\u003c/p\u003e\u003cpre\u003e let oconv = return . fromString\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OutBound",
          "package": "stomp-queue",
          "type": "type"
        },
        "index": {
          "description": "Out-bound converters are much simpler Since the application developer knows which encoding to use the MIME type is not needed The converter receives only the value of type and converts it into ByteString simple example to create an out-bound converter for plain strings could be let oconv return fromString",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OutBound",
          "package": "stomp-queue",
          "partial": "Out Bound",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:OutBound"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions that may be passed \n   to \u003ccode\u003e\u003ca\u003enewReader\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enewWriter\u003c/a\u003e\u003c/code\u003e and their variants.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Qopt",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Options that may be passed to newReader and newWriter and their variants",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Qopt",
          "package": "stomp-queue",
          "partial": "Qopt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Qopt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Queue for receiving messages\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Reader",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Queue for receiving messages",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Reader",
          "package": "stomp-queue",
          "partial": "Reader",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Reader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e parameters of \u003ccode\u003e\u003ca\u003ewithPair\u003c/a\u003e\u003c/code\u003e:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The reader's queue name \n\u003c/li\u003e\u003cli\u003e The reader's \u003ccode\u003e\u003ca\u003eQopt\u003c/a\u003e\u003c/code\u003es\n\u003c/li\u003e\u003cli\u003e The reader's \u003ccode\u003eHeader\u003c/code\u003es\n\u003c/li\u003e\u003cli\u003e The reader's (inbound) converter\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ReaderDesc",
          "package": "stomp-queue",
          "type": "type"
        },
        "index": {
          "description": "The Reader parameters of withPair The reader queue name The reader Qopt The reader Header The reader inbound converter",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ReaderDesc",
          "package": "stomp-queue",
          "partial": "Reader Desc",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:ReaderDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a receipt.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Rec",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "This is receipt",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Rec",
          "package": "stomp-queue",
          "partial": "Rec",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eJust a nicer word for \u003ccode\u003e\u003ca\u003eRec\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Receipt",
          "package": "stomp-queue",
          "type": "type"
        },
        "index": {
          "description": "Just nicer word for Rec",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Receipt",
          "package": "stomp-queue",
          "partial": "Receipt",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Receipt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eOptions passed to a transaction.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Topt",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Options passed to transaction",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Topt",
          "package": "stomp-queue",
          "partial": "Topt",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Topt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Tx",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Tx",
          "package": "stomp-queue",
          "partial": "Tx",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Tx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA Queue for sending messages.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Writer",
          "package": "stomp-queue",
          "type": "data"
        },
        "index": {
          "description": "Queue for sending messages",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Writer",
          "package": "stomp-queue",
          "partial": "Writer",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:Writer"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e parameters of \u003ccode\u003e\u003ca\u003ewithPair\u003c/a\u003e\u003c/code\u003e\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The writer's queue name\n\u003c/li\u003e\u003cli\u003e The writer's \u003ccode\u003e\u003ca\u003eQopt\u003c/a\u003e\u003c/code\u003es\n\u003c/li\u003e\u003cli\u003e The writer's \u003ccode\u003eHeader\u003c/code\u003es\n\u003c/li\u003e\u003cli\u003e The writer's (outbound) converter\n\u003c/li\u003e\u003c/ul\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "WriterDesc",
          "package": "stomp-queue",
          "type": "type"
        },
        "index": {
          "description": "The Writer parameters of withPair The writer queue name The writer Qopt The writer Header The writer outbound converter",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "WriterDesc",
          "package": "stomp-queue",
          "partial": "Writer Desc",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#t:WriterDesc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Auto",
          "package": "stomp-queue",
          "signature": "Auto",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Auto",
          "package": "stomp-queue",
          "partial": "Auto",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:Auto"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Client",
          "package": "stomp-queue",
          "signature": "Client",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Client",
          "package": "stomp-queue",
          "partial": "Client",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:Client"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ClientIndi",
          "package": "stomp-queue",
          "signature": "ClientIndi",
          "type": "function"
        },
        "index": {
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ClientIndi",
          "package": "stomp-queue",
          "partial": "Client Indi",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:ClientIndi"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNo receipt was sent with this interaction.\n   Receiving a \u003ccode\u003e\u003ca\u003eNoRec\u003c/a\u003e\u003c/code\u003e is not an error,\n   but the result of an inconsistent - but harmless -\n   use of \u003cem\u003ewriteQWith\u003c/em\u003e on a queue that does not\n   send receipts. An application should, of course,\n   not try to wait for a \u003ccode\u003e\u003ca\u003eNoRec\u003c/a\u003e\u003c/code\u003e. It will never be confirmed.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "NoRec",
          "package": "stomp-queue",
          "signature": "NoRec",
          "type": "function"
        },
        "index": {
          "description": "No receipt was sent with this interaction Receiving NoRec is not an error but the result of an inconsistent but harmless use of writeQWith on queue that does not send receipts An application should of course not try to wait for NoRec It will never be confirmed",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "NoRec",
          "package": "stomp-queue",
          "partial": "No Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:NoRec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIf a message has been received from a \n   queue with \u003ccode\u003eOMode\u003c/code\u003e option other \n   than \u003ccode\u003e\u003ca\u003eAuto\u003c/a\u003e\u003c/code\u003e and this message has not yet been\n   acknowledged when the transaction is ready\n   to terminate, the \u003cem\u003eack\u003c/em\u003e is \u003cem\u003emissing\u003c/em\u003e.\n   With this option, the transaction \n   will not commit with missing \u003cem\u003eacks\u003c/em\u003e,\n   but abort and raise \u003ccode\u003e\u003ca\u003eTxException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OAbortMissingAcks",
          "package": "stomp-queue",
          "signature": "OAbortMissingAcks",
          "type": "function"
        },
        "index": {
          "description": "If message has been received from queue with OMode option other than Auto and this message has not yet been acknowledged when the transaction is ready to terminate the ack is missing With this option the transaction will not commit with missing acks but abort and raise TxException",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OAbortMissingAcks",
          "package": "stomp-queue",
          "partial": "OAbort Missing Acks",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OAbortMissingAcks"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExpression often used by Ren&#233; Artois.\n   Furthermore, if \u003ccode\u003e\u003ca\u003eOMode\u003c/a\u003e\u003c/code\u003e is either\n   \u003ccode\u003e\u003ca\u003eClient\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eClientIndi\u003c/a\u003e\u003c/code\u003e, then \n   this option forces \u003ccode\u003e\u003ca\u003ereadQ\u003c/a\u003e\u003c/code\u003e to send an acknowledgement\n   automatically when a message has been read from the queue. \n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OAck",
          "package": "stomp-queue",
          "signature": "OAck",
          "type": "function"
        },
        "index": {
          "description": "Expression often used by Ren Artois Furthermore if OMode is either Client or ClientIndi then this option forces readQ to send an acknowledgement automatically when message has been read from the queue",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OAck",
          "package": "stomp-queue",
          "partial": "OAck",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OAck"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAuthentication: user and password\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OAuth",
          "package": "stomp-queue",
          "signature": "OAuth String String",
          "type": "function"
        },
        "index": {
          "description": "Authentication user and password",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OAuth",
          "package": "stomp-queue",
          "partial": "OAuth",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OAuth"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eIdentification: specifies the JMS Client ID for persistant connections\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OClientId",
          "package": "stomp-queue",
          "signature": "OClientId String",
          "type": "function"
        },
        "index": {
          "description": "Identification specifies the JMS Client ID for persistant connections",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OClientId",
          "package": "stomp-queue",
          "partial": "OClient Id",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OClientId"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA queue created with \u003ccode\u003e\u003ca\u003eOForceTx\u003c/a\u003e\u003c/code\u003e will throw \n   \u003ccode\u003e\u003ca\u003eQueueException\u003c/a\u003e\u003c/code\u003e when used outside a \u003ccode\u003eTransaction\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OForceTx",
          "package": "stomp-queue",
          "signature": "OForceTx",
          "type": "function"
        },
        "index": {
          "description": "queue created with OForceTx will throw QueueException when used outside Transaction",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OForceTx",
          "package": "stomp-queue",
          "partial": "OForce Tx",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OForceTx"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis option defines the client's bid\n   for negotiating heart beats (see \u003ccode\u003eHeartBeat\u003c/code\u003e). \n   By default, no heart beats are sent or accepted\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OHeartBeat",
          "package": "stomp-queue",
          "signature": "OHeartBeat Heart",
          "type": "function"
        },
        "index": {
          "description": "This option defines the client bid for negotiating heart beats see HeartBeat By default no heart beats are sent or accepted",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OHeartBeat",
          "package": "stomp-queue",
          "partial": "OHeart Beat",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OHeartBeat"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe maximum size of TCP/IP packets.\n   Indirectly, this options also defines the\n   maximum message size which is \u003cem\u003e10 * maxReceive\u003c/em\u003e.\n   By default, the maximum packet size is 1024 bytes.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OMaxRecv",
          "package": "stomp-queue",
          "signature": "OMaxRecv Int",
          "type": "function"
        },
        "index": {
          "description": "The maximum size of TCP IP packets Indirectly this options also defines the maximum message size which is maxReceive By default the maximum packet size is bytes",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OMaxRecv",
          "package": "stomp-queue",
          "partial": "OMax Recv",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OMaxRecv"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe option defines the \u003ccode\u003e\u003ca\u003eAckMode\u003c/a\u003e\u003c/code\u003e of the queue,\n   which is relevant for \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e only.\n   \u003ccode\u003e\u003ca\u003eAckMode\u003c/a\u003e\u003c/code\u003e is one of: \n   \u003ccode\u003e\u003ca\u003eAuto\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eClient\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eClientIndi\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eIf \u003ccode\u003e\u003ca\u003eOMode\u003c/a\u003e\u003c/code\u003e is not given, \u003ccode\u003e\u003ca\u003eAuto\u003c/a\u003e\u003c/code\u003e is assumed as default.\n\u003c/p\u003e\u003cp\u003eFor more details, see \u003ccode\u003e\u003ca\u003eAckMode\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OMode",
          "package": "stomp-queue",
          "signature": "OMode AckMode",
          "type": "function"
        },
        "index": {
          "description": "The option defines the AckMode of the queue which is relevant for Reader only AckMode is one of Auto Client ClientIndi If OMode is not given Auto is assumed as default For more details see AckMode",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OMode",
          "package": "stomp-queue",
          "partial": "OMode",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OMode"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDo not automatically add a content-length header\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ONoContentLen",
          "package": "stomp-queue",
          "signature": "ONoContentLen",
          "type": "function"
        },
        "index": {
          "description": "Do not automatically add content-length header",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ONoContentLen",
          "package": "stomp-queue",
          "partial": "ONo Content Len",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:ONoContentLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWith this option set, \u003ca\u003econnect\u003c/a\u003e will use \n   a \u003ca\u003eSTOMP\u003c/a\u003e frame instead of a \u003ca\u003eCONNECT\u003c/a\u003e frame\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OStomp",
          "package": "stomp-queue",
          "signature": "OStomp",
          "type": "function"
        },
        "index": {
          "description": "With this option set connect will use STOMP frame instead of CONNECT frame",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OStomp",
          "package": "stomp-queue",
          "partial": "OStomp",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OStomp"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe timeout in milliseconds (not microseconds!)\n   to wait for \u003cem\u003epending receipts\u003c/em\u003e.\n   If receipts are pending, when the transaction\n   is ready to terminate,\n   and no timeout or a timeout \u003cem\u003e\u003c= 0\u003c/em\u003e is given, \n   and the option \u003ccode\u003e\u003ca\u003eOWithReceipts\u003c/a\u003e\u003c/code\u003e \n   was passed to \u003ccode\u003ewithTransaction\u003c/code\u003e,\n   the transaction will be aborted with \u003ccode\u003e\u003ca\u003eTxException\u003c/a\u003e\u003c/code\u003e;\n   otherwise it will wait until all pending\n   ineractions with the broker have terminated\n   or the timeout has expired - whatever comes first.\n   If the timeout expires first, \u003ccode\u003e\u003ca\u003eTxException\u003c/a\u003e\u003c/code\u003e is raised. \n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OTimeout",
          "package": "stomp-queue",
          "signature": "OTimeout Int",
          "type": "function"
        },
        "index": {
          "description": "The timeout in milliseconds not microseconds to wait for pending receipts If receipts are pending when the transaction is ready to terminate and no timeout or timeout is given and the option OWithReceipts was passed to withTransaction the transaction will be aborted with TxException otherwise it will wait until all pending ineractions with the broker have terminated or the timeout has expired whatever comes first If the timeout expires first TxException is raised",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OTimeout",
          "package": "stomp-queue",
          "partial": "OTimeout",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OTimeout"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eTells the connection to wait \u003cem\u003en\u003c/em\u003e milliseconds for the \u003ccode\u003e\u003ca\u003eReceipt\u003c/a\u003e\u003c/code\u003e \n   sent with \u003ccode\u003eDisconnect\u003c/code\u003e at the end of the session.\n   The \u003cem\u003eStomp\u003c/em\u003e protocol advises to request a receipt \n   and to wait for it before actually closing the \n   socket. Many brokers, however, do not \n   implement this feature (or implement it inappropriately,\n   closing the connection immediately after having sent\n   the receipt).\n   \u003ccode\u003ewithConnection\u003c/code\u003e, for this reason, ignores \n   the receipt by default and simply closes the socket\n   after having sent the \u003ccode\u003eDisconnect\u003c/code\u003e frame.\n   If your broker shows a correct behaviour, \n   it is advisable to use this option.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWaitBroker",
          "package": "stomp-queue",
          "signature": "OWaitBroker Int",
          "type": "function"
        },
        "index": {
          "description": "Tells the connection to wait milliseconds for the Receipt sent with Disconnect at the end of the session The Stomp protocol advises to request receipt and to wait for it before actually closing the socket Many brokers however do not implement this feature or implement it inappropriately closing the connection immediately after having sent the receipt withConnection for this reason ignores the receipt by default and simply closes the socket after having sent the Disconnect frame If your broker shows correct behaviour it is advisable to use this option",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWaitBroker",
          "package": "stomp-queue",
          "partial": "OWait Broker",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OWaitBroker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA queue created with \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e will wait for the receipt\n   before returning from a call that has issued a request for receipt.\n   This implies that the current thread will yield the processor.\n   \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e will internally create a request for receipt and \n   wait for the broker to confirm the receipt before returning.\n   Note that, for \u003ccode\u003e\u003ca\u003enewReader\u003c/a\u003e\u003c/code\u003e, there is no difference between\n   \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e. Either option will cause\n   the thread to preempt until the receipt is confirmed.\n\u003c/p\u003e\u003cp\u003eOn writing a message, this is not always the preferred\n   method. You may want to fire and forget - and check \n   for the confirmation of the receipt only later.\n   In this case, you will create the\n   \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e only and, later, after having\n   sent a message with \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e, wait for the receipt using\n   \u003ccode\u003e\u003ca\u003ewaitReceipt\u003c/a\u003e\u003c/code\u003e. Note that \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e without \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e\n   has no meaning with \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e. \n   If you want to request a receipt with a message\n   and wait for the broker to confirm it, you have to use \n   both options.\n\u003c/p\u003e\u003cp\u003eIt is good practice to use \u003cem\u003etimeout\u003c/em\u003e with all calls\n   that may wait for receipts, \n   \u003cem\u003eie\u003c/em\u003e \u003ccode\u003e\u003ca\u003enewReader\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ewithReader\u003c/a\u003e\u003c/code\u003e \n   with options \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e,\n   or \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e with options \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e,\n   or \u003ccode\u003e\u003ca\u003eackWith\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003enackWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWaitReceipt",
          "package": "stomp-queue",
          "signature": "OWaitReceipt",
          "type": "function"
        },
        "index": {
          "description": "queue created with OWaitReceipt will wait for the receipt before returning from call that has issued request for receipt This implies that the current thread will yield the processor writeQ will internally create request for receipt and wait for the broker to confirm the receipt before returning Note that for newReader there is no difference between OWaitReceipt and OWithReceipt Either option will cause the thread to preempt until the receipt is confirmed On writing message this is not always the preferred method You may want to fire and forget and check for the confirmation of the receipt only later In this case you will create the Writer with OWithReceipt only and later after having sent message with writeQWith wait for the receipt using waitReceipt Note that OWaitReceipt without OWithReceipt has no meaning with writeQ and writeQWith If you want to request receipt with message and wait for the broker to confirm it you have to use both options It is good practice to use timeout with all calls that may wait for receipts ie newReader and withReader with options OWithReceipt or OWaitReceipt or writeQ and writeQWith with options OWaitReceipt or ackWith and nackWith",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWaitReceipt",
          "package": "stomp-queue",
          "partial": "OWait Receipt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OWaitReceipt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA queue created with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e will request a receipt\n   on all interactions with the broker.\n   The handling of receipts is usually transparent to applications, \n   but, in the case of sending message, may be made visible \n   by using \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e.\n   \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e return the receipt identifier\n   and the application can later invoke \u003ccode\u003e\u003ca\u003ewaitReceipt\u003c/a\u003e\u003c/code\u003e\n   to wait for the broker confirming this receipt.\n   Note that a \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e created with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e will \n   issue a request for receipt when subscribing to a Stomp queue.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWithReceipt",
          "package": "stomp-queue",
          "signature": "OWithReceipt",
          "type": "function"
        },
        "index": {
          "description": "queue created with OWithReceipt will request receipt on all interactions with the broker The handling of receipts is usually transparent to applications but in the case of sending message may be made visible by using writeQWith instead of writeQ writeQWith return the receipt identifier and the application can later invoke waitReceipt to wait for the broker confirming this receipt Note that Reader created with OWithReceipt will issue request for receipt when subscribing to Stomp queue",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWithReceipt",
          "package": "stomp-queue",
          "partial": "OWith Receipt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OWithReceipt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis option has two effects:\n   1) Internal interactions of the transaction\n      with the broker will request receipts;\n   2) before ending the transaction,\n      the library will check for receipts\n      that have not yet been confirmed by the broker\n      (including receipts requested by user calls\n       such as \u003cem\u003ewriteQ\u003c/em\u003e or \u003cem\u003eackWith\u003c/em\u003e).\n\u003c/p\u003e\u003cp\u003eIf receipts are pending, when the transaction\n   is ready to terminate and \u003ccode\u003e\u003ca\u003eOTimeout\u003c/a\u003e\u003c/code\u003e with\n   a value \u003cem\u003e\u003e 0\u003c/em\u003e is given, the transaction will\n   wait for pending receipts; otherwise\n   the transaction will be aborted with \u003ccode\u003e\u003ca\u003eTxException\u003c/a\u003e\u003c/code\u003e.\n   Note that it, usually, does not make sense to use\n   this options without \u003ccode\u003e\u003ca\u003eOTimeout\u003c/a\u003e\u003c/code\u003e,\n   since it is in all probability that a receipt \n   has not yet been confirmed when the transaction terminates.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWithReceipts",
          "package": "stomp-queue",
          "signature": "OWithReceipts",
          "type": "function"
        },
        "index": {
          "description": "This option has two effects Internal interactions of the transaction with the broker will request receipts before ending the transaction the library will check for receipts that have not yet been confirmed by the broker including receipts requested by user calls such as writeQ or ackWith If receipts are pending when the transaction is ready to terminate and OTimeout with value is given the transaction will wait for pending receipts otherwise the transaction will be aborted with TxException Note that it usually does not make sense to use this options without OTimeout since it is in all probability that receipt has not yet been confirmed when the transaction terminates",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "OWithReceipts",
          "package": "stomp-queue",
          "partial": "OWith Receipts",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:OWithReceipts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eA valid receipt\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Rec",
          "package": "stomp-queue",
          "signature": "Rec Int",
          "type": "function"
        },
        "index": {
          "description": "valid receipt",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "Rec",
          "package": "stomp-queue",
          "partial": "Rec",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:Rec"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAborts the transaction immediately by raising \u003ccode\u003e\u003ca\u003eAppException\u003c/a\u003e\u003c/code\u003e.\n   The string passed in to \u003ccode\u003e\u003ca\u003eabort\u003c/a\u003e\u003c/code\u003e will be added to the \n   exception message.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "abort",
          "package": "stomp-queue",
          "signature": "String -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Aborts the transaction immediately by raising AppException The string passed in to abort will be added to the exception message",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "abort",
          "normalized": "String-\u003eIO()",
          "package": "stomp-queue",
          "signature": "String-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:abort"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAcknowledges the arrival of \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e to the broker.\n   It is used with a \u003ccode\u003eConnection\u003c/code\u003e \u003cem\u003ec\u003c/em\u003e and a \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e \u003cem\u003ex\u003c/em\u003e like:\n\u003c/p\u003e\u003cpre\u003e ack c x\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ack",
          "package": "stomp-queue",
          "signature": "Con -\u003e Message a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Acknowledges the arrival of Message to the broker It is used with Connection and Message like ack",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ack",
          "normalized": "Con-\u003eMessage a-\u003eIO()",
          "package": "stomp-queue",
          "signature": "Con-\u003eMessage a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:ack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAcknowledges the arrival of \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e to the broker,\n   requests a receipt and waits until it is confirmed.\n   Since it preempts the calling thread,\n   it is usually used with \u003cem\u003etimeout\u003c/em\u003e,\n   for a \u003ccode\u003eConnection\u003c/code\u003e \u003cem\u003ec\u003c/em\u003e, a \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e \u003cem\u003ex\u003c/em\u003e \n   and a \u003cem\u003etimeout\u003c/em\u003e in microseconds \u003cem\u003etmo\u003c/em\u003e like:\n\u003c/p\u003e\u003cpre\u003e mbR \u003c- timeout tmo $ ackWith c x   \n case mbR of\n   Nothing -\u003e -- error handling\n   Just _  -\u003e do -- ...\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ackWith",
          "package": "stomp-queue",
          "signature": "Con -\u003e Message a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Acknowledges the arrival of Message to the broker requests receipt and waits until it is confirmed Since it preempts the calling thread it is usually used with timeout for Connection Message and timeout in microseconds tmo like mbR timeout tmo ackWith case mbR of Nothing error handling Just do",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "ackWith",
          "normalized": "Con-\u003eMessage a-\u003eIO()",
          "package": "stomp-queue",
          "partial": "With",
          "signature": "Con-\u003eMessage a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:ackWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemoves all references to the reader from the connection. \n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "destroyReader",
          "package": "stomp-queue",
          "signature": "Reader a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Removes all references to the reader from the connection",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "destroyReader",
          "normalized": "Reader a-\u003eIO()",
          "package": "stomp-queue",
          "partial": "Reader",
          "signature": "Reader a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:destroyReader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eDoes nothing, but should be used with \u003ccode\u003e\u003ca\u003enewWriter\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "destroyWriter",
          "package": "stomp-queue",
          "signature": "Writer a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Does nothing but should be used with newWriter",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "destroyWriter",
          "normalized": "Writer a-\u003eIO()",
          "package": "stomp-queue",
          "partial": "Writer",
          "signature": "Writer a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:destroyWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eReturns the content of the message in the format \n   produced by an in-bound converter\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgContent",
          "package": "stomp-queue",
          "signature": "Message a -\u003e a",
          "type": "function"
        },
        "index": {
          "description": "Returns the content of the message in the format produced by an in-bound converter",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgContent",
          "normalized": "Message a-\u003ea",
          "package": "stomp-queue",
          "partial": "Content",
          "signature": "Message a-\u003ea",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:msgContent"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe Stomp headers\n   that came with the message\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgHdrs",
          "package": "stomp-queue",
          "signature": "Message a -\u003e [Header]",
          "type": "function"
        },
        "index": {
          "description": "The Stomp headers that came with the message",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgHdrs",
          "normalized": "Message a-\u003e[Header]",
          "package": "stomp-queue",
          "partial": "Hdrs",
          "signature": "Message a-\u003e[Header]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:msgHdrs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe length of the \n   encoded content\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgLen",
          "package": "stomp-queue",
          "signature": "Message a -\u003e Int",
          "type": "function"
        },
        "index": {
          "description": "The length of the encoded content",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgLen",
          "normalized": "Message a-\u003eInt",
          "package": "stomp-queue",
          "partial": "Len",
          "signature": "Message a-\u003eInt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:msgLen"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe encoded content             \n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgRaw",
          "package": "stomp-queue",
          "signature": "Message a -\u003e ByteString",
          "type": "function"
        },
        "index": {
          "description": "The encoded content",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgRaw",
          "normalized": "Message a-\u003eByteString",
          "package": "stomp-queue",
          "partial": "Raw",
          "signature": "Message a-\u003eByteString",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:msgRaw"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThe \u003cem\u003eMIME\u003c/em\u003e type of the content\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgType",
          "package": "stomp-queue",
          "signature": "Message a -\u003e Type",
          "type": "function"
        },
        "index": {
          "description": "The MIME type of the content",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "msgType",
          "normalized": "Message a-\u003eType",
          "package": "stomp-queue",
          "partial": "Type",
          "signature": "Message a-\u003eType",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:msgType"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegatively acknowledges the arrival of \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e to the broker.\n   For more details see \u003ccode\u003e\u003ca\u003eack\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "nack",
          "package": "stomp-queue",
          "signature": "Con -\u003e Message a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Negatively acknowledges the arrival of Message to the broker For more details see ack",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "nack",
          "normalized": "Con-\u003eMessage a-\u003eIO()",
          "package": "stomp-queue",
          "signature": "Con-\u003eMessage a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:nack"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eNegatively acknowledges the arrival of \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e to the broker,\n   requests a receipt and waits until it is confirmed.\n   For more details see \u003ccode\u003e\u003ca\u003eackWith\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "nackWith",
          "package": "stomp-queue",
          "signature": "Con -\u003e Message a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Negatively acknowledges the arrival of Message to the broker requests receipt and waits until it is confirmed For more details see ackWith",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "nackWith",
          "normalized": "Con-\u003eMessage a-\u003eIO()",
          "package": "stomp-queue",
          "partial": "With",
          "signature": "Con-\u003eMessage a-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:nackWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e with the lifetime of the connection \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e.\n   Creating a receiving queue involves interaction with the broker;\n   this may result in preempting the calling thread, \n   depending on the options [\u003ccode\u003e\u003ca\u003eQopt\u003c/a\u003e\u003c/code\u003e].\n\u003c/p\u003e\u003cp\u003eParameters:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The connection handle \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e A queue name that should be unique in your application.\n     The queue name is useful for debugging, since it appears\n     in error messages.\n\u003c/li\u003e\u003cli\u003e The Stomp destination, \u003cem\u003ei.e.\u003c/em\u003e the name of the queue\n     as it is known to the broker and other applications.\n\u003c/li\u003e\u003cli\u003e A list of options (\u003ccode\u003e\u003ca\u003eQopt\u003c/a\u003e\u003c/code\u003e).\n\u003c/li\u003e\u003cli\u003e A list of headers (\u003ccode\u003eHeader\u003c/code\u003e), \n     which will be passed to the broker.\n     the \u003ccode\u003eHeader\u003c/code\u003e parameter is actually a breach in the abstraction\n     from the Stomp protocol. A header may be, for instance,\n     a selector that restricts the subscription to this queue,\n     such that only messages with certain attributes \n     (\u003cem\u003ei.e.\u003c/em\u003e specific headers) are sent to the subscribing client.\n     Selectors are broker-specific and typically expressed\n     as SQL or XPath.\n\u003c/li\u003e\u003cli\u003e An in-bound converter.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eA usage example to create a \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e\n   with \u003ccode\u003eConnection\u003c/code\u003e \u003cem\u003ec\u003c/em\u003e and the in-bound converter\n   \u003cem\u003eiconv\u003c/em\u003e would be:\n\u003c/p\u003e\u003cpre\u003e q \u003c- newReader c \"TestQ\" \"/queue/test\" [] [] iconv\n\u003c/pre\u003e\u003cp\u003eA call to \u003ccode\u003e\u003ca\u003enewReader\u003c/a\u003e\u003c/code\u003e may result in preemption when\n   one of the options \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e or \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e are given;\n   an example for such a call \n   with \u003cem\u003etmo\u003c/em\u003e an \u003ccode\u003eInt\u003c/code\u003e value representing a \u003cem\u003etimeout\u003c/em\u003e\n   in microseconds and \n   the result \u003cem\u003embQ\u003c/em\u003e of type \u003ccode\u003eMaybe\u003c/code\u003e is:\n\u003c/p\u003e\u003cpre\u003e mbQ \u003c- timeout tmo $ newReader c \"TestQ\" \"/queue/test\" [OWaitReceipt] [] oconv\n case mbQ of\n   Nothing -\u003e -- handle error\n   Just q  -\u003e do -- ...\n\u003c/pre\u003e\u003cp\u003eA newReader stores data in the connection \u003cem\u003ec\u003c/em\u003e.\n   If the lifetime of a reader is shorter than that of its connection\n   it should call \u003ccode\u003e\u003ca\u003edestroyReader\u003c/a\u003e\u003c/code\u003e to avoid memory leaks.\n   In such cases, it is usually preferable to use \u003ccode\u003e\u003ca\u003ewithReader\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "newReader",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e String -\u003e [Qopt] -\u003e [Header] -\u003e InBound a -\u003e IO (Reader a)",
          "type": "function"
        },
        "index": {
          "description": "Creates Reader with the lifetime of the connection Con Creating receiving queue involves interaction with the broker this may result in preempting the calling thread depending on the options Qopt Parameters The connection handle Con queue name that should be unique in your application The queue name is useful for debugging since it appears in error messages The Stomp destination i.e the name of the queue as it is known to the broker and other applications list of options Qopt list of headers Header which will be passed to the broker the Header parameter is actually breach in the abstraction from the Stomp protocol header may be for instance selector that restricts the subscription to this queue such that only messages with certain attributes i.e specific headers are sent to the subscribing client Selectors are broker-specific and typically expressed as SQL or XPath An in-bound converter usage example to create Reader with Connection and the in-bound converter iconv would be newReader TestQ queue test iconv call to newReader may result in preemption when one of the options OWaitReceipt or OWithReceipt are given an example for such call with tmo an Int value representing timeout in microseconds and the result mbQ of type Maybe is mbQ timeout tmo newReader TestQ queue test OWaitReceipt oconv case mbQ of Nothing handle error Just do newReader stores data in the connection If the lifetime of reader is shorter than that of its connection it should call destroyReader to avoid memory leaks In such cases it is usually preferable to use withReader",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "newReader",
          "normalized": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eInBound a-\u003eIO(Reader a)",
          "package": "stomp-queue",
          "partial": "Reader",
          "signature": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eInBound a-\u003eIO(Reader a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:newReader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e with the lifetime of the connection \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e.\n   Creating a sending queue does not involve interaction with the broker\n   and will not preempt the calling thread.\n\u003c/p\u003e\u003cp\u003eA sending queue may be created like in the following\n   code fragment, where \u003cem\u003eoconv\u003c/em\u003e is \n   an already defined out-bound converter:\n\u003c/p\u003e\u003cpre\u003e q \u003c- newWriter c \"TestQ\" \"/queue/test\" [] [] oconv\n\u003c/pre\u003e\u003cp\u003eCurrently no references to the writer are stored \n in the connection. It is advisable, however, \n to use \u003ccode\u003e\u003ca\u003ewithWriter\u003c/a\u003e\u003c/code\u003e instead of \u003ccode\u003e\u003ca\u003enewWriter\u003c/a\u003e\u003c/code\u003e\n whenever the lifetime of a writer is shorter than that\n of the connection. \n In cases where this is not possible,\n you should use \u003ccode\u003e\u003ca\u003edestroyWriter\u003c/a\u003e\u003c/code\u003e \n when the writer is not needed anymore.\n Currently \u003ccode\u003e\u003ca\u003edestroyWriter\u003c/a\u003e\u003c/code\u003e does nothing,\n but this may change in the future.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "newWriter",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e String -\u003e [Qopt] -\u003e [Header] -\u003e OutBound a -\u003e IO (Writer a)",
          "type": "function"
        },
        "index": {
          "description": "Creates Writer with the lifetime of the connection Con Creating sending queue does not involve interaction with the broker and will not preempt the calling thread sending queue may be created like in the following code fragment where oconv is an already defined out-bound converter newWriter TestQ queue test oconv Currently no references to the writer are stored in the connection It is advisable however to use withWriter instead of newWriter whenever the lifetime of writer is shorter than that of the connection In cases where this is not possible you should use destroyWriter when the writer is not needed anymore Currently destroyWriter does nothing but this may change in the future",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "newWriter",
          "normalized": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eOutBound a-\u003eIO(Writer a)",
          "package": "stomp-queue",
          "partial": "Writer",
          "signature": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eOutBound a-\u003eIO(Writer a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:newWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRemoves the oldest message from the queue\n   and returns it as \u003ccode\u003e\u003ca\u003eMessage\u003c/a\u003e\u003c/code\u003e.\n   The message cannot be read from the queue\n   by another call to \u003ccode\u003e\u003ca\u003ereadQ\u003c/a\u003e\u003c/code\u003e within the same connection.\n   Wether other connections will receive the message as well\n   depends on the broker and the queue patterns it implements.\n   If the queue is currently empty,\n   the thread will preempt until a message arrives.\n\u003c/p\u003e\u003cp\u003eIf the queue was created with \n   \u003ccode\u003e\u003ca\u003eOMode\u003c/a\u003e\u003c/code\u003e other than \u003ccode\u003e\u003ca\u003eAuto\u003c/a\u003e\u003c/code\u003e \n   and with \u003ccode\u003e\u003ca\u003eOAck\u003c/a\u003e\u003c/code\u003e, then an \u003cem\u003eack\u003c/em\u003e \n   will be automatically sent to the broker;\n   if \u003ccode\u003e\u003ca\u003eOAck\u003c/a\u003e\u003c/code\u003e was not set,\n   the message will be registered as pending \u003cem\u003eack\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eNote that, when \u003ccode\u003e\u003ca\u003ereadQ\u003c/a\u003e\u003c/code\u003e sends an \u003cem\u003eack\u003c/em\u003e internally,\n   it will not request a receipt from the broker.\n   The rationale for this design is simplicity.\n   If the function expected a receipt, \n   it would have to either wait for the receipt\n   or return it.\n   In the first case, it would be difficult\n   for the programmer to distinguish, on a timeout, between\n   \u003cem\u003eno message available\u003c/em\u003e and\n   \u003cem\u003eno receipt arrived\u003c/em\u003e.\n   In the second case, the receipt\n   would need to be returned.\n   This would unnecessarily blow up the interface.\n   If you need the reliability of receipts,\n   you should create the queue without \u003ccode\u003e\u003ca\u003eOAck\u003c/a\u003e\u003c/code\u003e\n   and use \u003ccode\u003e\u003ca\u003eackWith\u003c/a\u003e\u003c/code\u003e to acknowledge \n   the message explicitly.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "readQ",
          "package": "stomp-queue",
          "signature": "Reader a -\u003e IO (Message a)",
          "type": "function"
        },
        "index": {
          "description": "Removes the oldest message from the queue and returns it as Message The message cannot be read from the queue by another call to readQ within the same connection Wether other connections will receive the message as well depends on the broker and the queue patterns it implements If the queue is currently empty the thread will preempt until message arrives If the queue was created with OMode other than Auto and with OAck then an ack will be automatically sent to the broker if OAck was not set the message will be registered as pending ack Note that when readQ sends an ack internally it will not request receipt from the broker The rationale for this design is simplicity If the function expected receipt it would have to either wait for the receipt or return it In the first case it would be difficult for the programmer to distinguish on timeout between no message available and no receipt arrived In the second case the receipt would need to be returned This would unnecessarily blow up the interface If you need the reliability of receipts you should create the queue without OAck and use ackWith to acknowledge the message explicitly",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "readQ",
          "normalized": "Reader a-\u003eIO(Message a)",
          "package": "stomp-queue",
          "signature": "Reader a-\u003eIO(Message a)",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:readQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eWaits for the \u003ccode\u003e\u003ca\u003eReceipt\u003c/a\u003e\u003c/code\u003e to be confirmed by the broker.\n   Since the thread will preempt, the call should be protected\n   with \u003cem\u003etimeout\u003c/em\u003e, \u003cem\u003ee.g.\u003c/em\u003e:\n\u003c/p\u003e\u003cpre\u003e mb_ \u003c- timeout tmo $ waitReceipt c r\n case mb_ of\n  Nothing -\u003e -- error handling\n  Just _  -\u003e do -- ...\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "waitReceipt",
          "package": "stomp-queue",
          "signature": "Con -\u003e Receipt -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Waits for the Receipt to be confirmed by the broker Since the thread will preempt the call should be protected with timeout e.g mb timeout tmo waitReceipt case mb of Nothing error handling Just do",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "waitReceipt",
          "normalized": "Con-\u003eReceipt-\u003eIO()",
          "package": "stomp-queue",
          "partial": "Receipt",
          "signature": "Con-\u003eReceipt-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:waitReceipt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eInitialises a connection and executes an \u003ccode\u003eIO\u003c/code\u003e action.\n   The connection lifetime is the scope of this action.\n   The connection handle, \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e, that is passed to the action\n   should not be returned from \u003ccode\u003e\u003ca\u003ewithConnection\u003c/a\u003e\u003c/code\u003e.\n   Connections, however, can be shared among threads.\n   In this case, the programmer has to take care\n   not to terminate the action before all other threads\n   working on the connection have finished.\n\u003c/p\u003e\u003cp\u003eSince \u003ccode\u003eConnection\u003c/code\u003e is a heavy data type,\n   you should try to reduce the number of connections\n   to the same broker within the same process - \n   there is ideally only one connection per broker\n   in one process.\n\u003c/p\u003e\u003cp\u003eParamter:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eString\u003c/code\u003e: The broker's hostname or IP-address\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eInt\u003c/code\u003e: The broker's port\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003e\u003ca\u003eCopt\u003c/a\u003e\u003c/code\u003e: Control options passed to the connection\n             (including user/password)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eHeader\u003c/code\u003e: List of additional, broker-specific headers\n\u003c/li\u003e\u003cli\u003e (\u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e -\u003e \u003ccode\u003eIO\u003c/code\u003e a): The action to execute.\n                        The action receives the connection handle\n                        and returns a value of type \u003cem\u003ea\u003c/em\u003e \n                        in the \u003ccode\u003eIO\u003c/code\u003e monad.\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithConnection\u003c/a\u003e\u003c/code\u003e returns the result of the action passed into it.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithConnection\u003c/a\u003e\u003c/code\u003e will always disconnect from the broker \n when the action has terminated, even if an exception is raised.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e withConnection \"localhost\" 61613 [] [] $ \\c -\u003e do\n\u003c/pre\u003e\u003cp\u003eThis would connect to a broker listening to the loopback interface,\n port number 61613.\n The action is defined after the \u003cem\u003ehanging do\u003c/em\u003e.\n\u003c/p\u003e\u003cp\u003eInternally, connections use concurrent threads;\n errors are communicated by throwing exceptions\n to the owner of the connection, where\n the owner is the thread that created the connection\n by calling \u003ccode\u003e\u003ca\u003ewithConnection\u003c/a\u003e\u003c/code\u003e.\n It is therefore advisable to start different connections\n in different threads, so that each thread will receive\n only exceptions related to the connection it has opened.\n\u003c/p\u003e\u003cp\u003eExample:\n\u003c/p\u003e\u003cpre\u003e t \u003c- forkIO $ withConnection \"127.0.0.1\" 61613 [] [] $ \\c -\u003e do\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withConnection",
          "package": "stomp-queue",
          "signature": "String -\u003e Int -\u003e [Copt] -\u003e [Header] -\u003e (Con -\u003e IO a) -\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Initialises connection and executes an IO action The connection lifetime is the scope of this action The connection handle Con that is passed to the action should not be returned from withConnection Connections however can be shared among threads In this case the programmer has to take care not to terminate the action before all other threads working on the connection have finished Since Connection is heavy data type you should try to reduce the number of connections to the same broker within the same process there is ideally only one connection per broker in one process Paramter String The broker hostname or IP-address Int The broker port Copt Control options passed to the connection including user password Header List of additional broker-specific headers Con IO The action to execute The action receives the connection handle and returns value of type in the IO monad withConnection returns the result of the action passed into it withConnection will always disconnect from the broker when the action has terminated even if an exception is raised Example withConnection localhost do This would connect to broker listening to the loopback interface port number The action is defined after the hanging do Internally connections use concurrent threads errors are communicated by throwing exceptions to the owner of the connection where the owner is the thread that created the connection by calling withConnection It is therefore advisable to start different connections in different threads so that each thread will receive only exceptions related to the connection it has opened Example forkIO withConnection do",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withConnection",
          "normalized": "String-\u003eInt-\u003e[Copt]-\u003e[Header]-\u003e(Con-\u003eIO a)-\u003eIO a",
          "package": "stomp-queue",
          "partial": "Connection",
          "signature": "String-\u003eInt-\u003e[Copt]-\u003e[Header]-\u003e(Con-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:withConnection"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a pair of (\u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e i, \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e o) with limited lifetime. \n   The pair will live only in the scope of the action\n   that is passed as last parameter. \n   The function is useful for readers/writers\n   used in combination, \u003cem\u003ee.g.\u003c/em\u003e to emulate a client/server\n   kind of communication.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithPair\u003c/a\u003e\u003c/code\u003e returns the result of the action passed in.\n\u003c/p\u003e\u003cp\u003eThe parameters are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e The connection handle \u003ccode\u003e\u003ca\u003eCon\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e The name of the pair; \n     the reader will be identified by a string\n                with \"_r\" added to this name,\n     the writer by a string with \"_w\" added to this name.\n\u003c/li\u003e\u003cli\u003e The description of the \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eReaderDesc\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e The description of the \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e, \u003ccode\u003e\u003ca\u003eWriterDesc\u003c/a\u003e\u003c/code\u003e\n\u003c/li\u003e\u003cli\u003e The application-defined action\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eThe reason for introducing the reader and writer description\n  is to provide error detection at compile time:\n  It is this way much more difficult to accidently confuse\n  the writer's and the reader's parameters (\u003cem\u003ee.g.\u003c/em\u003e \n  passing the writer's \u003ccode\u003e\u003ca\u003eQopt\u003c/a\u003e\u003c/code\u003es to the reader).\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withPair",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e ReaderDesc i -\u003e WriterDesc o -\u003e ((Reader i, Writer o) -\u003e IO r) -\u003e IO r",
          "type": "function"
        },
        "index": {
          "description": "Creates pair of Reader Writer with limited lifetime The pair will live only in the scope of the action that is passed as last parameter The function is useful for readers writers used in combination e.g to emulate client server kind of communication withPair returns the result of the action passed in The parameters are The connection handle Con The name of the pair the reader will be identified by string with added to this name the writer by string with added to this name The description of the Reader ReaderDesc The description of the Writer WriterDesc The application-defined action The reason for introducing the reader and writer description is to provide error detection at compile time It is this way much more difficult to accidently confuse the writer and the reader parameters e.g passing the writer Qopt to the reader",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withPair",
          "normalized": "Con-\u003eString-\u003eReaderDesc a-\u003eWriterDesc b-\u003e((Reader a,Writer b)-\u003eIO c)-\u003eIO c",
          "package": "stomp-queue",
          "partial": "Pair",
          "signature": "Con-\u003eString-\u003eReaderDesc i-\u003eWriterDesc o-\u003e((Reader i,Writer o)-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:withPair"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003e\u003ca\u003eReader\u003c/a\u003e\u003c/code\u003e with limited lifetime. \n   The queue will live only in the scope of the action\n   that is passed as last parameter. \n   The function is useful for readers\n   with a lifetime shorter than that of the connection.\n   When the action terminates, the client unsubscribes from \n   the broker queue - even if an exception is raised.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithReader\u003c/a\u003e\u003c/code\u003e returns the result of the action.\n   Since the lifetime of the queue is limited to the action,\n   it should not be returned.\n   Any operation on a reader created by \u003ccode\u003e\u003ca\u003ewithReader\u003c/a\u003e\u003c/code\u003e\n   outside the action will raise \u003ccode\u003e\u003ca\u003eQueueException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eA usage example is: \n\u003c/p\u003e\u003cpre\u003e x \u003c- withReader c \"TestQ\" \"/queue/test\" [] [] iconv $ \\q -\u003e do\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withReader",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e String -\u003e [Qopt] -\u003e [Header] -\u003e InBound i -\u003e (Reader i -\u003e IO r) -\u003e IO r",
          "type": "function"
        },
        "index": {
          "description": "Creates Reader with limited lifetime The queue will live only in the scope of the action that is passed as last parameter The function is useful for readers with lifetime shorter than that of the connection When the action terminates the client unsubscribes from the broker queue even if an exception is raised withReader returns the result of the action Since the lifetime of the queue is limited to the action it should not be returned Any operation on reader created by withReader outside the action will raise QueueException usage example is withReader TestQ queue test iconv do",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withReader",
          "normalized": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eInBound a-\u003e(Reader a-\u003eIO b)-\u003eIO b",
          "package": "stomp-queue",
          "partial": "Reader",
          "signature": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eInBound i-\u003e(Reader i-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:withReader"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eStarts a transaction and executes the action\n   in the last parameter.\n   After the action has finished, \n   the transaction will be either committed or aborted\n   even if an exception has been raised.\n   Note that, depending on the options,\n   the way a transaction is terminated may vary,\n   refer to \u003ccode\u003e\u003ca\u003eTopt\u003c/a\u003e\u003c/code\u003e for details.\n\u003c/p\u003e\u003cp\u003eTransactions cannot be shared among threads.\n   Transactions are internally protected against\n   access from any thread but the one\n   that has actually started the transaction.\n\u003c/p\u003e\u003cp\u003eIt is \u003cem\u003enot\u003c/em\u003e advisable to use \u003ccode\u003e\u003ca\u003ewithTransaction\u003c/a\u003e\u003c/code\u003e with \u003cem\u003etimeout\u003c/em\u003e.\n   It is preferred to use \u003cem\u003etimeout\u003c/em\u003e on the \n   the actions executed within this transaction.\n   Whether and how much time the transaction itself\n   shall wait for the completion of on-going interactions with the broker,\n   in particular pending receipts,\n   shall be controlled\n   by the \u003ccode\u003e\u003ca\u003eOTimeout\u003c/a\u003e\u003c/code\u003e option.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithTransaction\u003c/a\u003e\u003c/code\u003e returns the result of the action.\n\u003c/p\u003e\u003cp\u003eThe simplest usage example with a \u003ccode\u003eConnection\u003c/code\u003e \u003cem\u003ec\u003c/em\u003e is:\n\u003c/p\u003e\u003cpre\u003e r \u003c- withTransaction c [] $ \\_ -\u003e do\n\u003c/pre\u003e\u003cp\u003eIf the transaction shall use receipts and, before terminating, wait 100\u003cem\u003ems\u003c/em\u003e\n   for all receipts to be confirmed by the broker\n   \u003ccode\u003e\u003ca\u003ewithTransaction\u003c/a\u003e\u003c/code\u003e is called like:\n\u003c/p\u003e\u003cpre\u003e eiR \u003c- try $ withTransaction c [OTimeout 100, OWithReceipts] \\_ -\u003e do\n case eiR of\n   Left e  -\u003e -- error handling\n   Right x -\u003e do -- ..\n\u003c/pre\u003e\u003cp\u003eNote that \u003ccode\u003e\u003ca\u003etry\u003c/a\u003e\u003c/code\u003e is used to catch any \u003ccode\u003e\u003ca\u003eStomplException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withTransaction",
          "package": "stomp-queue",
          "signature": "Con -\u003e [Topt] -\u003e (Tx -\u003e IO a) -\u003e IO a",
          "type": "function"
        },
        "index": {
          "description": "Starts transaction and executes the action in the last parameter After the action has finished the transaction will be either committed or aborted even if an exception has been raised Note that depending on the options the way transaction is terminated may vary refer to Topt for details Transactions cannot be shared among threads Transactions are internally protected against access from any thread but the one that has actually started the transaction It is not advisable to use withTransaction with timeout It is preferred to use timeout on the the actions executed within this transaction Whether and how much time the transaction itself shall wait for the completion of on-going interactions with the broker in particular pending receipts shall be controlled by the OTimeout option withTransaction returns the result of the action The simplest usage example with Connection is withTransaction do If the transaction shall use receipts and before terminating wait ms for all receipts to be confirmed by the broker withTransaction is called like eiR try withTransaction OTimeout OWithReceipts do case eiR of Left error handling Right do Note that try is used to catch any StomplException",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withTransaction",
          "normalized": "Con-\u003e[Topt]-\u003e(Tx-\u003eIO a)-\u003eIO a",
          "package": "stomp-queue",
          "partial": "Transaction",
          "signature": "Con-\u003e[Topt]-\u003e(Tx-\u003eIO a)-\u003eIO a",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:withTransaction"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eCreates a \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e with limited lifetime. \n   The queue will live only in the scope of the action\n   that is passed as last parameter. \n   The function is useful for writers\n   that are used only temporarly, \u003cem\u003ee.g.\u003c/em\u003e during initialisation.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e\u003ca\u003ewithWriter\u003c/a\u003e\u003c/code\u003e returns the result of the action.\n   Since the lifetime of the queue is limited to the action,\n   it should not be returned.\n   Any operation on a writer created by \u003ccode\u003e\u003ca\u003ewithWriter\u003c/a\u003e\u003c/code\u003e\n   outside the action will raise a \u003ccode\u003e\u003ca\u003eQueueException\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withWriter",
          "package": "stomp-queue",
          "signature": "Con -\u003e String -\u003e String -\u003e [Qopt] -\u003e [Header] -\u003e OutBound o -\u003e (Writer o -\u003e IO r) -\u003e IO r",
          "type": "function"
        },
        "index": {
          "description": "Creates Writer with limited lifetime The queue will live only in the scope of the action that is passed as last parameter The function is useful for writers that are used only temporarly e.g during initialisation withWriter returns the result of the action Since the lifetime of the queue is limited to the action it should not be returned Any operation on writer created by withWriter outside the action will raise QueueException",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "withWriter",
          "normalized": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eOutBound a-\u003e(Writer a-\u003eIO b)-\u003eIO b",
          "package": "stomp-queue",
          "partial": "Writer",
          "signature": "Con-\u003eString-\u003eString-\u003e[Qopt]-\u003e[Header]-\u003eOutBound o-\u003e(Writer o-\u003eIO r)-\u003eIO r",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:withWriter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e\n   that overwrites the destination queue defined in the writer queue.\n   It can be used for \u003cem\u003ead hoc\u003c/em\u003e communication and\n   for emulations of client/server-like protocols:\n   the client would pass the name of the queue\n   where it expects the server response in a header;\n   the server would send the resply to the queue\n   indicated in the header using \u003ccode\u003e\u003ca\u003ewriteAdHoc\u003c/a\u003e\u003c/code\u003e.\n   The additional \u003ccode\u003eString\u003c/code\u003e parameter contains the destination.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeAdHoc",
          "package": "stomp-queue",
          "signature": "Writer a -\u003e String -\u003e Type -\u003e [Header] -\u003e a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "This is variant of writeQ that overwrites the destination queue defined in the writer queue It can be used for ad hoc communication and for emulations of client server-like protocols the client would pass the name of the queue where it expects the server response in header the server would send the resply to the queue indicated in the header using writeAdHoc The additional String parameter contains the destination",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeAdHoc",
          "normalized": "Writer a-\u003eString-\u003eType-\u003e[Header]-\u003ea-\u003eIO()",
          "package": "stomp-queue",
          "partial": "Ad Hoc",
          "signature": "Writer a-\u003eString-\u003eType-\u003e[Header]-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:writeAdHoc"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of \u003ccode\u003e\u003ca\u003ewriteAdHoc\u003c/a\u003e\u003c/code\u003e \n   that is particularly useful for queues \n   created with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e, but without \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e.\n   It returns the \u003ccode\u003e\u003ca\u003eReceipt\u003c/a\u003e\u003c/code\u003e, so that it can be waited for\n   later, using \u003ccode\u003e\u003ca\u003ewaitReceipt\u003c/a\u003e\u003c/code\u003e.\n   Please refer to \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e for more details.\n\u003c/p\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeAdHocWith",
          "package": "stomp-queue",
          "signature": "Writer a -\u003e String -\u003e Type -\u003e [Header] -\u003e a -\u003e IO Receipt",
          "type": "function"
        },
        "index": {
          "description": "This is variant of writeAdHoc that is particularly useful for queues created with OWithReceipt but without OWaitReceipt It returns the Receipt so that it can be waited for later using waitReceipt Please refer to writeQWith for more details",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeAdHocWith",
          "normalized": "Writer a-\u003eString-\u003eType-\u003e[Header]-\u003ea-\u003eIO Receipt",
          "package": "stomp-queue",
          "partial": "Ad Hoc With",
          "signature": "Writer a-\u003eString-\u003eType-\u003e[Header]-\u003ea-\u003eIO Receipt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:writeAdHocWith"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eAdds the value \u003cem\u003ea\u003c/em\u003e as message at the end of the queue.\n   The Mime type as well as the headers \n   are added to the message.\n\u003c/p\u003e\u003cp\u003eIf the queue was created with the option\n   \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e will request a receipt from the broker.\n   If the queue was additionally created with\n   \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e,\n   \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e will preempt until the receipt is confirmed.\n\u003c/p\u003e\u003cp\u003eThe Stomp headers are useful for brokers\n   that provide selectors on \u003cem\u003esubscribe\u003c/em\u003e,\n   see \u003ccode\u003e\u003ca\u003enewReader\u003c/a\u003e\u003c/code\u003e for details.\n\u003c/p\u003e\u003cp\u003eA usage example for a \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e \u003cem\u003eq\u003c/em\u003e of type \u003ccode\u003eString\u003c/code\u003e\n   may be (\u003cem\u003enullType\u003c/em\u003e is defined as \u003cem\u003etext\u003c/em\u003e/\u003cem\u003eplain\u003c/em\u003e in Codec.MIME):\n\u003c/p\u003e\u003cpre\u003e writeQ q nullType [] \"hello world!\"\n\u003c/pre\u003e\u003cp\u003eFor a \u003ccode\u003e\u003ca\u003eWriter\u003c/a\u003e\u003c/code\u003e that was created \n   with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e,\n   the function should be called with \u003cem\u003etimeout\u003c/em\u003e:\n\u003c/p\u003e\u003cpre\u003e mbR \u003c- timeout tmo $ writeQ q nullType [] \"hello world!\"\n case mbR of\n   Nothing -\u003e -- error handling\n   Just r  -\u003e do -- ...\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeQ",
          "package": "stomp-queue",
          "signature": "Writer a -\u003e Type -\u003e [Header] -\u003e a -\u003e IO ()",
          "type": "function"
        },
        "index": {
          "description": "Adds the value as message at the end of the queue The Mime type as well as the headers are added to the message If the queue was created with the option OWithReceipt writeQ will request receipt from the broker If the queue was additionally created with OWaitReceipt writeQ will preempt until the receipt is confirmed The Stomp headers are useful for brokers that provide selectors on subscribe see newReader for details usage example for Writer of type String may be nullType is defined as text plain in Codec.MIME writeQ nullType hello world For Writer that was created with OWithReceipt and OWaitReceipt the function should be called with timeout mbR timeout tmo writeQ nullType hello world case mbR of Nothing error handling Just do",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeQ",
          "normalized": "Writer a-\u003eType-\u003e[Header]-\u003ea-\u003eIO()",
          "package": "stomp-queue",
          "signature": "Writer a-\u003eType-\u003e[Header]-\u003ea-\u003eIO()",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:writeQ"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is a variant of \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e \n   that is particularly useful for queues \n   created with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e, but without \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e.\n   It returns the \u003ccode\u003e\u003ca\u003eReceipt\u003c/a\u003e\u003c/code\u003e, so that it can be waited for\n   later, using \u003ccode\u003e\u003ca\u003ewaitReceipt\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eNote that the behaviour of \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e, \n   besides of returning the receipt, is the same as \u003ccode\u003e\u003ca\u003ewriteQ\u003c/a\u003e\u003c/code\u003e,\n   \u003cem\u003ei.e.\u003c/em\u003e, on a queue with \u003ccode\u003e\u003ca\u003eOWithReceipt\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003eOWaitReceipt\u003c/a\u003e\u003c/code\u003e\n   \u003ccode\u003e\u003ca\u003ewriteQWith\u003c/a\u003e\u003c/code\u003e will wait for the receipt being confirmed.\n   In this case, the returned receipt is, in fact, \n   of no further use for the application.\n\u003c/p\u003e\u003cp\u003eThe function is used like:\n\u003c/p\u003e\u003cpre\u003e r \u003c- writeQWith q nullType [] \"hello world!\"\n\u003c/pre\u003e",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeQWith",
          "package": "stomp-queue",
          "signature": "Writer a -\u003e Type -\u003e [Header] -\u003e a -\u003e IO Receipt",
          "type": "function"
        },
        "index": {
          "description": "This is variant of writeQ that is particularly useful for queues created with OWithReceipt but without OWaitReceipt It returns the Receipt so that it can be waited for later using waitReceipt Note that the behaviour of writeQWith besides of returning the receipt is the same as writeQ i.e on queue with OWithReceipt and OWaitReceipt writeQWith will wait for the receipt being confirmed In this case the returned receipt is in fact of no further use for the application The function is used like writeQWith nullType hello world",
          "hierarchy": "Network Mom Stompl Client Queue",
          "module": "Network.Mom.Stompl.Client.Queue",
          "name": "writeQWith",
          "normalized": "Writer a-\u003eType-\u003e[Header]-\u003ea-\u003eIO Receipt",
          "package": "stomp-queue",
          "partial": "QWith",
          "signature": "Writer a-\u003eType-\u003e[Header]-\u003ea-\u003eIO Receipt",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/stomp-queue/docs/Network-Mom-Stompl-Client-Queue.html#v:writeQWith"
      }
    }
  ]
]