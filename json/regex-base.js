[
  {
    "cmd": "delete-by-query",
    "query": {
      "contexts": [
        "package"
      ],
      "query": {
        "op": "case",
        "type": "word",
        "word": "regex-base"
      },
      "type": "context"
    }
  },
  [
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eThis is a module of instances of \u003ccode\u003e\u003ca\u003eRegexContext\u003c/a\u003e\u003c/code\u003e (defined in\nText.Regex.Base.RegexLike).  Nothing else is exported.  This is\nusually imported via the Text.Regex.Base convenience package which\nitself is re-exported from newer Text.Regex.XXX modules provided by\nthe different regex-xxx backends.\n\u003c/p\u003e\u003cp\u003eThese instances work for all the supported types and backends\ninterchangably.  These instances provide the different results that\ncan be gotten from a match or matchM operation (often via the \u003ccode\u003e=~\u003c/code\u003e and\n\u003ccode\u003e=~~\u003c/code\u003e operators with combine \u003ccode\u003emakeRegex\u003c/code\u003e with \u003ccode\u003ematch\u003c/code\u003e and \u003ccode\u003ematchM\u003c/code\u003e\nrespectively).  This module name is Context because they operators are\ncontext dependent: use them in a context that expects an Int and you\nget a count of matches, use them in a Bool context and get True if\nthere is a match, etc.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003eRegexContext a b c\u003c/code\u003e takes a regular expression suppied in a type \u003ccode\u003ea\u003c/code\u003e\ngenerated by \u003ccode\u003eRegexMaker\u003c/code\u003e and a target text supplied in type \u003ccode\u003eb\u003c/code\u003e to a\nresult type \u003ccode\u003ec\u003c/code\u003e using the \u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e class function.  The \u003ccode\u003e\u003ca\u003ematchM\u003c/a\u003e\u003c/code\u003e class\nfunction works like \u003ccode\u003e\u003ca\u003ematch\u003c/a\u003e\u003c/code\u003e unless there is no match found, in which\ncase it calls \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e in the (arbitrary) monad context.\n\u003c/p\u003e\u003cp\u003eThere are a few type synonyms from RegexLike that are used here:\n\u003c/p\u003e\u003cpre\u003e \n-- | 0 based index from start of source, or (-1) for unused\ntype MatchOffset = Int\n-- | non-negative length of a match\ntype MatchLength = Int\ntype MatchArray = Array Int (MatchOffset, MatchLength)\ntype MatchText source = Array Int (source, (MatchOffset, MatchLength))\n\u003c/pre\u003e\u003cp\u003eThere are also a few newtypes that used to prevent any possible\noverlap of types, which were not needed for GHC's late overlap\ndetection but are needed for use in Hugs.\n\u003c/p\u003e\u003cpre\u003e\nnewtype AllSubmatches f b = AllSubmatches {getAllSubmatches :: (f b)}\nnewtype AllTextSubmatches f b = AllTextSubmatches {getAllTextSubmatches :: (f b)}\nnewtype AllMatches f b = AllMatches {getAllMatches :: (f b)}\nnewtype AllTextMatches f b = AllTextMatches {getAllTextMatches :: (f b) }\n\u003c/pre\u003e\u003cp\u003eThe newtypes' \u003ccode\u003ef\u003c/code\u003e parameters are the containers, usually \u003ccode\u003e[]\u003c/code\u003e or\n\u003ccode\u003eArray Int\u003c/code\u003e, (where the arrays all have lower bound 0).\n\u003c/p\u003e\u003cp\u003eThe two *Submatches newtypes return only information on the first\nmatch.  The other two newtypes return information on all the\nnon-overlapping matches.  The two *Text* newtypes are used to mark\nresult types that contain the same type as the target text.\n\u003c/p\u003e\u003cp\u003eWhere provided, noncaptured submatches will have a \u003ccode\u003eMatchOffset\u003c/code\u003e of\n(-1) and non-negative otherwise.  The semantics of submatches depend\non the backend and its compile and execution options.  Where provided,\n\u003ccode\u003eMatchLength\u003c/code\u003e will always be non-negative.  Arrays with no elements\nare returned with bounds of (1,0).  Arrays with elements will have a\nlower bound of 0.\n\u003c/p\u003e\u003cp\u003eXXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX\n\u003c/p\u003e\u003cp\u003eThese are for finding the first match in the target text:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b Bool \u003c/code\u003e :\n  Whether there is any match or not.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b () \u003c/code\u003e :\n  Useful as a guard with \u003ccode\u003ematchM\u003c/code\u003e or \u003ccode\u003e=~~\u003c/code\u003e in a monad, since failure to match calls \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b b \u003c/code\u003e :\n  This returns the text of the whole match.\n  It will return \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e from the \u003ccode\u003e\u003ca\u003eExtract\u003c/a\u003e\u003c/code\u003e type class if there is no match.\n  These are defined in each backend module, but documented here for convenience.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b (MatchOffset,MatchLength) \u003c/code\u003e :\n  This returns the initial index and length of the whole match.\n  MatchLength will always be non-negative, and 0 for a failed match.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b (MatchResult b) \u003c/code\u003e : The\n  \u003ccode\u003e\u003ca\u003eMatchResult\u003c/a\u003e\u003c/code\u003e structure with details for the match.  This is the\n  structure copied from the old \u003ccode\u003eJRegex\u003c/code\u003e pacakge.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b (b, b, b) \u003c/code\u003e :\n  The text before the match, the text of the match, the text after the match\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b (b, MatchText b, b) \u003c/code\u003e :\n  The text before the match, the details of the match, and the text after the match\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b (b, b, b, [b]) \u003c/code\u003e : \n  The text before the match, the text of the match, the text after the\n  match, and a list of the text of the 1st and higher sub-parts of the\n  match.  This is the same return value as used in the old\n  \u003ccode\u003eText.Regex\u003c/code\u003e API.\n\u003c/p\u003e\u003cp\u003eTwo containers of the submatch offset information:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b MatchArray \u003c/code\u003e :\n  Array of \u003ccode\u003e(MatchOffset,MatchLength)\u003c/code\u003e for all the sub matches.\n  The whole match is at the intial 0th index.\n  Noncaptured submatches will have a \u003ccode\u003eMatchOffset\u003c/code\u003e of (-1)\n  The array will have no elements and bounds (1,0) if there is no match.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b (AllSubmatches [] (MatchOffset,MatchLength) \u003c/code\u003e :\n  List of \u003ccode\u003e(MatchOffset,MatchLength)\u003c/code\u003e\n  The whole match is the first element, the rest are the submatches (if any) in order.\n  The list is empty if there is no match.\n\u003c/p\u003e\u003cp\u003eTwo containers of the submatch text and offset information:\n\u003c/p\u003e\u003cpre\u003e RegexContext a b (AllTextSubmatches (Array Int) (b, (MatchOffset, MatchLength)))\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllTextSubmatches [] (b, (MatchOffset, MatchLength)))\u003c/pre\u003e\u003cp\u003eTwo containers of the submatch text information:\n\u003c/p\u003e\u003cpre\u003e RegexContext a b (AllTextSubmatches [] b)\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllTextSubmatches (Array Int) b)\u003c/pre\u003e\u003cp\u003eThese instances are for all the matches (non-overlapping).  Note that\nbackends are supposed to supply \u003ccode\u003e\u003ca\u003eRegexLike\u003c/a\u003e\u003c/code\u003e instances for which the\ndefault \u003ccode\u003e\u003ca\u003ematchAll\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003ematchAllText\u003c/a\u003e\u003c/code\u003e stop searching after returning\nany successful but empty match.\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b Int \u003c/code\u003e :\n  The number of matches, non-negative.\n\u003c/p\u003e\u003cp\u003eTwo containers for locations of all matches:\n\u003c/p\u003e\u003cpre\u003e RegexContext a b (AllMatches [] (MatchOffset, MatchLength))\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllMatches (Array Int) (MatchOffset,MatchLength))\u003c/pre\u003e\u003cp\u003eTwo containers for the locations of all matches and their submatches:\n\u003c/p\u003e\u003cp\u003e\u003ccode\u003e RegexContext a b [MatchArray] \u003c/code\u003e :\n\u003c/p\u003e\u003cpre\u003e RegexContext a b (AllMatches (Array Int) MatchArray)\u003c/pre\u003e\u003cp\u003eTwo containers for the text and locations of all matches and their submatches:\n\u003c/p\u003e\u003cpre\u003e RegexContext a b [MatchText b]\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllTextMatches (Array Int) (MatchText b))\u003c/pre\u003e\u003cp\u003eTwo containers for text of all matches:\n\u003ccode\u003e RegexContext a b (AllTextMatches [] b) \u003c/code\u003e\n\u003c/p\u003e\u003cpre\u003e RegexContext a b (AllTextMatches (Array Int) b)\u003c/pre\u003e\u003cp\u003eFour containers for text of all matches and their submatches:\n\u003c/p\u003e\u003cpre\u003e RegexContext a b [[b]]\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllTextMatches (Array Int) [b])\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllTextMatches [] (Array Int b))\u003c/pre\u003e\u003cpre\u003e RegexContext a b (AllTextMatches (Array Int) (Array Int b))\u003c/pre\u003e\u003cp\u003eUnused matches are \u003ccode\u003e\u003ca\u003eempty\u003c/a\u003e\u003c/code\u003e (defined via \u003ccode\u003e\u003ca\u003eExtract\u003c/a\u003e\u003c/code\u003e)\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Base.Context",
          "name": "Context",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-Context.html",
          "type": "module"
        },
        "index": {
          "description": "This is module of instances of RegexContext defined in Text.Regex.Base.RegexLike Nothing else is exported This is usually imported via the Text.Regex.Base convenience package which itself is re-exported from newer Text.Regex.XXX modules provided by the different regex-xxx backends These instances work for all the supported types and backends interchangably These instances provide the different results that can be gotten from match or matchM operation often via the and operators with combine makeRegex with match and matchM respectively This module name is Context because they operators are context dependent use them in context that expects an Int and you get count of matches use them in Bool context and get True if there is match etc RegexContext takes regular expression suppied in type generated by RegexMaker and target text supplied in type to result type using the match class function The matchM class function works like match unless there is no match found in which case it calls fail in the arbitrary monad context There are few type synonyms from RegexLike that are used here based index from start of source or for unused type MatchOffset Int non-negative length of match type MatchLength Int type MatchArray Array Int MatchOffset MatchLength type MatchText source Array Int source MatchOffset MatchLength There are also few newtypes that used to prevent any possible overlap of types which were not needed for GHC late overlap detection but are needed for use in Hugs newtype AllSubmatches AllSubmatches getAllSubmatches newtype AllTextSubmatches AllTextSubmatches getAllTextSubmatches newtype AllMatches AllMatches getAllMatches newtype AllTextMatches AllTextMatches getAllTextMatches The newtypes parameters are the containers usually or Array Int where the arrays all have lower bound The two Submatches newtypes return only information on the first match The other two newtypes return information on all the non-overlapping matches The two Text newtypes are used to mark result types that contain the same type as the target text Where provided noncaptured submatches will have MatchOffset of and non-negative otherwise The semantics of submatches depend on the backend and its compile and execution options Where provided MatchLength will always be non-negative Arrays with no elements are returned with bounds of Arrays with elements will have lower bound of XXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX These are for finding the first match in the target text RegexContext Bool Whether there is any match or not RegexContext Useful as guard with matchM or in monad since failure to match calls fail RegexContext This returns the text of the whole match It will return empty from the Extract type class if there is no match These are defined in each backend module but documented here for convenience RegexContext MatchOffset MatchLength This returns the initial index and length of the whole match MatchLength will always be non-negative and for failed match RegexContext MatchResult The MatchResult structure with details for the match This is the structure copied from the old JRegex pacakge RegexContext The text before the match the text of the match the text after the match RegexContext MatchText The text before the match the details of the match and the text after the match RegexContext The text before the match the text of the match the text after the match and list of the text of the st and higher sub-parts of the match This is the same return value as used in the old Text.Regex API Two containers of the submatch offset information RegexContext MatchArray Array of MatchOffset MatchLength for all the sub matches The whole match is at the intial th index Noncaptured submatches will have MatchOffset of The array will have no elements and bounds if there is no match RegexContext AllSubmatches MatchOffset MatchLength List of MatchOffset MatchLength The whole match is the first element the rest are the submatches if any in order The list is empty if there is no match Two containers of the submatch text and offset information RegexContext AllTextSubmatches Array Int MatchOffset MatchLength RegexContext AllTextSubmatches MatchOffset MatchLength Two containers of the submatch text information RegexContext AllTextSubmatches RegexContext AllTextSubmatches Array Int These instances are for all the matches non-overlapping Note that backends are supposed to supply RegexLike instances for which the default matchAll and matchAllText stop searching after returning any successful but empty match RegexContext Int The number of matches non-negative Two containers for locations of all matches RegexContext AllMatches MatchOffset MatchLength RegexContext AllMatches Array Int MatchOffset MatchLength Two containers for the locations of all matches and their submatches RegexContext MatchArray RegexContext AllMatches Array Int MatchArray Two containers for the text and locations of all matches and their submatches RegexContext MatchText RegexContext AllTextMatches Array Int MatchText Two containers for text of all matches RegexContext AllTextMatches RegexContext AllTextMatches Array Int Four containers for text of all matches and their submatches RegexContext RegexContext AllTextMatches Array Int RegexContext AllTextMatches Array Int RegexContext AllTextMatches Array Int Array Int Unused matches are empty defined via Extract",
          "hierarchy": "Text Regex Base Context",
          "module": "Text.Regex.Base.Context",
          "name": "Context",
          "package": "regex-base",
          "partial": "Context",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-Context.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eHelper functions for defining certain instances of\n RegexContext. These help when defining instances of RegexContext\n with repeated types:\n\u003c/p\u003e\u003cpre\u003e\n instance (RegexLike regex source) =\u003e RegexContext regex source source where\n\u003c/pre\u003e\u003cp\u003eruns into overlapping restrictions. To avoid this I have each backend\n define, for its own Regex type:\n\u003c/p\u003e\u003cpre\u003e\n instance RegexContext Regex String String where\n   match = polymatch\n   matchM = polymatchM\n\u003c/pre\u003e\u003cpre\u003e\n instance RegexContext Regex ByteString ByteString where\n   match = polymatch\n   matchM = polymatchM\n\u003c/pre\u003e\u003c/div\u003e",
          "module": "Text.Regex.Base.Impl",
          "name": "Impl",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-Impl.html",
          "type": "module"
        },
        "index": {
          "description": "Helper functions for defining certain instances of RegexContext These help when defining instances of RegexContext with repeated types instance RegexLike regex source RegexContext regex source source where runs into overlapping restrictions To avoid this have each backend define for its own Regex type instance RegexContext Regex String String where match polymatch matchM polymatchM instance RegexContext Regex ByteString ByteString where match polymatch matchM polymatchM",
          "hierarchy": "Text Regex Base Impl",
          "module": "Text.Regex.Base.Impl",
          "name": "Impl",
          "package": "regex-base",
          "partial": "Impl",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-Impl.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.Impl",
          "name": "polymatch",
          "package": "regex-base",
          "signature": "a -\u003e b -\u003e b",
          "source": "src/Text-Regex-Base-Impl.html#polymatch",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base Impl",
          "module": "Text.Regex.Base.Impl",
          "name": "polymatch",
          "normalized": "a-\u003eb-\u003eb",
          "package": "regex-base",
          "signature": "a-\u003eb-\u003eb",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-Impl.html#v:polymatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.Impl",
          "name": "polymatchM",
          "package": "regex-base",
          "signature": "a -\u003e b -\u003e m b",
          "source": "src/Text-Regex-Base-Impl.html#polymatchM",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base Impl",
          "module": "Text.Regex.Base.Impl",
          "name": "polymatchM",
          "normalized": "a-\u003eb-\u003ec b",
          "package": "regex-base",
          "signature": "a-\u003eb-\u003em b",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-Impl.html#v:polymatchM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClasses and instances for Regex matching.\n\u003c/p\u003e\u003cp\u003eAll the classes are declared here, and some common type aliases, and\n the MatchResult data type.\n\u003c/p\u003e\u003cp\u003eThe only instances here are for Extract String and Extract ByteString.\n There are no data values.  The \u003ccode\u003e\u003ca\u003eRegexContext\u003c/a\u003e\u003c/code\u003e instances are in\n \u003ca\u003eText.Regex.Base.Context\u003c/a\u003e, except for ones which run afoul of a\n repeated variable (RegexContext regex a a), which are defined in each\n modules' String and ByteString modules.\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexLike",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html",
          "type": "module"
        },
        "index": {
          "description": "Classes and instances for Regex matching All the classes are declared here and some common type aliases and the MatchResult data type The only instances here are for Extract String and Extract ByteString There are no data values The RegexContext instances are in Text.Regex.Base.Context except for ones which run afoul of repeated variable RegexContext regex which are defined in each modules String and ByteString modules",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexLike",
          "package": "regex-base",
          "partial": "Regex Like",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in results of RegexContext instances\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllMatches",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#AllMatches",
          "type": "newtype"
        },
        "index": {
          "description": "Used in results of RegexContext instances",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllMatches",
          "package": "regex-base",
          "partial": "All Matches",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:AllMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in results of RegexContext instances\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllSubmatches",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#AllSubmatches",
          "type": "newtype"
        },
        "index": {
          "description": "Used in results of RegexContext instances",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllSubmatches",
          "package": "regex-base",
          "partial": "All Submatches",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:AllSubmatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in results of RegexContext instances\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextMatches",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#AllTextMatches",
          "type": "newtype"
        },
        "index": {
          "description": "Used in results of RegexContext instances",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextMatches",
          "package": "regex-base",
          "partial": "All Text Matches",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:AllTextMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eUsed in results of RegexContext instances\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextSubmatches",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#AllTextSubmatches",
          "type": "newtype"
        },
        "index": {
          "description": "Used in results of RegexContext instances",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextSubmatches",
          "package": "regex-base",
          "partial": "All Text Submatches",
          "type": "newtype"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:AllTextSubmatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eExtract allows for indexing operations on String or ByteString.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "Extract",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#Extract",
          "type": "class"
        },
        "index": {
          "description": "Extract allows for indexing operations on String or ByteString",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "Extract",
          "package": "regex-base",
          "partial": "Extract",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:Extract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based array, with 0th index indicating the full match.  If the\n full match location is not available, represent as (0,0).\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchArray",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchArray",
          "type": "type"
        },
        "index": {
          "description": "based array with th index indicating the full match If the full match location is not available represent as",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchArray",
          "package": "regex-base",
          "partial": "Match Array",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:MatchArray"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003enon-negative length of a match\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchLength",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchLength",
          "type": "type"
        },
        "index": {
          "description": "non-negative length of match",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchLength",
          "package": "regex-base",
          "partial": "Match Length",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:MatchLength"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003e0 based index from start of source, or (-1) for unused\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchOffset",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchOffset",
          "type": "type"
        },
        "index": {
          "description": "based index from start of source or for unused",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchOffset",
          "package": "regex-base",
          "partial": "Match Offset",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:MatchOffset"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is the same as the type from JRegex.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchResult",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "data"
        },
        "index": {
          "description": "This is the same as the type from JRegex",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchResult",
          "package": "regex-base",
          "partial": "Match Result",
          "type": "data"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:MatchResult"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchText",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchText",
          "type": "type"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MatchText",
          "package": "regex-base",
          "partial": "Match Text",
          "type": "type"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:MatchText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegexContext is the polymorphic interface to do matching.  Since\n \u003ccode\u003etarget\u003c/code\u003e is polymorphic you may need to suply the type explicitly\n in contexts where it cannot be inferred.\n\u003c/p\u003e\u003cp\u003eThe monadic \u003ccode\u003e\u003ca\u003ematchM\u003c/a\u003e\u003c/code\u003e version uses \u003ccode\u003e\u003ca\u003efail\u003c/a\u003e\u003c/code\u003e to report when the \u003ccode\u003eregex\u003c/code\u003e\n has no match in \u003ccode\u003esource\u003c/code\u003e.  Two examples:\n\u003c/p\u003e\u003cp\u003eHere the contest \u003ccode\u003e\u003ca\u003eBool\u003c/a\u003e\u003c/code\u003e is inferred:\n\u003c/p\u003e\u003cpre\u003e [ c | let notVowel = makeRegex \"[^aeiou]\" :: Regex, c \u003c- ['a'..'z'], match notVowel [c]  ]\n\n \"bcdfghjklmnpqrstvwxyz\"\n\u003c/pre\u003e\u003cp\u003eHere the context '[String]' must be supplied:\n\u003c/p\u003e\u003cpre\u003e let notVowel = (makeRegex \"[^aeiou]\" :: Regex )\n in do { c \u003c- ['a'..'z'] ; matchM notVowel [c] } :: [String]\n\n [\"b\",\"c\",\"d\",\"f\",\"g\",\"h\",\"j\",\"k\",\"l\",\"m\",\"n\",\"p\",\"q\",\"r\",\"s\",\"t\",\"v\",\"w\",\"x\",\"y\",\"z\"]\n\u003c/pre\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexContext",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#RegexContext",
          "type": "class"
        },
        "index": {
          "description": "RegexContext is the polymorphic interface to do matching Since target is polymorphic you may need to suply the type explicitly in contexts where it cannot be inferred The monadic matchM version uses fail to report when the regex has no match in source Two examples Here the contest Bool is inferred let notVowel makeRegex aeiou Regex match notVowel bcdfghjklmnpqrstvwxyz Here the context String must be supplied let notVowel makeRegex aeiou Regex in do matchM notVowel String",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexContext",
          "package": "regex-base",
          "partial": "Regex Context",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:RegexContext"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegexLike is parametrized on a regular expression type and a\n source type to run the matching on.\n\u003c/p\u003e\u003cp\u003eThere are default implementations: matchTest and matchOnceText use\n matchOnce; matchCount and matchAllText use matchAll. matchOnce uses\n matchOnceText and matchAll uses matchAllText. So a minimal complete\n instance need to provide at least (matchOnce or matchOnceText) and\n (matchAll or matchAllText).  Additional definitions are often\n provided where they will increase efficiency.\n\u003c/p\u003e\u003cpre\u003e [ c | let notVowel = makeRegex \"[^aeiou]\" :: Regex, c \u003c- ['a'..'z'], matchTest notVowel [c]  ]\n\n \"bcdfghjklmnpqrstvwxyz\"\n\u003c/pre\u003e\u003cp\u003eThe strictness of these functions is instance dependent.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexLike",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#RegexLike",
          "type": "class"
        },
        "index": {
          "description": "RegexLike is parametrized on regular expression type and source type to run the matching on There are default implementations matchTest and matchOnceText use matchOnce matchCount and matchAllText use matchAll matchOnce uses matchOnceText and matchAll uses matchAllText So minimal complete instance need to provide at least matchOnce or matchOnceText and matchAll or matchAllText Additional definitions are often provided where they will increase efficiency let notVowel makeRegex aeiou Regex matchTest notVowel bcdfghjklmnpqrstvwxyz The strictness of these functions is instance dependent",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexLike",
          "package": "regex-base",
          "partial": "Regex Like",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:RegexLike"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRegexMaker captures the creation of the compiled regular\n expression from a source type and an option type.  \u003ccode\u003e\u003ca\u003emakeRegexM\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003emakeRegexM\u003c/a\u003e\u003c/code\u003e report parse error using \u003ccode\u003eMonadError\u003c/code\u003e, usually (Either\n String regex).\n\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003e\u003ca\u003emakeRegex\u003c/a\u003e\u003c/code\u003e function has a default implementation that depends\n on makeRegexOpts and used \u003ccode\u003e\u003ca\u003edefaultCompOpt\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003edefaultExecOpt\u003c/a\u003e\u003c/code\u003e.\n Similarly for \u003ccode\u003e\u003ca\u003emakeRegexM\u003c/a\u003e\u003c/code\u003e and \u003ccode\u003e\u003ca\u003emakeRegexOptsM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e\u003cp\u003eThere are also default implementaions for \u003ccode\u003e\u003ca\u003emakeRegexOpts\u003c/a\u003e\u003c/code\u003e and\n \u003ccode\u003e\u003ca\u003emakeRegexOptsM\u003c/a\u003e\u003c/code\u003e in terms of each other.  So a minimal instance\n definition needs to only define one of these, hopefully\n \u003ccode\u003e\u003ca\u003emakeRegexOptsM\u003c/a\u003e\u003c/code\u003e.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexMaker",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#RegexMaker",
          "type": "class"
        },
        "index": {
          "description": "RegexMaker captures the creation of the compiled regular expression from source type and an option type makeRegexM and makeRegexM report parse error using MonadError usually Either String regex The makeRegex function has default implementation that depends on makeRegexOpts and used defaultCompOpt and defaultExecOpt Similarly for makeRegexM and makeRegexOptsM There are also default implementaions for makeRegexOpts and makeRegexOptsM in terms of each other So minimal instance definition needs to only define one of these hopefully makeRegexOptsM",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexMaker",
          "package": "regex-base",
          "partial": "Regex Maker",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:RegexMaker"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eRather than carry them around spearately, the options for how to\n execute a regex are kept as part of the regex.  There are two types\n of options.  Those that can only be specified at compilation time\n and never changed are CompOpt.  Those that can be changed later and\n affect how matching is performed are ExecOpt.  The actually types\n for these depend on the backend.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexOptions",
          "package": "regex-base",
          "source": "src/Text-Regex-Base-RegexLike.html#RegexOptions",
          "type": "class"
        },
        "index": {
          "description": "Rather than carry them around spearately the options for how to execute regex are kept as part of the regex There are two types of options Those that can only be specified at compilation time and never changed are CompOpt Those that can be changed later and affect how matching is performed are ExecOpt The actually types for these depend on the backend",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "RegexOptions",
          "package": "regex-base",
          "partial": "Regex Options",
          "type": "class"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#t:RegexOptions"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllMatches",
          "package": "regex-base",
          "signature": "AllMatches",
          "source": "src/Text-Regex-Base-RegexLike.html#AllMatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllMatches",
          "package": "regex-base",
          "partial": "All Matches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:AllMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllSubmatches",
          "package": "regex-base",
          "signature": "AllSubmatches",
          "source": "src/Text-Regex-Base-RegexLike.html#AllSubmatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllSubmatches",
          "package": "regex-base",
          "partial": "All Submatches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:AllSubmatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextMatches",
          "package": "regex-base",
          "signature": "AllTextMatches",
          "source": "src/Text-Regex-Base-RegexLike.html#AllTextMatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextMatches",
          "package": "regex-base",
          "partial": "All Text Matches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:AllTextMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextSubmatches",
          "package": "regex-base",
          "signature": "AllTextSubmatches",
          "source": "src/Text-Regex-Base-RegexLike.html#AllTextSubmatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "AllTextSubmatches",
          "package": "regex-base",
          "partial": "All Text Submatches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:AllTextSubmatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "MR",
          "package": "regex-base",
          "signature": "MR",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "MR",
          "package": "regex-base",
          "partial": "MR",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:MR"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eafter is a renamed \u003ca\u003edrop\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "after",
          "package": "regex-base",
          "signature": "Int -\u003e source -\u003e source",
          "source": "src/Text-Regex-Base-RegexLike.html#after",
          "type": "method"
        },
        "index": {
          "description": "after is renamed drop",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "after",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "regex-base",
          "signature": "Int-\u003esource-\u003esource",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:after"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ebefore is a renamed \u003ca\u003etake\u003c/a\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "before",
          "package": "regex-base",
          "signature": "Int -\u003e source -\u003e source",
          "source": "src/Text-Regex-Base-RegexLike.html#before",
          "type": "method"
        },
        "index": {
          "description": "before is renamed take",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "before",
          "normalized": "Int-\u003ea-\u003ea",
          "package": "regex-base",
          "signature": "Int-\u003esource-\u003esource",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:before"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "blankCompOpt",
          "package": "regex-base",
          "signature": "blankCompOpt",
          "source": "src/Text-Regex-Base-RegexLike.html#blankCompOpt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "blankCompOpt",
          "package": "regex-base",
          "partial": "Comp Opt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:blankCompOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "blankExecOpt",
          "package": "regex-base",
          "signature": "blankExecOpt",
          "source": "src/Text-Regex-Base-RegexLike.html#blankExecOpt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "blankExecOpt",
          "package": "regex-base",
          "partial": "Exec Opt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:blankExecOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "defaultCompOpt",
          "package": "regex-base",
          "signature": "defaultCompOpt",
          "source": "src/Text-Regex-Base-RegexLike.html#defaultCompOpt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "defaultCompOpt",
          "package": "regex-base",
          "partial": "Comp Opt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:defaultCompOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "defaultExecOpt",
          "package": "regex-base",
          "signature": "defaultExecOpt",
          "source": "src/Text-Regex-Base-RegexLike.html#defaultExecOpt",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "defaultExecOpt",
          "package": "regex-base",
          "partial": "Exec Opt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:defaultExecOpt"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eFor when there is no match, this can construct an empty data value\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "empty",
          "package": "regex-base",
          "signature": "source",
          "source": "src/Text-Regex-Base-RegexLike.html#empty",
          "type": "method"
        },
        "index": {
          "description": "For when there is no match this can construct an empty data value",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "empty",
          "package": "regex-base",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:empty"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eextract takes an offset and length and has a default\n implementation of \u003ccode\u003eextract (off,len) source = before len (after\n off source)\u003c/code\u003e\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "extract",
          "package": "regex-base",
          "signature": "(Int, Int) -\u003e source -\u003e source",
          "source": "src/Text-Regex-Base-RegexLike.html#extract",
          "type": "method"
        },
        "index": {
          "description": "extract takes an offset and length and has default implementation of extract off len source before len after off source",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "extract",
          "normalized": "(Int,Int)-\u003ea-\u003ea",
          "package": "regex-base",
          "signature": "(Int,Int)-\u003esource-\u003esource",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:extract"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllMatches",
          "package": "regex-base",
          "signature": "f b",
          "source": "src/Text-Regex-Base-RegexLike.html#AllMatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllMatches",
          "package": "regex-base",
          "partial": "All Matches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:getAllMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllSubmatches",
          "package": "regex-base",
          "signature": "f b",
          "source": "src/Text-Regex-Base-RegexLike.html#AllSubmatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllSubmatches",
          "package": "regex-base",
          "partial": "All Submatches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:getAllSubmatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllTextMatches",
          "package": "regex-base",
          "signature": "f b",
          "source": "src/Text-Regex-Base-RegexLike.html#AllTextMatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllTextMatches",
          "package": "regex-base",
          "partial": "All Text Matches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:getAllTextMatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllTextSubmatches",
          "package": "regex-base",
          "signature": "f b",
          "source": "src/Text-Regex-Base-RegexLike.html#AllTextSubmatches",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "getAllTextSubmatches",
          "package": "regex-base",
          "partial": "All Text Submatches",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:getAllTextSubmatches"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eretrieve the current flags\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "getExecOpts",
          "package": "regex-base",
          "signature": "regex -\u003e execOpt",
          "source": "src/Text-Regex-Base-RegexLike.html#getExecOpts",
          "type": "method"
        },
        "index": {
          "description": "retrieve the current flags",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "getExecOpts",
          "normalized": "a-\u003eb",
          "package": "regex-base",
          "partial": "Exec Opts",
          "signature": "regex-\u003eexecOpt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:getExecOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emake using the defaultCompOpt and defaultExecOpt\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegex",
          "package": "regex-base",
          "signature": "source -\u003e regex",
          "source": "src/Text-Regex-Base-RegexLike.html#makeRegex",
          "type": "method"
        },
        "index": {
          "description": "make using the defaultCompOpt and defaultExecOpt",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegex",
          "normalized": "a-\u003eb",
          "package": "regex-base",
          "partial": "Regex",
          "signature": "source-\u003eregex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:makeRegex"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003emake using the defaultCompOpt and defaultExecOpt, reporting errors with fail\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegexM",
          "package": "regex-base",
          "signature": "source -\u003e m regex",
          "source": "src/Text-Regex-Base-RegexLike.html#makeRegexM",
          "type": "method"
        },
        "index": {
          "description": "make using the defaultCompOpt and defaultExecOpt reporting errors with fail",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegexM",
          "normalized": "a-\u003eb c",
          "package": "regex-base",
          "partial": "Regex",
          "signature": "source-\u003em regex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:makeRegexM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify your own options\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegexOpts",
          "package": "regex-base",
          "signature": "compOpt -\u003e execOpt -\u003e source -\u003e regex",
          "source": "src/Text-Regex-Base-RegexLike.html#makeRegexOpts",
          "type": "method"
        },
        "index": {
          "description": "Specify your own options",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegexOpts",
          "normalized": "a-\u003eb-\u003ec-\u003ed",
          "package": "regex-base",
          "partial": "Regex Opts",
          "signature": "compOpt-\u003eexecOpt-\u003esource-\u003eregex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:makeRegexOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eSpecify your own options, reporting errors with fail\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegexOptsM",
          "package": "regex-base",
          "signature": "compOpt -\u003e execOpt -\u003e source -\u003e m regex",
          "source": "src/Text-Regex-Base-RegexLike.html#makeRegexOptsM",
          "type": "method"
        },
        "index": {
          "description": "Specify your own options reporting errors with fail",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "makeRegexOptsM",
          "normalized": "a-\u003eb-\u003ec-\u003ed e",
          "package": "regex-base",
          "partial": "Regex Opts",
          "signature": "compOpt-\u003eexecOpt-\u003esource-\u003em regex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:makeRegexOptsM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "match",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e target",
          "source": "src/Text-Regex-Base-RegexLike.html#match",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "match",
          "normalized": "a-\u003eb-\u003ec",
          "package": "regex-base",
          "signature": "regex-\u003esource-\u003etarget",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:match"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematchAll returns a list of matches.  The matches are in order\n and do not overlap. If any match succeeds but has 0 length then\n this will be the last match in the list.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchAll",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e [MatchArray]",
          "source": "src/Text-Regex-Base-RegexLike.html#matchAll",
          "type": "method"
        },
        "index": {
          "description": "matchAll returns list of matches The matches are in order and do not overlap If any match succeeds but has length then this will be the last match in the list",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchAll",
          "normalized": "a-\u003eb-\u003e[MatchArray]",
          "package": "regex-base",
          "partial": "All",
          "signature": "regex-\u003esource-\u003e[MatchArray]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchAll"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis is matchAll with the actual subsections of the source\n instead of just the (offset,length) information.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchAllText",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e [MatchText source]",
          "source": "src/Text-Regex-Base-RegexLike.html#matchAllText",
          "type": "method"
        },
        "index": {
          "description": "This is matchAll with the actual subsections of the source instead of just the offset length information",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchAllText",
          "normalized": "a-\u003eb-\u003e[MatchText b]",
          "package": "regex-base",
          "partial": "All Text",
          "signature": "regex-\u003esource-\u003e[MatchText source]",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchAllText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematchCount returns the number of non-overlapping matches\n returned by matchAll.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchCount",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e Int",
          "source": "src/Text-Regex-Base-RegexLike.html#matchCount",
          "type": "method"
        },
        "index": {
          "description": "matchCount returns the number of non-overlapping matches returned by matchAll",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchCount",
          "normalized": "a-\u003eb-\u003eInt",
          "package": "regex-base",
          "partial": "Count",
          "signature": "regex-\u003esource-\u003eInt",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchCount"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchM",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e m target",
          "source": "src/Text-Regex-Base-RegexLike.html#matchM",
          "type": "method"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchM",
          "normalized": "a-\u003eb-\u003ec d",
          "package": "regex-base",
          "signature": "regex-\u003esource-\u003em target",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchM"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis returns the first match in the source (it checks the whole\n source, not just at the start). This returns an array of\n (offset,length) index pairs for the match and captured\n substrings.  The offset is 0-based.  A (-1) for an offset means a\n failure to match.  The lower bound of the array is 0, and the 0th\n element is the (offset,length) for the whole match.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchOnce",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e Maybe MatchArray",
          "source": "src/Text-Regex-Base-RegexLike.html#matchOnce",
          "type": "method"
        },
        "index": {
          "description": "This returns the first match in the source it checks the whole source not just at the start This returns an array of offset length index pairs for the match and captured substrings The offset is based for an offset means failure to match The lower bound of the array is and the th element is the offset length for the whole match",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchOnce",
          "normalized": "a-\u003eb-\u003eMaybe MatchArray",
          "package": "regex-base",
          "partial": "Once",
          "signature": "regex-\u003esource-\u003eMaybe MatchArray",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchOnce"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eThis can return a tuple of three items: the source before the\n match, an array of the match and captured substrings (with their\n indices), and the source after the match.\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchOnceText",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e Maybe (source, MatchText source, source)",
          "source": "src/Text-Regex-Base-RegexLike.html#matchOnceText",
          "type": "method"
        },
        "index": {
          "description": "This can return tuple of three items the source before the match an array of the match and captured substrings with their indices and the source after the match",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchOnceText",
          "normalized": "a-\u003eb-\u003eMaybe(b,MatchText b,b)",
          "package": "regex-base",
          "partial": "Once Text",
          "signature": "regex-\u003esource-\u003eMaybe(source,MatchText source,source)",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchOnceText"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003ematchTest return True if there is a match somewhere in the\n source (it checks the whole source not just at the start).\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchTest",
          "package": "regex-base",
          "signature": "regex -\u003e source -\u003e Bool",
          "source": "src/Text-Regex-Base-RegexLike.html#matchTest",
          "type": "method"
        },
        "index": {
          "description": "matchTest return True if there is match somewhere in the source it checks the whole source not just at the start",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "matchTest",
          "normalized": "a-\u003eb-\u003eBool",
          "package": "regex-base",
          "partial": "Test",
          "signature": "regex-\u003esource-\u003eBool",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:matchTest"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrAfter",
          "package": "regex-base",
          "signature": "a",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrAfter",
          "package": "regex-base",
          "partial": "After",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:mrAfter"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrBefore",
          "package": "regex-base",
          "signature": "a",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrBefore",
          "package": "regex-base",
          "partial": "Before",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:mrBefore"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrMatch",
          "package": "regex-base",
          "signature": "a",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrMatch",
          "package": "regex-base",
          "partial": "Match",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:mrMatch"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrSubList",
          "package": "regex-base",
          "signature": "[a]",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrSubList",
          "normalized": "[a]",
          "package": "regex-base",
          "partial": "Sub List",
          "signature": "[a]",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:mrSubList"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrSubs",
          "package": "regex-base",
          "signature": "Array Int a",
          "source": "src/Text-Regex-Base-RegexLike.html#MatchResult",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "mrSubs",
          "package": "regex-base",
          "partial": "Subs",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:mrSubs"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cp\u003eforget old flags and use new ones\n\u003c/p\u003e",
          "module": "Text.Regex.Base.RegexLike",
          "name": "setExecOpts",
          "package": "regex-base",
          "signature": "execOpt -\u003e regex -\u003e regex",
          "source": "src/Text-Regex-Base-RegexLike.html#setExecOpts",
          "type": "method"
        },
        "index": {
          "description": "forget old flags and use new ones",
          "hierarchy": "Text Regex Base RegexLike",
          "module": "Text.Regex.Base.RegexLike",
          "name": "setExecOpts",
          "normalized": "a-\u003eb-\u003eb",
          "package": "regex-base",
          "partial": "Exec Opts",
          "signature": "execOpt-\u003eregex-\u003eregex",
          "type": "method"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base-RegexLike.html#v:setExecOpts"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "description": "\u003cdiv class=\"doc\"\u003e\u003cp\u003eClasses and instances for Regex matching.\n\u003c/p\u003e\u003cp\u003eThis module merely imports and re-exports the common part of the new\n api: \u003ca\u003eText.Regex.Base.RegexLike\u003c/a\u003e and \u003ca\u003eText.Regex.Base.Context\u003c/a\u003e.\n\u003c/p\u003e\u003cp\u003eTo see what result types the instances of RegexContext can produce,\n please read the \u003ca\u003eText.Regex.Base.Context\u003c/a\u003e haddock documentation.\n\u003c/p\u003e\u003cp\u003eThis does not provide any of the backends, just the common interface\n they all use.  The modules which provide the backends and their cabal\n packages are:\n\u003c/p\u003e\u003cul\u003e\u003cli\u003e \u003ccode\u003eText.Regex.Posix\u003c/code\u003e from regex-posix\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eText.Regex\u003c/code\u003e from regex-compat (uses regex-posix)\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eText.Regex.Parsec\u003c/code\u003e from regex-parsec\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eText.Regex.DFA\u003c/code\u003e from regex-dfa\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eText.Regex.PCRE\u003c/code\u003e from regex-pcre\n\u003c/li\u003e\u003cli\u003e \u003ccode\u003eTest.Regex.TRE\u003c/code\u003e from regex-tre\n\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eIn fact, just importing one of the backends is adequate, you do not\n also need to import this module.\n\u003c/p\u003e\u003cp\u003eTODO: Copy Example*hs files into this haddock comment\n\u003c/p\u003e\u003c/div\u003e",
          "module": "Text.Regex.Base",
          "name": "Base",
          "package": "regex-base",
          "source": "src/Text-Regex-Base.html",
          "type": "module"
        },
        "index": {
          "description": "Classes and instances for Regex matching This module merely imports and re-exports the common part of the new api Text.Regex.Base.RegexLike and Text.Regex.Base.Context To see what result types the instances of RegexContext can produce please read the Text.Regex.Base.Context haddock documentation This does not provide any of the backends just the common interface they all use The modules which provide the backends and their cabal packages are Text.Regex.Posix from regex-posix Text.Regex from regex-compat uses regex-posix Text.Regex.Parsec from regex-parsec Text.Regex.DFA from regex-dfa Text.Regex.PCRE from regex-pcre Test.Regex.TRE from regex-tre In fact just importing one of the backends is adequate you do not also need to import this module TODO Copy Example hs files into this haddock comment",
          "hierarchy": "Text Regex Base",
          "module": "Text.Regex.Base",
          "name": "Base",
          "package": "regex-base",
          "partial": "Base",
          "type": "module"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base.html#"
      }
    },
    {
      "cmd": "insert",
      "document": {
        "description": {
          "module": "Text.Regex.Base",
          "name": "getVersion_Text_Regex_Base",
          "package": "regex-base",
          "signature": "Version",
          "source": "src/Text-Regex-Base.html#getVersion_Text_Regex_Base",
          "type": "function"
        },
        "index": {
          "hierarchy": "Text Regex Base",
          "module": "Text.Regex.Base",
          "name": "getVersion_Text_Regex_Base",
          "package": "regex-base",
          "partial": "Version Text Regex Base",
          "type": "function"
        },
        "uri": "http://hackage.haskell.org/package/regex-base/docs/Text-Regex-Base.html#v:getVersion_Text_Regex_Base"
      }
    }
  ]
]